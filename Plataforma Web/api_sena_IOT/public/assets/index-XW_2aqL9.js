(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
/**
* @vue/shared v3.4.31
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function makeMap(str, expectsLowerCase) {
  const set2 = new Set(str.split(","));
  return (val) => set2.has(val);
}
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend$1 = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty$2 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$2.call(val, key);
const isArray$2 = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isRegExp$1 = (val) => toTypeString(val) === "[object RegExp]";
const isFunction$1 = (val) => typeof val === "function";
const isString$1 = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject$4 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return (isObject$4(val) || isFunction$1(val)) && isFunction$1(val.then) && isFunction$1(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value2) => objectToString.call(value2);
const toRawType = (value2) => {
  return toTypeString(value2).slice(8, -1);
};
const isPlainObject$2 = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString$1(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const cacheStringFunction = (fn) => {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache2[str];
    return hit || (cache2[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_2, c2) => c2 ? c2.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize$1 = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction((str) => {
  const s2 = str ? `on${capitalize$1(str)}` : ``;
  return s2;
});
const hasChanged = (value2, oldValue) => !Object.is(value2, oldValue);
const invokeArrayFns = (fns, ...arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](...arg);
  }
};
const def = (obj, key, value2, writable = false) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    writable,
    value: value2
  });
};
const looseToNumber = (val) => {
  const n2 = parseFloat(val);
  return isNaN(n2) ? val : n2;
};
const toNumber = (val) => {
  const n2 = isString$1(val) ? Number(val) : NaN;
  return isNaN(n2) ? val : n2;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function normalizeStyle(value2) {
  if (isArray$2(value2)) {
    const res = {};
    for (let i = 0; i < value2.length; i++) {
      const item = value2[i];
      const normalized = isString$1(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString$1(value2) || isObject$4(value2)) {
    return value2;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value2) {
  let res = "";
  if (isString$1(value2)) {
    res = value2;
  } else if (isArray$2(value2)) {
    for (let i = 0; i < value2.length; i++) {
      const normalized = normalizeClass(value2[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$4(value2)) {
    for (const name in value2) {
      if (value2[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value2) {
  return !!value2 || value2 === "";
}
const isRef$1 = (val) => {
  return !!(val && val.__v_isRef === true);
};
const toDisplayString = (val) => {
  return isString$1(val) ? val : val == null ? "" : isArray$2(val) || isObject$4(val) && (val.toString === objectToString || !isFunction$1(val.toString)) ? isRef$1(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (isRef$1(val)) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce(
        (entries, [key, val2], i) => {
          entries[stringifySymbol(key, i) + " =>"] = val2;
          return entries;
        },
        {}
      )
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()].map((v2) => stringifySymbol(v2))
    };
  } else if (isSymbol(val)) {
    return stringifySymbol(val);
  } else if (isObject$4(val) && !isArray$2(val) && !isPlainObject$2(val)) {
    return String(val);
  }
  return val;
};
const stringifySymbol = (v2, i = "") => {
  var _a2;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    isSymbol(v2) ? `Symbol(${(_a2 = v2.description) != null ? _a2 : i})` : v2
  );
};
/**
* @vue/reactivity v3.4.31
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this.effects = [];
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      let i, l2;
      for (i = 0, l2 = this.effects.length; i < l2; i++) {
        this.effects[i].stop();
      }
      for (i = 0, l2 = this.cleanups.length; i < l2; i++) {
        this.cleanups[i]();
      }
      if (this.scopes) {
        for (i = 0, l2 = this.scopes.length; i < l2; i++) {
          this.scopes[i].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function recordEffectScope(effect2, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect2);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  }
}
let activeEffect;
class ReactiveEffect {
  constructor(fn, trigger2, scheduler, scope) {
    this.fn = fn;
    this.trigger = trigger2;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this._dirtyLevel = 4;
    this._trackId = 0;
    this._runnings = 0;
    this._shouldSchedule = false;
    this._depsLength = 0;
    recordEffectScope(this, scope);
  }
  get dirty() {
    if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
      this._dirtyLevel = 1;
      pauseTracking();
      for (let i = 0; i < this._depsLength; i++) {
        const dep = this.deps[i];
        if (dep.computed) {
          triggerComputed(dep.computed);
          if (this._dirtyLevel >= 4) {
            break;
          }
        }
      }
      if (this._dirtyLevel === 1) {
        this._dirtyLevel = 0;
      }
      resetTracking();
    }
    return this._dirtyLevel >= 4;
  }
  set dirty(v2) {
    this._dirtyLevel = v2 ? 4 : 0;
  }
  run() {
    this._dirtyLevel = 0;
    if (!this.active) {
      return this.fn();
    }
    let lastShouldTrack = shouldTrack;
    let lastEffect = activeEffect;
    try {
      shouldTrack = true;
      activeEffect = this;
      this._runnings++;
      preCleanupEffect(this);
      return this.fn();
    } finally {
      postCleanupEffect(this);
      this._runnings--;
      activeEffect = lastEffect;
      shouldTrack = lastShouldTrack;
    }
  }
  stop() {
    if (this.active) {
      preCleanupEffect(this);
      postCleanupEffect(this);
      this.onStop && this.onStop();
      this.active = false;
    }
  }
}
function triggerComputed(computed2) {
  return computed2.value;
}
function preCleanupEffect(effect2) {
  effect2._trackId++;
  effect2._depsLength = 0;
}
function postCleanupEffect(effect2) {
  if (effect2.deps.length > effect2._depsLength) {
    for (let i = effect2._depsLength; i < effect2.deps.length; i++) {
      cleanupDepEffect(effect2.deps[i], effect2);
    }
    effect2.deps.length = effect2._depsLength;
  }
}
function cleanupDepEffect(dep, effect2) {
  const trackId = dep.get(effect2);
  if (trackId !== void 0 && effect2._trackId !== trackId) {
    dep.delete(effect2);
    if (dep.size === 0) {
      dep.cleanup();
    }
  }
}
let shouldTrack = true;
let pauseScheduleStack = 0;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function pauseScheduling() {
  pauseScheduleStack++;
}
function resetScheduling() {
  pauseScheduleStack--;
  while (!pauseScheduleStack && queueEffectSchedulers.length) {
    queueEffectSchedulers.shift()();
  }
}
function trackEffect(effect2, dep, debuggerEventExtraInfo) {
  if (dep.get(effect2) !== effect2._trackId) {
    dep.set(effect2, effect2._trackId);
    const oldDep = effect2.deps[effect2._depsLength];
    if (oldDep !== dep) {
      if (oldDep) {
        cleanupDepEffect(oldDep, effect2);
      }
      effect2.deps[effect2._depsLength++] = dep;
    } else {
      effect2._depsLength++;
    }
  }
}
const queueEffectSchedulers = [];
function triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {
  pauseScheduling();
  for (const effect2 of dep.keys()) {
    let tracking;
    if (effect2._dirtyLevel < dirtyLevel && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
      effect2._shouldSchedule || (effect2._shouldSchedule = effect2._dirtyLevel === 0);
      effect2._dirtyLevel = dirtyLevel;
    }
    if (effect2._shouldSchedule && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
      effect2.trigger();
      if ((!effect2._runnings || effect2.allowRecurse) && effect2._dirtyLevel !== 2) {
        effect2._shouldSchedule = false;
        if (effect2.scheduler) {
          queueEffectSchedulers.push(effect2.scheduler);
        }
      }
    }
  }
  resetScheduling();
}
const createDep = (cleanup, computed2) => {
  const dep = /* @__PURE__ */ new Map();
  dep.cleanup = cleanup;
  dep.computed = computed2;
  return dep;
};
const targetMap = /* @__PURE__ */ new WeakMap();
const ITERATE_KEY = Symbol("");
const MAP_KEY_ITERATE_KEY = Symbol("");
function track(target2, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target2);
    if (!depsMap) {
      targetMap.set(target2, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep(() => depsMap.delete(key)));
    }
    trackEffect(
      activeEffect,
      dep
    );
  }
}
function trigger$1(target2, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target2);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray$2(target2)) {
    const newLength = Number(newValue);
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || !isSymbol(key2) && key2 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray$2(target2)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target2)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray$2(target2)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target2)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target2)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  pauseScheduling();
  for (const dep of deps) {
    if (dep) {
      triggerEffects(
        dep,
        4
      );
    }
  }
  resetScheduling();
}
function getDepFromReactive(object, key) {
  const depsMap = targetMap.get(object);
  return depsMap && depsMap.get(key);
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i = 0, l2 = this.length; i < l2; i++) {
        track(arr, "get", i + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      pauseScheduling();
      const res = toRaw(this)[key].apply(this, args);
      resetScheduling();
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function hasOwnProperty$1(key) {
  if (!isSymbol(key)) key = String(key);
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
class BaseReactiveHandler {
  constructor(_isReadonly = false, _isShallow = false) {
    this._isReadonly = _isReadonly;
    this._isShallow = _isShallow;
  }
  get(target2, key, receiver) {
    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return isShallow2;
    } else if (key === "__v_raw") {
      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target2) || // receiver is not the reactive proxy, but has the same prototype
      // this means the reciever is a user proxy of the reactive proxy
      Object.getPrototypeOf(target2) === Object.getPrototypeOf(receiver)) {
        return target2;
      }
      return;
    }
    const targetIsArray = isArray$2(target2);
    if (!isReadonly2) {
      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty$1;
      }
    }
    const res = Reflect.get(target2, key, receiver);
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target2, "get", key);
    }
    if (isShallow2) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject$4(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  }
}
class MutableReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(false, isShallow2);
  }
  set(target2, key, value2, receiver) {
    let oldValue = target2[key];
    if (!this._isShallow) {
      const isOldValueReadonly = isReadonly(oldValue);
      if (!isShallow(value2) && !isReadonly(value2)) {
        oldValue = toRaw(oldValue);
        value2 = toRaw(value2);
      }
      if (!isArray$2(target2) && isRef(oldValue) && !isRef(value2)) {
        if (isOldValueReadonly) {
          return false;
        } else {
          oldValue.value = value2;
          return true;
        }
      }
    }
    const hadKey = isArray$2(target2) && isIntegerKey(key) ? Number(key) < target2.length : hasOwn(target2, key);
    const result = Reflect.set(target2, key, value2, receiver);
    if (target2 === toRaw(receiver)) {
      if (!hadKey) {
        trigger$1(target2, "add", key, value2);
      } else if (hasChanged(value2, oldValue)) {
        trigger$1(target2, "set", key, value2);
      }
    }
    return result;
  }
  deleteProperty(target2, key) {
    const hadKey = hasOwn(target2, key);
    target2[key];
    const result = Reflect.deleteProperty(target2, key);
    if (result && hadKey) {
      trigger$1(target2, "delete", key, void 0);
    }
    return result;
  }
  has(target2, key) {
    const result = Reflect.has(target2, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target2, "has", key);
    }
    return result;
  }
  ownKeys(target2) {
    track(
      target2,
      "iterate",
      isArray$2(target2) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target2);
  }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(true, isShallow2);
  }
  set(target2, key) {
    return true;
  }
  deleteProperty(target2, key) {
    return true;
  }
}
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(
  true
);
const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
const toShallow = (value2) => value2;
const getProto = (v2) => Reflect.getPrototypeOf(v2);
function get$1(target2, key, isReadonly2 = false, isShallow2 = false) {
  target2 = target2["__v_raw"];
  const rawTarget = toRaw(target2);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (hasChanged(key, rawKey)) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target2.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target2.get(rawKey));
  } else if (target2 !== rawTarget) {
    target2.get(key);
  }
}
function has(key, isReadonly2 = false) {
  const target2 = this["__v_raw"];
  const rawTarget = toRaw(target2);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (hasChanged(key, rawKey)) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target2.has(key) : target2.has(key) || target2.has(rawKey);
}
function size$1(target2, isReadonly2 = false) {
  target2 = target2["__v_raw"];
  !isReadonly2 && track(toRaw(target2), "iterate", ITERATE_KEY);
  return Reflect.get(target2, "size", target2);
}
function add(value2) {
  value2 = toRaw(value2);
  const target2 = toRaw(this);
  const proto = getProto(target2);
  const hadKey = proto.has.call(target2, value2);
  if (!hadKey) {
    target2.add(value2);
    trigger$1(target2, "add", value2, value2);
  }
  return this;
}
function set$1(key, value2) {
  value2 = toRaw(value2);
  const target2 = toRaw(this);
  const { has: has2, get: get2 } = getProto(target2);
  let hadKey = has2.call(target2, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target2, key);
  }
  const oldValue = get2.call(target2, key);
  target2.set(key, value2);
  if (!hadKey) {
    trigger$1(target2, "add", key, value2);
  } else if (hasChanged(value2, oldValue)) {
    trigger$1(target2, "set", key, value2);
  }
  return this;
}
function deleteEntry(key) {
  const target2 = toRaw(this);
  const { has: has2, get: get2 } = getProto(target2);
  let hadKey = has2.call(target2, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target2, key);
  }
  get2 ? get2.call(target2, key) : void 0;
  const result = target2.delete(key);
  if (hadKey) {
    trigger$1(target2, "delete", key, void 0);
  }
  return result;
}
function clear() {
  const target2 = toRaw(this);
  const hadItems = target2.size !== 0;
  const result = target2.clear();
  if (hadItems) {
    trigger$1(target2, "clear", void 0, void 0);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach2(callback, thisArg) {
    const observed = this;
    const target2 = observed["__v_raw"];
    const rawTarget = toRaw(target2);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target2.forEach((value2, key) => {
      return callback.call(thisArg, wrap(value2), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target2 = this["__v_raw"];
    const rawTarget = toRaw(target2);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target2[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value: value2, done } = innerIterator.next();
        return done ? { value: value2, done } : {
          value: isPair ? [wrap(value2[0]), wrap(value2[1])] : wrap(value2),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : type === "clear" ? void 0 : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get$1(this, key);
    },
    get size() {
      return size$1(this);
    },
    has,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get$1(this, key, false, true);
    },
    get size() {
      return size$1(this);
    },
    has,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get$1(this, key, true);
    },
    get size() {
      return size$1(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get$1(this, key, true, true);
    },
    get size() {
      return size$1(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      true
    );
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [
  mutableInstrumentations,
  readonlyInstrumentations,
  shallowInstrumentations,
  shallowReadonlyInstrumentations
] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target2, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target2;
    }
    return Reflect.get(
      hasOwn(instrumentations, key) && key in target2 ? instrumentations : target2,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value2) {
  return value2["__v_skip"] || !Object.isExtensible(value2) ? 0 : targetTypeMap(toRawType(value2));
}
function reactive(target2) {
  if (isReadonly(target2)) {
    return target2;
  }
  return createReactiveObject(
    target2,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target2) {
  return createReactiveObject(
    target2,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target2) {
  return createReactiveObject(
    target2,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function shallowReadonly(target2) {
  return createReactiveObject(
    target2,
    true,
    shallowReadonlyHandlers,
    shallowReadonlyCollectionHandlers,
    shallowReadonlyMap
  );
}
function createReactiveObject(target2, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$4(target2)) {
    return target2;
  }
  if (target2["__v_raw"] && !(isReadonly2 && target2["__v_isReactive"])) {
    return target2;
  }
  const existingProxy = proxyMap.get(target2);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target2);
  if (targetType === 0) {
    return target2;
  }
  const proxy = new Proxy(
    target2,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target2, proxy);
  return proxy;
}
function isReactive(value2) {
  if (isReadonly(value2)) {
    return isReactive(value2["__v_raw"]);
  }
  return !!(value2 && value2["__v_isReactive"]);
}
function isReadonly(value2) {
  return !!(value2 && value2["__v_isReadonly"]);
}
function isShallow(value2) {
  return !!(value2 && value2["__v_isShallow"]);
}
function isProxy(value2) {
  return value2 ? !!value2["__v_raw"] : false;
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value2) {
  if (Object.isExtensible(value2)) {
    def(value2, "__v_skip", true);
  }
  return value2;
}
const toReactive = (value2) => isObject$4(value2) ? reactive(value2) : value2;
const toReadonly = (value2) => isObject$4(value2) ? readonly(value2) : value2;
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this.getter = getter;
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this["__v_isReadonly"] = false;
    this.effect = new ReactiveEffect(
      () => getter(this._value),
      () => triggerRefValue(
        this,
        this.effect._dirtyLevel === 2 ? 2 : 3
      )
    );
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    if ((!self2._cacheable || self2.effect.dirty) && hasChanged(self2._value, self2._value = self2.effect.run())) {
      triggerRefValue(self2, 4);
    }
    trackRefValue(self2);
    if (self2.effect._dirtyLevel >= 2) {
      triggerRefValue(self2, 2);
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
  // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x
  get _dirty() {
    return this.effect.dirty;
  }
  set _dirty(v2) {
    this.effect.dirty = v2;
  }
  // #endregion
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction$1(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  return cRef;
}
function trackRefValue(ref2) {
  var _a2;
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    trackEffect(
      activeEffect,
      (_a2 = ref2.dep) != null ? _a2 : ref2.dep = createDep(
        () => ref2.dep = void 0,
        ref2 instanceof ComputedRefImpl ? ref2 : void 0
      )
    );
  }
}
function triggerRefValue(ref2, dirtyLevel = 4, newVal, oldVal) {
  ref2 = toRaw(ref2);
  const dep = ref2.dep;
  if (dep) {
    triggerEffects(
      dep,
      dirtyLevel
    );
  }
}
function isRef(r) {
  return !!(r && r.__v_isRef === true);
}
function ref(value2) {
  return createRef(value2, false);
}
function shallowRef(value2) {
  return createRef(value2, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value2, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value2 : toRaw(value2);
    this._value = __v_isShallow ? value2 : toReactive(value2);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
    newVal = useDirectValue ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue;
      this._rawValue = newVal;
      this._value = useDirectValue ? newVal : toReactive(newVal);
      triggerRefValue(this, 4);
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target2, key, receiver) => unref(Reflect.get(target2, key, receiver)),
  set: (target2, key, value2, receiver) => {
    const oldValue = target2[key];
    if (isRef(oldValue) && !isRef(value2)) {
      oldValue.value = value2;
      return true;
    } else {
      return Reflect.set(target2, key, value2, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
function toRefs(object) {
  const ret = isArray$2(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = propertyToRef(object, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this.__v_isRef = true;
  }
  get value() {
    const val = this._object[this._key];
    return val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
  get dep() {
    return getDepFromReactive(toRaw(this._object), this._key);
  }
}
function propertyToRef(source, key, defaultValue) {
  const val = source[key];
  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
}
/**
* @vue/runtime-core v3.4.31
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const stack = [];
function warn$1(msg, ...args) {
  pauseTracking();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(
      appWarnHandler,
      instance,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        msg + args.map((a2) => {
          var _a2, _b2;
          return (_b2 = (_a2 = a2.toString) == null ? void 0 : _a2.call(a2)) != null ? _b2 : JSON.stringify(a2);
        }).join(""),
        instance && instance.proxy,
        trace.map(
          ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
        ).join("\n"),
        trace
      ]
    );
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && // avoid spamming console during tests
    true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open2 = ` at <${formatComponentName(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
  const close = `>` + postfix;
  return vnode.props ? [open2, ...formatProps(vnode.props), close] : [open2 + close];
}
function formatProps(props2) {
  const res = [];
  const keys = Object.keys(props2);
  keys.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props2[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value2, raw) {
  if (isString$1(value2)) {
    value2 = JSON.stringify(value2);
    return raw ? value2 : [`${key}=${value2}`];
  } else if (typeof value2 === "number" || typeof value2 === "boolean" || value2 == null) {
    return raw ? value2 : [`${key}=${value2}`];
  } else if (isRef(value2)) {
    value2 = formatProp(key, toRaw(value2.value), true);
    return raw ? value2 : [`${key}=Ref<`, value2, `>`];
  } else if (isFunction$1(value2)) {
    return [`${key}=fn${value2.name ? `<${value2.name}>` : ``}`];
  } else {
    value2 = toRaw(value2);
    return raw ? value2 : [`${key}=`, value2];
  }
}
function callWithErrorHandling(fn, instance, type, args) {
  try {
    return args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction$1(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  if (isArray$2(fn)) {
    const values = [];
    for (let i = 0; i < fn.length; i++) {
      values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
    }
    return values;
  }
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      pauseTracking();
      callWithErrorHandling(
        appErrorHandler,
        null,
        10,
        [err, exposedInstance, errorInfo]
      );
      resetTracking();
      return;
    }
  }
  logError$1(err, type, contextVNode, throwInDev);
}
function logError$1(err, type, contextVNode, throwInDev = true) {
  {
    console.error(err);
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue$1 = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick$1(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex$1(id2) {
  let start = flushIndex + 1;
  let end = queue$1.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJob = queue$1[middle];
    const middleJobId = getId$1(middleJob);
    if (middleJobId < id2 || middleJobId === id2 && middleJob.pre) {
      start = middle + 1;
    } else {
      end = middle;
    }
  }
  return start;
}
function queueJob(job) {
  if (!queue$1.length || !queue$1.includes(
    job,
    isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
  )) {
    if (job.id == null) {
      queue$1.push(job);
    } else {
      queue$1.splice(findInsertionIndex$1(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i = queue$1.indexOf(job);
  if (i > flushIndex) {
    queue$1.splice(i, 1);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray$2(cb)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(
      cb,
      cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
    )) {
      pendingPostFlushCbs.push(cb);
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(instance, seen2, i = isFlushing ? flushIndex + 1 : 0) {
  for (; i < queue$1.length; i++) {
    const cb = queue$1[i];
    if (cb && cb.pre) {
      if (instance && cb.id !== instance.uid) {
        continue;
      }
      queue$1.splice(i, 1);
      i--;
      cb();
    }
  }
}
function flushPostFlushCbs(seen2) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)].sort(
      (a2, b2) => getId$1(a2) - getId$1(b2)
    );
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      const cb = activePostFlushCbs[postFlushIndex];
      if (cb.active !== false) cb();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId$1 = (job) => job.id == null ? Infinity : job.id;
const comparator = (a2, b2) => {
  const diff = getId$1(a2) - getId$1(b2);
  if (diff === 0) {
    if (a2.pre && !b2.pre) return -1;
    if (b2.pre && !a2.pre) return 1;
  }
  return diff;
};
function flushJobs(seen2) {
  isFlushPending = false;
  isFlushing = true;
  queue$1.sort(comparator);
  try {
    for (flushIndex = 0; flushIndex < queue$1.length; flushIndex++) {
      const job = queue$1[flushIndex];
      if (job && job.active !== false) {
        if (false) ;
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue$1.length = 0;
    flushPostFlushCbs();
    isFlushing = false;
    currentFlushPromise = null;
    if (queue$1.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted) return;
  const props2 = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props2) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number, trim: trim2 } = props2[modifiersKey] || EMPTY_OBJ;
    if (trim2) {
      args = rawArgs.map((a2) => isString$1(a2) ? a2.trim() : a2);
    }
    if (number) {
      args = rawArgs.map(looseToNumber);
    }
  }
  let handlerName;
  let handler = props2[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props2[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props2[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(
      handler,
      instance,
      6,
      args
    );
  }
  const onceHandler = props2[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.emitsCache;
  const cached = cache2.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$1(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend$1(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$4(comp)) {
      cache2.set(comp, null);
    }
    return null;
  }
  if (isArray$2(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend$1(normalized, raw);
  }
  if (isObject$4(comp)) {
    cache2.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function pushScopeId(id2) {
  currentScopeId = id2;
}
function popScopeId() {
  currentScopeId = null;
}
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx) return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit: emit2,
    render,
    renderCache,
    props: props2,
    data,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  const prev = setCurrentRenderingInstance(instance);
  let result;
  let fallthroughAttrs;
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      const thisProxy = false ? new Proxy(proxyToUse, {
        get(target2, key, receiver) {
          warn$1(
            `Property '${String(
              key
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          );
          return Reflect.get(target2, key, receiver);
        }
      }) : proxyToUse;
      result = normalizeVNode(
        render.call(
          thisProxy,
          proxyToUse,
          renderCache,
          false ? shallowReadonly(props2) : props2,
          setupState,
          data,
          ctx
        )
      );
      fallthroughAttrs = attrs;
    } else {
      const render2 = Component;
      if (false) ;
      result = normalizeVNode(
        render2.length > 1 ? render2(
          false ? shallowReadonly(props2) : props2,
          false ? {
            get attrs() {
              markAttrsAccessed();
              return shallowReadonly(attrs);
            },
            slots,
            emit: emit2
          } : { attrs, slots, emit: emit2 }
        ) : render2(
          false ? shallowReadonly(props2) : props2,
          null
        )
      );
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root = cloneVNode(root, fallthroughAttrs, false, true);
      }
    }
  }
  if (vnode.dirs) {
    root = cloneVNode(root, null, false, true);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    root.transition = vnode.transition;
  }
  {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props2) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props2)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent) {
    const root = parent.subTree;
    if (root.suspense && root.suspense.activeBranch === vnode) {
      root.el = vnode.el;
    }
    if (root === vnode) {
      (vnode = parent.vnode).el = el;
      parent = parent.parent;
    } else {
      break;
    }
  }
}
const COMPONENTS = "components";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    {
      const selfName = getComponentName(
        Component,
        false
      );
      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize$1(camelize(name)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve(instance[type] || Component[type], name) || // global registration
      resolve(instance.appContext[type], name)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[camelize(name)] || registry[capitalize$1(camelize(name))]);
}
const isSuspense = (type) => type.__isSuspense;
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$2(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
function injectHook(type, hook, target2 = currentInstance, prepend = false) {
  if (target2) {
    const hooks = target2[type] || (target2[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      pauseTracking();
      const reset = setCurrentInstance(target2);
      const res = callWithAsyncErrorHandling(hook, target2, type, args);
      reset();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target2 = currentInstance) => {
  if (!isInSSRComponentSetup || lifecycle === "sp") {
    injectHook(lifecycle, (...args) => hook(...args), target2);
  }
};
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook(
  "rtg"
);
const onRenderTracked = createHook(
  "rtc"
);
function onErrorCaptured(hook, target2 = currentInstance) {
  injectHook("ec", hook, target2);
}
function withDirectives(vnode, directives) {
  if (currentRenderingInstance === null) {
    return vnode;
  }
  const instance = getComponentPublicInstance(currentRenderingInstance);
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives.length; i++) {
    let [dir, value2, arg, modifiers = EMPTY_OBJ] = directives[i];
    if (dir) {
      if (isFunction$1(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value2);
      }
      bindings.push({
        dir,
        instance,
        value: value2,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
function renderList(source, renderItem, cache2, index) {
  let ret;
  const cached = cache2;
  if (isArray$2(source) || isString$1(source)) {
    ret = new Array(source.length);
    for (let i = 0, l2 = source.length; i < l2; i++) {
      ret[i] = renderItem(source[i], i, void 0, cached);
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached);
    }
  } else if (isObject$4(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item, i) => renderItem(item, i, void 0, cached)
      );
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i = 0, l2 = keys.length; i < l2; i++) {
        const key = keys[i];
        ret[i] = renderItem(source[key], key, i, cached);
      }
    }
  } else {
    ret = [];
  }
  return ret;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineComponent(options, extraOptions) {
  return isFunction$1(options) ? (
    // #8326: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => extend$1({ name: options.name }, extraOptions, { setup: options }))()
  ) : options;
}
const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
const getPublicInstance = (i) => {
  if (!i) return null;
  if (isStatefulComponent(i)) return getComponentPublicInstance(i);
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend$1(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => i.props,
    $attrs: (i) => i.attrs,
    $slots: (i) => i.slots,
    $refs: (i) => i.refs,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $emit: (i) => i.emit,
    $options: (i) => resolveMergedOptions(i),
    $forceUpdate: (i) => i.f || (i.f = () => {
      i.effect.dirty = true;
      queueJob(i.update);
    }),
    $nextTick: (i) => i.n || (i.n = nextTick$1.bind(i.proxy)),
    $watch: (i) => instanceWatch.bind(i)
  })
);
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    if (key === "__v_skip") {
      return true;
    }
    const { ctx, setupState, data, props: props2, accessCache, type, appContext } = instance;
    let normalizedProps;
    if (key[0] !== "$") {
      const n2 = accessCache[key];
      if (n2 !== void 0) {
        switch (n2) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props2[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props2[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance.attrs, "get", "");
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else ;
  },
  set({ _: instance }, key, value2) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value2;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value2;
      return true;
    } else if (hasOwn(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value2;
      }
    }
    return true;
  },
  has({
    _: { data, setupState, accessCache, ctx, appContext, propsOptions }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target2, key, descriptor) {
    if (descriptor.get != null) {
      target2._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target2, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target2, key, descriptor);
  }
};
function normalizePropsOrEmits(props2) {
  return isArray$2(props2) ? props2.reduce(
    (normalized, p2) => (normalized[p2] = null, normalized),
    {}
  ) : props2;
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components: components2,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction$1(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject$4(data)) ;
    else {
      instance.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get2 = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set2 = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c2 = computed({
        get: get2,
        set: set2
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c2.value,
        set: (v2) => c2.value = v2
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook$1(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray$2(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$2(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render && instance.render === NOOP) {
    instance.render = render;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components2) instance.components = components2;
  if (directives) instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray$2(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$4(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v2) => injected.value = v2
      });
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook$1(hook, instance, type) {
  callWithAsyncErrorHandling(
    isArray$2(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString$1(raw)) {
    const handler = ctx[raw];
    if (isFunction$1(handler)) {
      watch(getter, handler);
    }
  } else if (isFunction$1(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject$4(raw)) {
    if (isArray$2(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$1(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else ;
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache2,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache2.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m2) => mergeOptions$1(resolved, m2, optionMergeStrategies, true)
      );
    }
    mergeOptions$1(resolved, base, optionMergeStrategies);
  }
  if (isObject$4(base)) {
    cache2.set(base, resolved);
  }
  return resolved;
}
function mergeOptions$1(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions$1(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m2) => mergeOptions$1(to, m2, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose") ;
    else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend$1(
      isFunction$1(to) ? to.call(this, this) : to,
      isFunction$1(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray$2(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend$1(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
  if (to) {
    if (isArray$2(to) && isArray$2(from)) {
      return [.../* @__PURE__ */ new Set([...to, ...from])];
    }
    return extend$1(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
function mergeWatchOptions(to, from) {
  if (!to) return from;
  if (!from) return to;
  const merged = extend$1(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1$1 = 0;
function createAppAPI(render, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction$1(rootComponent)) {
      rootComponent = extend$1({}, rootComponent);
    }
    if (rootProps != null && !isObject$4(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new WeakSet();
    let isMounted = false;
    const app2 = context.app = {
      _uid: uid$1$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v2) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin)) ;
        else if (plugin && isFunction$1(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app2, ...options);
        } else if (isFunction$1(plugin)) {
          installedPlugins.add(plugin);
          plugin(app2, ...options);
        } else ;
        return app2;
      },
      mixin(mixin2) {
        {
          if (!context.mixins.includes(mixin2)) {
            context.mixins.push(mixin2);
          }
        }
        return app2;
      },
      component(name, component) {
        if (!component) {
          return context.components[name];
        }
        context.components[name] = component;
        return app2;
      },
      directive(name, directive) {
        if (!directive) {
          return context.directives[name];
        }
        context.directives[name] = directive;
        return app2;
      },
      mount(rootContainer, isHydrate, namespace) {
        if (!isMounted) {
          const vnode = createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (namespace === true) {
            namespace = "svg";
          } else if (namespace === false) {
            namespace = void 0;
          }
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render(vnode, rootContainer, namespace);
          }
          isMounted = true;
          app2._container = rootContainer;
          rootContainer.__vue_app__ = app2;
          return getComponentPublicInstance(vnode.component);
        }
      },
      unmount() {
        if (isMounted) {
          render(null, app2._container);
          delete app2._container.__vue_app__;
        }
      },
      provide(key, value2) {
        context.provides[key] = value2;
        return app2;
      },
      runWithContext(fn) {
        const lastApp = currentApp;
        currentApp = app2;
        try {
          return fn();
        } finally {
          currentApp = lastApp;
        }
      }
    };
    return app2;
  };
}
let currentApp = null;
function provide(key, value2) {
  if (!currentInstance) ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value2;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance || currentApp) {
    const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else ;
  }
}
function hasInjectionContext() {
  return !!(currentInstance || currentRenderingInstance || currentApp);
}
const internalObjectProto = {};
const createInternalObject = () => Object.create(internalObjectProto);
const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props2 = {};
  const attrs = createInternalObject();
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props2, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props2)) {
      props2[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props2 : shallowReactive(props2);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props2;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props: props2,
    attrs,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = toRaw(props2);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value2 = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value2 !== attrs[key]) {
              attrs[key] = value2;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props2[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value2,
              instance,
              false
            );
          }
        } else {
          if (value2 !== attrs[key]) {
            attrs[key] = value2;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props2, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props2[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
            );
          }
        } else {
          delete props2[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger$1(instance.attrs, "set", "");
  }
}
function setFullProps(instance, rawProps, props2, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value2 = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props2[camelKey] = value2;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value2;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value2 !== attrs[key]) {
          attrs[key] = value2;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props2);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props2[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !hasOwn(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props2, key, value2, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value2 === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction$1(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value2 = propsDefaults[key];
        } else {
          const reset = setCurrentInstance(instance);
          value2 = propsDefaults[key] = defaultValue.call(
            null,
            props2
          );
          reset();
        }
      } else {
        value2 = defaultValue;
      }
    }
    if (opt[
      0
      /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value2 = false;
      } else if (opt[
        1
        /* shouldCastTrue */
      ] && (value2 === "" || value2 === hyphenate(key))) {
        value2 = true;
      }
    }
  }
  return value2;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.propsCache;
  const cached = cache2.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$1(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props2, keys] = normalizePropsOptions(raw2, appContext, true);
      extend$1(normalized, props2);
      if (keys) needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$4(comp)) {
      cache2.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray$2(raw)) {
    for (let i = 0; i < raw.length; i++) {
      const normalizedKey = camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray$2(opt) || isFunction$1(opt) ? { type: opt } : extend$1({}, opt);
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[
            0
            /* shouldCast */
          ] = booleanIndex > -1;
          prop[
            1
            /* shouldCastTrue */
          ] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject$4(comp)) {
    cache2.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$" && !isReservedProp(key)) {
    return true;
  }
  return false;
}
function getType(ctor) {
  if (ctor === null) {
    return "null";
  }
  if (typeof ctor === "function") {
    return ctor.name || "";
  } else if (typeof ctor === "object") {
    const name = ctor.constructor && ctor.constructor.name;
    return name || "";
  }
  return "";
}
function isSameType(a2, b2) {
  return getType(a2) === getType(b2);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray$2(expectedTypes)) {
    return expectedTypes.findIndex((t2) => isSameType(t2, type));
  } else if (isFunction$1(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value2) => isArray$2(value2) ? value2.map(normalizeVNode) : [normalizeVNode(value2)];
const normalizeSlot$1 = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false) ;
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key)) continue;
    const value2 = rawSlots[key];
    if (isFunction$1(value2)) {
      slots[key] = normalizeSlot$1(key, value2, ctx);
    } else if (value2 != null) {
      const normalized = normalizeSlotValue(value2);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
  const slots = instance.slots = createInternalObject();
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      extend$1(slots, children);
      def(slots, "_", type, true);
    } else {
      normalizeObjectSlots(children, slots);
    }
  } else if (children) {
    normalizeVNodeSlots(instance, children);
  }
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        extend$1(slots, children);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
        delete slots[key];
      }
    }
  }
};
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray$2(rawRef)) {
    rawRef.forEach(
      (r, i) => setRef(
        r,
        oldRawRef && (isArray$2(oldRawRef) ? oldRawRef[i] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
  const value2 = isUnmount ? null : refValue;
  const { i: owner, r: ref3 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref3) {
    if (isString$1(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction$1(ref3)) {
    callWithErrorHandling(ref3, owner, 12, [value2, refs]);
  } else {
    const _isString = isString$1(ref3);
    const _isRef = isRef(ref3);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? hasOwn(setupState, ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
          if (isUnmount) {
            isArray$2(existing) && remove(existing, refValue);
          } else {
            if (!isArray$2(existing)) {
              if (_isString) {
                refs[ref3] = [refValue];
                if (hasOwn(setupState, ref3)) {
                  setupState[ref3] = refs[ref3];
                }
              } else {
                ref3.value = [refValue];
                if (rawRef.k) refs[rawRef.k] = ref3.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref3] = value2;
          if (hasOwn(setupState, ref3)) {
            setupState[ref3] = value2;
          }
        } else if (_isRef) {
          ref3.value = value2;
          if (rawRef.k) refs[rawRef.k] = value2;
        } else ;
      };
      if (value2) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target2 = getGlobalThis();
  target2.__VUE__ = true;
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref3, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, namespace);
        }
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else ;
    }
    if (ref3 != null && parentComponent) {
      setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, namespace) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      namespace,
      n2.el,
      n2.anchor
    );
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    if (n2.type === "svg") {
      namespace = "svg";
    } else if (n2.type === "math") {
      namespace = "mathml";
    }
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      patchElement(
        n1,
        n2,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { props: props2, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(
      vnode.type,
      namespace,
      props2 && props2.is,
      props2
    );
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(vnode, namespace),
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props2) {
      for (const key in props2) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(
            el,
            key,
            null,
            props2[key],
            namespace,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in props2) {
        hostPatchProp(el, "value", null, props2.value, namespace);
      }
      if (vnodeHook = props2.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = needTransition(parentSuspense, transition);
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props2 && props2.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds
      );
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(
          el,
          n2,
          oldProps,
          newProps,
          parentComponent,
          parentSuspense,
          namespace
        );
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, namespace);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(
                el,
                key,
                prev,
                next,
                namespace,
                n1.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(
        el,
        n2,
        oldProps,
        newProps,
        parentComponent,
        parentSuspense,
        namespace
      );
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, namespace) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el,
              key,
              oldProps[key],
              null,
              namespace,
              vnode.children,
              parentComponent,
              parentSuspense,
              unmountChildren
            );
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key)) continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(
            el,
            key,
            prev,
            next,
            namespace,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        // #10007
        // such fragment like `<></>` will be compiled into
        // a fragment which doesn't have a children.
        // In this case fallback to an empty array
        n2.children || [],
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          namespace,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
    const instance = initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    );
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
    } else {
      setupRenderEffect(
        instance,
        initialVNode,
        container,
        anchor,
        parentSuspense,
        namespace,
        optimized
      );
    }
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.effect.dirty = true;
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props: props2 } = initialVNode;
        const { bm, m: m2, parent } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props2 && props2.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            instance.subTree = renderComponentRoot(instance);
            hydrateNode(
              el,
              instance.subTree,
              instance,
              parentSuspense,
              null
            );
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(
              // note: we are moving the render call into an async callback,
              // which means it won't track dependencies - but it's ok because
              // a server-rendered async wrapper is already in resolved state
              // and it will never need to change.
              () => !instance.isUnmounted && hydrateSubTree()
            );
          } else {
            hydrateSubTree();
          }
        } else {
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            namespace
          );
          initialVNode.el = subTree.el;
        }
        if (m2) {
          queuePostRenderEffect(m2, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props2 && props2.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u: u2, parent, vnode } = instance;
        {
          const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
          if (nonHydratedAsyncRoot) {
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            }
            nonHydratedAsyncRoot.asyncDep.then(() => {
              if (!instance.isUnmounted) {
                componentUpdateFn();
              }
            });
            return;
          }
        }
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          namespace
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u2) {
          queuePostRenderEffect(u2, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
      }
    };
    const effect2 = instance.effect = new ReactiveEffect(
      componentUpdateFn,
      NOOP,
      () => queueJob(update2),
      instance.scope
      // track it in component's effect scope
    );
    const update2 = instance.update = () => {
      if (effect2.dirty) {
        effect2.run();
      }
    };
    update2.id = instance.uid;
    toggleRecurse(instance, true);
    update2();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs(instance);
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(
        c1[i],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(
            null,
            c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j2;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j2 = s2; j2 <= e2; j2++) {
            if (newIndexToOldIndexMap[j2 - s2] === 0 && isSameVNodeType(prevChild, c2[j2])) {
              newIndex = j2;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c2[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j2 = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j2 < 0 || i !== increasingNewIndexSequence[j2]) {
            move(nextChild, container, anchor, 2);
          } else {
            j2--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition2) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove22 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove22();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove22, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props: props2,
      ref: ref3,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs,
      memoIndex
    } = vnode;
    if (patchFlag === -2) {
      optimized = false;
    }
    if (ref3 != null) {
      setRef(ref3, null, parentSuspense, vnode, true);
    }
    if (memoIndex != null) {
      parentComponent.renderCache[memoIndex] = void 0;
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props2 && props2.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props2 && props2.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, update: update2, subTree, um, m: m2, a: a2 } = instance;
    invalidateMount(m2);
    invalidateMount(a2);
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update2) {
      update2.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  let isFlushing2 = false;
  const render = (vnode, container, namespace) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(
        container._vnode || null,
        vnode,
        container,
        null,
        null,
        null,
        namespace
      );
    }
    if (!isFlushing2) {
      isFlushing2 = true;
      flushPreFlushCbs();
      flushPostFlushCbs();
      isFlushing2 = false;
    }
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  return {
    render,
    hydrate,
    createApp: createAppAPI(render, hydrate)
  };
}
function resolveChildrenNamespace({ type, props: props2 }, currentNamespace) {
  return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props2 && props2.encoding && props2.encoding.includes("html") ? void 0 : currentNamespace;
}
function toggleRecurse({ effect: effect2, update: update2 }, allowed) {
  effect2.allowRecurse = update2.allowRecurse = allowed;
}
function needTransition(parentSuspense, transition) {
  return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray$2(ch1) && isArray$2(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow && c2.patchFlag !== -2)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i, j2, u2, v2, c2;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j2 = result[result.length - 1];
      if (arr[j2] < arrI) {
        p2[i] = j2;
        result.push(i);
        continue;
      }
      u2 = 0;
      v2 = result.length - 1;
      while (u2 < v2) {
        c2 = u2 + v2 >> 1;
        if (arr[result[c2]] < arrI) {
          u2 = c2 + 1;
        } else {
          v2 = c2;
        }
      }
      if (arrI < arr[result[u2]]) {
        if (u2 > 0) {
          p2[i] = result[u2 - 1];
        }
        result[u2] = i;
      }
    }
  }
  u2 = result.length;
  v2 = result[u2 - 1];
  while (u2-- > 0) {
    result[u2] = v2;
    v2 = p2[v2];
  }
  return result;
}
function locateNonHydratedAsyncRoot(instance) {
  const subComponent = instance.subTree.component;
  if (subComponent) {
    if (subComponent.asyncDep && !subComponent.asyncResolved) {
      return subComponent;
    } else {
      return locateNonHydratedAsyncRoot(subComponent);
    }
  }
}
function invalidateMount(hooks) {
  if (hooks) {
    for (let i = 0; i < hooks.length; i++) hooks[i].active = false;
  }
}
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    return ctx;
  }
};
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, {
  immediate,
  deep,
  flush,
  once,
  onTrack,
  onTrigger
} = EMPTY_OBJ) {
  if (cb && once) {
    const _cb = cb;
    cb = (...args) => {
      _cb(...args);
      unwatch();
    };
  }
  const instance = currentInstance;
  const reactiveGetter = (source2) => deep === true ? source2 : (
    // for deep: false, only traverse root-level properties
    traverse(source2, deep === false ? 1 : void 0)
  );
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => reactiveGetter(source);
    forceTrigger = true;
  } else if (isArray$2(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s2) => isReactive(s2) || isShallow(s2));
    getter = () => source.map((s2) => {
      if (isRef(s2)) {
        return s2.value;
      } else if (isReactive(s2)) {
        return reactiveGetter(s2);
      } else if (isFunction$1(s2)) {
        return callWithErrorHandling(s2, instance, 2);
      } else ;
    });
  } else if (isFunction$1(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, instance, 2);
    } else {
      getter = () => {
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(
          source,
          instance,
          3,
          [onCleanup]
        );
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect2.onStop = () => {
      callWithErrorHandling(fn, instance, 4);
      cleanup = effect2.onStop = void 0;
    };
  };
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else {
      return NOOP;
    }
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect2.active || !effect2.dirty) {
      return;
    }
    if (cb) {
      const newValue = effect2.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v2, i) => hasChanged(v2, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          // pass undefined as the old value when it's changed for the first time
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect2.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    job.pre = true;
    if (instance) job.id = instance.uid;
    scheduler = () => queueJob(job);
  }
  const effect2 = new ReactiveEffect(getter, NOOP, scheduler);
  const scope = getCurrentScope();
  const unwatch = () => {
    effect2.stop();
    if (scope) {
      remove(scope.effects, effect2);
    }
  };
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect2.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(
      effect2.run.bind(effect2),
      instance && instance.suspense
    );
  } else {
    effect2.run();
  }
  if (ssrCleanup) ssrCleanup.push(unwatch);
  return unwatch;
}
function instanceWatch(source, value2, options) {
  const publicThis = this.proxy;
  const getter = isString$1(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction$1(value2)) {
    cb = value2;
  } else {
    cb = value2.handler;
    options = value2;
  }
  const reset = setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  reset();
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
function traverse(value2, depth = Infinity, seen2) {
  if (depth <= 0 || !isObject$4(value2) || value2["__v_skip"]) {
    return value2;
  }
  seen2 = seen2 || /* @__PURE__ */ new Set();
  if (seen2.has(value2)) {
    return value2;
  }
  seen2.add(value2);
  depth--;
  if (isRef(value2)) {
    traverse(value2.value, depth, seen2);
  } else if (isArray$2(value2)) {
    for (let i = 0; i < value2.length; i++) {
      traverse(value2[i], depth, seen2);
    }
  } else if (isSet(value2) || isMap(value2)) {
    value2.forEach((v2) => {
      traverse(v2, depth, seen2);
    });
  } else if (isPlainObject$2(value2)) {
    for (const key in value2) {
      traverse(value2[key], depth, seen2);
    }
    for (const key of Object.getOwnPropertySymbols(value2)) {
      if (Object.prototype.propertyIsEnumerable.call(value2, key)) {
        traverse(value2[key], depth, seen2);
      }
    }
  }
  return value2;
}
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
const KeepAliveImpl = {
  name: `KeepAlive`,
  // Marker for special handling inside the renderer. We are not using a ===
  // check directly on KeepAlive in the renderer, because importing it directly
  // would prevent it from being tree-shaken.
  __isKeepAlive: true,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(props2, { slots }) {
    const instance = getCurrentInstance();
    const sharedContext = instance.ctx;
    if (!sharedContext.renderer) {
      return () => {
        const children = slots.default && slots.default();
        return children && children.length === 1 ? children[0] : children;
      };
    }
    const cache2 = /* @__PURE__ */ new Map();
    const keys = /* @__PURE__ */ new Set();
    let current = null;
    const parentSuspense = instance.suspense;
    const {
      renderer: {
        p: patch,
        m: move,
        um: _unmount,
        o: { createElement }
      }
    } = sharedContext;
    const storageContainer = createElement("div");
    sharedContext.activate = (vnode, container, anchor, namespace, optimized) => {
      const instance2 = vnode.component;
      move(vnode, container, anchor, 0, parentSuspense);
      patch(
        instance2.vnode,
        vnode,
        container,
        anchor,
        instance2,
        parentSuspense,
        namespace,
        vnode.slotScopeIds,
        optimized
      );
      queuePostRenderEffect(() => {
        instance2.isDeactivated = false;
        if (instance2.a) {
          invokeArrayFns(instance2.a);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
      }, parentSuspense);
    };
    sharedContext.deactivate = (vnode) => {
      const instance2 = vnode.component;
      invalidateMount(instance2.m);
      invalidateMount(instance2.a);
      move(vnode, storageContainer, null, 1, parentSuspense);
      queuePostRenderEffect(() => {
        if (instance2.da) {
          invokeArrayFns(instance2.da);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
        instance2.isDeactivated = true;
      }, parentSuspense);
    };
    function unmount(vnode) {
      resetShapeFlag(vnode);
      _unmount(vnode, instance, parentSuspense, true);
    }
    function pruneCache(filter2) {
      cache2.forEach((vnode, key) => {
        const name = getComponentName(vnode.type);
        if (name && (!filter2 || !filter2(name))) {
          pruneCacheEntry(key);
        }
      });
    }
    function pruneCacheEntry(key) {
      const cached = cache2.get(key);
      if (!current || !isSameVNodeType(cached, current)) {
        unmount(cached);
      } else if (current) {
        resetShapeFlag(current);
      }
      cache2.delete(key);
      keys.delete(key);
    }
    watch(
      () => [props2.include, props2.exclude],
      ([include, exclude]) => {
        include && pruneCache((name) => matches(include, name));
        exclude && pruneCache((name) => !matches(exclude, name));
      },
      // prune post-render after `current` has been updated
      { flush: "post", deep: true }
    );
    let pendingCacheKey = null;
    const cacheSubtree = () => {
      if (pendingCacheKey != null) {
        if (isSuspense(instance.subTree.type)) {
          queuePostRenderEffect(() => {
            cache2.set(pendingCacheKey, getInnerChild(instance.subTree));
          }, instance.subTree.suspense);
        } else {
          cache2.set(pendingCacheKey, getInnerChild(instance.subTree));
        }
      }
    };
    onMounted(cacheSubtree);
    onUpdated(cacheSubtree);
    onBeforeUnmount(() => {
      cache2.forEach((cached) => {
        const { subTree, suspense } = instance;
        const vnode = getInnerChild(subTree);
        if (cached.type === vnode.type && cached.key === vnode.key) {
          resetShapeFlag(vnode);
          const da = vnode.component.da;
          da && queuePostRenderEffect(da, suspense);
          return;
        }
        unmount(cached);
      });
    });
    return () => {
      pendingCacheKey = null;
      if (!slots.default) {
        return null;
      }
      const children = slots.default();
      const rawVNode = children[0];
      if (children.length > 1) {
        current = null;
        return children;
      } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
        current = null;
        return rawVNode;
      }
      let vnode = getInnerChild(rawVNode);
      const comp = vnode.type;
      const name = getComponentName(
        isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp
      );
      const { include, exclude, max: max2 } = props2;
      if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
        current = vnode;
        return rawVNode;
      }
      const key = vnode.key == null ? comp : vnode.key;
      const cachedVNode = cache2.get(key);
      if (vnode.el) {
        vnode = cloneVNode(vnode);
        if (rawVNode.shapeFlag & 128) {
          rawVNode.ssContent = vnode;
        }
      }
      pendingCacheKey = key;
      if (cachedVNode) {
        vnode.el = cachedVNode.el;
        vnode.component = cachedVNode.component;
        if (vnode.transition) {
          setTransitionHooks(vnode, vnode.transition);
        }
        vnode.shapeFlag |= 512;
        keys.delete(key);
        keys.add(key);
      } else {
        keys.add(key);
        if (max2 && keys.size > parseInt(max2, 10)) {
          pruneCacheEntry(keys.values().next().value);
        }
      }
      vnode.shapeFlag |= 256;
      current = vnode;
      return isSuspense(rawVNode.type) ? rawVNode : vnode;
    };
  }
};
const KeepAlive = KeepAliveImpl;
function matches(pattern, name) {
  if (isArray$2(pattern)) {
    return pattern.some((p2) => matches(p2, name));
  } else if (isString$1(pattern)) {
    return pattern.split(",").includes(name);
  } else if (isRegExp$1(pattern)) {
    return pattern.test(name);
  }
  return false;
}
function onActivated(hook, target2) {
  registerKeepAliveHook(hook, "a", target2);
}
function onDeactivated(hook, target2) {
  registerKeepAliveHook(hook, "da", target2);
}
function registerKeepAliveHook(hook, type, target2 = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target2;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target2);
  if (target2) {
    let current = target2.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target2, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target2, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target2);
}
function resetShapeFlag(vnode) {
  vnode.shapeFlag &= ~256;
  vnode.shapeFlag &= ~512;
}
function getInnerChild(vnode) {
  return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
}
const leaveCbKey = Symbol("_leaveCb");
const enterCbKey$1 = Symbol("_enterCb");
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  // leave
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  // appear
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
const recursiveGetSubtree = (instance) => {
  const subTree = instance.subTree;
  return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
};
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: BaseTransitionPropsValidators,
  setup(props2, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      let child = children[0];
      if (children.length > 1) {
        for (const c2 of children) {
          if (c2.type !== Comment) {
            child = c2;
            break;
          }
        }
      }
      const rawProps = toRaw(props2);
      const { mode } = rawProps;
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getKeepAliveChild(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      let enterHooks = resolveTransitionHooks(
        innerChild,
        rawProps,
        state,
        instance,
        // #11061, ensure enterHooks is fresh after clone
        (hooks) => enterHooks = hooks
      );
      setTransitionHooks(innerChild, enterHooks);
      const oldChild = instance.subTree;
      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {
        const leavingHooks = resolveTransitionHooks(
          oldInnerChild,
          rawProps,
          state,
          instance
        );
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in" && innerChild.type !== Comment) {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (instance.update.active !== false) {
              instance.effect.dirty = true;
              instance.update();
            }
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(
              state,
              oldInnerChild
            );
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el[leaveCbKey] = () => {
              earlyRemove();
              el[leaveCbKey] = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props2, state, instance, postClone) {
  const {
    appear,
    mode,
    persisted = false,
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onEnterCancelled,
    onBeforeLeave,
    onLeave,
    onAfterLeave,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props2;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(
      hook,
      instance,
      9,
      args
    );
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook2(hook, args);
    if (isArray$2(hook)) {
      if (hook.every((hook2) => hook2.length <= 1)) done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el[leaveCbKey]) {
        el[leaveCbKey](
          true
          /* cancelled */
        );
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
        leavingVNode.el[leaveCbKey]();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el[enterCbKey$1] = (cancelled) => {
        if (called) return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el[enterCbKey$1] = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove2) {
      const key2 = String(vnode.key);
      if (el[enterCbKey$1]) {
        el[enterCbKey$1](
          true
          /* cancelled */
        );
      }
      if (state.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el]);
      let called = false;
      const done = el[leaveCbKey] = (cancelled) => {
        if (called) return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave, [el]);
        }
        el[leaveCbKey] = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      const hooks2 = resolveTransitionHooks(
        vnode2,
        props2,
        state,
        instance,
        postClone
      );
      if (postClone) postClone(hooks2);
      return hooks2;
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getKeepAliveChild(vnode) {
  if (!isKeepAlive(vnode)) {
    return vnode;
  }
  const { shapeFlag, children } = vnode;
  if (children) {
    if (shapeFlag & 16) {
      return children[0];
    }
    if (shapeFlag & 32 && isFunction$1(children.default)) {
      return children.default();
    }
  }
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i = 0; i < children.length; i++) {
    let child = children[i];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
    if (child.type === Fragment) {
      if (child.patchFlag & 128) keyedFragmentCount++;
      ret = ret.concat(
        getTransitionRawChildren(child.children, keepComment, key)
      );
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = -2;
    }
  }
  return ret;
}
const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props2) => props2 && (props2.disabled || props2.disabled === "");
const isTargetSVG = (target2) => typeof SVGElement !== "undefined" && target2 instanceof SVGElement;
const isTargetMathML = (target2) => typeof MathMLElement === "function" && target2 instanceof MathMLElement;
const resolveTarget = (props2, select) => {
  const targetSelector = props2 && props2.to;
  if (isString$1(targetSelector)) {
    if (!select) {
      return null;
    } else {
      const target2 = select(targetSelector);
      return target2;
    }
  } else {
    return targetSelector;
  }
};
const TeleportImpl = {
  name: "Teleport",
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
    const {
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      o: { insert, querySelector, createText, createComment }
    } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (n1 == null) {
      const placeholder = n2.el = createText("");
      const mainAnchor = n2.anchor = createText("");
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const target2 = n2.target = resolveTarget(n2.props, querySelector);
      const targetAnchor = n2.targetAnchor = createText("");
      if (target2) {
        insert(targetAnchor, target2);
        if (namespace === "svg" || isTargetSVG(target2)) {
          namespace = "svg";
        } else if (namespace === "mathml" || isTargetMathML(target2)) {
          namespace = "mathml";
        }
      }
      const mount = (container2, anchor2) => {
        if (shapeFlag & 16) {
          mountChildren(
            children,
            container2,
            anchor2,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      if (disabled) {
        mount(container, mainAnchor);
      } else if (target2) {
        mount(target2, targetAnchor);
      }
    } else {
      n2.el = n1.el;
      const mainAnchor = n2.anchor = n1.anchor;
      const target2 = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target2;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      if (namespace === "svg" || isTargetSVG(target2)) {
        namespace = "svg";
      } else if (namespace === "mathml" || isTargetMathML(target2)) {
        namespace = "mathml";
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          currentContainer,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          currentContainer,
          currentAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          false
        );
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(
            n2,
            container,
            mainAnchor,
            internals,
            1
          );
        } else {
          if (n2.props && n1.props && n2.props.to !== n1.props.to) {
            n2.props.to = n1.props.to;
          }
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(
            n2.props,
            querySelector
          );
          if (nextTarget) {
            moveTeleport(
              n2,
              nextTarget,
              null,
              internals,
              0
            );
          }
        } else if (wasDisabled) {
          moveTeleport(
            n2,
            target2,
            targetAnchor,
            internals,
            1
          );
        }
      }
    }
    updateCssVars(n2);
  },
  remove(vnode, parentComponent, parentSuspense, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const { shapeFlag, children, anchor, targetAnchor, target: target2, props: props2 } = vnode;
    if (target2) {
      hostRemove(targetAnchor);
    }
    doRemove && hostRemove(anchor);
    if (shapeFlag & 16) {
      const shouldRemove = doRemove || !isTeleportDisabled(props2);
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        unmount(
          child,
          parentComponent,
          parentSuspense,
          shouldRemove,
          !!child.dynamicChildren
        );
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props: props2 } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props2)) {
    if (shapeFlag & 16) {
      for (let i = 0; i < children.length; i++) {
        move(
          children[i],
          container,
          parentAnchor,
          2
        );
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
  o: { nextSibling, parentNode, querySelector }
}, hydrateChildren) {
  const target2 = vnode.target = resolveTarget(
    vnode.props,
    querySelector
  );
  if (target2) {
    const targetNode = target2._lpa || target2.firstChild;
    if (vnode.shapeFlag & 16) {
      if (isTeleportDisabled(vnode.props)) {
        vnode.anchor = hydrateChildren(
          nextSibling(node),
          vnode,
          parentNode(node),
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        vnode.targetAnchor = targetNode;
      } else {
        vnode.anchor = nextSibling(node);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          targetAnchor = nextSibling(targetAnchor);
          if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
            vnode.targetAnchor = targetAnchor;
            target2._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
            break;
          }
        }
        hydrateChildren(
          targetNode,
          vnode,
          target2,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      }
    }
    updateCssVars(vnode);
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode) {
  const ctx = vnode.ctx;
  if (ctx && ctx.ut) {
    let node = vnode.children[0].el;
    while (node && node !== vnode.targetAnchor) {
      if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx.uid);
      node = node.nextSibling;
    }
    ctx.ut();
  }
}
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value2) {
  isBlockTreeEnabled += value2;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props2, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type,
      props2,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
    )
  );
}
function createBlock(type, props2, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type,
      props2,
      children,
      patchFlag,
      dynamicProps,
      true
    )
  );
}
function isVNode(value2) {
  return value2 ? value2.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
  ref: ref3,
  ref_key,
  ref_for
}) => {
  if (typeof ref3 === "number") {
    ref3 = "" + ref3;
  }
  return ref3 != null ? isString$1(ref3) || isRef(ref3) || isFunction$1(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
};
function createBaseVNode(type, props2 = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props: props2,
    key: props2 && normalizeKey(props2),
    ref: props2 && normalizeRef(props2),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString$1(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props2 = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(
      type,
      props2,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag = -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props2) {
    props2 = guardReactiveProps(props2);
    let { class: klass, style } = props2;
    if (klass && !isString$1(klass)) {
      props2.class = normalizeClass(klass);
    }
    if (isObject$4(style)) {
      if (isProxy(style) && !isArray$2(style)) {
        style = extend$1({}, style);
      }
      props2.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString$1(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$4(type) ? 4 : isFunction$1(type) ? 2 : 0;
  return createBaseVNode(
    type,
    props2,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props2) {
  if (!props2) return null;
  return isProxy(props2) || isInternalObject(props2) ? extend$1({}, props2) : props2;
}
function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
  const { props: props2, ref: ref3, patchFlag, children, transition } = vnode;
  const mergedProps = extraProps ? mergeProps(props2 || {}, extraProps) : props2;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref3 ? isArray$2(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref3,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  if (transition && cloneTransition) {
    setTransitionHooks(
      cloned,
      transition.clone(cloned)
    );
  }
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray$2(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray$2(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !isInternalObject(children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$1(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray$2(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid$4 = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid$4++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    attrsProxy: null,
    slotsProxy: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let setInSSRSetupState;
{
  const g2 = getGlobalThis();
  const registerGlobalSetter = (key, setter) => {
    let setters;
    if (!(setters = g2[key])) setters = g2[key] = [];
    setters.push(setter);
    return (v2) => {
      if (setters.length > 1) setters.forEach((set2) => set2(v2));
      else setters[0](v2);
    };
  };
  internalSetCurrentInstance = registerGlobalSetter(
    `__VUE_INSTANCE_SETTERS__`,
    (v2) => currentInstance = v2
  );
  setInSSRSetupState = registerGlobalSetter(
    `__VUE_SSR_SETTERS__`,
    (v2) => isInSSRComponentSetup = v2
  );
}
const setCurrentInstance = (instance) => {
  const prev = currentInstance;
  internalSetCurrentInstance(instance);
  instance.scope.on();
  return () => {
    instance.scope.off();
    internalSetCurrentInstance(prev);
  };
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isSSR && setInSSRSetupState(isSSR);
  const { props: props2, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props2, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isSSR && setInSSRSetupState(false);
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
  const { setup } = Component;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    const reset = setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(
      setup,
      instance,
      0,
      [
        instance.props,
        setupContext
      ]
    );
    resetTracking();
    reset();
    if (isPromise(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e2) => {
          handleError(e2, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$1(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$4(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else ;
  finishComponentSetup(instance, isSSR);
}
let compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance).template;
      if (template) {
        const { isCustomElement: isCustomElement2, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend$1(
          extend$1(
            {
              isCustomElement: isCustomElement2,
              delimiters
            },
            compilerOptions
          ),
          componentCompilerOptions
        );
        Component.render = compile(template, finalCompilerOptions);
      }
    }
    instance.render = Component.render || NOOP;
  }
  {
    const reset = setCurrentInstance(instance);
    pauseTracking();
    try {
      applyOptions(instance);
    } finally {
      resetTracking();
      reset();
    }
  }
}
const attrsProxyHandlers = {
  get(target2, key) {
    track(target2, "get", "");
    return target2[key];
  }
};
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  {
    return {
      attrs: new Proxy(instance.attrs, attrsProxyHandlers),
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getComponentPublicInstance(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target2, key) {
        if (key in target2) {
          return target2[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target2, key) {
        return key in target2 || key in publicPropertiesMap;
      }
    }));
  } else {
    return instance.proxy;
  }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, (c2) => c2.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
  return isFunction$1(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name = match[1];
    }
  }
  if (!name && instance && instance.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name = inferFromRegistry(
      instance.components || instance.parent.type.components
    ) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value2) {
  return isFunction$1(value2) && "__vccOpts" in value2;
}
const computed = (getterOrOptions, debugOptions) => {
  const c2 = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
  return c2;
};
function h$1(type, propsOrChildren, children) {
  const l2 = arguments.length;
  if (l2 === 2) {
    if (isObject$4(propsOrChildren) && !isArray$2(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l2 > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l2 === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
const version = "3.4.31";
/**
* @vue/runtime-dom v3.4.31
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const svgNS = "http://www.w3.org/2000/svg";
const mathmlNS = "http://www.w3.org/1998/Math/MathML";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, namespace, is, props2) => {
    const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
    if (tag === "select" && props2 && props2.multiple != null) {
      el.setAttribute("multiple", props2.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id2) {
    el.setAttribute(id2, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content2, parent, anchor, namespace, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling)) break;
      }
    } else {
      templateContainer.innerHTML = namespace === "svg" ? `<svg>${content2}</svg>` : namespace === "mathml" ? `<math>${content2}</math>` : content2;
      const template = templateContainer.content;
      if (namespace === "svg" || namespace === "mathml") {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
const TRANSITION = "transition";
const ANIMATION = "animation";
const vtcKey = Symbol("_vtc");
const Transition = (props2, { slots }) => h$1(BaseTransition, resolveTransitionProps(props2), slots);
Transition.displayName = "Transition";
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend$1(
  {},
  BaseTransitionPropsValidators,
  DOMTransitionPropsValidators
);
const callHook = (hook, args = []) => {
  if (isArray$2(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray$2(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const {
    name = "v",
    type,
    duration: duration2,
    enterFromClass = `${name}-enter-from`,
    enterActiveClass = `${name}-enter-active`,
    enterToClass = `${name}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name}-leave-from`,
    leaveActiveClass = `${name}-leave-active`,
    leaveToClass = `${name}-leave-to`
  } = rawProps;
  const durations = normalizeDuration(duration2);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter,
    onEnter,
    onEnterCancelled,
    onLeave,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter,
    onAppear = onEnter,
    onAppearCancelled = onEnterCancelled
  } = baseProps;
  const finishEnter = (el, isAppear, done) => {
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve2 = () => finishEnter(el, isAppear, done);
      callHook(hook, [el, resolve2]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve2);
        }
      });
    };
  };
  return extend$1(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve2 = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      addTransitionClass(el, leaveActiveClass);
      forceReflow();
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve2);
        }
      });
      callHook(onLeave, [el, resolve2]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration2) {
  if (duration2 == null) {
    return null;
  } else if (isObject$4(duration2)) {
    return [NumberOf(duration2.enter), NumberOf(duration2.leave)];
  } else {
    const n2 = NumberOf(duration2);
    return [n2, n2];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c2) => c2 && el.classList.add(c2));
  (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c2) => c2 && el.classList.remove(c2));
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el[vtcKey] = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
  const id2 = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id2 === el._endId) {
      resolve2();
    }
  };
  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout: timeout2, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve2();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e2) => {
    if (e2.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout2 + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout2 = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout2 = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout2 = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout2 = Math.max(transitionTimeout, animationTimeout);
    type = timeout2 > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
    getStyleProperties(`${TRANSITION}Property`).toString()
  );
  return {
    type,
    timeout: timeout2,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d2, i) => toMs(d2) + toMs(delays[i])));
}
function toMs(s2) {
  if (s2 === "auto") return 0;
  return Number(s2.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
function patchClass(el, value2, isSVG2) {
  const transitionClasses = el[vtcKey];
  if (transitionClasses) {
    value2 = (value2 ? [value2, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value2 == null) {
    el.removeAttribute("class");
  } else if (isSVG2) {
    el.setAttribute("class", value2);
  } else {
    el.className = value2;
  }
}
const vShowOriginalDisplay = Symbol("_vod");
const vShowHidden = Symbol("_vsh");
const CSS_VAR_TEXT = Symbol("");
const displayRE = /(^|;)\s*display\s*:/;
function patchStyle(el, prev, next) {
  const style = el.style;
  const isCssString = isString$1(next);
  let hasControlledDisplay = false;
  if (next && !isCssString) {
    if (prev) {
      if (!isString$1(prev)) {
        for (const key in prev) {
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      } else {
        for (const prevStyle of prev.split(";")) {
          const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      }
    }
    for (const key in next) {
      if (key === "display") {
        hasControlledDisplay = true;
      }
      setStyle(style, key, next[key]);
    }
  } else {
    if (isCssString) {
      if (prev !== next) {
        const cssVarText = style[CSS_VAR_TEXT];
        if (cssVarText) {
          next += ";" + cssVarText;
        }
        style.cssText = next;
        hasControlledDisplay = displayRE.test(next);
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
  }
  if (vShowOriginalDisplay in el) {
    el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
    if (el[vShowHidden]) {
      style.display = "none";
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
  if (isArray$2(val)) {
    val.forEach((v2) => setStyle(style, name, v2));
  } else {
    if (val == null) val = "";
    if (name.startsWith("--")) {
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);
      if (importantRE.test(val)) {
        style.setProperty(
          hyphenate(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style) {
    return prefixCache[rawName] = name;
  }
  name = capitalize$1(name);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value2, isSVG2, instance, isBoolean2 = isSpecialBooleanAttr(key)) {
  if (isSVG2 && key.startsWith("xlink:")) {
    if (value2 == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value2);
    }
  } else {
    if (value2 == null || isBoolean2 && !includeBooleanAttr(value2)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(
        key,
        isBoolean2 ? "" : isSymbol(value2) ? String(value2) : value2
      );
    }
  }
}
function patchDOMProp(el, key, value2, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key] = value2 == null ? "" : value2;
    return;
  }
  const tag = el.tagName;
  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
    const newValue = value2 == null ? "" : String(value2);
    if (oldValue !== newValue || !("_value" in el)) {
      el.value = newValue;
    }
    if (value2 == null) {
      el.removeAttribute(key);
    }
    el._value = value2;
    return;
  }
  let needRemove = false;
  if (value2 === "" || value2 == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value2 = includeBooleanAttr(value2);
    } else if (value2 == null && type === "string") {
      value2 = "";
      needRemove = true;
    } else if (type === "number") {
      value2 = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value2;
  } catch (e2) {
  }
  needRemove && el.removeAttribute(key);
}
function addEventListener$1(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener$1(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
const veiKey = Symbol("_vei");
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el[veiKey] || (el[veiKey] = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(
        nextValue,
        instance
      );
      addEventListener$1(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener$1(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m2;
    while (m2 = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m2[0].length);
      options[m2[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p$1 = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p$1.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e2) => {
    if (!e2._vts) {
      e2._vts = Date.now();
    } else if (e2._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(
      patchStopImmediatePropagation(e2, invoker.value),
      instance,
      5,
      [e2]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e2, value2) {
  if (isArray$2(value2)) {
    const originalStop = e2.stopImmediatePropagation;
    e2.stopImmediatePropagation = () => {
      originalStop.call(e2);
      e2._stopped = true;
    };
    return value2.map(
      (fn) => (e22) => !e22._stopped && fn && fn(e22)
    );
  } else {
    return value2;
  }
}
const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
const patchProp = (el, key, prevValue, nextValue, namespace, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  const isSVG2 = namespace === "svg";
  if (key === "class") {
    patchClass(el, nextValue, isSVG2);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG2)) {
    patchDOMProp(
      el,
      key,
      nextValue,
      prevChildren,
      parentComponent,
      parentSuspense,
      unmountChildren
    );
    if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
      patchAttr(el, key, nextValue, isSVG2, parentComponent, key !== "value");
    }
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG2);
  }
};
function shouldSetAsProp(el, key, value2, isSVG2) {
  if (isSVG2) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && isNativeOn(key) && isFunction$1(value2)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (key === "width" || key === "height") {
    const tag = el.tagName;
    if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
      return false;
    }
  }
  if (isNativeOn(key) && isString$1(value2)) {
    return false;
  }
  return key in el;
}
const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const moveCbKey = Symbol("_moveCb");
const enterCbKey = Symbol("_enterCb");
const TransitionGroupImpl = {
  name: "TransitionGroup",
  props: /* @__PURE__ */ extend$1({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props2, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevChildren;
    let children;
    onUpdated(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props2.moveClass || `${props2.name || "v"}-move`;
      if (!hasCSSTransform(
        prevChildren[0].el,
        instance.vnode.el,
        moveClass
      )) {
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach((c2) => {
        const el = c2.el;
        const style = el.style;
        addTransitionClass(el, moveClass);
        style.transform = style.webkitTransform = style.transitionDuration = "";
        const cb = el[moveCbKey] = (e2) => {
          if (e2 && e2.target !== el) {
            return;
          }
          if (!e2 || /transform$/.test(e2.propertyName)) {
            el.removeEventListener("transitionend", cb);
            el[moveCbKey] = null;
            removeTransitionClass(el, moveClass);
          }
        };
        el.addEventListener("transitionend", cb);
      });
    });
    return () => {
      const rawProps = toRaw(props2);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag = rawProps.tag || Fragment;
      prevChildren = [];
      if (children) {
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (child.el && child.el instanceof Element) {
            prevChildren.push(child);
            setTransitionHooks(
              child,
              resolveTransitionHooks(
                child,
                cssTransitionProps,
                state,
                instance
              )
            );
            positionMap.set(
              child,
              child.el.getBoundingClientRect()
            );
          }
        }
      }
      children = slots.default ? getTransitionRawChildren(slots.default()) : [];
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (child.key != null) {
          setTransitionHooks(
            child,
            resolveTransitionHooks(child, cssTransitionProps, state, instance)
          );
        }
      }
      return createVNode(tag, null, children);
    };
  }
};
const removeMode = (props2) => delete props2.mode;
/* @__PURE__ */ removeMode(TransitionGroupImpl.props);
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c2) {
  const el = c2.el;
  if (el[moveCbKey]) {
    el[moveCbKey]();
  }
  if (el[enterCbKey]) {
    el[enterCbKey]();
  }
}
function recordPosition(c2) {
  newPositionMap.set(c2, c2.el.getBoundingClientRect());
}
function applyTranslation(c2) {
  const oldPos = positionMap.get(c2);
  const newPos = newPositionMap.get(c2);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s2 = c2.el.style;
    s2.transform = s2.webkitTransform = `translate(${dx}px,${dy}px)`;
    s2.transitionDuration = "0s";
    return c2;
  }
}
function hasCSSTransform(el, root, moveClass) {
  const clone = el.cloneNode();
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c2) => c2 && clone.classList.remove(c2));
    });
  }
  moveClass.split(/\s+/).forEach((c2) => c2 && clone.classList.add(c2));
  clone.style.display = "none";
  const container = root.nodeType === 1 ? root : root.parentNode;
  container.appendChild(clone);
  const { hasTransform } = getTransitionInfo(clone);
  container.removeChild(clone);
  return hasTransform;
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e2) => e2.stopPropagation(),
  prevent: (e2) => e2.preventDefault(),
  self: (e2) => e2.target !== e2.currentTarget,
  ctrl: (e2) => !e2.ctrlKey,
  shift: (e2) => !e2.shiftKey,
  alt: (e2) => !e2.altKey,
  meta: (e2) => !e2.metaKey,
  left: (e2) => "button" in e2 && e2.button !== 0,
  middle: (e2) => "button" in e2 && e2.button !== 1,
  right: (e2) => "button" in e2 && e2.button !== 2,
  exact: (e2, modifiers) => systemModifiers.some((m2) => e2[`${m2}Key`] && !modifiers.includes(m2))
};
const withModifiers = (fn, modifiers) => {
  const cache2 = fn._withMods || (fn._withMods = {});
  const cacheKey = modifiers.join(".");
  return cache2[cacheKey] || (cache2[cacheKey] = (event, ...args) => {
    for (let i = 0; i < modifiers.length; i++) {
      const guard = modifierGuards[modifiers[i]];
      if (guard && guard(event, modifiers)) return;
    }
    return fn(event, ...args);
  });
};
const rendererOptions = /* @__PURE__ */ extend$1({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const createApp = (...args) => {
  const app2 = ensureRenderer().createApp(...args);
  const { mount } = app2;
  app2.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container) return;
    const component = app2._component;
    if (!isFunction$1(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount(container, false, resolveRootNamespace(container));
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app2;
};
function resolveRootNamespace(container) {
  if (container instanceof SVGElement) {
    return "svg";
  }
  if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
    return "mathml";
  }
}
function normalizeContainer(container) {
  if (isString$1(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
function injectProp(target2, propName, get2, set2) {
  Object.defineProperty(target2, propName, {
    get: get2,
    set: set2,
    enumerable: true
  });
  return target2;
}
function injectMultipleProps(target2, props2) {
  for (const key in props2) {
    injectProp(target2, key, props2[key]);
  }
  return target2;
}
function createComponent(raw) {
  return markRaw(/* @__PURE__ */ defineComponent(raw));
}
function createDirective(raw) {
  return markRaw(raw);
}
const createReactivePlugin = (state, plugin) => {
  const reactiveState = reactive(state);
  for (const name in state) {
    injectProp(
      plugin,
      name,
      () => reactiveState[name],
      (val) => {
        reactiveState[name] = val;
      }
    );
  }
  return plugin;
};
function hSlot(slot, otherwise) {
  return slot !== void 0 ? slot() || otherwise : otherwise;
}
function hUniqueSlot(slot, otherwise) {
  if (slot !== void 0) {
    const vnode = slot();
    if (vnode !== void 0 && vnode !== null) {
      return vnode.slice();
    }
  }
  return otherwise;
}
function hMergeSlot(slot, source) {
  return slot !== void 0 ? source.concat(slot()) : source;
}
function hMergeSlotSafely(slot, source) {
  if (slot === void 0) {
    return source;
  }
  return source !== void 0 ? source.concat(slot()) : slot();
}
function hDir(tag, data, children, key, condition, getDirsFn) {
  data.key = key + condition;
  const vnode = h$1(tag, data, children);
  return condition === true ? withDirectives(vnode, getDirsFn()) : vnode;
}
const quasarKey = "_q_";
const layoutKey = "_q_l_";
const pageContainerKey = "_q_pc_";
const formKey = "_q_fo_";
const tabsKey = "_q_tabs_";
function emptyRenderFn() {
}
const QPageContainer = createComponent({
  name: "QPageContainer",
  setup(_2, { slots }) {
    const { proxy: { $q } } = getCurrentInstance();
    const $layout = inject(layoutKey, emptyRenderFn);
    if ($layout === emptyRenderFn) {
      console.error("QPageContainer needs to be child of QLayout");
      return emptyRenderFn;
    }
    provide(pageContainerKey, true);
    const style = computed(() => {
      const css2 = {};
      if ($layout.header.space === true) {
        css2.paddingTop = `${$layout.header.size}px`;
      }
      if ($layout.right.space === true) {
        css2[`padding${$q.lang.rtl === true ? "Left" : "Right"}`] = `${$layout.right.size}px`;
      }
      if ($layout.footer.space === true) {
        css2.paddingBottom = `${$layout.footer.size}px`;
      }
      if ($layout.left.space === true) {
        css2[`padding${$q.lang.rtl === true ? "Right" : "Left"}`] = `${$layout.left.size}px`;
      }
      return css2;
    });
    return () => h$1("div", {
      class: "q-page-container",
      style: style.value
    }, hSlot(slots.default));
  }
});
const isRuntimeSsrPreHydration = ref(
  false
);
let preHydrationBrowser;
function getMatch(userAgent2, platformMatch) {
  const match = /(edg|edge|edga|edgios)\/([\w.]+)/.exec(userAgent2) || /(opr)[\/]([\w.]+)/.exec(userAgent2) || /(vivaldi)[\/]([\w.]+)/.exec(userAgent2) || /(chrome|crios)[\/]([\w.]+)/.exec(userAgent2) || /(version)(applewebkit)[\/]([\w.]+).*(safari)[\/]([\w.]+)/.exec(userAgent2) || /(webkit)[\/]([\w.]+).*(version)[\/]([\w.]+).*(safari)[\/]([\w.]+)/.exec(userAgent2) || /(firefox|fxios)[\/]([\w.]+)/.exec(userAgent2) || /(webkit)[\/]([\w.]+)/.exec(userAgent2) || /(opera)(?:.*version|)[\/]([\w.]+)/.exec(userAgent2) || [];
  return {
    browser: match[5] || match[3] || match[1] || "",
    version: match[4] || match[2] || "0",
    platform: platformMatch[0] || ""
  };
}
function getPlatformMatch(userAgent2) {
  return /(ipad)/.exec(userAgent2) || /(ipod)/.exec(userAgent2) || /(windows phone)/.exec(userAgent2) || /(iphone)/.exec(userAgent2) || /(kindle)/.exec(userAgent2) || /(silk)/.exec(userAgent2) || /(android)/.exec(userAgent2) || /(win)/.exec(userAgent2) || /(mac)/.exec(userAgent2) || /(linux)/.exec(userAgent2) || /(cros)/.exec(userAgent2) || /(playbook)/.exec(userAgent2) || /(bb)/.exec(userAgent2) || /(blackberry)/.exec(userAgent2) || [];
}
const hasTouch = "ontouchstart" in window || window.navigator.maxTouchPoints > 0;
function getPlatform(UA) {
  const userAgent2 = UA.toLowerCase(), platformMatch = getPlatformMatch(userAgent2), matched = getMatch(userAgent2, platformMatch), browser = {};
  if (matched.browser) {
    browser[matched.browser] = true;
    browser.version = matched.version;
    browser.versionNumber = parseInt(matched.version, 10);
  }
  if (matched.platform) {
    browser[matched.platform] = true;
  }
  const knownMobiles = browser.android || browser.ios || browser.bb || browser.blackberry || browser.ipad || browser.iphone || browser.ipod || browser.kindle || browser.playbook || browser.silk || browser["windows phone"];
  if (knownMobiles === true || userAgent2.indexOf("mobile") !== -1) {
    browser.mobile = true;
  } else {
    browser.desktop = true;
  }
  if (browser["windows phone"]) {
    browser.winphone = true;
    delete browser["windows phone"];
  }
  if (browser.edga || browser.edgios || browser.edg) {
    browser.edge = true;
    matched.browser = "edge";
  } else if (browser.crios) {
    browser.chrome = true;
    matched.browser = "chrome";
  } else if (browser.fxios) {
    browser.firefox = true;
    matched.browser = "firefox";
  }
  if (browser.ipod || browser.ipad || browser.iphone) {
    browser.ios = true;
  }
  if (browser.vivaldi) {
    matched.browser = "vivaldi";
    browser.vivaldi = true;
  }
  if (
    // Chrome, Opera 15+, Vivaldi and Safari are webkit based browsers
    browser.chrome || browser.opr || browser.safari || browser.vivaldi || browser.mobile === true && browser.ios !== true && knownMobiles !== true
  ) {
    browser.webkit = true;
  }
  if (browser.opr) {
    matched.browser = "opera";
    browser.opera = true;
  }
  if (browser.safari) {
    if (browser.blackberry || browser.bb) {
      matched.browser = "blackberry";
      browser.blackberry = true;
    } else if (browser.playbook) {
      matched.browser = "playbook";
      browser.playbook = true;
    } else if (browser.android) {
      matched.browser = "android";
      browser.android = true;
    } else if (browser.kindle) {
      matched.browser = "kindle";
      browser.kindle = true;
    } else if (browser.silk) {
      matched.browser = "silk";
      browser.silk = true;
    }
  }
  browser.name = matched.browser;
  browser.platform = matched.platform;
  {
    if (userAgent2.indexOf("electron") !== -1) {
      browser.electron = true;
    } else if (document.location.href.indexOf("-extension://") !== -1) {
      browser.bex = true;
    } else {
      if (window.Capacitor !== void 0) {
        browser.capacitor = true;
        browser.nativeMobile = true;
        browser.nativeMobileWrapper = "capacitor";
      } else if (window._cordovaNative !== void 0 || window.cordova !== void 0) {
        browser.cordova = true;
        browser.nativeMobile = true;
        browser.nativeMobileWrapper = "cordova";
      }
      if (isRuntimeSsrPreHydration.value === true) {
        preHydrationBrowser = { is: { ...browser } };
      }
      if (hasTouch === true && browser.mac === true && (browser.desktop === true && browser.safari === true || browser.nativeMobile === true && browser.android !== true && browser.ios !== true && browser.ipad !== true)) {
        delete browser.mac;
        delete browser.desktop;
        const platform2 = Math.min(window.innerHeight, window.innerWidth) > 414 ? "ipad" : "iphone";
        Object.assign(browser, {
          mobile: true,
          ios: true,
          platform: platform2,
          [platform2]: true
        });
      }
      if (browser.mobile !== true && window.navigator.userAgentData && window.navigator.userAgentData.mobile) {
        delete browser.desktop;
        browser.mobile = true;
      }
    }
  }
  return browser;
}
const userAgent = navigator.userAgent || navigator.vendor || window.opera;
const ssrClient = {
  has: {
    touch: false,
    webStorage: false
  },
  within: { iframe: false }
};
const client = {
  userAgent,
  is: getPlatform(userAgent),
  has: {
    touch: hasTouch
  },
  within: {
    iframe: window.self !== window.top
  }
};
const Platform = {
  install(opts) {
    const { $q } = opts;
    if (isRuntimeSsrPreHydration.value === true) {
      opts.onSSRHydrated.push(() => {
        Object.assign($q.platform, client);
        isRuntimeSsrPreHydration.value = false;
      });
      $q.platform = reactive(this);
    } else {
      $q.platform = this;
    }
  }
};
{
  let hasWebStorage;
  injectProp(client.has, "webStorage", () => {
    if (hasWebStorage !== void 0) {
      return hasWebStorage;
    }
    try {
      if (window.localStorage) {
        hasWebStorage = true;
        return true;
      }
    } catch (_2) {
    }
    hasWebStorage = false;
    return false;
  });
  Object.assign(Platform, client);
  if (isRuntimeSsrPreHydration.value === true) {
    Object.assign(Platform, preHydrationBrowser, ssrClient);
    preHydrationBrowser = null;
  }
}
function css(element, css2) {
  const style = element.style;
  for (const prop in css2) {
    style[prop] = css2[prop];
  }
}
function getElement(el) {
  if (el === void 0 || el === null) {
    return void 0;
  }
  if (typeof el === "string") {
    try {
      return document.querySelector(el) || void 0;
    } catch (err) {
      return void 0;
    }
  }
  const target2 = unref(el);
  if (target2) {
    return target2.$el || target2;
  }
}
function childHasFocus(el, focusedEl) {
  if (el === void 0 || el === null || el.contains(focusedEl) === true) {
    return true;
  }
  for (let next = el.nextElementSibling; next !== null; next = next.nextElementSibling) {
    if (next.contains(focusedEl)) {
      return true;
    }
  }
  return false;
}
const scrollTargetProp = [Element, String];
const scrollTargets = [null, document, document.body, document.scrollingElement, document.documentElement];
function getScrollTarget(el, targetEl) {
  let target2 = getElement(targetEl);
  if (target2 === void 0) {
    if (el === void 0 || el === null) {
      return window;
    }
    target2 = el.closest(".scroll,.scroll-y,.overflow-auto");
  }
  return scrollTargets.includes(target2) ? window : target2;
}
function getVerticalScrollPosition(scrollTarget) {
  return scrollTarget === window ? window.pageYOffset || window.scrollY || document.body.scrollTop || 0 : scrollTarget.scrollTop;
}
function getHorizontalScrollPosition(scrollTarget) {
  return scrollTarget === window ? window.pageXOffset || window.scrollX || document.body.scrollLeft || 0 : scrollTarget.scrollLeft;
}
function animVerticalScrollTo(el, to, duration2 = 0) {
  const prevTime = arguments[3] === void 0 ? performance.now() : arguments[3];
  const pos = getVerticalScrollPosition(el);
  if (duration2 <= 0) {
    if (pos !== to) {
      setScroll$1(el, to);
    }
    return;
  }
  requestAnimationFrame((nowTime) => {
    const frameTime = nowTime - prevTime;
    const newPos = pos + (to - pos) / Math.max(frameTime, duration2) * frameTime;
    setScroll$1(el, newPos);
    if (newPos !== to) {
      animVerticalScrollTo(el, to, duration2 - frameTime, nowTime);
    }
  });
}
function animHorizontalScrollTo(el, to, duration2 = 0) {
  const prevTime = arguments[3] === void 0 ? performance.now() : arguments[3];
  const pos = getHorizontalScrollPosition(el);
  if (duration2 <= 0) {
    if (pos !== to) {
      setHorizontalScroll(el, to);
    }
    return;
  }
  requestAnimationFrame((nowTime) => {
    const frameTime = nowTime - prevTime;
    const newPos = pos + (to - pos) / Math.max(frameTime, duration2) * frameTime;
    setHorizontalScroll(el, newPos);
    if (newPos !== to) {
      animHorizontalScrollTo(el, to, duration2 - frameTime, nowTime);
    }
  });
}
function setScroll$1(scrollTarget, offset) {
  if (scrollTarget === window) {
    window.scrollTo(window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, offset);
    return;
  }
  scrollTarget.scrollTop = offset;
}
function setHorizontalScroll(scrollTarget, offset) {
  if (scrollTarget === window) {
    window.scrollTo(offset, window.pageYOffset || window.scrollY || document.body.scrollTop || 0);
    return;
  }
  scrollTarget.scrollLeft = offset;
}
function setVerticalScrollPosition(scrollTarget, offset, duration2) {
  if (duration2) {
    animVerticalScrollTo(scrollTarget, offset, duration2);
    return;
  }
  setScroll$1(scrollTarget, offset);
}
function setHorizontalScrollPosition(scrollTarget, offset, duration2) {
  if (duration2) {
    animHorizontalScrollTo(scrollTarget, offset, duration2);
    return;
  }
  setHorizontalScroll(scrollTarget, offset);
}
let size;
function getScrollbarWidth() {
  if (size !== void 0) {
    return size;
  }
  const inner = document.createElement("p"), outer = document.createElement("div");
  css(inner, {
    width: "100%",
    height: "200px"
  });
  css(outer, {
    position: "absolute",
    top: "0px",
    left: "0px",
    visibility: "hidden",
    width: "200px",
    height: "150px",
    overflow: "hidden"
  });
  outer.appendChild(inner);
  document.body.appendChild(outer);
  const w1 = inner.offsetWidth;
  outer.style.overflow = "scroll";
  let w2 = inner.offsetWidth;
  if (w1 === w2) {
    w2 = outer.clientWidth;
  }
  outer.remove();
  size = w1 - w2;
  return size;
}
function hasScrollbar(el, onY = true) {
  if (!el || el.nodeType !== Node.ELEMENT_NODE) {
    return false;
  }
  return onY ? el.scrollHeight > el.clientHeight && (el.classList.contains("scroll") || el.classList.contains("overflow-auto") || ["auto", "scroll"].includes(window.getComputedStyle(el)["overflow-y"])) : el.scrollWidth > el.clientWidth && (el.classList.contains("scroll") || el.classList.contains("overflow-auto") || ["auto", "scroll"].includes(window.getComputedStyle(el)["overflow-x"]));
}
const listenOpts = {
  hasPassive: false,
  passiveCapture: true,
  notPassiveCapture: true
};
try {
  const opts = Object.defineProperty({}, "passive", {
    get() {
      Object.assign(listenOpts, {
        hasPassive: true,
        passive: { passive: true },
        notPassive: { passive: false },
        passiveCapture: { passive: true, capture: true },
        notPassiveCapture: { passive: false, capture: true }
      });
    }
  });
  window.addEventListener("qtest", null, opts);
  window.removeEventListener("qtest", null, opts);
} catch (_2) {
}
function noop$3() {
}
function leftClick(e2) {
  return e2.button === 0;
}
function position$1(e2) {
  if (e2.touches && e2.touches[0]) {
    e2 = e2.touches[0];
  } else if (e2.changedTouches && e2.changedTouches[0]) {
    e2 = e2.changedTouches[0];
  } else if (e2.targetTouches && e2.targetTouches[0]) {
    e2 = e2.targetTouches[0];
  }
  return {
    top: e2.clientY,
    left: e2.clientX
  };
}
function getEventPath(e2) {
  if (e2.path) {
    return e2.path;
  }
  if (e2.composedPath) {
    return e2.composedPath();
  }
  const path = [];
  let el = e2.target;
  while (el) {
    path.push(el);
    if (el.tagName === "HTML") {
      path.push(document);
      path.push(window);
      return path;
    }
    el = el.parentElement;
  }
}
function stop(e2) {
  e2.stopPropagation();
}
function prevent(e2) {
  e2.cancelable !== false && e2.preventDefault();
}
function stopAndPrevent(e2) {
  e2.cancelable !== false && e2.preventDefault();
  e2.stopPropagation();
}
function preventDraggable(el, status) {
  if (el === void 0 || status === true && el.__dragPrevented === true) {
    return;
  }
  const fn = status === true ? (el2) => {
    el2.__dragPrevented = true;
    el2.addEventListener("dragstart", prevent, listenOpts.notPassiveCapture);
  } : (el2) => {
    delete el2.__dragPrevented;
    el2.removeEventListener("dragstart", prevent, listenOpts.notPassiveCapture);
  };
  el.querySelectorAll("a, img").forEach(fn);
}
function addEvt(ctx, targetName, events) {
  const name = `__q_${targetName}_evt`;
  ctx[name] = ctx[name] !== void 0 ? ctx[name].concat(events) : events;
  events.forEach((evt) => {
    evt[0].addEventListener(evt[1], ctx[evt[2]], listenOpts[evt[3]]);
  });
}
function cleanEvt(ctx, targetName) {
  const name = `__q_${targetName}_evt`;
  if (ctx[name] !== void 0) {
    ctx[name].forEach((evt) => {
      evt[0].removeEventListener(evt[1], ctx[evt[2]], listenOpts[evt[3]]);
    });
    ctx[name] = void 0;
  }
}
const { passive: passive$1 } = listenOpts;
const axisValues = ["both", "horizontal", "vertical"];
const QScrollObserver = createComponent({
  name: "QScrollObserver",
  props: {
    axis: {
      type: String,
      validator: (v2) => axisValues.includes(v2),
      default: "vertical"
    },
    debounce: [String, Number],
    scrollTarget: scrollTargetProp
  },
  emits: ["scroll"],
  setup(props2, { emit: emit2 }) {
    const scroll = {
      position: {
        top: 0,
        left: 0
      },
      direction: "down",
      directionChanged: false,
      delta: {
        top: 0,
        left: 0
      },
      inflectionPoint: {
        top: 0,
        left: 0
      }
    };
    let clearTimer = null, localScrollTarget, parentEl;
    watch(() => props2.scrollTarget, () => {
      unconfigureScrollTarget();
      configureScrollTarget();
    });
    function emitEvent() {
      clearTimer !== null && clearTimer();
      const top = Math.max(0, getVerticalScrollPosition(localScrollTarget));
      const left = getHorizontalScrollPosition(localScrollTarget);
      const delta = {
        top: top - scroll.position.top,
        left: left - scroll.position.left
      };
      if (props2.axis === "vertical" && delta.top === 0 || props2.axis === "horizontal" && delta.left === 0) {
        return;
      }
      const curDir = Math.abs(delta.top) >= Math.abs(delta.left) ? delta.top < 0 ? "up" : "down" : delta.left < 0 ? "left" : "right";
      scroll.position = { top, left };
      scroll.directionChanged = scroll.direction !== curDir;
      scroll.delta = delta;
      if (scroll.directionChanged === true) {
        scroll.direction = curDir;
        scroll.inflectionPoint = scroll.position;
      }
      emit2("scroll", { ...scroll });
    }
    function configureScrollTarget() {
      localScrollTarget = getScrollTarget(parentEl, props2.scrollTarget);
      localScrollTarget.addEventListener("scroll", trigger2, passive$1);
      trigger2(true);
    }
    function unconfigureScrollTarget() {
      if (localScrollTarget !== void 0) {
        localScrollTarget.removeEventListener("scroll", trigger2, passive$1);
        localScrollTarget = void 0;
      }
    }
    function trigger2(immediately) {
      if (immediately === true || props2.debounce === 0 || props2.debounce === "0") {
        emitEvent();
      } else if (clearTimer === null) {
        const [timer, fn] = props2.debounce ? [setTimeout(emitEvent, props2.debounce), clearTimeout] : [requestAnimationFrame(emitEvent), cancelAnimationFrame];
        clearTimer = () => {
          fn(timer);
          clearTimer = null;
        };
      }
    }
    const { proxy } = getCurrentInstance();
    watch(() => proxy.$q.lang.rtl, emitEvent);
    onMounted(() => {
      parentEl = proxy.$el.parentNode;
      configureScrollTarget();
    });
    onBeforeUnmount(() => {
      clearTimer !== null && clearTimer();
      unconfigureScrollTarget();
    });
    Object.assign(proxy, {
      trigger: trigger2,
      getPosition: () => scroll
    });
    return noop$3;
  }
});
function useHydration() {
  const isHydrated = ref(!isRuntimeSsrPreHydration.value);
  if (isHydrated.value === false) {
    onMounted(() => {
      isHydrated.value = true;
    });
  }
  return { isHydrated };
}
const hasObserver = typeof ResizeObserver !== "undefined";
const resizeProps = hasObserver === true ? {} : {
  style: "display:block;position:absolute;top:0;left:0;right:0;bottom:0;height:100%;width:100%;overflow:hidden;pointer-events:none;z-index:-1;",
  url: "about:blank"
};
const QResizeObserver = createComponent({
  name: "QResizeObserver",
  props: {
    debounce: {
      type: [String, Number],
      default: 100
    }
  },
  emits: ["resize"],
  setup(props2, { emit: emit2 }) {
    let timer = null, targetEl, size2 = { width: -1, height: -1 };
    function trigger2(immediately) {
      if (immediately === true || props2.debounce === 0 || props2.debounce === "0") {
        emitEvent();
      } else if (timer === null) {
        timer = setTimeout(emitEvent, props2.debounce);
      }
    }
    function emitEvent() {
      if (timer !== null) {
        clearTimeout(timer);
        timer = null;
      }
      if (targetEl) {
        const { offsetWidth: width2, offsetHeight: height } = targetEl;
        if (width2 !== size2.width || height !== size2.height) {
          size2 = { width: width2, height };
          emit2("resize", size2);
        }
      }
    }
    const { proxy } = getCurrentInstance();
    proxy.trigger = trigger2;
    if (hasObserver === true) {
      let observer;
      const init2 = (stop2) => {
        targetEl = proxy.$el.parentNode;
        if (targetEl) {
          observer = new ResizeObserver(trigger2);
          observer.observe(targetEl);
          emitEvent();
        } else if (stop2 !== true) {
          nextTick$1(() => {
            init2(true);
          });
        }
      };
      onMounted(() => {
        init2();
      });
      onBeforeUnmount(() => {
        timer !== null && clearTimeout(timer);
        if (observer !== void 0) {
          if (observer.disconnect !== void 0) {
            observer.disconnect();
          } else if (targetEl) {
            observer.unobserve(targetEl);
          }
        }
      });
      return noop$3;
    } else {
      let cleanup = function() {
        if (timer !== null) {
          clearTimeout(timer);
          timer = null;
        }
        if (curDocView !== void 0) {
          if (curDocView.removeEventListener !== void 0) {
            curDocView.removeEventListener("resize", trigger2, listenOpts.passive);
          }
          curDocView = void 0;
        }
      }, onObjLoad = function() {
        cleanup();
        if (targetEl && targetEl.contentDocument) {
          curDocView = targetEl.contentDocument.defaultView;
          curDocView.addEventListener("resize", trigger2, listenOpts.passive);
          emitEvent();
        }
      };
      const { isHydrated } = useHydration();
      let curDocView;
      onMounted(() => {
        nextTick$1(() => {
          targetEl = proxy.$el;
          targetEl && onObjLoad();
        });
      });
      onBeforeUnmount(cleanup);
      return () => {
        if (isHydrated.value === true) {
          return h$1("object", {
            class: "q--avoid-card-border",
            style: resizeProps.style,
            tabindex: -1,
            // fix for Firefox
            type: "text/html",
            data: resizeProps.url,
            "aria-hidden": "true",
            onLoad: onObjLoad
          });
        }
      };
    }
  }
});
const QLayout = createComponent({
  name: "QLayout",
  props: {
    container: Boolean,
    view: {
      type: String,
      default: "hhh lpr fff",
      validator: (v2) => /^(h|l)h(h|r) lpr (f|l)f(f|r)$/.test(v2.toLowerCase())
    },
    onScroll: Function,
    onScrollHeight: Function,
    onResize: Function
  },
  setup(props2, { slots, emit: emit2 }) {
    const { proxy: { $q } } = getCurrentInstance();
    const rootRef = ref(null);
    const height = ref($q.screen.height);
    const width2 = ref(props2.container === true ? 0 : $q.screen.width);
    const scroll = ref({ position: 0, direction: "down", inflectionPoint: 0 });
    const containerHeight = ref(0);
    const scrollbarWidth = ref(isRuntimeSsrPreHydration.value === true ? 0 : getScrollbarWidth());
    const classes = computed(
      () => "q-layout q-layout--" + (props2.container === true ? "containerized" : "standard")
    );
    const style = computed(() => props2.container === false ? { minHeight: $q.screen.height + "px" } : null);
    const targetStyle = computed(() => scrollbarWidth.value !== 0 ? { [$q.lang.rtl === true ? "left" : "right"]: `${scrollbarWidth.value}px` } : null);
    const targetChildStyle = computed(() => scrollbarWidth.value !== 0 ? {
      [$q.lang.rtl === true ? "right" : "left"]: 0,
      [$q.lang.rtl === true ? "left" : "right"]: `-${scrollbarWidth.value}px`,
      width: `calc(100% + ${scrollbarWidth.value}px)`
    } : null);
    function onPageScroll(data) {
      if (props2.container === true || document.qScrollPrevented !== true) {
        const info = {
          position: data.position.top,
          direction: data.direction,
          directionChanged: data.directionChanged,
          inflectionPoint: data.inflectionPoint.top,
          delta: data.delta.top
        };
        scroll.value = info;
        props2.onScroll !== void 0 && emit2("scroll", info);
      }
    }
    function onPageResize(data) {
      const { height: newHeight, width: newWidth } = data;
      let resized = false;
      if (height.value !== newHeight) {
        resized = true;
        height.value = newHeight;
        props2.onScrollHeight !== void 0 && emit2("scrollHeight", newHeight);
        updateScrollbarWidth();
      }
      if (width2.value !== newWidth) {
        resized = true;
        width2.value = newWidth;
      }
      if (resized === true && props2.onResize !== void 0) {
        emit2("resize", data);
      }
    }
    function onContainerResize({ height: height2 }) {
      if (containerHeight.value !== height2) {
        containerHeight.value = height2;
        updateScrollbarWidth();
      }
    }
    function updateScrollbarWidth() {
      if (props2.container === true) {
        const width22 = height.value > containerHeight.value ? getScrollbarWidth() : 0;
        if (scrollbarWidth.value !== width22) {
          scrollbarWidth.value = width22;
        }
      }
    }
    let animateTimer = null;
    const $layout = {
      instances: {},
      view: computed(() => props2.view),
      isContainer: computed(() => props2.container),
      rootRef,
      height,
      containerHeight,
      scrollbarWidth,
      totalWidth: computed(() => width2.value + scrollbarWidth.value),
      rows: computed(() => {
        const rows = props2.view.toLowerCase().split(" ");
        return {
          top: rows[0].split(""),
          middle: rows[1].split(""),
          bottom: rows[2].split("")
        };
      }),
      header: reactive({ size: 0, offset: 0, space: false }),
      right: reactive({ size: 300, offset: 0, space: false }),
      footer: reactive({ size: 0, offset: 0, space: false }),
      left: reactive({ size: 300, offset: 0, space: false }),
      scroll,
      animate() {
        if (animateTimer !== null) {
          clearTimeout(animateTimer);
        } else {
          document.body.classList.add("q-body--layout-animate");
        }
        animateTimer = setTimeout(() => {
          animateTimer = null;
          document.body.classList.remove("q-body--layout-animate");
        }, 155);
      },
      update(part, prop, val) {
        $layout[part][prop] = val;
      }
    };
    provide(layoutKey, $layout);
    if (getScrollbarWidth() > 0) {
      let restoreScrollbar = function() {
        timer = null;
        el.classList.remove("hide-scrollbar");
      }, hideScrollbar = function() {
        if (timer === null) {
          if (el.scrollHeight > $q.screen.height) {
            return;
          }
          el.classList.add("hide-scrollbar");
        } else {
          clearTimeout(timer);
        }
        timer = setTimeout(restoreScrollbar, 300);
      }, updateScrollEvent = function(action) {
        if (timer !== null && action === "remove") {
          clearTimeout(timer);
          restoreScrollbar();
        }
        window[`${action}EventListener`]("resize", hideScrollbar);
      };
      let timer = null;
      const el = document.body;
      watch(
        () => props2.container !== true ? "add" : "remove",
        updateScrollEvent
      );
      props2.container !== true && updateScrollEvent("add");
      onUnmounted(() => {
        updateScrollEvent("remove");
      });
    }
    return () => {
      const content2 = hMergeSlot(slots.default, [
        h$1(QScrollObserver, { onScroll: onPageScroll }),
        h$1(QResizeObserver, { onResize: onPageResize })
      ]);
      const layout = h$1("div", {
        class: classes.value,
        style: style.value,
        ref: props2.container === true ? void 0 : rootRef,
        tabindex: -1
      }, content2);
      if (props2.container === true) {
        return h$1("div", {
          class: "q-layout-container overflow-hidden",
          ref: rootRef
        }, [
          h$1(QResizeObserver, { onResize: onContainerResize }),
          h$1("div", {
            class: "absolute-full",
            style: targetStyle.value
          }, [
            h$1("div", {
              class: "scroll",
              style: targetChildStyle.value
            }, [layout])
          ])
        ]);
      }
      return layout;
    };
  }
});
const _export_sfc = (sfc, props2) => {
  const target2 = sfc.__vccOpts || sfc;
  for (const [key, val] of props2) {
    target2[key] = val;
  }
  return target2;
};
const _sfc_main$i = {};
function _sfc_render$1(_ctx, _cache) {
  const _component_router_view = resolveComponent("router-view");
  return openBlock(), createElementBlock("div", null, [
    createVNode(QLayout, { view: "hHh lpR fff" }, {
      default: withCtx(() => [
        createVNode(QPageContainer, { style: { "padding-left": "0" } }, {
          default: withCtx(() => [
            createVNode(_component_router_view)
          ]),
          _: 1
        })
      ]),
      _: 1
    })
  ]);
}
const App = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["render", _sfc_render$1], ["__scopeId", "data-v-d94ab3c4"]]);
function debounce(fn, wait = 250, immediate) {
  let timer = null;
  function debounced() {
    const args = arguments;
    const later = () => {
      timer = null;
      {
        fn.apply(this, args);
      }
    };
    if (timer !== null) {
      clearTimeout(timer);
    }
    timer = setTimeout(later, wait);
  }
  debounced.cancel = () => {
    timer !== null && clearTimeout(timer);
  };
  return debounced;
}
const SIZE_LIST = ["sm", "md", "lg", "xl"];
const { passive } = listenOpts;
const Screen = createReactivePlugin({
  width: 0,
  height: 0,
  name: "xs",
  sizes: {
    sm: 600,
    md: 1024,
    lg: 1440,
    xl: 1920
  },
  lt: {
    sm: true,
    md: true,
    lg: true,
    xl: true
  },
  gt: {
    xs: false,
    sm: false,
    md: false,
    lg: false
  },
  xs: true,
  sm: false,
  md: false,
  lg: false,
  xl: false
}, {
  setSizes: noop$3,
  setDebounce: noop$3,
  install({ $q, onSSRHydrated }) {
    $q.screen = this;
    if (this.__installed === true) {
      if ($q.config.screen !== void 0) {
        if ($q.config.screen.bodyClasses === false) {
          document.body.classList.remove(`screen--${this.name}`);
        } else {
          this.__update(true);
        }
      }
      return;
    }
    const { visualViewport } = window;
    const target2 = visualViewport || window;
    const scrollingElement = document.scrollingElement || document.documentElement;
    const getSize = visualViewport === void 0 || client.is.mobile === true ? () => [
      Math.max(window.innerWidth, scrollingElement.clientWidth),
      Math.max(window.innerHeight, scrollingElement.clientHeight)
    ] : () => [
      visualViewport.width * visualViewport.scale + window.innerWidth - scrollingElement.clientWidth,
      visualViewport.height * visualViewport.scale + window.innerHeight - scrollingElement.clientHeight
    ];
    const classes = $q.config.screen !== void 0 && $q.config.screen.bodyClasses === true;
    this.__update = (force) => {
      const [w2, h2] = getSize();
      if (h2 !== this.height) {
        this.height = h2;
      }
      if (w2 !== this.width) {
        this.width = w2;
      } else if (force !== true) {
        return;
      }
      let s2 = this.sizes;
      this.gt.xs = w2 >= s2.sm;
      this.gt.sm = w2 >= s2.md;
      this.gt.md = w2 >= s2.lg;
      this.gt.lg = w2 >= s2.xl;
      this.lt.sm = w2 < s2.sm;
      this.lt.md = w2 < s2.md;
      this.lt.lg = w2 < s2.lg;
      this.lt.xl = w2 < s2.xl;
      this.xs = this.lt.sm;
      this.sm = this.gt.xs === true && this.lt.md === true;
      this.md = this.gt.sm === true && this.lt.lg === true;
      this.lg = this.gt.md === true && this.lt.xl === true;
      this.xl = this.gt.lg;
      s2 = this.xs === true && "xs" || this.sm === true && "sm" || this.md === true && "md" || this.lg === true && "lg" || "xl";
      if (s2 !== this.name) {
        if (classes === true) {
          document.body.classList.remove(`screen--${this.name}`);
          document.body.classList.add(`screen--${s2}`);
        }
        this.name = s2;
      }
    };
    let updateEvt, updateSizes = {}, updateDebounce = 16;
    this.setSizes = (sizes) => {
      SIZE_LIST.forEach((name) => {
        if (sizes[name] !== void 0) {
          updateSizes[name] = sizes[name];
        }
      });
    };
    this.setDebounce = (deb) => {
      updateDebounce = deb;
    };
    const start = () => {
      const style = getComputedStyle(document.body);
      if (style.getPropertyValue("--q-size-sm")) {
        SIZE_LIST.forEach((name) => {
          this.sizes[name] = parseInt(style.getPropertyValue(`--q-size-${name}`), 10);
        });
      }
      this.setSizes = (sizes) => {
        SIZE_LIST.forEach((name) => {
          if (sizes[name]) {
            this.sizes[name] = sizes[name];
          }
        });
        this.__update(true);
      };
      this.setDebounce = (delay) => {
        updateEvt !== void 0 && target2.removeEventListener("resize", updateEvt, passive);
        updateEvt = delay > 0 ? debounce(this.__update, delay) : this.__update;
        target2.addEventListener("resize", updateEvt, passive);
      };
      this.setDebounce(updateDebounce);
      if (Object.keys(updateSizes).length !== 0) {
        this.setSizes(updateSizes);
        updateSizes = void 0;
      } else {
        this.__update();
      }
      classes === true && this.name === "xs" && document.body.classList.add("screen--xs");
    };
    if (isRuntimeSsrPreHydration.value === true) {
      onSSRHydrated.push(start);
    } else {
      start();
    }
  }
});
const Plugin$3 = createReactivePlugin({
  isActive: false,
  mode: false
}, {
  __media: void 0,
  set(val) {
    Plugin$3.mode = val;
    if (val === "auto") {
      if (Plugin$3.__media === void 0) {
        Plugin$3.__media = window.matchMedia("(prefers-color-scheme: dark)");
        Plugin$3.__updateMedia = () => {
          Plugin$3.set("auto");
        };
        Plugin$3.__media.addListener(Plugin$3.__updateMedia);
      }
      val = Plugin$3.__media.matches;
    } else if (Plugin$3.__media !== void 0) {
      Plugin$3.__media.removeListener(Plugin$3.__updateMedia);
      Plugin$3.__media = void 0;
    }
    Plugin$3.isActive = val === true;
    document.body.classList.remove(`body--${val === true ? "light" : "dark"}`);
    document.body.classList.add(`body--${val === true ? "dark" : "light"}`);
  },
  toggle() {
    {
      Plugin$3.set(Plugin$3.isActive === false);
    }
  },
  install({ $q, ssrContext }) {
    const { dark } = $q.config;
    $q.dark = this;
    if (this.__installed !== true) {
      this.set(dark !== void 0 ? dark : false);
    }
  }
});
function setCssVar(propName, value2, element = document.body) {
  if (typeof propName !== "string") {
    throw new TypeError("Expected a string as propName");
  }
  if (typeof value2 !== "string") {
    throw new TypeError("Expected a string as value");
  }
  if (!(element instanceof Element)) {
    throw new TypeError("Expected a DOM element");
  }
  element.style.setProperty(`--q-${propName}`, value2);
}
let lastKeyCompositionStatus = false;
function onKeyDownComposition(evt) {
  lastKeyCompositionStatus = evt.isComposing === true;
}
function shouldIgnoreKey(evt) {
  return lastKeyCompositionStatus === true || evt !== Object(evt) || evt.isComposing === true || evt.qKeyEvent === true;
}
function isKeyCode(evt, keyCodes) {
  return shouldIgnoreKey(evt) === true ? false : [].concat(keyCodes).includes(evt.keyCode);
}
function getMobilePlatform(is) {
  if (is.ios === true) return "ios";
  if (is.android === true) return "android";
}
function getBodyClasses({ is, has: has2, within }, cfg) {
  const cls = [
    is.desktop === true ? "desktop" : "mobile",
    `${has2.touch === false ? "no-" : ""}touch`
  ];
  if (is.mobile === true) {
    const mobile = getMobilePlatform(is);
    mobile !== void 0 && cls.push("platform-" + mobile);
  }
  if (is.nativeMobile === true) {
    const type = is.nativeMobileWrapper;
    cls.push(type);
    cls.push("native-mobile");
    if (is.ios === true && (cfg[type] === void 0 || cfg[type].iosStatusBarPadding !== false)) {
      cls.push("q-ios-padding");
    }
  } else if (is.electron === true) {
    cls.push("electron");
  } else if (is.bex === true) {
    cls.push("bex");
  }
  within.iframe === true && cls.push("within-iframe");
  return cls;
}
function applyClientSsrCorrections() {
  const { is } = client;
  const classes = document.body.className;
  const classList = new Set(classes.replace(/ {2}/g, " ").split(" "));
  if (is.nativeMobile !== true && is.electron !== true && is.bex !== true) {
    if (is.desktop === true) {
      classList.delete("mobile");
      classList.delete("platform-ios");
      classList.delete("platform-android");
      classList.add("desktop");
    } else if (is.mobile === true) {
      classList.delete("desktop");
      classList.add("mobile");
      classList.delete("platform-ios");
      classList.delete("platform-android");
      const mobile = getMobilePlatform(is);
      if (mobile !== void 0) {
        classList.add(`platform-${mobile}`);
      }
    }
  }
  if (client.has.touch === true) {
    classList.delete("no-touch");
    classList.add("touch");
  }
  if (client.within.iframe === true) {
    classList.add("within-iframe");
  }
  const newCls = Array.from(classList).join(" ");
  if (classes !== newCls) {
    document.body.className = newCls;
  }
}
function setColors(brand) {
  for (const color2 in brand) {
    setCssVar(color2, brand[color2]);
  }
}
const Body = {
  install(opts) {
    if (this.__installed === true) return;
    if (isRuntimeSsrPreHydration.value === true) {
      applyClientSsrCorrections();
    } else {
      const { $q } = opts;
      $q.config.brand !== void 0 && setColors($q.config.brand);
      const cls = getBodyClasses(client, $q.config);
      document.body.classList.add.apply(document.body.classList, cls);
    }
    if (client.is.ios === true) {
      document.body.addEventListener("touchstart", noop$3);
    }
    window.addEventListener("keydown", onKeyDownComposition, true);
  }
};
const getTrue = () => true;
function filterInvalidPath(path) {
  return typeof path === "string" && path !== "" && path !== "/" && path !== "#/";
}
function normalizeExitPath(path) {
  path.startsWith("#") === true && (path = path.substring(1));
  path.startsWith("/") === false && (path = "/" + path);
  path.endsWith("/") === true && (path = path.substring(0, path.length - 1));
  return "#" + path;
}
function getShouldExitFn(cfg) {
  if (cfg.backButtonExit === false) {
    return () => false;
  }
  if (cfg.backButtonExit === "*") {
    return getTrue;
  }
  const exitPaths = ["#/"];
  Array.isArray(cfg.backButtonExit) === true && exitPaths.push(
    ...cfg.backButtonExit.filter(filterInvalidPath).map(normalizeExitPath)
  );
  return () => exitPaths.includes(window.location.hash);
}
const History = {
  __history: [],
  add: noop$3,
  remove: noop$3,
  install({ $q }) {
    if (this.__installed === true) return;
    const { cordova, capacitor } = client.is;
    if (cordova !== true && capacitor !== true) {
      return;
    }
    const qConf = $q.config[cordova === true ? "cordova" : "capacitor"];
    if (qConf !== void 0 && qConf.backButton === false) {
      return;
    }
    if (
      // if we're on Capacitor mode
      capacitor === true && (window.Capacitor === void 0 || window.Capacitor.Plugins.App === void 0)
    ) {
      return;
    }
    this.add = (entry) => {
      if (entry.condition === void 0) {
        entry.condition = getTrue;
      }
      this.__history.push(entry);
    };
    this.remove = (entry) => {
      const index = this.__history.indexOf(entry);
      if (index >= 0) {
        this.__history.splice(index, 1);
      }
    };
    const shouldExit = getShouldExitFn(
      Object.assign(
        { backButtonExit: true },
        qConf
      )
    );
    const backHandler = () => {
      if (this.__history.length) {
        const entry = this.__history[this.__history.length - 1];
        if (entry.condition() === true) {
          this.__history.pop();
          entry.handler();
        }
      } else if (shouldExit() === true) {
        navigator.app.exitApp();
      } else {
        window.history.back();
      }
    };
    if (cordova === true) {
      document.addEventListener("deviceready", () => {
        document.addEventListener("backbutton", backHandler, false);
      });
    } else {
      window.Capacitor.Plugins.App.addListener("backButton", backHandler);
    }
  }
};
const defaultLang = {
  isoName: "en-US",
  nativeName: "English (US)",
  label: {
    clear: "Clear",
    ok: "OK",
    cancel: "Cancel",
    close: "Close",
    set: "Set",
    select: "Select",
    reset: "Reset",
    remove: "Remove",
    update: "Update",
    create: "Create",
    search: "Search",
    filter: "Filter",
    refresh: "Refresh",
    expand: (label) => label ? `Expand "${label}"` : "Expand",
    collapse: (label) => label ? `Collapse "${label}"` : "Collapse"
  },
  date: {
    days: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
    daysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
    months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
    monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
    firstDayOfWeek: 0,
    // 0-6, 0 - Sunday, 1 Monday, ...
    format24h: false,
    pluralDay: "days"
  },
  table: {
    noData: "No data available",
    noResults: "No matching records found",
    loading: "Loading...",
    selectedRecords: (rows) => rows === 1 ? "1 record selected." : (rows === 0 ? "No" : rows) + " records selected.",
    recordsPerPage: "Records per page:",
    allRows: "All",
    pagination: (start, end, total) => start + "-" + end + " of " + total,
    columns: "Columns"
  },
  editor: {
    url: "URL",
    bold: "Bold",
    italic: "Italic",
    strikethrough: "Strikethrough",
    underline: "Underline",
    unorderedList: "Unordered List",
    orderedList: "Ordered List",
    subscript: "Subscript",
    superscript: "Superscript",
    hyperlink: "Hyperlink",
    toggleFullscreen: "Toggle Fullscreen",
    quote: "Quote",
    left: "Left align",
    center: "Center align",
    right: "Right align",
    justify: "Justify align",
    print: "Print",
    outdent: "Decrease indentation",
    indent: "Increase indentation",
    removeFormat: "Remove formatting",
    formatting: "Formatting",
    fontSize: "Font Size",
    align: "Align",
    hr: "Insert Horizontal Rule",
    undo: "Undo",
    redo: "Redo",
    heading1: "Heading 1",
    heading2: "Heading 2",
    heading3: "Heading 3",
    heading4: "Heading 4",
    heading5: "Heading 5",
    heading6: "Heading 6",
    paragraph: "Paragraph",
    code: "Code",
    size1: "Very small",
    size2: "A bit small",
    size3: "Normal",
    size4: "Medium-large",
    size5: "Big",
    size6: "Very big",
    size7: "Maximum",
    defaultFont: "Default Font",
    viewSource: "View Source"
  },
  tree: {
    noNodes: "No nodes available",
    noResults: "No matching nodes found"
  }
};
function getLocale() {
  const val = Array.isArray(navigator.languages) === true && navigator.languages.length !== 0 ? navigator.languages[0] : navigator.language;
  if (typeof val === "string") {
    return val.split(/[-_]/).map((v2, i) => i === 0 ? v2.toLowerCase() : i > 1 || v2.length < 4 ? v2.toUpperCase() : v2[0].toUpperCase() + v2.slice(1).toLowerCase()).join("-");
  }
}
const Plugin$2 = createReactivePlugin({
  __qLang: {}
}, {
  // props: object
  // __langConfig: object
  getLocale,
  set(langObject = defaultLang, ssrContext) {
    const lang = {
      ...langObject,
      rtl: langObject.rtl === true,
      getLocale
    };
    {
      lang.set = Plugin$2.set;
      if (Plugin$2.__langConfig === void 0 || Plugin$2.__langConfig.noHtmlAttrs !== true) {
        const el = document.documentElement;
        el.setAttribute("dir", lang.rtl === true ? "rtl" : "ltr");
        el.setAttribute("lang", lang.isoName);
      }
      Object.assign(Plugin$2.__qLang, lang);
    }
  },
  install({ $q, lang, ssrContext }) {
    {
      $q.lang = Plugin$2.__qLang;
      Plugin$2.__langConfig = $q.config.lang;
      if (this.__installed === true) {
        lang !== void 0 && this.set(lang);
      } else {
        this.props = new Proxy(this.__qLang, {
          get() {
            return Reflect.get(...arguments);
          },
          ownKeys(target2) {
            return Reflect.ownKeys(target2).filter((key) => key !== "set" && key !== "getLocale");
          }
        });
        this.set(lang || defaultLang);
      }
    }
  }
});
const materialIcons = {
  name: "material-icons",
  type: {
    positive: "check_circle",
    negative: "warning",
    info: "info",
    warning: "priority_high"
  },
  arrow: {
    up: "arrow_upward",
    right: "arrow_forward",
    down: "arrow_downward",
    left: "arrow_back",
    dropdown: "arrow_drop_down"
  },
  chevron: {
    left: "chevron_left",
    right: "chevron_right"
  },
  colorPicker: {
    spectrum: "gradient",
    tune: "tune",
    palette: "style"
  },
  pullToRefresh: {
    icon: "refresh"
  },
  carousel: {
    left: "chevron_left",
    right: "chevron_right",
    up: "keyboard_arrow_up",
    down: "keyboard_arrow_down",
    navigationIcon: "lens"
  },
  chip: {
    remove: "cancel",
    selected: "check"
  },
  datetime: {
    arrowLeft: "chevron_left",
    arrowRight: "chevron_right",
    now: "access_time",
    today: "today"
  },
  editor: {
    bold: "format_bold",
    italic: "format_italic",
    strikethrough: "strikethrough_s",
    underline: "format_underlined",
    unorderedList: "format_list_bulleted",
    orderedList: "format_list_numbered",
    subscript: "vertical_align_bottom",
    superscript: "vertical_align_top",
    hyperlink: "link",
    toggleFullscreen: "fullscreen",
    quote: "format_quote",
    left: "format_align_left",
    center: "format_align_center",
    right: "format_align_right",
    justify: "format_align_justify",
    print: "print",
    outdent: "format_indent_decrease",
    indent: "format_indent_increase",
    removeFormat: "format_clear",
    formatting: "text_format",
    fontSize: "format_size",
    align: "format_align_left",
    hr: "remove",
    undo: "undo",
    redo: "redo",
    heading: "format_size",
    code: "code",
    size: "format_size",
    font: "font_download",
    viewSource: "code"
  },
  expansionItem: {
    icon: "keyboard_arrow_down",
    denseIcon: "arrow_drop_down"
  },
  fab: {
    icon: "add",
    activeIcon: "close"
  },
  field: {
    clear: "cancel",
    error: "error"
  },
  pagination: {
    first: "first_page",
    prev: "keyboard_arrow_left",
    next: "keyboard_arrow_right",
    last: "last_page"
  },
  rating: {
    icon: "grade"
  },
  stepper: {
    done: "check",
    active: "edit",
    error: "warning"
  },
  tabs: {
    left: "chevron_left",
    right: "chevron_right",
    up: "keyboard_arrow_up",
    down: "keyboard_arrow_down"
  },
  table: {
    arrowUp: "arrow_upward",
    warning: "warning",
    firstPage: "first_page",
    prevPage: "chevron_left",
    nextPage: "chevron_right",
    lastPage: "last_page"
  },
  tree: {
    icon: "play_arrow"
  },
  uploader: {
    done: "done",
    clear: "clear",
    add: "add_box",
    upload: "cloud_upload",
    removeQueue: "clear_all",
    removeUploaded: "done_all"
  }
};
const Plugin$1 = createReactivePlugin({
  iconMapFn: null,
  __qIconSet: {}
}, {
  // props: object
  set(setObject, ssrContext) {
    const def2 = { ...setObject };
    {
      def2.set = Plugin$1.set;
      Object.assign(Plugin$1.__qIconSet, def2);
    }
  },
  install({ $q, iconSet, ssrContext }) {
    {
      if ($q.config.iconMapFn !== void 0) {
        this.iconMapFn = $q.config.iconMapFn;
      }
      $q.iconSet = this.__qIconSet;
      injectProp($q, "iconMapFn", () => this.iconMapFn, (val) => {
        this.iconMapFn = val;
      });
      if (this.__installed === true) {
        iconSet !== void 0 && this.set(iconSet);
      } else {
        this.props = new Proxy(this.__qIconSet, {
          get() {
            return Reflect.get(...arguments);
          },
          ownKeys(target2) {
            return Reflect.ownKeys(target2).filter((key) => key !== "set");
          }
        });
        this.set(iconSet || materialIcons);
      }
    }
  }
});
const globalConfig = {};
let globalConfigIsFrozen = false;
function freezeGlobalConfig() {
  globalConfigIsFrozen = true;
}
function isDeepEqual(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (a2 !== null && b2 !== null && typeof a2 === "object" && typeof b2 === "object") {
    if (a2.constructor !== b2.constructor) {
      return false;
    }
    let length, i;
    if (a2.constructor === Array) {
      length = a2.length;
      if (length !== b2.length) {
        return false;
      }
      for (i = length; i-- !== 0; ) {
        if (isDeepEqual(a2[i], b2[i]) !== true) {
          return false;
        }
      }
      return true;
    }
    if (a2.constructor === Map) {
      if (a2.size !== b2.size) {
        return false;
      }
      let iter = a2.entries();
      i = iter.next();
      while (i.done !== true) {
        if (b2.has(i.value[0]) !== true) {
          return false;
        }
        i = iter.next();
      }
      iter = a2.entries();
      i = iter.next();
      while (i.done !== true) {
        if (isDeepEqual(i.value[1], b2.get(i.value[0])) !== true) {
          return false;
        }
        i = iter.next();
      }
      return true;
    }
    if (a2.constructor === Set) {
      if (a2.size !== b2.size) {
        return false;
      }
      const iter = a2.entries();
      i = iter.next();
      while (i.done !== true) {
        if (b2.has(i.value[0]) !== true) {
          return false;
        }
        i = iter.next();
      }
      return true;
    }
    if (a2.buffer != null && a2.buffer.constructor === ArrayBuffer) {
      length = a2.length;
      if (length !== b2.length) {
        return false;
      }
      for (i = length; i-- !== 0; ) {
        if (a2[i] !== b2[i]) {
          return false;
        }
      }
      return true;
    }
    if (a2.constructor === RegExp) {
      return a2.source === b2.source && a2.flags === b2.flags;
    }
    if (a2.valueOf !== Object.prototype.valueOf) {
      return a2.valueOf() === b2.valueOf();
    }
    if (a2.toString !== Object.prototype.toString) {
      return a2.toString() === b2.toString();
    }
    const keys = Object.keys(a2).filter((key) => a2[key] !== void 0);
    length = keys.length;
    if (length !== Object.keys(b2).filter((key) => b2[key] !== void 0).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      const key = keys[i];
      if (isDeepEqual(a2[key], b2[key]) !== true) {
        return false;
      }
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
}
function isObject$3(v2) {
  return v2 !== null && typeof v2 === "object" && Array.isArray(v2) !== true;
}
function isDate$1(v2) {
  return Object.prototype.toString.call(v2) === "[object Date]";
}
function isNumber$1(v2) {
  return typeof v2 === "number" && isFinite(v2);
}
const autoInstalledPlugins = [
  Platform,
  Body,
  Plugin$3,
  Screen,
  History,
  Plugin$2,
  Plugin$1
];
function createChildApp(appCfg, parentApp) {
  const app2 = createApp(appCfg);
  app2.config.globalProperties = parentApp.config.globalProperties;
  const { reload, ...appContext } = parentApp._context;
  Object.assign(app2._context, appContext);
  return app2;
}
function installPlugins(pluginOpts, pluginList) {
  pluginList.forEach((Plugin2) => {
    Plugin2.install(pluginOpts);
    Plugin2.__installed = true;
  });
}
function prepareApp(app2, uiOpts, pluginOpts) {
  app2.config.globalProperties.$q = pluginOpts.$q;
  app2.provide(quasarKey, pluginOpts.$q);
  installPlugins(pluginOpts, autoInstalledPlugins);
  uiOpts.components !== void 0 && Object.values(uiOpts.components).forEach((c2) => {
    if (isObject$3(c2) === true && c2.name !== void 0) {
      app2.component(c2.name, c2);
    }
  });
  uiOpts.directives !== void 0 && Object.values(uiOpts.directives).forEach((d2) => {
    if (isObject$3(d2) === true && d2.name !== void 0) {
      app2.directive(d2.name, d2);
    }
  });
  uiOpts.plugins !== void 0 && installPlugins(
    pluginOpts,
    Object.values(uiOpts.plugins).filter(
      (p2) => typeof p2.install === "function" && autoInstalledPlugins.includes(p2) === false
    )
  );
  if (isRuntimeSsrPreHydration.value === true) {
    pluginOpts.$q.onSSRHydrated = () => {
      pluginOpts.onSSRHydrated.forEach((fn) => {
        fn();
      });
      pluginOpts.$q.onSSRHydrated = () => {
      };
    };
  }
}
const installQuasar = function(parentApp, opts = {}) {
  const $q = { version: "2.16.4" };
  if (globalConfigIsFrozen === false) {
    if (opts.config !== void 0) {
      Object.assign(globalConfig, opts.config);
    }
    $q.config = { ...globalConfig };
    freezeGlobalConfig();
  } else {
    $q.config = opts.config || {};
  }
  prepareApp(parentApp, opts, {
    parentApp,
    $q,
    lang: opts.lang,
    iconSet: opts.iconSet,
    onSSRHydrated: []
  });
};
const Quasar = {
  name: "Quasar",
  version: "2.16.4",
  install: installQuasar,
  // TODO: remove in Qv3 (should only be used through the plugin)
  // We provide a deprecated fallback here
  lang: Plugin$2,
  // TODO: remove in Qv3 (should only be used through the plugin)
  // We provide a deprecated fallback here
  iconSet: Plugin$1
};
const useSizeDefaults = {
  xs: 18,
  sm: 24,
  md: 32,
  lg: 38,
  xl: 46
};
const useSizeProps = {
  size: String
};
function useSize(props2, sizes = useSizeDefaults) {
  return computed(() => props2.size !== void 0 ? { fontSize: props2.size in sizes ? `${sizes[props2.size]}px` : props2.size } : null);
}
const defaultViewBox = "0 0 24 24";
const sameFn = (i) => i;
const ionFn = (i) => `ionicons ${i}`;
const libMap = {
  "mdi-": (i) => `mdi ${i}`,
  "icon-": sameFn,
  // fontawesome equiv
  "bt-": (i) => `bt ${i}`,
  "eva-": (i) => `eva ${i}`,
  "ion-md": ionFn,
  "ion-ios": ionFn,
  "ion-logo": ionFn,
  "iconfont ": sameFn,
  "ti-": (i) => `themify-icon ${i}`,
  "bi-": (i) => `bootstrap-icons ${i}`
};
const matMap = {
  o_: "-outlined",
  r_: "-round",
  s_: "-sharp"
};
const symMap = {
  sym_o_: "-outlined",
  sym_r_: "-rounded",
  sym_s_: "-sharp"
};
const libRE = new RegExp("^(" + Object.keys(libMap).join("|") + ")");
const matRE = new RegExp("^(" + Object.keys(matMap).join("|") + ")");
const symRE = new RegExp("^(" + Object.keys(symMap).join("|") + ")");
const mRE = /^[Mm]\s?[-+]?\.?\d/;
const imgRE = /^img:/;
const svgUseRE = /^svguse:/;
const ionRE = /^ion-/;
const faRE = /^(fa-(sharp|solid|regular|light|brands|duotone|thin)|[lf]a[srlbdk]?) /;
const QIcon = createComponent({
  name: "QIcon",
  props: {
    ...useSizeProps,
    tag: {
      type: String,
      default: "i"
    },
    name: String,
    color: String,
    left: Boolean,
    right: Boolean
  },
  setup(props2, { slots }) {
    const { proxy: { $q } } = getCurrentInstance();
    const sizeStyle = useSize(props2);
    const classes = computed(
      () => "q-icon" + (props2.left === true ? " on-left" : "") + (props2.right === true ? " on-right" : "") + (props2.color !== void 0 ? ` text-${props2.color}` : "")
    );
    const type = computed(() => {
      let cls;
      let icon = props2.name;
      if (icon === "none" || !icon) {
        return { none: true };
      }
      if ($q.iconMapFn !== null) {
        const res = $q.iconMapFn(icon);
        if (res !== void 0) {
          if (res.icon !== void 0) {
            icon = res.icon;
            if (icon === "none" || !icon) {
              return { none: true };
            }
          } else {
            return {
              cls: res.cls,
              content: res.content !== void 0 ? res.content : " "
            };
          }
        }
      }
      if (mRE.test(icon) === true) {
        const [def2, viewBox = defaultViewBox] = icon.split("|");
        return {
          svg: true,
          viewBox,
          nodes: def2.split("&&").map((path) => {
            const [d2, style, transform2] = path.split("@@");
            return h$1("path", { style, d: d2, transform: transform2 });
          })
        };
      }
      if (imgRE.test(icon) === true) {
        return {
          img: true,
          src: icon.substring(4)
        };
      }
      if (svgUseRE.test(icon) === true) {
        const [def2, viewBox = defaultViewBox] = icon.split("|");
        return {
          svguse: true,
          src: def2.substring(7),
          viewBox
        };
      }
      let content2 = " ";
      const matches2 = icon.match(libRE);
      if (matches2 !== null) {
        cls = libMap[matches2[1]](icon);
      } else if (faRE.test(icon) === true) {
        cls = icon;
      } else if (ionRE.test(icon) === true) {
        cls = `ionicons ion-${$q.platform.is.ios === true ? "ios" : "md"}${icon.substring(3)}`;
      } else if (symRE.test(icon) === true) {
        cls = "notranslate material-symbols";
        const matches3 = icon.match(symRE);
        if (matches3 !== null) {
          icon = icon.substring(6);
          cls += symMap[matches3[1]];
        }
        content2 = icon;
      } else {
        cls = "notranslate material-icons";
        const matches3 = icon.match(matRE);
        if (matches3 !== null) {
          icon = icon.substring(2);
          cls += matMap[matches3[1]];
        }
        content2 = icon;
      }
      return {
        cls,
        content: content2
      };
    });
    return () => {
      const data = {
        class: classes.value,
        style: sizeStyle.value,
        "aria-hidden": "true",
        role: "presentation"
      };
      if (type.value.none === true) {
        return h$1(props2.tag, data, hSlot(slots.default));
      }
      if (type.value.img === true) {
        return h$1(props2.tag, data, hMergeSlot(slots.default, [
          h$1("img", { src: type.value.src })
        ]));
      }
      if (type.value.svg === true) {
        return h$1(props2.tag, data, hMergeSlot(slots.default, [
          h$1("svg", {
            viewBox: type.value.viewBox || "0 0 24 24"
          }, type.value.nodes)
        ]));
      }
      if (type.value.svguse === true) {
        return h$1(props2.tag, data, hMergeSlot(slots.default, [
          h$1("svg", {
            viewBox: type.value.viewBox
          }, [
            h$1("use", { "xlink:href": type.value.src })
          ])
        ]));
      }
      if (type.value.cls !== void 0) {
        data.class += " " + type.value.cls;
      }
      return h$1(props2.tag, data, hMergeSlot(slots.default, [
        type.value.content
      ]));
    };
  }
});
const QAvatar = createComponent({
  name: "QAvatar",
  props: {
    ...useSizeProps,
    fontSize: String,
    color: String,
    textColor: String,
    icon: String,
    square: Boolean,
    rounded: Boolean
  },
  setup(props2, { slots }) {
    const sizeStyle = useSize(props2);
    const classes = computed(
      () => "q-avatar" + (props2.color ? ` bg-${props2.color}` : "") + (props2.textColor ? ` text-${props2.textColor} q-chip--colored` : "") + (props2.square === true ? " q-avatar--square" : props2.rounded === true ? " rounded-borders" : "")
    );
    const contentStyle = computed(() => props2.fontSize ? { fontSize: props2.fontSize } : null);
    return () => {
      const icon = props2.icon !== void 0 ? [h$1(QIcon, { name: props2.icon })] : void 0;
      return h$1("div", {
        class: classes.value,
        style: sizeStyle.value
      }, [
        h$1("div", {
          class: "q-avatar__content row flex-center overflow-hidden",
          style: contentStyle.value
        }, hMergeSlotSafely(slots.default, icon))
      ]);
    };
  }
});
const useSpinnerProps = {
  size: {
    type: [String, Number],
    default: "1em"
  },
  color: String
};
function useSpinner(props2) {
  return {
    cSize: computed(() => props2.size in useSizeDefaults ? `${useSizeDefaults[props2.size]}px` : props2.size),
    classes: computed(
      () => "q-spinner" + (props2.color ? ` text-${props2.color}` : "")
    )
  };
}
const QSpinner = createComponent({
  name: "QSpinner",
  props: {
    ...useSpinnerProps,
    thickness: {
      type: Number,
      default: 5
    }
  },
  setup(props2) {
    const { cSize, classes } = useSpinner(props2);
    return () => h$1("svg", {
      class: classes.value + " q-spinner-mat",
      width: cSize.value,
      height: cSize.value,
      viewBox: "25 25 50 50"
    }, [
      h$1("circle", {
        class: "path",
        cx: "50",
        cy: "50",
        r: "20",
        fill: "none",
        stroke: "currentColor",
        "stroke-width": props2.thickness,
        "stroke-miterlimit": "10"
      })
    ]);
  }
});
function throttle$1(fn, limit = 250) {
  let wait = false, result;
  return function() {
    if (wait === false) {
      wait = true;
      setTimeout(() => {
        wait = false;
      }, limit);
      result = fn.apply(this, arguments);
    }
    return result;
  };
}
function showRipple(evt, el, ctx, forceCenter) {
  ctx.modifiers.stop === true && stop(evt);
  const color2 = ctx.modifiers.color;
  let center = ctx.modifiers.center;
  center = center === true || forceCenter === true;
  const node = document.createElement("span"), innerNode = document.createElement("span"), pos = position$1(evt), { left, top, width: width2, height } = el.getBoundingClientRect(), diameter = Math.sqrt(width2 * width2 + height * height), radius = diameter / 2, centerX = `${(width2 - diameter) / 2}px`, x2 = center ? centerX : `${pos.left - left - radius}px`, centerY = `${(height - diameter) / 2}px`, y2 = center ? centerY : `${pos.top - top - radius}px`;
  innerNode.className = "q-ripple__inner";
  css(innerNode, {
    height: `${diameter}px`,
    width: `${diameter}px`,
    transform: `translate3d(${x2},${y2},0) scale3d(.2,.2,1)`,
    opacity: 0
  });
  node.className = `q-ripple${color2 ? " text-" + color2 : ""}`;
  node.setAttribute("dir", "ltr");
  node.appendChild(innerNode);
  el.appendChild(node);
  const abort = () => {
    node.remove();
    clearTimeout(timer);
  };
  ctx.abort.push(abort);
  let timer = setTimeout(() => {
    innerNode.classList.add("q-ripple__inner--enter");
    innerNode.style.transform = `translate3d(${centerX},${centerY},0) scale3d(1,1,1)`;
    innerNode.style.opacity = 0.2;
    timer = setTimeout(() => {
      innerNode.classList.remove("q-ripple__inner--enter");
      innerNode.classList.add("q-ripple__inner--leave");
      innerNode.style.opacity = 0;
      timer = setTimeout(() => {
        node.remove();
        ctx.abort.splice(ctx.abort.indexOf(abort), 1);
      }, 275);
    }, 250);
  }, 50);
}
function updateModifiers(ctx, { modifiers, value: value2, arg }) {
  const cfg = Object.assign({}, ctx.cfg.ripple, modifiers, value2);
  ctx.modifiers = {
    early: cfg.early === true,
    stop: cfg.stop === true,
    center: cfg.center === true,
    color: cfg.color || arg,
    keyCodes: [].concat(cfg.keyCodes || 13)
  };
}
const Ripple = createDirective(
  {
    name: "ripple",
    beforeMount(el, binding) {
      const cfg = binding.instance.$.appContext.config.globalProperties.$q.config || {};
      if (cfg.ripple === false) {
        return;
      }
      const ctx = {
        cfg,
        enabled: binding.value !== false,
        modifiers: {},
        abort: [],
        start(evt) {
          if (ctx.enabled === true && evt.qSkipRipple !== true && evt.type === (ctx.modifiers.early === true ? "pointerdown" : "click")) {
            showRipple(evt, el, ctx, evt.qKeyEvent === true);
          }
        },
        keystart: throttle$1((evt) => {
          if (ctx.enabled === true && evt.qSkipRipple !== true && isKeyCode(evt, ctx.modifiers.keyCodes) === true && evt.type === `key${ctx.modifiers.early === true ? "down" : "up"}`) {
            showRipple(evt, el, ctx, true);
          }
        }, 300)
      };
      updateModifiers(ctx, binding);
      el.__qripple = ctx;
      addEvt(ctx, "main", [
        [el, "pointerdown", "start", "passive"],
        [el, "click", "start", "passive"],
        [el, "keydown", "keystart", "passive"],
        [el, "keyup", "keystart", "passive"]
      ]);
    },
    updated(el, binding) {
      if (binding.oldValue !== binding.value) {
        const ctx = el.__qripple;
        if (ctx !== void 0) {
          ctx.enabled = binding.value !== false;
          if (ctx.enabled === true && Object(binding.value) === binding.value) {
            updateModifiers(ctx, binding);
          }
        }
      }
    },
    beforeUnmount(el) {
      const ctx = el.__qripple;
      if (ctx !== void 0) {
        ctx.abort.forEach((fn) => {
          fn();
        });
        cleanEvt(ctx, "main");
        delete el._qripple;
      }
    }
  }
);
const alignMap = {
  left: "start",
  center: "center",
  right: "end",
  between: "between",
  around: "around",
  evenly: "evenly",
  stretch: "stretch"
};
const alignValues$2 = Object.keys(alignMap);
const useAlignProps = {
  align: {
    type: String,
    validator: (v2) => alignValues$2.includes(v2)
  }
};
function useAlign(props2) {
  return computed(() => {
    const align = props2.align === void 0 ? props2.vertical === true ? "stretch" : "left" : props2.align;
    return `${props2.vertical === true ? "items" : "justify"}-${alignMap[align]}`;
  });
}
function getParentProxy(proxy) {
  if (Object(proxy.$parent) === proxy.$parent) {
    return proxy.$parent;
  }
  let { parent } = proxy.$;
  while (Object(parent) === parent) {
    if (Object(parent.proxy) === parent.proxy) {
      return parent.proxy;
    }
    parent = parent.parent;
  }
}
function fillNormalizedVNodes(children, vnode) {
  if (typeof vnode.type === "symbol") {
    if (Array.isArray(vnode.children) === true) {
      vnode.children.forEach((child) => {
        fillNormalizedVNodes(children, child);
      });
    }
  } else {
    children.add(vnode);
  }
}
function getNormalizedVNodes(vnodes) {
  const children = /* @__PURE__ */ new Set();
  vnodes.forEach((vnode) => {
    fillNormalizedVNodes(children, vnode);
  });
  return Array.from(children);
}
function vmHasRouter(vm2) {
  return vm2.appContext.config.globalProperties.$router !== void 0;
}
function vmIsDestroyed(vm2) {
  return vm2.isUnmounted === true || vm2.isDeactivated === true;
}
function getOriginalPath$1(record) {
  return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
}
function isSameRouteRecord$1(a2, b2) {
  return (a2.aliasOf || a2) === (b2.aliasOf || b2);
}
function includesParams$1(outer, inner) {
  for (const key in inner) {
    const innerValue = inner[key], outerValue = outer[key];
    if (typeof innerValue === "string") {
      if (innerValue !== outerValue) {
        return false;
      }
    } else if (Array.isArray(outerValue) === false || outerValue.length !== innerValue.length || innerValue.some((value2, i) => value2 !== outerValue[i])) {
      return false;
    }
  }
  return true;
}
function isEquivalentArray$1(a2, b2) {
  return Array.isArray(b2) === true ? a2.length === b2.length && a2.every((value2, i) => value2 === b2[i]) : a2.length === 1 && a2[0] === b2;
}
function isSameRouteLocationParamsValue$1(a2, b2) {
  return Array.isArray(a2) === true ? isEquivalentArray$1(a2, b2) : Array.isArray(b2) === true ? isEquivalentArray$1(b2, a2) : a2 === b2;
}
function isSameRouteLocationParams$1(a2, b2) {
  if (Object.keys(a2).length !== Object.keys(b2).length) {
    return false;
  }
  for (const key in a2) {
    if (isSameRouteLocationParamsValue$1(a2[key], b2[key]) === false) {
      return false;
    }
  }
  return true;
}
const useRouterLinkNonMatchingProps = {
  // router-link
  to: [String, Object],
  replace: Boolean,
  // regular <a> link
  href: String,
  target: String,
  // state
  disable: Boolean
};
const useRouterLinkProps = {
  ...useRouterLinkNonMatchingProps,
  // router-link
  exact: Boolean,
  activeClass: {
    type: String,
    default: "q-router-link--active"
  },
  exactActiveClass: {
    type: String,
    default: "q-router-link--exact-active"
  }
};
function useRouterLink({ fallbackTag, useDisableForRouterLinkProps = true } = {}) {
  const vm2 = getCurrentInstance();
  const { props: props2, proxy, emit: emit2 } = vm2;
  const hasRouter = vmHasRouter(vm2);
  const hasHrefLink = computed(() => props2.disable !== true && props2.href !== void 0);
  const hasRouterLinkProps = useDisableForRouterLinkProps === true ? computed(
    () => hasRouter === true && props2.disable !== true && hasHrefLink.value !== true && props2.to !== void 0 && props2.to !== null && props2.to !== ""
  ) : computed(
    () => hasRouter === true && hasHrefLink.value !== true && props2.to !== void 0 && props2.to !== null && props2.to !== ""
  );
  const resolvedLink = computed(() => hasRouterLinkProps.value === true ? getLink(props2.to) : null);
  const hasRouterLink = computed(() => resolvedLink.value !== null);
  const hasLink = computed(() => hasHrefLink.value === true || hasRouterLink.value === true);
  const linkTag = computed(() => props2.type === "a" || hasLink.value === true ? "a" : props2.tag || fallbackTag || "div");
  const linkAttrs = computed(() => hasHrefLink.value === true ? {
    href: props2.href,
    target: props2.target
  } : hasRouterLink.value === true ? {
    href: resolvedLink.value.href,
    target: props2.target
  } : {});
  const linkActiveIndex = computed(() => {
    if (hasRouterLink.value === false) {
      return -1;
    }
    const { matched } = resolvedLink.value, { length } = matched, routeMatched = matched[length - 1];
    if (routeMatched === void 0) {
      return -1;
    }
    const currentMatched = proxy.$route.matched;
    if (currentMatched.length === 0) {
      return -1;
    }
    const index = currentMatched.findIndex(
      isSameRouteRecord$1.bind(null, routeMatched)
    );
    if (index !== -1) {
      return index;
    }
    const parentRecordPath = getOriginalPath$1(matched[length - 2]);
    return (
      // we are dealing with nested routes
      length > 1 && getOriginalPath$1(routeMatched) === parentRecordPath && currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(
        isSameRouteRecord$1.bind(null, matched[length - 2])
      ) : index
    );
  });
  const linkIsActive = computed(
    () => hasRouterLink.value === true && linkActiveIndex.value !== -1 && includesParams$1(proxy.$route.params, resolvedLink.value.params)
  );
  const linkIsExactActive = computed(
    () => linkIsActive.value === true && linkActiveIndex.value === proxy.$route.matched.length - 1 && isSameRouteLocationParams$1(proxy.$route.params, resolvedLink.value.params)
  );
  const linkClass = computed(() => hasRouterLink.value === true ? linkIsExactActive.value === true ? ` ${props2.exactActiveClass} ${props2.activeClass}` : props2.exact === true ? "" : linkIsActive.value === true ? ` ${props2.activeClass}` : "" : "");
  function getLink(to) {
    try {
      return proxy.$router.resolve(to);
    } catch (_2) {
    }
    return null;
  }
  function navigateToRouterLink(e2, { returnRouterError, to = props2.to, replace = props2.replace } = {}) {
    if (props2.disable === true) {
      e2.preventDefault();
      return Promise.resolve(false);
    }
    if (
      // don't redirect with control keys;
      // should match RouterLink from Vue Router
      e2.metaKey || e2.altKey || e2.ctrlKey || e2.shiftKey || e2.button !== void 0 && e2.button !== 0 || props2.target === "_blank"
    ) {
      return Promise.resolve(false);
    }
    e2.preventDefault();
    const promise = proxy.$router[replace === true ? "replace" : "push"](to);
    return returnRouterError === true ? promise : promise.then(() => {
    }).catch(() => {
    });
  }
  function navigateOnClick(e2) {
    if (hasRouterLink.value === true) {
      const go = (opts) => navigateToRouterLink(e2, opts);
      emit2("click", e2, go);
      e2.defaultPrevented !== true && go();
    } else {
      emit2("click", e2);
    }
  }
  return {
    hasRouterLink,
    hasHrefLink,
    hasLink,
    linkTag,
    resolvedLink,
    linkIsActive,
    linkIsExactActive,
    linkClass,
    linkAttrs,
    getLink,
    navigateToRouterLink,
    navigateOnClick
  };
}
const btnPadding = {
  none: 0,
  xs: 4,
  sm: 8,
  md: 16,
  lg: 24,
  xl: 32
};
const defaultSizes$2 = {
  xs: 8,
  sm: 10,
  md: 14,
  lg: 20,
  xl: 24
};
const formTypes = ["button", "submit", "reset"];
const mediaTypeRE = /[^\s]\/[^\s]/;
const btnDesignOptions = ["flat", "outline", "push", "unelevated"];
function getBtnDesign(props2, defaultValue) {
  if (props2.flat === true) return "flat";
  if (props2.outline === true) return "outline";
  if (props2.push === true) return "push";
  if (props2.unelevated === true) return "unelevated";
  return defaultValue;
}
const nonRoundBtnProps = {
  ...useSizeProps,
  ...useRouterLinkNonMatchingProps,
  type: {
    type: String,
    default: "button"
  },
  label: [Number, String],
  icon: String,
  iconRight: String,
  ...btnDesignOptions.reduce(
    (acc, val) => (acc[val] = Boolean) && acc,
    {}
  ),
  square: Boolean,
  rounded: Boolean,
  glossy: Boolean,
  size: String,
  fab: Boolean,
  fabMini: Boolean,
  padding: String,
  color: String,
  textColor: String,
  noCaps: Boolean,
  noWrap: Boolean,
  dense: Boolean,
  tabindex: [Number, String],
  ripple: {
    type: [Boolean, Object],
    default: true
  },
  align: {
    ...useAlignProps.align,
    default: "center"
  },
  stack: Boolean,
  stretch: Boolean,
  loading: {
    type: Boolean,
    default: null
  },
  disable: Boolean
};
const useBtnProps = {
  ...nonRoundBtnProps,
  round: Boolean
};
function useBtn(props2) {
  const sizeStyle = useSize(props2, defaultSizes$2);
  const alignClass = useAlign(props2);
  const { hasRouterLink, hasLink, linkTag, linkAttrs, navigateOnClick } = useRouterLink({
    fallbackTag: "button"
  });
  const style = computed(() => {
    const obj = props2.fab === false && props2.fabMini === false ? sizeStyle.value : {};
    return props2.padding !== void 0 ? Object.assign({}, obj, {
      padding: props2.padding.split(/\s+/).map((v2) => v2 in btnPadding ? btnPadding[v2] + "px" : v2).join(" "),
      minWidth: "0",
      minHeight: "0"
    }) : obj;
  });
  const isRounded = computed(
    () => props2.rounded === true || props2.fab === true || props2.fabMini === true
  );
  const isActionable = computed(
    () => props2.disable !== true && props2.loading !== true
  );
  const tabIndex = computed(() => isActionable.value === true ? props2.tabindex || 0 : -1);
  const design = computed(() => getBtnDesign(props2, "standard"));
  const attributes = computed(() => {
    const acc = { tabindex: tabIndex.value };
    if (hasLink.value === true) {
      Object.assign(acc, linkAttrs.value);
    } else if (formTypes.includes(props2.type) === true) {
      acc.type = props2.type;
    }
    if (linkTag.value === "a") {
      if (props2.disable === true) {
        acc["aria-disabled"] = "true";
      } else if (acc.href === void 0) {
        acc.role = "button";
      }
      if (hasRouterLink.value !== true && mediaTypeRE.test(props2.type) === true) {
        acc.type = props2.type;
      }
    } else if (props2.disable === true) {
      acc.disabled = "";
      acc["aria-disabled"] = "true";
    }
    if (props2.loading === true && props2.percentage !== void 0) {
      Object.assign(acc, {
        role: "progressbar",
        "aria-valuemin": 0,
        "aria-valuemax": 100,
        "aria-valuenow": props2.percentage
      });
    }
    return acc;
  });
  const classes = computed(() => {
    let colors;
    if (props2.color !== void 0) {
      if (props2.flat === true || props2.outline === true) {
        colors = `text-${props2.textColor || props2.color}`;
      } else {
        colors = `bg-${props2.color} text-${props2.textColor || "white"}`;
      }
    } else if (props2.textColor) {
      colors = `text-${props2.textColor}`;
    }
    const shape = props2.round === true ? "round" : `rectangle${isRounded.value === true ? " q-btn--rounded" : props2.square === true ? " q-btn--square" : ""}`;
    return `q-btn--${design.value} q-btn--${shape}` + (colors !== void 0 ? " " + colors : "") + (isActionable.value === true ? " q-btn--actionable q-focusable q-hoverable" : props2.disable === true ? " disabled" : "") + (props2.fab === true ? " q-btn--fab" : props2.fabMini === true ? " q-btn--fab-mini" : "") + (props2.noCaps === true ? " q-btn--no-uppercase" : "") + (props2.dense === true ? " q-btn--dense" : "") + (props2.stretch === true ? " no-border-radius self-stretch" : "") + (props2.glossy === true ? " glossy" : "") + (props2.square ? " q-btn--square" : "");
  });
  const innerClasses = computed(
    () => alignClass.value + (props2.stack === true ? " column" : " row") + (props2.noWrap === true ? " no-wrap text-no-wrap" : "") + (props2.loading === true ? " q-btn__content--hidden" : "")
  );
  return {
    classes,
    style,
    innerClasses,
    attributes,
    hasLink,
    linkTag,
    navigateOnClick,
    isActionable
  };
}
const { passiveCapture } = listenOpts;
let touchTarget = null, keyboardTarget = null, mouseTarget = null;
const QBtn = createComponent({
  name: "QBtn",
  props: {
    ...useBtnProps,
    percentage: Number,
    darkPercentage: Boolean,
    onTouchstart: [Function, Array]
  },
  emits: ["click", "keydown", "mousedown", "keyup"],
  setup(props2, { slots, emit: emit2 }) {
    const { proxy } = getCurrentInstance();
    const {
      classes,
      style,
      innerClasses,
      attributes,
      hasLink,
      linkTag,
      navigateOnClick,
      isActionable
    } = useBtn(props2);
    const rootRef = ref(null);
    const blurTargetRef = ref(null);
    let localTouchTargetEl = null, avoidMouseRipple, mouseTimer = null;
    const hasLabel = computed(
      () => props2.label !== void 0 && props2.label !== null && props2.label !== ""
    );
    const ripple = computed(() => props2.disable === true || props2.ripple === false ? false : {
      keyCodes: hasLink.value === true ? [13, 32] : [13],
      ...props2.ripple === true ? {} : props2.ripple
    });
    const rippleProps = computed(() => ({ center: props2.round }));
    const percentageStyle = computed(() => {
      const val = Math.max(0, Math.min(100, props2.percentage));
      return val > 0 ? { transition: "transform 0.6s", transform: `translateX(${val - 100}%)` } : {};
    });
    const onEvents = computed(() => {
      if (props2.loading === true) {
        return {
          onMousedown: onLoadingEvt,
          onTouchstart: onLoadingEvt,
          onClick: onLoadingEvt,
          onKeydown: onLoadingEvt,
          onKeyup: onLoadingEvt
        };
      }
      if (isActionable.value === true) {
        const acc = {
          onClick,
          onKeydown: onKeydown2,
          onMousedown
        };
        if (proxy.$q.platform.has.touch === true) {
          const suffix = props2.onTouchstart !== void 0 ? "" : "Passive";
          acc[`onTouchstart${suffix}`] = onTouchstart;
        }
        return acc;
      }
      return {
        // needed; especially for disabled <a> tags
        onClick: stopAndPrevent
      };
    });
    const nodeProps = computed(() => ({
      ref: rootRef,
      class: "q-btn q-btn-item non-selectable no-outline " + classes.value,
      style: style.value,
      ...attributes.value,
      ...onEvents.value
    }));
    function onClick(e2) {
      if (rootRef.value === null) return;
      if (e2 !== void 0) {
        if (e2.defaultPrevented === true) {
          return;
        }
        const el = document.activeElement;
        if (props2.type === "submit" && el !== document.body && rootRef.value.contains(el) === false && el.contains(rootRef.value) === false) {
          rootRef.value.focus();
          const onClickCleanup = () => {
            document.removeEventListener("keydown", stopAndPrevent, true);
            document.removeEventListener("keyup", onClickCleanup, passiveCapture);
            rootRef.value !== null && rootRef.value.removeEventListener("blur", onClickCleanup, passiveCapture);
          };
          document.addEventListener("keydown", stopAndPrevent, true);
          document.addEventListener("keyup", onClickCleanup, passiveCapture);
          rootRef.value.addEventListener("blur", onClickCleanup, passiveCapture);
        }
      }
      navigateOnClick(e2);
    }
    function onKeydown2(e2) {
      if (rootRef.value === null) return;
      emit2("keydown", e2);
      if (isKeyCode(e2, [13, 32]) === true && keyboardTarget !== rootRef.value) {
        keyboardTarget !== null && cleanup();
        if (e2.defaultPrevented !== true) {
          rootRef.value.focus();
          keyboardTarget = rootRef.value;
          rootRef.value.classList.add("q-btn--active");
          document.addEventListener("keyup", onPressEnd, true);
          rootRef.value.addEventListener("blur", onPressEnd, passiveCapture);
        }
        stopAndPrevent(e2);
      }
    }
    function onTouchstart(e2) {
      if (rootRef.value === null) return;
      emit2("touchstart", e2);
      if (e2.defaultPrevented === true) return;
      if (touchTarget !== rootRef.value) {
        touchTarget !== null && cleanup();
        touchTarget = rootRef.value;
        localTouchTargetEl = e2.target;
        localTouchTargetEl.addEventListener("touchcancel", onPressEnd, passiveCapture);
        localTouchTargetEl.addEventListener("touchend", onPressEnd, passiveCapture);
      }
      avoidMouseRipple = true;
      mouseTimer !== null && clearTimeout(mouseTimer);
      mouseTimer = setTimeout(() => {
        mouseTimer = null;
        avoidMouseRipple = false;
      }, 200);
    }
    function onMousedown(e2) {
      if (rootRef.value === null) return;
      e2.qSkipRipple = avoidMouseRipple === true;
      emit2("mousedown", e2);
      if (e2.defaultPrevented !== true && mouseTarget !== rootRef.value) {
        mouseTarget !== null && cleanup();
        mouseTarget = rootRef.value;
        rootRef.value.classList.add("q-btn--active");
        document.addEventListener("mouseup", onPressEnd, passiveCapture);
      }
    }
    function onPressEnd(e2) {
      if (rootRef.value === null) return;
      if (e2 !== void 0 && e2.type === "blur" && document.activeElement === rootRef.value) {
        return;
      }
      if (e2 !== void 0 && e2.type === "keyup") {
        if (keyboardTarget === rootRef.value && isKeyCode(e2, [13, 32]) === true) {
          const evt = new MouseEvent("click", e2);
          evt.qKeyEvent = true;
          e2.defaultPrevented === true && prevent(evt);
          e2.cancelBubble === true && stop(evt);
          rootRef.value.dispatchEvent(evt);
          stopAndPrevent(e2);
          e2.qKeyEvent = true;
        }
        emit2("keyup", e2);
      }
      cleanup();
    }
    function cleanup(destroying) {
      const blurTarget = blurTargetRef.value;
      if (destroying !== true && (touchTarget === rootRef.value || mouseTarget === rootRef.value) && blurTarget !== null && blurTarget !== document.activeElement) {
        blurTarget.setAttribute("tabindex", -1);
        blurTarget.focus();
      }
      if (touchTarget === rootRef.value) {
        if (localTouchTargetEl !== null) {
          localTouchTargetEl.removeEventListener("touchcancel", onPressEnd, passiveCapture);
          localTouchTargetEl.removeEventListener("touchend", onPressEnd, passiveCapture);
        }
        touchTarget = localTouchTargetEl = null;
      }
      if (mouseTarget === rootRef.value) {
        document.removeEventListener("mouseup", onPressEnd, passiveCapture);
        mouseTarget = null;
      }
      if (keyboardTarget === rootRef.value) {
        document.removeEventListener("keyup", onPressEnd, true);
        rootRef.value !== null && rootRef.value.removeEventListener("blur", onPressEnd, passiveCapture);
        keyboardTarget = null;
      }
      rootRef.value !== null && rootRef.value.classList.remove("q-btn--active");
    }
    function onLoadingEvt(evt) {
      stopAndPrevent(evt);
      evt.qSkipRipple = true;
    }
    onBeforeUnmount(() => {
      cleanup(true);
    });
    Object.assign(proxy, {
      click: (e2) => {
        if (isActionable.value === true) {
          onClick(e2);
        }
      }
    });
    return () => {
      let inner = [];
      props2.icon !== void 0 && inner.push(
        h$1(QIcon, {
          name: props2.icon,
          left: props2.stack !== true && hasLabel.value === true,
          role: "img",
          "aria-hidden": "true"
        })
      );
      hasLabel.value === true && inner.push(
        h$1("span", { class: "block" }, [props2.label])
      );
      inner = hMergeSlot(slots.default, inner);
      if (props2.iconRight !== void 0 && props2.round === false) {
        inner.push(
          h$1(QIcon, {
            name: props2.iconRight,
            right: props2.stack !== true && hasLabel.value === true,
            role: "img",
            "aria-hidden": "true"
          })
        );
      }
      const child = [
        h$1("span", {
          class: "q-focus-helper",
          ref: blurTargetRef
        })
      ];
      if (props2.loading === true && props2.percentage !== void 0) {
        child.push(
          h$1("span", {
            class: "q-btn__progress absolute-full overflow-hidden" + (props2.darkPercentage === true ? " q-btn__progress--dark" : "")
          }, [
            h$1("span", {
              class: "q-btn__progress-indicator fit block",
              style: percentageStyle.value
            })
          ])
        );
      }
      child.push(
        h$1("span", {
          class: "q-btn__content text-center col items-center q-anchor--skip " + innerClasses.value
        }, inner)
      );
      props2.loading !== null && child.push(
        h$1(Transition, {
          name: "q-transition--fade"
        }, () => props2.loading === true ? [
          h$1("span", {
            key: "loading",
            class: "absolute-full flex flex-center"
          }, slots.loading !== void 0 ? slots.loading() : [h$1(QSpinner)])
        ] : null)
      );
      return withDirectives(
        h$1(
          linkTag.value,
          nodeProps.value,
          child
        ),
        [[
          Ripple,
          ripple.value,
          void 0,
          rippleProps.value
        ]]
      );
    };
  }
});
let portalIndex = 1;
let target = document.body;
function createGlobalNode(id2, portalType) {
  const el = document.createElement("div");
  el.id = portalType !== void 0 ? `q-portal--${portalType}--${portalIndex++}` : id2;
  if (globalConfig.globalNodes !== void 0) {
    const cls = globalConfig.globalNodes.class;
    if (cls !== void 0) {
      el.className = cls;
    }
  }
  target.appendChild(el);
  return el;
}
function removeGlobalNode(el) {
  el.remove();
}
let uid$3 = 0;
const defaults$2 = {};
const groups = {};
const notificationsList = {};
const positionClass$1 = {};
const emptyRE = /^\s*$/;
const notifRefs = [];
const invalidTimeoutValues = [void 0, null, true, false, ""];
const positionList = [
  "top-left",
  "top-right",
  "bottom-left",
  "bottom-right",
  "top",
  "bottom",
  "left",
  "right",
  "center"
];
const badgePositions = [
  "top-left",
  "top-right",
  "bottom-left",
  "bottom-right"
];
const notifTypes = {
  positive: {
    icon: ($q) => $q.iconSet.type.positive,
    color: "positive"
  },
  negative: {
    icon: ($q) => $q.iconSet.type.negative,
    color: "negative"
  },
  warning: {
    icon: ($q) => $q.iconSet.type.warning,
    color: "warning",
    textColor: "dark"
  },
  info: {
    icon: ($q) => $q.iconSet.type.info,
    color: "info"
  },
  ongoing: {
    group: false,
    timeout: 0,
    spinner: true,
    color: "grey-8"
  }
};
function addNotification(config, $q, originalApi) {
  if (!config) {
    return logError("parameter required");
  }
  let Api;
  const notif = { textColor: "white" };
  if (config.ignoreDefaults !== true) {
    Object.assign(notif, defaults$2);
  }
  if (isObject$3(config) === false) {
    if (notif.type) {
      Object.assign(notif, notifTypes[notif.type]);
    }
    config = { message: config };
  }
  Object.assign(notif, notifTypes[config.type || notif.type], config);
  if (typeof notif.icon === "function") {
    notif.icon = notif.icon($q);
  }
  if (!notif.spinner) {
    notif.spinner = false;
  } else {
    if (notif.spinner === true) {
      notif.spinner = QSpinner;
    }
    notif.spinner = markRaw(notif.spinner);
  }
  notif.meta = {
    hasMedia: Boolean(notif.spinner !== false || notif.icon || notif.avatar),
    hasText: hasContent(notif.message) || hasContent(notif.caption)
  };
  if (notif.position) {
    if (positionList.includes(notif.position) === false) {
      return logError("wrong position", config);
    }
  } else {
    notif.position = "bottom";
  }
  if (invalidTimeoutValues.includes(notif.timeout) === true) {
    notif.timeout = 5e3;
  } else {
    const t2 = Number(notif.timeout);
    if (isNaN(t2) || t2 < 0) {
      return logError("wrong timeout", config);
    }
    notif.timeout = Number.isFinite(t2) ? t2 : 0;
  }
  if (notif.timeout === 0) {
    notif.progress = false;
  } else if (notif.progress === true) {
    notif.meta.progressClass = "q-notification__progress" + (notif.progressClass ? ` ${notif.progressClass}` : "");
    notif.meta.progressStyle = {
      animationDuration: `${notif.timeout + 1e3}ms`
    };
  }
  const actions = (Array.isArray(config.actions) === true ? config.actions : []).concat(
    config.ignoreDefaults !== true && Array.isArray(defaults$2.actions) === true ? defaults$2.actions : []
  ).concat(
    notifTypes[config.type] !== void 0 && Array.isArray(notifTypes[config.type].actions) === true ? notifTypes[config.type].actions : []
  );
  const { closeBtn } = notif;
  closeBtn && actions.push({
    label: typeof closeBtn === "string" ? closeBtn : $q.lang.label.close
  });
  notif.actions = actions.map(({ handler, noDismiss, ...item }) => ({
    flat: true,
    ...item,
    onClick: typeof handler === "function" ? () => {
      handler();
      noDismiss !== true && dismiss();
    } : () => {
      dismiss();
    }
  }));
  if (notif.multiLine === void 0) {
    notif.multiLine = notif.actions.length > 1;
  }
  Object.assign(notif.meta, {
    class: `q-notification row items-stretch q-notification--${notif.multiLine === true ? "multi-line" : "standard"}` + (notif.color !== void 0 ? ` bg-${notif.color}` : "") + (notif.textColor !== void 0 ? ` text-${notif.textColor}` : "") + (notif.classes !== void 0 ? ` ${notif.classes}` : ""),
    wrapperClass: "q-notification__wrapper col relative-position border-radius-inherit " + (notif.multiLine === true ? "column no-wrap justify-center" : "row items-center"),
    contentClass: "q-notification__content row items-center" + (notif.multiLine === true ? "" : " col"),
    leftClass: notif.meta.hasText === true ? "additional" : "single",
    attrs: {
      role: "alert",
      ...notif.attrs
    }
  });
  if (notif.group === false) {
    notif.group = void 0;
    notif.meta.group = void 0;
  } else {
    if (notif.group === void 0 || notif.group === true) {
      notif.group = [
        notif.message,
        notif.caption,
        notif.multiline
      ].concat(
        notif.actions.map((props2) => `${props2.label}*${props2.icon}`)
      ).join("|");
    }
    notif.meta.group = notif.group + "|" + notif.position;
  }
  if (notif.actions.length === 0) {
    notif.actions = void 0;
  } else {
    notif.meta.actionsClass = "q-notification__actions row items-center " + (notif.multiLine === true ? "justify-end" : "col-auto") + (notif.meta.hasMedia === true ? " q-notification__actions--with-media" : "");
  }
  if (originalApi !== void 0) {
    if (originalApi.notif.meta.timer) {
      clearTimeout(originalApi.notif.meta.timer);
      originalApi.notif.meta.timer = void 0;
    }
    notif.meta.uid = originalApi.notif.meta.uid;
    const index = notificationsList[notif.position].value.indexOf(originalApi.notif);
    notificationsList[notif.position].value[index] = notif;
  } else {
    const original = groups[notif.meta.group];
    if (original === void 0) {
      notif.meta.uid = uid$3++;
      notif.meta.badge = 1;
      if (["left", "right", "center"].indexOf(notif.position) !== -1) {
        notificationsList[notif.position].value.splice(
          Math.floor(notificationsList[notif.position].value.length / 2),
          0,
          notif
        );
      } else {
        const action = notif.position.indexOf("top") !== -1 ? "unshift" : "push";
        notificationsList[notif.position].value[action](notif);
      }
      if (notif.group !== void 0) {
        groups[notif.meta.group] = notif;
      }
    } else {
      if (original.meta.timer) {
        clearTimeout(original.meta.timer);
        original.meta.timer = void 0;
      }
      if (notif.badgePosition !== void 0) {
        if (badgePositions.includes(notif.badgePosition) === false) {
          return logError("wrong badgePosition", config);
        }
      } else {
        notif.badgePosition = `top-${notif.position.indexOf("left") !== -1 ? "right" : "left"}`;
      }
      notif.meta.uid = original.meta.uid;
      notif.meta.badge = original.meta.badge + 1;
      notif.meta.badgeClass = `q-notification__badge q-notification__badge--${notif.badgePosition}` + (notif.badgeColor !== void 0 ? ` bg-${notif.badgeColor}` : "") + (notif.badgeTextColor !== void 0 ? ` text-${notif.badgeTextColor}` : "") + (notif.badgeClass ? ` ${notif.badgeClass}` : "");
      const index = notificationsList[notif.position].value.indexOf(original);
      notificationsList[notif.position].value[index] = groups[notif.meta.group] = notif;
    }
  }
  const dismiss = () => {
    removeNotification(notif);
    Api = void 0;
  };
  if (notif.timeout > 0) {
    notif.meta.timer = setTimeout(() => {
      notif.meta.timer = void 0;
      dismiss();
    }, notif.timeout + /* show duration */
    1e3);
  }
  if (notif.group !== void 0) {
    return (props2) => {
      if (props2 !== void 0) {
        logError("trying to update a grouped one which is forbidden", config);
      } else {
        dismiss();
      }
    };
  }
  Api = {
    dismiss,
    config,
    notif
  };
  if (originalApi !== void 0) {
    Object.assign(originalApi, Api);
    return;
  }
  return (props2) => {
    if (Api !== void 0) {
      if (props2 === void 0) {
        Api.dismiss();
      } else {
        const newNotif = Object.assign({}, Api.config, props2, {
          group: false,
          position: notif.position
        });
        addNotification(newNotif, $q, Api);
      }
    }
  };
}
function removeNotification(notif) {
  if (notif.meta.timer) {
    clearTimeout(notif.meta.timer);
    notif.meta.timer = void 0;
  }
  const index = notificationsList[notif.position].value.indexOf(notif);
  if (index !== -1) {
    if (notif.group !== void 0) {
      delete groups[notif.meta.group];
    }
    const el = notifRefs["" + notif.meta.uid];
    if (el) {
      const { width: width2, height } = getComputedStyle(el);
      el.style.left = `${el.offsetLeft}px`;
      el.style.width = width2;
      el.style.height = height;
    }
    notificationsList[notif.position].value.splice(index, 1);
    if (typeof notif.onDismiss === "function") {
      notif.onDismiss();
    }
  }
}
function hasContent(str) {
  return str !== void 0 && str !== null && emptyRE.test(str) !== true;
}
function logError(error, config) {
  console.error(`Notify: ${error}`, config);
  return false;
}
function getComponent() {
  return createComponent({
    name: "QNotifications",
    // hide App from Vue devtools
    devtools: { hide: true },
    setup() {
      return () => h$1("div", { class: "q-notifications" }, positionList.map((pos) => {
        return h$1(TransitionGroup, {
          key: pos,
          class: positionClass$1[pos],
          tag: "div",
          name: `q-notification--${pos}`
        }, () => notificationsList[pos].value.map((notif) => {
          const meta = notif.meta;
          const mainChild = [];
          if (meta.hasMedia === true) {
            if (notif.spinner !== false) {
              mainChild.push(
                h$1(notif.spinner, {
                  class: "q-notification__spinner q-notification__spinner--" + meta.leftClass,
                  color: notif.spinnerColor,
                  size: notif.spinnerSize
                })
              );
            } else if (notif.icon) {
              mainChild.push(
                h$1(QIcon, {
                  class: "q-notification__icon q-notification__icon--" + meta.leftClass,
                  name: notif.icon,
                  color: notif.iconColor,
                  size: notif.iconSize,
                  role: "img"
                })
              );
            } else if (notif.avatar) {
              mainChild.push(
                h$1(QAvatar, {
                  class: "q-notification__avatar q-notification__avatar--" + meta.leftClass
                }, () => h$1("img", { src: notif.avatar, "aria-hidden": "true" }))
              );
            }
          }
          if (meta.hasText === true) {
            let msgChild;
            const msgData = { class: "q-notification__message col" };
            if (notif.html === true) {
              msgData.innerHTML = notif.caption ? `<div>${notif.message}</div><div class="q-notification__caption">${notif.caption}</div>` : notif.message;
            } else {
              const msgNode = [notif.message];
              msgChild = notif.caption ? [
                h$1("div", msgNode),
                h$1("div", { class: "q-notification__caption" }, [notif.caption])
              ] : msgNode;
            }
            mainChild.push(
              h$1("div", msgData, msgChild)
            );
          }
          const child = [
            h$1("div", { class: meta.contentClass }, mainChild)
          ];
          notif.progress === true && child.push(
            h$1("div", {
              key: `${meta.uid}|p|${meta.badge}`,
              class: meta.progressClass,
              style: meta.progressStyle
            })
          );
          notif.actions !== void 0 && child.push(
            h$1("div", {
              class: meta.actionsClass
            }, notif.actions.map((props2) => h$1(QBtn, props2)))
          );
          meta.badge > 1 && child.push(
            h$1("div", {
              key: `${meta.uid}|${meta.badge}`,
              class: notif.meta.badgeClass,
              style: notif.badgeStyle
            }, [meta.badge])
          );
          return h$1("div", {
            ref: (el) => {
              notifRefs["" + meta.uid] = el;
            },
            key: meta.uid,
            class: meta.class,
            ...meta.attrs
          }, [
            h$1("div", { class: meta.wrapperClass }, child)
          ]);
        }));
      }));
    }
  });
}
const Notify = {
  setDefaults(opts) {
    {
      isObject$3(opts) === true && Object.assign(defaults$2, opts);
    }
  },
  registerType(typeName, typeOpts) {
    if (isObject$3(typeOpts) === true) {
      notifTypes[typeName] = typeOpts;
    }
  },
  install({ $q, parentApp }) {
    $q.notify = this.create = (opts) => addNotification(opts, $q);
    $q.notify.setDefaults = this.setDefaults;
    $q.notify.registerType = this.registerType;
    if ($q.config.notify !== void 0) {
      this.setDefaults($q.config.notify);
    }
    if (this.__installed !== true) {
      positionList.forEach((pos) => {
        notificationsList[pos] = ref([]);
        const vert = ["left", "center", "right"].includes(pos) === true ? "center" : pos.indexOf("top") !== -1 ? "top" : "bottom", align = pos.indexOf("left") !== -1 ? "start" : pos.indexOf("right") !== -1 ? "end" : "center", classes = ["left", "right"].includes(pos) ? `items-${pos === "left" ? "start" : "end"} justify-center` : pos === "center" ? "flex-center" : `items-${align}`;
        positionClass$1[pos] = `q-notifications__list q-notifications__list--${vert} fixed column no-wrap ${classes}`;
      });
      const el = createGlobalNode("q-notify");
      createChildApp(getComponent(), parentApp).mount(el);
    }
  }
};
function useHistory(showing, hide, hideOnRouteChange) {
  let historyEntry;
  function removeFromHistory() {
    if (historyEntry !== void 0) {
      History.remove(historyEntry);
      historyEntry = void 0;
    }
  }
  onBeforeUnmount(() => {
    showing.value === true && removeFromHistory();
  });
  return {
    removeFromHistory,
    addToHistory() {
      historyEntry = {
        condition: () => hideOnRouteChange.value === true,
        handler: hide
      };
      History.add(historyEntry);
    }
  };
}
function useTimeout() {
  let timer = null;
  const vm2 = getCurrentInstance();
  function removeTimeout() {
    if (timer !== null) {
      clearTimeout(timer);
      timer = null;
    }
  }
  onDeactivated(removeTimeout);
  onBeforeUnmount(removeTimeout);
  return {
    removeTimeout,
    registerTimeout(fn, delay) {
      removeTimeout();
      if (vmIsDestroyed(vm2) === false) {
        timer = setTimeout(() => {
          timer = null;
          fn();
        }, delay);
      }
    }
  };
}
function useTick() {
  let tickFn;
  const vm2 = getCurrentInstance();
  function removeTick() {
    tickFn = void 0;
  }
  onDeactivated(removeTick);
  onBeforeUnmount(removeTick);
  return {
    removeTick,
    registerTick(fn) {
      tickFn = fn;
      nextTick$1(() => {
        if (tickFn === fn) {
          vmIsDestroyed(vm2) === false && tickFn();
          tickFn = void 0;
        }
      });
    }
  };
}
const useModelToggleProps = {
  modelValue: {
    type: Boolean,
    default: null
  },
  "onUpdate:modelValue": [Function, Array]
};
const useModelToggleEmits = [
  "beforeShow",
  "show",
  "beforeHide",
  "hide"
];
function useModelToggle({
  showing,
  canShow,
  // optional
  hideOnRouteChange,
  // optional
  handleShow,
  // optional
  handleHide,
  // optional
  processOnMount
  // optional
}) {
  const vm2 = getCurrentInstance();
  const { props: props2, emit: emit2, proxy } = vm2;
  let payload;
  function toggle(evt) {
    if (showing.value === true) {
      hide(evt);
    } else {
      show(evt);
    }
  }
  function show(evt) {
    if (props2.disable === true || evt !== void 0 && evt.qAnchorHandled === true || canShow !== void 0 && canShow(evt) !== true) {
      return;
    }
    const listener = props2["onUpdate:modelValue"] !== void 0;
    if (listener === true && true) {
      emit2("update:modelValue", true);
      payload = evt;
      nextTick$1(() => {
        if (payload === evt) {
          payload = void 0;
        }
      });
    }
    if (props2.modelValue === null || listener === false || false) {
      processShow(evt);
    }
  }
  function processShow(evt) {
    if (showing.value === true) {
      return;
    }
    showing.value = true;
    emit2("beforeShow", evt);
    if (handleShow !== void 0) {
      handleShow(evt);
    } else {
      emit2("show", evt);
    }
  }
  function hide(evt) {
    if (props2.disable === true) {
      return;
    }
    const listener = props2["onUpdate:modelValue"] !== void 0;
    if (listener === true && true) {
      emit2("update:modelValue", false);
      payload = evt;
      nextTick$1(() => {
        if (payload === evt) {
          payload = void 0;
        }
      });
    }
    if (props2.modelValue === null || listener === false || false) {
      processHide(evt);
    }
  }
  function processHide(evt) {
    if (showing.value === false) {
      return;
    }
    showing.value = false;
    emit2("beforeHide", evt);
    if (handleHide !== void 0) {
      handleHide(evt);
    } else {
      emit2("hide", evt);
    }
  }
  function processModelChange(val) {
    if (props2.disable === true && val === true) {
      if (props2["onUpdate:modelValue"] !== void 0) {
        emit2("update:modelValue", false);
      }
    } else if (val === true !== showing.value) {
      const fn = val === true ? processShow : processHide;
      fn(payload);
    }
  }
  watch(() => props2.modelValue, processModelChange);
  if (hideOnRouteChange !== void 0 && vmHasRouter(vm2) === true) {
    watch(() => proxy.$route.fullPath, () => {
      if (hideOnRouteChange.value === true && showing.value === true) {
        hide();
      }
    });
  }
  processOnMount === true && onMounted(() => {
    processModelChange(props2.modelValue);
  });
  const publicMethods = { show, hide, toggle };
  Object.assign(proxy, publicMethods);
  return publicMethods;
}
const useTransitionProps = {
  transitionShow: {
    type: String,
    default: "fade"
  },
  transitionHide: {
    type: String,
    default: "fade"
  },
  transitionDuration: {
    type: [String, Number],
    default: 300
  }
};
function useTransition(props2, defaultShowFn = () => {
}, defaultHideFn = () => {
}) {
  return {
    transitionProps: computed(() => {
      const show = `q-transition--${props2.transitionShow || defaultShowFn()}`;
      const hide = `q-transition--${props2.transitionHide || defaultHideFn()}`;
      return {
        appear: true,
        enterFromClass: `${show}-enter-from`,
        enterActiveClass: `${show}-enter-active`,
        enterToClass: `${show}-enter-to`,
        leaveFromClass: `${hide}-leave-from`,
        leaveActiveClass: `${hide}-leave-active`,
        leaveToClass: `${hide}-leave-to`
      };
    }),
    transitionStyle: computed(() => `--q-transition-duration: ${props2.transitionDuration}ms`)
  };
}
let queue = [];
let waitFlags = [];
function clearFlag(flag) {
  waitFlags = waitFlags.filter((entry) => entry !== flag);
}
function addFocusWaitFlag(flag) {
  clearFlag(flag);
  waitFlags.push(flag);
}
function removeFocusWaitFlag(flag) {
  clearFlag(flag);
  if (waitFlags.length === 0 && queue.length !== 0) {
    queue[queue.length - 1]();
    queue = [];
  }
}
function addFocusFn(fn) {
  if (waitFlags.length === 0) {
    fn();
  } else {
    queue.push(fn);
  }
}
function removeFocusFn(fn) {
  queue = queue.filter((entry) => entry !== fn);
}
const portalProxyList = [];
function getPortalProxy(el) {
  return portalProxyList.find(
    (proxy) => proxy.contentEl !== null && proxy.contentEl.contains(el)
  );
}
function closePortalMenus(proxy, evt) {
  do {
    if (proxy.$options.name === "QMenu") {
      proxy.hide(evt);
      if (proxy.$props.separateClosePopup === true) {
        return getParentProxy(proxy);
      }
    } else if (proxy.__qPortal === true) {
      const parent = getParentProxy(proxy);
      if (parent !== void 0 && parent.$options.name === "QPopupProxy") {
        proxy.hide(evt);
        return parent;
      } else {
        return proxy;
      }
    }
    proxy = getParentProxy(proxy);
  } while (proxy !== void 0 && proxy !== null);
}
function closePortals(proxy, evt, depth) {
  while (depth !== 0 && proxy !== void 0 && proxy !== null) {
    if (proxy.__qPortal === true) {
      depth--;
      if (proxy.$options.name === "QMenu") {
        proxy = closePortalMenus(proxy, evt);
        continue;
      }
      proxy.hide(evt);
    }
    proxy = getParentProxy(proxy);
  }
}
const QPortal = createComponent({
  name: "QPortal",
  setup(_2, { slots }) {
    return () => slots.default();
  }
});
function isOnGlobalDialog(vm2) {
  vm2 = vm2.parent;
  while (vm2 !== void 0 && vm2 !== null) {
    if (vm2.type.name === "QGlobalDialog") {
      return true;
    }
    if (vm2.type.name === "QDialog" || vm2.type.name === "QMenu") {
      return false;
    }
    vm2 = vm2.parent;
  }
  return false;
}
function usePortal(vm2, innerRef, renderPortalContent, type) {
  const portalIsActive = ref(false);
  const portalIsAccessible = ref(false);
  let portalEl = null;
  const focusObj = {};
  const onGlobalDialog = type === "dialog" && isOnGlobalDialog(vm2);
  function showPortal(isReady) {
    if (isReady === true) {
      removeFocusWaitFlag(focusObj);
      portalIsAccessible.value = true;
      return;
    }
    portalIsAccessible.value = false;
    if (portalIsActive.value === false) {
      if (onGlobalDialog === false && portalEl === null) {
        portalEl = createGlobalNode(false, type);
      }
      portalIsActive.value = true;
      portalProxyList.push(vm2.proxy);
      addFocusWaitFlag(focusObj);
    }
  }
  function hidePortal(isReady) {
    portalIsAccessible.value = false;
    if (isReady !== true) return;
    removeFocusWaitFlag(focusObj);
    portalIsActive.value = false;
    const index = portalProxyList.indexOf(vm2.proxy);
    if (index !== -1) {
      portalProxyList.splice(index, 1);
    }
    if (portalEl !== null) {
      removeGlobalNode(portalEl);
      portalEl = null;
    }
  }
  onUnmounted(() => {
    hidePortal(true);
  });
  vm2.proxy.__qPortal = true;
  injectProp(vm2.proxy, "contentEl", () => innerRef.value);
  return {
    showPortal,
    hidePortal,
    portalIsActive,
    portalIsAccessible,
    renderPortal: () => onGlobalDialog === true ? renderPortalContent() : portalIsActive.value === true ? [h$1(Teleport, { to: portalEl }, h$1(QPortal, renderPortalContent))] : void 0
  };
}
let registered = 0, scrollPositionX, scrollPositionY, maxScrollTop, vpPendingUpdate = false, bodyLeft, bodyTop, href, closeTimer = null;
function onWheel(e2) {
  if (shouldPreventScroll(e2)) {
    stopAndPrevent(e2);
  }
}
function shouldPreventScroll(e2) {
  if (e2.target === document.body || e2.target.classList.contains("q-layout__backdrop")) {
    return true;
  }
  const path = getEventPath(e2), shift = e2.shiftKey && !e2.deltaX, scrollY = !shift && Math.abs(e2.deltaX) <= Math.abs(e2.deltaY), delta = shift || scrollY ? e2.deltaY : e2.deltaX;
  for (let index = 0; index < path.length; index++) {
    const el = path[index];
    if (hasScrollbar(el, scrollY)) {
      return scrollY ? delta < 0 && el.scrollTop === 0 ? true : delta > 0 && el.scrollTop + el.clientHeight === el.scrollHeight : delta < 0 && el.scrollLeft === 0 ? true : delta > 0 && el.scrollLeft + el.clientWidth === el.scrollWidth;
    }
  }
  return true;
}
function onAppleScroll(e2) {
  if (e2.target === document) {
    document.scrollingElement.scrollTop = document.scrollingElement.scrollTop;
  }
}
function onAppleResize(evt) {
  if (vpPendingUpdate === true) {
    return;
  }
  vpPendingUpdate = true;
  requestAnimationFrame(() => {
    vpPendingUpdate = false;
    const { height } = evt.target, { clientHeight, scrollTop } = document.scrollingElement;
    if (maxScrollTop === void 0 || height !== window.innerHeight) {
      maxScrollTop = clientHeight - height;
      document.scrollingElement.scrollTop = scrollTop;
    }
    if (scrollTop > maxScrollTop) {
      document.scrollingElement.scrollTop -= Math.ceil((scrollTop - maxScrollTop) / 8);
    }
  });
}
function apply(action) {
  const body = document.body, hasViewport = window.visualViewport !== void 0;
  if (action === "add") {
    const { overflowY, overflowX } = window.getComputedStyle(body);
    scrollPositionX = getHorizontalScrollPosition(window);
    scrollPositionY = getVerticalScrollPosition(window);
    bodyLeft = body.style.left;
    bodyTop = body.style.top;
    href = window.location.href;
    body.style.left = `-${scrollPositionX}px`;
    body.style.top = `-${scrollPositionY}px`;
    if (overflowX !== "hidden" && (overflowX === "scroll" || body.scrollWidth > window.innerWidth)) {
      body.classList.add("q-body--force-scrollbar-x");
    }
    if (overflowY !== "hidden" && (overflowY === "scroll" || body.scrollHeight > window.innerHeight)) {
      body.classList.add("q-body--force-scrollbar-y");
    }
    body.classList.add("q-body--prevent-scroll");
    document.qScrollPrevented = true;
    if (client.is.ios === true) {
      if (hasViewport === true) {
        window.scrollTo(0, 0);
        window.visualViewport.addEventListener("resize", onAppleResize, listenOpts.passiveCapture);
        window.visualViewport.addEventListener("scroll", onAppleResize, listenOpts.passiveCapture);
        window.scrollTo(0, 0);
      } else {
        window.addEventListener("scroll", onAppleScroll, listenOpts.passiveCapture);
      }
    }
  }
  if (client.is.desktop === true && client.is.mac === true) {
    window[`${action}EventListener`]("wheel", onWheel, listenOpts.notPassive);
  }
  if (action === "remove") {
    if (client.is.ios === true) {
      if (hasViewport === true) {
        window.visualViewport.removeEventListener("resize", onAppleResize, listenOpts.passiveCapture);
        window.visualViewport.removeEventListener("scroll", onAppleResize, listenOpts.passiveCapture);
      } else {
        window.removeEventListener("scroll", onAppleScroll, listenOpts.passiveCapture);
      }
    }
    body.classList.remove("q-body--prevent-scroll");
    body.classList.remove("q-body--force-scrollbar-x");
    body.classList.remove("q-body--force-scrollbar-y");
    document.qScrollPrevented = false;
    body.style.left = bodyLeft;
    body.style.top = bodyTop;
    if (window.location.href === href) {
      window.scrollTo(scrollPositionX, scrollPositionY);
    }
    maxScrollTop = void 0;
  }
}
function preventScroll(state) {
  let action = "add";
  if (state === true) {
    registered++;
    if (closeTimer !== null) {
      clearTimeout(closeTimer);
      closeTimer = null;
      return;
    }
    if (registered > 1) {
      return;
    }
  } else {
    if (registered === 0) {
      return;
    }
    registered--;
    if (registered > 0) {
      return;
    }
    action = "remove";
    if (client.is.ios === true && client.is.nativeMobile === true) {
      closeTimer !== null && clearTimeout(closeTimer);
      closeTimer = setTimeout(() => {
        apply(action);
        closeTimer = null;
      }, 100);
      return;
    }
  }
  apply(action);
}
function usePreventScroll() {
  let currentState;
  return {
    preventBodyScroll(state) {
      if (state !== currentState && (currentState !== void 0 || state === true)) {
        currentState = state;
        preventScroll(state);
      }
    }
  };
}
const handlers$1 = [];
let escDown;
function onKeydown(evt) {
  escDown = evt.keyCode === 27;
}
function onBlur() {
  if (escDown === true) {
    escDown = false;
  }
}
function onKeyup(evt) {
  if (escDown === true) {
    escDown = false;
    if (isKeyCode(evt, 27) === true) {
      handlers$1[handlers$1.length - 1](evt);
    }
  }
}
function update(action) {
  window[action]("keydown", onKeydown);
  window[action]("blur", onBlur);
  window[action]("keyup", onKeyup);
  escDown = false;
}
function addEscapeKey(fn) {
  if (client.is.desktop === true) {
    handlers$1.push(fn);
    if (handlers$1.length === 1) {
      update("addEventListener");
    }
  }
}
function removeEscapeKey(fn) {
  const index = handlers$1.indexOf(fn);
  if (index !== -1) {
    handlers$1.splice(index, 1);
    if (handlers$1.length === 0) {
      update("removeEventListener");
    }
  }
}
const handlers = [];
function trigger(e2) {
  handlers[handlers.length - 1](e2);
}
function addFocusout(fn) {
  if (client.is.desktop === true) {
    handlers.push(fn);
    if (handlers.length === 1) {
      document.body.addEventListener("focusin", trigger);
    }
  }
}
function removeFocusout(fn) {
  const index = handlers.indexOf(fn);
  if (index !== -1) {
    handlers.splice(index, 1);
    if (handlers.length === 0) {
      document.body.removeEventListener("focusin", trigger);
    }
  }
}
let maximizedModals = 0;
const positionClass = {
  standard: "fixed-full flex-center",
  top: "fixed-top justify-center",
  bottom: "fixed-bottom justify-center",
  right: "fixed-right items-center",
  left: "fixed-left items-center"
};
const defaultTransitions = {
  standard: ["scale", "scale"],
  top: ["slide-down", "slide-up"],
  bottom: ["slide-up", "slide-down"],
  right: ["slide-left", "slide-right"],
  left: ["slide-right", "slide-left"]
};
const QDialog = createComponent({
  name: "QDialog",
  inheritAttrs: false,
  props: {
    ...useModelToggleProps,
    ...useTransitionProps,
    transitionShow: String,
    // override useTransitionProps
    transitionHide: String,
    // override useTransitionProps
    persistent: Boolean,
    autoClose: Boolean,
    allowFocusOutside: Boolean,
    noEscDismiss: Boolean,
    noBackdropDismiss: Boolean,
    noRouteDismiss: Boolean,
    noRefocus: Boolean,
    noFocus: Boolean,
    noShake: Boolean,
    seamless: Boolean,
    maximized: Boolean,
    fullWidth: Boolean,
    fullHeight: Boolean,
    square: Boolean,
    backdropFilter: String,
    position: {
      type: String,
      default: "standard",
      validator: (val) => ["standard", "top", "bottom", "left", "right"].includes(val)
    }
  },
  emits: [
    ...useModelToggleEmits,
    "shake",
    "click",
    "escapeKey"
  ],
  setup(props2, { slots, emit: emit2, attrs }) {
    const vm2 = getCurrentInstance();
    const innerRef = ref(null);
    const showing = ref(false);
    const animating = ref(false);
    let shakeTimeout = null, refocusTarget = null, isMaximized, avoidAutoClose;
    const hideOnRouteChange = computed(
      () => props2.persistent !== true && props2.noRouteDismiss !== true && props2.seamless !== true
    );
    const { preventBodyScroll } = usePreventScroll();
    const { registerTimeout } = useTimeout();
    const { registerTick, removeTick } = useTick();
    const { transitionProps, transitionStyle } = useTransition(
      props2,
      () => defaultTransitions[props2.position][0],
      () => defaultTransitions[props2.position][1]
    );
    const backdropStyle = computed(() => transitionStyle.value + (props2.backdropFilter !== void 0 ? `;backdrop-filter:${props2.backdropFilter};-webkit-backdrop-filter:${props2.backdropFilter}` : ""));
    const { showPortal, hidePortal, portalIsAccessible, renderPortal } = usePortal(
      vm2,
      innerRef,
      renderPortalContent,
      "dialog"
    );
    const { hide } = useModelToggle({
      showing,
      hideOnRouteChange,
      handleShow,
      handleHide,
      processOnMount: true
    });
    const { addToHistory, removeFromHistory } = useHistory(showing, hide, hideOnRouteChange);
    const classes = computed(
      () => `q-dialog__inner flex no-pointer-events q-dialog__inner--${props2.maximized === true ? "maximized" : "minimized"} q-dialog__inner--${props2.position} ${positionClass[props2.position]}` + (animating.value === true ? " q-dialog__inner--animating" : "") + (props2.fullWidth === true ? " q-dialog__inner--fullwidth" : "") + (props2.fullHeight === true ? " q-dialog__inner--fullheight" : "") + (props2.square === true ? " q-dialog__inner--square" : "")
    );
    const useBackdrop = computed(() => showing.value === true && props2.seamless !== true);
    const onEvents = computed(() => props2.autoClose === true ? { onClick: onAutoClose } : {});
    const rootClasses = computed(() => [
      `q-dialog fullscreen no-pointer-events q-dialog--${useBackdrop.value === true ? "modal" : "seamless"}`,
      attrs.class
    ]);
    watch(() => props2.maximized, (state) => {
      showing.value === true && updateMaximized(state);
    });
    watch(useBackdrop, (val) => {
      preventBodyScroll(val);
      if (val === true) {
        addFocusout(onFocusChange);
        addEscapeKey(onEscapeKey);
      } else {
        removeFocusout(onFocusChange);
        removeEscapeKey(onEscapeKey);
      }
    });
    function handleShow(evt) {
      addToHistory();
      refocusTarget = props2.noRefocus === false && document.activeElement !== null ? document.activeElement : null;
      updateMaximized(props2.maximized);
      showPortal();
      animating.value = true;
      if (props2.noFocus !== true) {
        document.activeElement !== null && document.activeElement.blur();
        registerTick(focus);
      } else {
        removeTick();
      }
      registerTimeout(() => {
        if (vm2.proxy.$q.platform.is.ios === true) {
          if (props2.seamless !== true && document.activeElement) {
            const { top, bottom } = document.activeElement.getBoundingClientRect(), { innerHeight } = window, height = window.visualViewport !== void 0 ? window.visualViewport.height : innerHeight;
            if (top > 0 && bottom > height / 2) {
              document.scrollingElement.scrollTop = Math.min(
                document.scrollingElement.scrollHeight - height,
                bottom >= innerHeight ? Infinity : Math.ceil(document.scrollingElement.scrollTop + bottom - height / 2)
              );
            }
            document.activeElement.scrollIntoView();
          }
          avoidAutoClose = true;
          innerRef.value.click();
          avoidAutoClose = false;
        }
        showPortal(true);
        animating.value = false;
        emit2("show", evt);
      }, props2.transitionDuration);
    }
    function handleHide(evt) {
      removeTick();
      removeFromHistory();
      cleanup(true);
      animating.value = true;
      hidePortal();
      if (refocusTarget !== null) {
        ((evt && evt.type.indexOf("key") === 0 ? refocusTarget.closest('[tabindex]:not([tabindex^="-"])') : void 0) || refocusTarget).focus();
        refocusTarget = null;
      }
      registerTimeout(() => {
        hidePortal(true);
        animating.value = false;
        emit2("hide", evt);
      }, props2.transitionDuration);
    }
    function focus(selector) {
      addFocusFn(() => {
        let node = innerRef.value;
        if (node === null) return;
        if (selector !== void 0) {
          const target2 = node.querySelector(selector);
          if (target2 !== null) {
            target2.focus({ preventScroll: true });
            return;
          }
        }
        if (node.contains(document.activeElement) !== true) {
          node = node.querySelector("[autofocus][tabindex], [data-autofocus][tabindex]") || node.querySelector("[autofocus] [tabindex], [data-autofocus] [tabindex]") || node.querySelector("[autofocus], [data-autofocus]") || node;
          node.focus({ preventScroll: true });
        }
      });
    }
    function shake(focusTarget) {
      if (focusTarget && typeof focusTarget.focus === "function") {
        focusTarget.focus({ preventScroll: true });
      } else {
        focus();
      }
      emit2("shake");
      const node = innerRef.value;
      if (node !== null) {
        node.classList.remove("q-animate--scale");
        node.classList.add("q-animate--scale");
        shakeTimeout !== null && clearTimeout(shakeTimeout);
        shakeTimeout = setTimeout(() => {
          shakeTimeout = null;
          if (innerRef.value !== null) {
            node.classList.remove("q-animate--scale");
            focus();
          }
        }, 170);
      }
    }
    function onEscapeKey() {
      if (props2.seamless !== true) {
        if (props2.persistent === true || props2.noEscDismiss === true) {
          props2.maximized !== true && props2.noShake !== true && shake();
        } else {
          emit2("escapeKey");
          hide();
        }
      }
    }
    function cleanup(hiding) {
      if (shakeTimeout !== null) {
        clearTimeout(shakeTimeout);
        shakeTimeout = null;
      }
      if (hiding === true || showing.value === true) {
        updateMaximized(false);
        if (props2.seamless !== true) {
          preventBodyScroll(false);
          removeFocusout(onFocusChange);
          removeEscapeKey(onEscapeKey);
        }
      }
      if (hiding !== true) {
        refocusTarget = null;
      }
    }
    function updateMaximized(active) {
      if (active === true) {
        if (isMaximized !== true) {
          maximizedModals < 1 && document.body.classList.add("q-body--dialog");
          maximizedModals++;
          isMaximized = true;
        }
      } else if (isMaximized === true) {
        if (maximizedModals < 2) {
          document.body.classList.remove("q-body--dialog");
        }
        maximizedModals--;
        isMaximized = false;
      }
    }
    function onAutoClose(e2) {
      if (avoidAutoClose !== true) {
        hide(e2);
        emit2("click", e2);
      }
    }
    function onBackdropClick(e2) {
      if (props2.persistent !== true && props2.noBackdropDismiss !== true) {
        hide(e2);
      } else if (props2.noShake !== true) {
        shake();
      }
    }
    function onFocusChange(evt) {
      if (props2.allowFocusOutside !== true && portalIsAccessible.value === true && childHasFocus(innerRef.value, evt.target) !== true) {
        focus('[tabindex]:not([tabindex="-1"])');
      }
    }
    Object.assign(vm2.proxy, {
      // expose public methods
      focus,
      shake,
      // private but needed by QSelect
      __updateRefocusTarget(target2) {
        refocusTarget = target2 || null;
      }
    });
    onBeforeUnmount(cleanup);
    function renderPortalContent() {
      return h$1("div", {
        role: "dialog",
        "aria-modal": useBackdrop.value === true ? "true" : "false",
        ...attrs,
        class: rootClasses.value
      }, [
        h$1(Transition, {
          name: "q-transition--fade",
          appear: true
        }, () => useBackdrop.value === true ? h$1("div", {
          class: "q-dialog__backdrop fixed-full",
          style: backdropStyle.value,
          "aria-hidden": "true",
          tabindex: -1,
          onClick: onBackdropClick
        }) : null),
        h$1(
          Transition,
          transitionProps.value,
          () => showing.value === true ? h$1("div", {
            ref: innerRef,
            class: classes.value,
            style: transitionStyle.value,
            tabindex: -1,
            ...onEvents.value
          }, hSlot(slots.default)) : null
        )
      ]);
    }
    return renderPortal;
  }
});
const useDarkProps = {
  dark: {
    type: Boolean,
    default: null
  }
};
function useDark(props2, $q) {
  return computed(() => props2.dark === null ? $q.dark.isActive : props2.dark);
}
const QCard = createComponent({
  name: "QCard",
  props: {
    ...useDarkProps,
    tag: {
      type: String,
      default: "div"
    },
    square: Boolean,
    flat: Boolean,
    bordered: Boolean
  },
  setup(props2, { slots }) {
    const { proxy: { $q } } = getCurrentInstance();
    const isDark = useDark(props2, $q);
    const classes = computed(
      () => "q-card" + (isDark.value === true ? " q-card--dark q-dark" : "") + (props2.bordered === true ? " q-card--bordered" : "") + (props2.square === true ? " q-card--square no-border-radius" : "") + (props2.flat === true ? " q-card--flat no-shadow" : "")
    );
    return () => h$1(props2.tag, { class: classes.value }, hSlot(slots.default));
  }
});
const QCardSection = createComponent({
  name: "QCardSection",
  props: {
    tag: {
      type: String,
      default: "div"
    },
    horizontal: Boolean
  },
  setup(props2, { slots }) {
    const classes = computed(
      () => `q-card__section q-card__section--${props2.horizontal === true ? "horiz row no-wrap" : "vert"}`
    );
    return () => h$1(props2.tag, { class: classes.value }, hSlot(slots.default));
  }
});
const QCardActions = createComponent({
  name: "QCardActions",
  props: {
    ...useAlignProps,
    vertical: Boolean
  },
  setup(props2, { slots }) {
    const alignClass = useAlign(props2);
    const classes = computed(
      () => `q-card__actions ${alignClass.value} q-card__actions--${props2.vertical === true ? "vert column" : "horiz row"}`
    );
    return () => h$1("div", { class: classes.value }, hSlot(slots.default));
  }
});
const insetMap = {
  true: "inset",
  item: "item-inset",
  "item-thumbnail": "item-thumbnail-inset"
};
const margins = {
  xs: 2,
  sm: 4,
  md: 8,
  lg: 16,
  xl: 24
};
const QSeparator = createComponent({
  name: "QSeparator",
  props: {
    ...useDarkProps,
    spaced: [Boolean, String],
    inset: [Boolean, String],
    vertical: Boolean,
    color: String,
    size: String
  },
  setup(props2) {
    const vm2 = getCurrentInstance();
    const isDark = useDark(props2, vm2.proxy.$q);
    const orientation = computed(() => props2.vertical === true ? "vertical" : "horizontal");
    const orientClass = computed(() => ` q-separator--${orientation.value}`);
    const insetClass = computed(() => props2.inset !== false ? `${orientClass.value}-${insetMap[props2.inset]}` : "");
    const classes = computed(
      () => `q-separator${orientClass.value}${insetClass.value}` + (props2.color !== void 0 ? ` bg-${props2.color}` : "") + (isDark.value === true ? " q-separator--dark" : "")
    );
    const style = computed(() => {
      const acc = {};
      if (props2.size !== void 0) {
        acc[props2.vertical === true ? "width" : "height"] = props2.size;
      }
      if (props2.spaced !== false) {
        const size2 = props2.spaced === true ? `${margins.md}px` : props2.spaced in margins ? `${margins[props2.spaced]}px` : props2.spaced;
        const dir = props2.vertical === true ? ["Left", "Right"] : ["Top", "Bottom"];
        acc[`margin${dir[0]}`] = acc[`margin${dir[1]}`] = size2;
      }
      return acc;
    });
    return () => h$1("hr", {
      class: classes.value,
      style: style.value,
      "aria-orientation": orientation.value
    });
  }
});
let buf, bufIdx = 0;
const hexBytes = new Array(256);
for (let i = 0; i < 256; i++) {
  hexBytes[i] = (i + 256).toString(16).substring(1);
}
const randomBytes = (() => {
  const lib = typeof crypto !== "undefined" ? crypto : typeof window !== "undefined" ? window.crypto || window.msCrypto : void 0;
  if (lib !== void 0) {
    if (lib.randomBytes !== void 0) {
      return lib.randomBytes;
    }
    if (lib.getRandomValues !== void 0) {
      return (n2) => {
        const bytes = new Uint8Array(n2);
        lib.getRandomValues(bytes);
        return bytes;
      };
    }
  }
  return (n2) => {
    const r = [];
    for (let i = n2; i > 0; i--) {
      r.push(Math.floor(Math.random() * 256));
    }
    return r;
  };
})();
const BUFFER_SIZE = 4096;
function uid$2() {
  if (buf === void 0 || bufIdx + 16 > BUFFER_SIZE) {
    bufIdx = 0;
    buf = randomBytes(BUFFER_SIZE);
  }
  const b2 = Array.prototype.slice.call(buf, bufIdx, bufIdx += 16);
  b2[6] = b2[6] & 15 | 64;
  b2[8] = b2[8] & 63 | 128;
  return hexBytes[b2[0]] + hexBytes[b2[1]] + hexBytes[b2[2]] + hexBytes[b2[3]] + "-" + hexBytes[b2[4]] + hexBytes[b2[5]] + "-" + hexBytes[b2[6]] + hexBytes[b2[7]] + "-" + hexBytes[b2[8]] + hexBytes[b2[9]] + "-" + hexBytes[b2[10]] + hexBytes[b2[11]] + hexBytes[b2[12]] + hexBytes[b2[13]] + hexBytes[b2[14]] + hexBytes[b2[15]];
}
function parseValue(val) {
  return val === void 0 || val === null ? null : val;
}
function getId(val, required) {
  return val === void 0 || val === null ? required === true ? `f_${uid$2()}` : null : val;
}
function useId({ getValue, required = true } = {}) {
  if (isRuntimeSsrPreHydration.value === true) {
    const id2 = getValue !== void 0 ? ref(parseValue(getValue())) : ref(null);
    if (required === true && id2.value === null) {
      onMounted(() => {
        id2.value = `f_${uid$2()}`;
      });
    }
    if (getValue !== void 0) {
      watch(getValue, (newId) => {
        id2.value = getId(newId, required);
      });
    }
    return id2;
  }
  return getValue !== void 0 ? computed(() => getId(getValue(), required)) : ref(`f_${uid$2()}`);
}
const listenerRE = /^on[A-Z]/;
function useSplitAttrs() {
  const { attrs, vnode } = getCurrentInstance();
  const acc = {
    listeners: ref({}),
    attributes: ref({})
  };
  function update2() {
    const attributes = {};
    const listeners = {};
    for (const key in attrs) {
      if (key !== "class" && key !== "style" && listenerRE.test(key) === false) {
        attributes[key] = attrs[key];
      }
    }
    for (const key in vnode.props) {
      if (listenerRE.test(key) === true) {
        listeners[key] = vnode.props[key];
      }
    }
    acc.attributes.value = attributes;
    acc.listeners.value = listeners;
  }
  onBeforeUpdate(update2);
  update2();
  return acc;
}
function useFormChild({ validate, resetValidation, requiresQForm }) {
  const $form = inject(formKey, false);
  if ($form !== false) {
    const { props: props2, proxy } = getCurrentInstance();
    Object.assign(proxy, { validate, resetValidation });
    watch(() => props2.disable, (val) => {
      if (val === true) {
        typeof resetValidation === "function" && resetValidation();
        $form.unbindComponent(proxy);
      } else {
        $form.bindComponent(proxy);
      }
    });
    onMounted(() => {
      props2.disable !== true && $form.bindComponent(proxy);
    });
    onBeforeUnmount(() => {
      props2.disable !== true && $form.unbindComponent(proxy);
    });
  } else if (requiresQForm === true) {
    console.error("Parent QForm not found on useFormChild()!");
  }
}
const hex = /^#[0-9a-fA-F]{3}([0-9a-fA-F]{3})?$/, hexa = /^#[0-9a-fA-F]{4}([0-9a-fA-F]{4})?$/, hexOrHexa = /^#([0-9a-fA-F]{3}|[0-9a-fA-F]{4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/, rgb$1 = /^rgb\(((0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),){2}(0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5])\)$/, rgba = /^rgba\(((0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),){2}(0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),(0|0\.[0-9]+[1-9]|0\.[1-9]+|1)\)$/;
const testPattern = {
  date: (v2) => /^-?[\d]+\/[0-1]\d\/[0-3]\d$/.test(v2),
  time: (v2) => /^([0-1]?\d|2[0-3]):[0-5]\d$/.test(v2),
  fulltime: (v2) => /^([0-1]?\d|2[0-3]):[0-5]\d:[0-5]\d$/.test(v2),
  timeOrFulltime: (v2) => /^([0-1]?\d|2[0-3]):[0-5]\d(:[0-5]\d)?$/.test(v2),
  // -- RFC 5322 --
  // -- Added in v2.6.6 --
  // This is a basic helper validation.
  // For something more complex (like RFC 822) you should write and use your own rule.
  // We won't be accepting PRs to enhance the one below because of the reason above.
  // eslint-disable-next-line
  email: (v2) => /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(v2),
  hexColor: (v2) => hex.test(v2),
  hexaColor: (v2) => hexa.test(v2),
  hexOrHexaColor: (v2) => hexOrHexa.test(v2),
  rgbColor: (v2) => rgb$1.test(v2),
  rgbaColor: (v2) => rgba.test(v2),
  rgbOrRgbaColor: (v2) => rgb$1.test(v2) || rgba.test(v2),
  hexOrRgbColor: (v2) => hex.test(v2) || rgb$1.test(v2),
  hexaOrRgbaColor: (v2) => hexa.test(v2) || rgba.test(v2),
  anyColor: (v2) => hexOrHexa.test(v2) || rgb$1.test(v2) || rgba.test(v2)
};
const lazyRulesValues = [true, false, "ondemand"];
const useValidateProps = {
  modelValue: {},
  error: {
    type: Boolean,
    default: null
  },
  errorMessage: String,
  noErrorIcon: Boolean,
  rules: Array,
  reactiveRules: Boolean,
  lazyRules: {
    type: [Boolean, String],
    default: false,
    // statement unneeded but avoids future vue implementation changes
    validator: (v2) => lazyRulesValues.includes(v2)
  }
};
function useValidate(focused, innerLoading) {
  const { props: props2, proxy } = getCurrentInstance();
  const innerError = ref(false);
  const innerErrorMessage = ref(null);
  const isDirtyModel = ref(false);
  useFormChild({ validate, resetValidation });
  let validateIndex = 0, unwatchRules;
  const hasRules = computed(
    () => props2.rules !== void 0 && props2.rules !== null && props2.rules.length !== 0
  );
  const canDebounceValidate = computed(() => props2.disable !== true && hasRules.value === true && innerLoading.value === false);
  const hasError = computed(
    () => props2.error === true || innerError.value === true
  );
  const errorMessage = computed(() => typeof props2.errorMessage === "string" && props2.errorMessage.length !== 0 ? props2.errorMessage : innerErrorMessage.value);
  watch(() => props2.modelValue, () => {
    isDirtyModel.value = true;
    if (canDebounceValidate.value === true && props2.lazyRules === false) {
      debouncedValidate();
    }
  });
  function onRulesChange() {
    if (props2.lazyRules !== "ondemand" && canDebounceValidate.value === true && isDirtyModel.value === true) {
      debouncedValidate();
    }
  }
  watch(() => props2.reactiveRules, (val) => {
    if (val === true) {
      if (unwatchRules === void 0) {
        unwatchRules = watch(() => props2.rules, onRulesChange, { immediate: true, deep: true });
      }
    } else if (unwatchRules !== void 0) {
      unwatchRules();
      unwatchRules = void 0;
    }
  }, { immediate: true });
  watch(() => props2.lazyRules, onRulesChange);
  watch(focused, (val) => {
    if (val === true) {
      isDirtyModel.value = true;
    } else if (canDebounceValidate.value === true && props2.lazyRules !== "ondemand") {
      debouncedValidate();
    }
  });
  function resetValidation() {
    validateIndex++;
    innerLoading.value = false;
    isDirtyModel.value = false;
    innerError.value = false;
    innerErrorMessage.value = null;
    debouncedValidate.cancel();
  }
  function validate(val = props2.modelValue) {
    if (props2.disable === true || hasRules.value === false) {
      return true;
    }
    const index = ++validateIndex;
    const setDirty = innerLoading.value !== true ? () => {
      isDirtyModel.value = true;
    } : () => {
    };
    const update2 = (err, msg) => {
      err === true && setDirty();
      innerError.value = err;
      innerErrorMessage.value = msg || null;
      innerLoading.value = false;
    };
    const promises = [];
    for (let i = 0; i < props2.rules.length; i++) {
      const rule = props2.rules[i];
      let res;
      if (typeof rule === "function") {
        res = rule(val, testPattern);
      } else if (typeof rule === "string" && testPattern[rule] !== void 0) {
        res = testPattern[rule](val);
      }
      if (res === false || typeof res === "string") {
        update2(true, res);
        return false;
      } else if (res !== true && res !== void 0) {
        promises.push(res);
      }
    }
    if (promises.length === 0) {
      update2(false);
      return true;
    }
    innerLoading.value = true;
    return Promise.all(promises).then(
      (res) => {
        if (res === void 0 || Array.isArray(res) === false || res.length === 0) {
          index === validateIndex && update2(false);
          return true;
        }
        const msg = res.find((r) => r === false || typeof r === "string");
        index === validateIndex && update2(msg !== void 0, msg);
        return msg === void 0;
      },
      (e2) => {
        if (index === validateIndex) {
          console.error(e2);
          update2(true);
        }
        return false;
      }
    );
  }
  const debouncedValidate = debounce(validate, 0);
  onBeforeUnmount(() => {
    unwatchRules !== void 0 && unwatchRules();
    debouncedValidate.cancel();
  });
  Object.assign(proxy, { resetValidation, validate });
  injectProp(proxy, "hasError", () => hasError.value);
  return {
    isDirtyModel,
    hasRules,
    hasError,
    errorMessage,
    validate,
    resetValidation
  };
}
function fieldValueIsFilled(val) {
  return val !== void 0 && val !== null && ("" + val).length !== 0;
}
const useNonInputFieldProps = {
  ...useDarkProps,
  ...useValidateProps,
  label: String,
  stackLabel: Boolean,
  hint: String,
  hideHint: Boolean,
  prefix: String,
  suffix: String,
  labelColor: String,
  color: String,
  bgColor: String,
  filled: Boolean,
  outlined: Boolean,
  borderless: Boolean,
  standout: [Boolean, String],
  square: Boolean,
  loading: Boolean,
  labelSlot: Boolean,
  bottomSlots: Boolean,
  hideBottomSpace: Boolean,
  rounded: Boolean,
  dense: Boolean,
  itemAligned: Boolean,
  counter: Boolean,
  clearable: Boolean,
  clearIcon: String,
  disable: Boolean,
  readonly: Boolean,
  autofocus: Boolean,
  for: String
};
const useFieldProps = {
  ...useNonInputFieldProps,
  maxlength: [Number, String]
};
const useFieldEmits = ["update:modelValue", "clear", "focus", "blur"];
function useFieldState({ requiredForAttr = true, tagProp, changeEvent = false } = {}) {
  const { props: props2, proxy } = getCurrentInstance();
  const isDark = useDark(props2, proxy.$q);
  const targetUid = useId({
    required: requiredForAttr,
    getValue: () => props2.for
  });
  return {
    requiredForAttr,
    changeEvent,
    tag: tagProp === true ? computed(() => props2.tag) : { value: "label" },
    isDark,
    editable: computed(
      () => props2.disable !== true && props2.readonly !== true
    ),
    innerLoading: ref(false),
    focused: ref(false),
    hasPopupOpen: false,
    splitAttrs: useSplitAttrs(),
    targetUid,
    rootRef: ref(null),
    targetRef: ref(null),
    controlRef: ref(null)
    /**
         * user supplied additionals:
    
         * innerValue - computed
         * floatingLabel - computed
         * inputRef - computed
    
         * fieldClass - computed
         * hasShadow - computed
    
         * controlEvents - Object with fn(e)
    
         * getControl - fn
         * getInnerAppend - fn
         * getControlChild - fn
         * getShadowControl - fn
         * showPopup - fn
         */
  };
}
function useField(state) {
  const { props: props2, emit: emit2, slots, attrs, proxy } = getCurrentInstance();
  const { $q } = proxy;
  let focusoutTimer = null;
  if (state.hasValue === void 0) {
    state.hasValue = computed(() => fieldValueIsFilled(props2.modelValue));
  }
  if (state.emitValue === void 0) {
    state.emitValue = (value2) => {
      emit2("update:modelValue", value2);
    };
  }
  if (state.controlEvents === void 0) {
    state.controlEvents = {
      onFocusin: onControlFocusin,
      onFocusout: onControlFocusout
    };
  }
  Object.assign(state, {
    clearValue,
    onControlFocusin,
    onControlFocusout,
    focus
  });
  if (state.computedCounter === void 0) {
    state.computedCounter = computed(() => {
      if (props2.counter !== false) {
        const len = typeof props2.modelValue === "string" || typeof props2.modelValue === "number" ? ("" + props2.modelValue).length : Array.isArray(props2.modelValue) === true ? props2.modelValue.length : 0;
        const max2 = props2.maxlength !== void 0 ? props2.maxlength : props2.maxValues;
        return len + (max2 !== void 0 ? " / " + max2 : "");
      }
    });
  }
  const {
    isDirtyModel,
    hasRules,
    hasError,
    errorMessage,
    resetValidation
  } = useValidate(state.focused, state.innerLoading);
  const floatingLabel = state.floatingLabel !== void 0 ? computed(() => props2.stackLabel === true || state.focused.value === true || state.floatingLabel.value === true) : computed(() => props2.stackLabel === true || state.focused.value === true || state.hasValue.value === true);
  const shouldRenderBottom = computed(
    () => props2.bottomSlots === true || props2.hint !== void 0 || hasRules.value === true || props2.counter === true || props2.error !== null
  );
  const styleType = computed(() => {
    if (props2.filled === true) {
      return "filled";
    }
    if (props2.outlined === true) {
      return "outlined";
    }
    if (props2.borderless === true) {
      return "borderless";
    }
    if (props2.standout) {
      return "standout";
    }
    return "standard";
  });
  const classes = computed(
    () => `q-field row no-wrap items-start q-field--${styleType.value}` + (state.fieldClass !== void 0 ? ` ${state.fieldClass.value}` : "") + (props2.rounded === true ? " q-field--rounded" : "") + (props2.square === true ? " q-field--square" : "") + (floatingLabel.value === true ? " q-field--float" : "") + (hasLabel.value === true ? " q-field--labeled" : "") + (props2.dense === true ? " q-field--dense" : "") + (props2.itemAligned === true ? " q-field--item-aligned q-item-type" : "") + (state.isDark.value === true ? " q-field--dark" : "") + (state.getControl === void 0 ? " q-field--auto-height" : "") + (state.focused.value === true ? " q-field--focused" : "") + (hasError.value === true ? " q-field--error" : "") + (hasError.value === true || state.focused.value === true ? " q-field--highlighted" : "") + (props2.hideBottomSpace !== true && shouldRenderBottom.value === true ? " q-field--with-bottom" : "") + (props2.disable === true ? " q-field--disabled" : props2.readonly === true ? " q-field--readonly" : "")
  );
  const contentClass = computed(
    () => "q-field__control relative-position row no-wrap" + (props2.bgColor !== void 0 ? ` bg-${props2.bgColor}` : "") + (hasError.value === true ? " text-negative" : typeof props2.standout === "string" && props2.standout.length !== 0 && state.focused.value === true ? ` ${props2.standout}` : props2.color !== void 0 ? ` text-${props2.color}` : "")
  );
  const hasLabel = computed(
    () => props2.labelSlot === true || props2.label !== void 0
  );
  const labelClass = computed(
    () => "q-field__label no-pointer-events absolute ellipsis" + (props2.labelColor !== void 0 && hasError.value !== true ? ` text-${props2.labelColor}` : "")
  );
  const controlSlotScope = computed(() => ({
    id: state.targetUid.value,
    editable: state.editable.value,
    focused: state.focused.value,
    floatingLabel: floatingLabel.value,
    modelValue: props2.modelValue,
    emitValue: state.emitValue
  }));
  const attributes = computed(() => {
    const acc = {};
    if (state.targetUid.value) {
      acc.for = state.targetUid.value;
    }
    if (props2.disable === true) {
      acc["aria-disabled"] = "true";
    }
    return acc;
  });
  function focusHandler() {
    const el = document.activeElement;
    let target2 = state.targetRef !== void 0 && state.targetRef.value;
    if (target2 && (el === null || el.id !== state.targetUid.value)) {
      target2.hasAttribute("tabindex") === true || (target2 = target2.querySelector("[tabindex]"));
      if (target2 && target2 !== el) {
        target2.focus({ preventScroll: true });
      }
    }
  }
  function focus() {
    addFocusFn(focusHandler);
  }
  function blur() {
    removeFocusFn(focusHandler);
    const el = document.activeElement;
    if (el !== null && state.rootRef.value.contains(el)) {
      el.blur();
    }
  }
  function onControlFocusin(e2) {
    if (focusoutTimer !== null) {
      clearTimeout(focusoutTimer);
      focusoutTimer = null;
    }
    if (state.editable.value === true && state.focused.value === false) {
      state.focused.value = true;
      emit2("focus", e2);
    }
  }
  function onControlFocusout(e2, then) {
    focusoutTimer !== null && clearTimeout(focusoutTimer);
    focusoutTimer = setTimeout(() => {
      focusoutTimer = null;
      if (document.hasFocus() === true && (state.hasPopupOpen === true || state.controlRef === void 0 || state.controlRef.value === null || state.controlRef.value.contains(document.activeElement) !== false)) {
        return;
      }
      if (state.focused.value === true) {
        state.focused.value = false;
        emit2("blur", e2);
      }
      then !== void 0 && then();
    });
  }
  function clearValue(e2) {
    stopAndPrevent(e2);
    if ($q.platform.is.mobile !== true) {
      const el = state.targetRef !== void 0 && state.targetRef.value || state.rootRef.value;
      el.focus();
    } else if (state.rootRef.value.contains(document.activeElement) === true) {
      document.activeElement.blur();
    }
    if (props2.type === "file") {
      state.inputRef.value.value = null;
    }
    emit2("update:modelValue", null);
    state.changeEvent === true && emit2("change", null);
    emit2("clear", props2.modelValue);
    nextTick$1(() => {
      const isDirty = isDirtyModel.value;
      resetValidation();
      isDirtyModel.value = isDirty;
    });
  }
  function onClearableKeyup(evt) {
    [13, 32].includes(evt.keyCode) && clearValue(evt);
  }
  function getContent() {
    const node = [];
    slots.prepend !== void 0 && node.push(
      h$1("div", {
        class: "q-field__prepend q-field__marginal row no-wrap items-center",
        key: "prepend",
        onClick: prevent
      }, slots.prepend())
    );
    node.push(
      h$1("div", {
        class: "q-field__control-container col relative-position row no-wrap q-anchor--skip"
      }, getControlContainer())
    );
    hasError.value === true && props2.noErrorIcon === false && node.push(
      getInnerAppendNode("error", [
        h$1(QIcon, { name: $q.iconSet.field.error, color: "negative" })
      ])
    );
    if (props2.loading === true || state.innerLoading.value === true) {
      node.push(
        getInnerAppendNode(
          "inner-loading-append",
          slots.loading !== void 0 ? slots.loading() : [h$1(QSpinner, { color: props2.color })]
        )
      );
    } else if (props2.clearable === true && state.hasValue.value === true && state.editable.value === true) {
      node.push(
        getInnerAppendNode("inner-clearable-append", [
          h$1(QIcon, {
            class: "q-field__focusable-action",
            name: props2.clearIcon || $q.iconSet.field.clear,
            tabindex: 0,
            role: "button",
            "aria-label": $q.lang.label.clear,
            onKeyup: onClearableKeyup,
            onClick: clearValue
          })
        ])
      );
    }
    slots.append !== void 0 && node.push(
      h$1("div", {
        class: "q-field__append q-field__marginal row no-wrap items-center",
        key: "append",
        onClick: prevent
      }, slots.append())
    );
    state.getInnerAppend !== void 0 && node.push(
      getInnerAppendNode("inner-append", state.getInnerAppend())
    );
    state.getControlChild !== void 0 && node.push(
      state.getControlChild()
    );
    return node;
  }
  function getControlContainer() {
    const node = [];
    props2.prefix !== void 0 && props2.prefix !== null && node.push(
      h$1("div", {
        class: "q-field__prefix no-pointer-events row items-center"
      }, props2.prefix)
    );
    if (state.getShadowControl !== void 0 && state.hasShadow.value === true) {
      node.push(
        state.getShadowControl()
      );
    }
    if (state.getControl !== void 0) {
      node.push(state.getControl());
    } else if (slots.rawControl !== void 0) {
      node.push(slots.rawControl());
    } else if (slots.control !== void 0) {
      node.push(
        h$1("div", {
          ref: state.targetRef,
          class: "q-field__native row",
          tabindex: -1,
          ...state.splitAttrs.attributes.value,
          "data-autofocus": props2.autofocus === true || void 0
        }, slots.control(controlSlotScope.value))
      );
    }
    hasLabel.value === true && node.push(
      h$1("div", {
        class: labelClass.value
      }, hSlot(slots.label, props2.label))
    );
    props2.suffix !== void 0 && props2.suffix !== null && node.push(
      h$1("div", {
        class: "q-field__suffix no-pointer-events row items-center"
      }, props2.suffix)
    );
    return node.concat(hSlot(slots.default));
  }
  function getBottom() {
    let msg, key;
    if (hasError.value === true) {
      if (errorMessage.value !== null) {
        msg = [h$1("div", { role: "alert" }, errorMessage.value)];
        key = `q--slot-error-${errorMessage.value}`;
      } else {
        msg = hSlot(slots.error);
        key = "q--slot-error";
      }
    } else if (props2.hideHint !== true || state.focused.value === true) {
      if (props2.hint !== void 0) {
        msg = [h$1("div", props2.hint)];
        key = `q--slot-hint-${props2.hint}`;
      } else {
        msg = hSlot(slots.hint);
        key = "q--slot-hint";
      }
    }
    const hasCounter = props2.counter === true || slots.counter !== void 0;
    if (props2.hideBottomSpace === true && hasCounter === false && msg === void 0) {
      return;
    }
    const main = h$1("div", {
      key,
      class: "q-field__messages col"
    }, msg);
    return h$1("div", {
      class: "q-field__bottom row items-start q-field__bottom--" + (props2.hideBottomSpace !== true ? "animated" : "stale"),
      onClick: prevent
    }, [
      props2.hideBottomSpace === true ? main : h$1(Transition, { name: "q-transition--field-message" }, () => main),
      hasCounter === true ? h$1("div", {
        class: "q-field__counter"
      }, slots.counter !== void 0 ? slots.counter() : state.computedCounter.value) : null
    ]);
  }
  function getInnerAppendNode(key, content2) {
    return content2 === null ? null : h$1("div", {
      key,
      class: "q-field__append q-field__marginal row no-wrap items-center q-anchor--skip"
    }, content2);
  }
  let shouldActivate = false;
  onDeactivated(() => {
    shouldActivate = true;
  });
  onActivated(() => {
    shouldActivate === true && props2.autofocus === true && proxy.focus();
  });
  props2.autofocus === true && onMounted(() => {
    proxy.focus();
  });
  onBeforeUnmount(() => {
    focusoutTimer !== null && clearTimeout(focusoutTimer);
  });
  Object.assign(proxy, { focus, blur });
  return function renderField() {
    const labelAttrs = state.getControl === void 0 && slots.control === void 0 ? {
      ...state.splitAttrs.attributes.value,
      "data-autofocus": props2.autofocus === true || void 0,
      ...attributes.value
    } : attributes.value;
    return h$1(state.tag.value, {
      ref: state.rootRef,
      class: [
        classes.value,
        attrs.class
      ],
      style: attrs.style,
      ...labelAttrs
    }, [
      slots.before !== void 0 ? h$1("div", {
        class: "q-field__before q-field__marginal row no-wrap items-center",
        onClick: prevent
      }, slots.before()) : null,
      h$1("div", {
        class: "q-field__inner relative-position col self-stretch"
      }, [
        h$1("div", {
          ref: state.controlRef,
          class: contentClass.value,
          tabindex: -1,
          ...state.controlEvents
        }, getContent()),
        shouldRenderBottom.value === true ? getBottom() : null
      ]),
      slots.after !== void 0 ? h$1("div", {
        class: "q-field__after q-field__marginal row no-wrap items-center",
        onClick: prevent
      }, slots.after()) : null
    ]);
  };
}
const NAMED_MASKS = {
  date: "####/##/##",
  datetime: "####/##/## ##:##",
  time: "##:##",
  fulltime: "##:##:##",
  phone: "(###) ### - ####",
  card: "#### #### #### ####"
};
const TOKENS = {
  "#": { pattern: "[\\d]", negate: "[^\\d]" },
  S: { pattern: "[a-zA-Z]", negate: "[^a-zA-Z]" },
  N: { pattern: "[0-9a-zA-Z]", negate: "[^0-9a-zA-Z]" },
  A: { pattern: "[a-zA-Z]", negate: "[^a-zA-Z]", transform: (v2) => v2.toLocaleUpperCase() },
  a: { pattern: "[a-zA-Z]", negate: "[^a-zA-Z]", transform: (v2) => v2.toLocaleLowerCase() },
  X: { pattern: "[0-9a-zA-Z]", negate: "[^0-9a-zA-Z]", transform: (v2) => v2.toLocaleUpperCase() },
  x: { pattern: "[0-9a-zA-Z]", negate: "[^0-9a-zA-Z]", transform: (v2) => v2.toLocaleLowerCase() }
};
const KEYS = Object.keys(TOKENS);
KEYS.forEach((key) => {
  TOKENS[key].regex = new RegExp(TOKENS[key].pattern);
});
const tokenRegexMask = new RegExp("\\\\([^.*+?^${}()|([\\]])|([.*+?^${}()|[\\]])|([" + KEYS.join("") + "])|(.)", "g"), escRegex = /[.*+?^${}()|[\]\\]/g;
const MARKER = String.fromCharCode(1);
const useMaskProps = {
  mask: String,
  reverseFillMask: Boolean,
  fillMask: [Boolean, String],
  unmaskedValue: Boolean
};
function useMask(props2, emit2, emitValue, inputRef) {
  let maskMarked, maskReplaced, computedMask, computedUnmask, pastedTextStart, selectionAnchor;
  const hasMask = ref(null);
  const innerValue = ref(getInitialMaskedValue());
  function getIsTypeText() {
    return props2.autogrow === true || ["textarea", "text", "search", "url", "tel", "password"].includes(props2.type);
  }
  watch(() => props2.type + props2.autogrow, updateMaskInternals);
  watch(() => props2.mask, (v2) => {
    if (v2 !== void 0) {
      updateMaskValue(innerValue.value, true);
    } else {
      const val = unmaskValue(innerValue.value);
      updateMaskInternals();
      props2.modelValue !== val && emit2("update:modelValue", val);
    }
  });
  watch(() => props2.fillMask + props2.reverseFillMask, () => {
    hasMask.value === true && updateMaskValue(innerValue.value, true);
  });
  watch(() => props2.unmaskedValue, () => {
    hasMask.value === true && updateMaskValue(innerValue.value);
  });
  function getInitialMaskedValue() {
    updateMaskInternals();
    if (hasMask.value === true) {
      const masked = maskValue(unmaskValue(props2.modelValue));
      return props2.fillMask !== false ? fillWithMask(masked) : masked;
    }
    return props2.modelValue;
  }
  function getPaddedMaskMarked(size2) {
    if (size2 < maskMarked.length) {
      return maskMarked.slice(-size2);
    }
    let pad2 = "", localMaskMarked = maskMarked;
    const padPos = localMaskMarked.indexOf(MARKER);
    if (padPos !== -1) {
      for (let i = size2 - localMaskMarked.length; i > 0; i--) {
        pad2 += MARKER;
      }
      localMaskMarked = localMaskMarked.slice(0, padPos) + pad2 + localMaskMarked.slice(padPos);
    }
    return localMaskMarked;
  }
  function updateMaskInternals() {
    hasMask.value = props2.mask !== void 0 && props2.mask.length !== 0 && getIsTypeText();
    if (hasMask.value === false) {
      computedUnmask = void 0;
      maskMarked = "";
      maskReplaced = "";
      return;
    }
    const localComputedMask = NAMED_MASKS[props2.mask] === void 0 ? props2.mask : NAMED_MASKS[props2.mask], fillChar = typeof props2.fillMask === "string" && props2.fillMask.length !== 0 ? props2.fillMask.slice(0, 1) : "_", fillCharEscaped = fillChar.replace(escRegex, "\\$&"), unmask = [], extract = [], mask = [];
    let firstMatch = props2.reverseFillMask === true, unmaskChar = "", negateChar = "";
    localComputedMask.replace(tokenRegexMask, (_2, char1, esc, token2, char2) => {
      if (token2 !== void 0) {
        const c2 = TOKENS[token2];
        mask.push(c2);
        negateChar = c2.negate;
        if (firstMatch === true) {
          extract.push("(?:" + negateChar + "+)?(" + c2.pattern + "+)?(?:" + negateChar + "+)?(" + c2.pattern + "+)?");
          firstMatch = false;
        }
        extract.push("(?:" + negateChar + "+)?(" + c2.pattern + ")?");
      } else if (esc !== void 0) {
        unmaskChar = "\\" + (esc === "\\" ? "" : esc);
        mask.push(esc);
        unmask.push("([^" + unmaskChar + "]+)?" + unmaskChar + "?");
      } else {
        const c2 = char1 !== void 0 ? char1 : char2;
        unmaskChar = c2 === "\\" ? "\\\\\\\\" : c2.replace(escRegex, "\\\\$&");
        mask.push(c2);
        unmask.push("([^" + unmaskChar + "]+)?" + unmaskChar + "?");
      }
    });
    const unmaskMatcher = new RegExp(
      "^" + unmask.join("") + "(" + (unmaskChar === "" ? "." : "[^" + unmaskChar + "]") + "+)?" + (unmaskChar === "" ? "" : "[" + unmaskChar + "]*") + "$"
    ), extractLast = extract.length - 1, extractMatcher = extract.map((re2, index) => {
      if (index === 0 && props2.reverseFillMask === true) {
        return new RegExp("^" + fillCharEscaped + "*" + re2);
      } else if (index === extractLast) {
        return new RegExp(
          "^" + re2 + "(" + (negateChar === "" ? "." : negateChar) + "+)?" + (props2.reverseFillMask === true ? "$" : fillCharEscaped + "*")
        );
      }
      return new RegExp("^" + re2);
    });
    computedMask = mask;
    computedUnmask = (val) => {
      const unmaskMatch = unmaskMatcher.exec(props2.reverseFillMask === true ? val : val.slice(0, mask.length + 1));
      if (unmaskMatch !== null) {
        val = unmaskMatch.slice(1).join("");
      }
      const extractMatch = [], extractMatcherLength = extractMatcher.length;
      for (let i = 0, str = val; i < extractMatcherLength; i++) {
        const m2 = extractMatcher[i].exec(str);
        if (m2 === null) {
          break;
        }
        str = str.slice(m2.shift().length);
        extractMatch.push(...m2);
      }
      if (extractMatch.length !== 0) {
        return extractMatch.join("");
      }
      return val;
    };
    maskMarked = mask.map((v2) => typeof v2 === "string" ? v2 : MARKER).join("");
    maskReplaced = maskMarked.split(MARKER).join(fillChar);
  }
  function updateMaskValue(rawVal, updateMaskInternalsFlag, inputType) {
    const inp = inputRef.value, end = inp.selectionEnd, endReverse = inp.value.length - end, unmasked = unmaskValue(rawVal);
    updateMaskInternalsFlag === true && updateMaskInternals();
    const preMasked = maskValue(unmasked), masked = props2.fillMask !== false ? fillWithMask(preMasked) : preMasked, changed = innerValue.value !== masked;
    inp.value !== masked && (inp.value = masked);
    changed === true && (innerValue.value = masked);
    document.activeElement === inp && nextTick$1(() => {
      if (masked === maskReplaced) {
        const cursor = props2.reverseFillMask === true ? maskReplaced.length : 0;
        inp.setSelectionRange(cursor, cursor, "forward");
        return;
      }
      if (inputType === "insertFromPaste" && props2.reverseFillMask !== true) {
        const maxEnd = inp.selectionEnd;
        let cursor = end - 1;
        for (let i = pastedTextStart; i <= cursor && i < maxEnd; i++) {
          if (maskMarked[i] !== MARKER) {
            cursor++;
          }
        }
        moveCursor.right(inp, cursor);
        return;
      }
      if (["deleteContentBackward", "deleteContentForward"].indexOf(inputType) !== -1) {
        const cursor = props2.reverseFillMask === true ? end === 0 ? masked.length > preMasked.length ? 1 : 0 : Math.max(0, masked.length - (masked === maskReplaced ? 0 : Math.min(preMasked.length, endReverse) + 1)) + 1 : end;
        inp.setSelectionRange(cursor, cursor, "forward");
        return;
      }
      if (props2.reverseFillMask === true) {
        if (changed === true) {
          const cursor = Math.max(0, masked.length - (masked === maskReplaced ? 0 : Math.min(preMasked.length, endReverse + 1)));
          if (cursor === 1 && end === 1) {
            inp.setSelectionRange(cursor, cursor, "forward");
          } else {
            moveCursor.rightReverse(inp, cursor);
          }
        } else {
          const cursor = masked.length - endReverse;
          inp.setSelectionRange(cursor, cursor, "backward");
        }
      } else {
        if (changed === true) {
          const cursor = Math.max(0, maskMarked.indexOf(MARKER), Math.min(preMasked.length, end) - 1);
          moveCursor.right(inp, cursor);
        } else {
          const cursor = end - 1;
          moveCursor.right(inp, cursor);
        }
      }
    });
    const val = props2.unmaskedValue === true ? unmaskValue(masked) : masked;
    if (String(props2.modelValue) !== val && (props2.modelValue !== null || val !== "")) {
      emitValue(val, true);
    }
  }
  function moveCursorForPaste(inp, start, end) {
    const preMasked = maskValue(unmaskValue(inp.value));
    start = Math.max(0, maskMarked.indexOf(MARKER), Math.min(preMasked.length, start));
    pastedTextStart = start;
    inp.setSelectionRange(start, end, "forward");
  }
  const moveCursor = {
    left(inp, cursor) {
      const noMarkBefore = maskMarked.slice(cursor - 1).indexOf(MARKER) === -1;
      let i = Math.max(0, cursor - 1);
      for (; i >= 0; i--) {
        if (maskMarked[i] === MARKER) {
          cursor = i;
          noMarkBefore === true && cursor++;
          break;
        }
      }
      if (i < 0 && maskMarked[cursor] !== void 0 && maskMarked[cursor] !== MARKER) {
        return moveCursor.right(inp, 0);
      }
      cursor >= 0 && inp.setSelectionRange(cursor, cursor, "backward");
    },
    right(inp, cursor) {
      const limit = inp.value.length;
      let i = Math.min(limit, cursor + 1);
      for (; i <= limit; i++) {
        if (maskMarked[i] === MARKER) {
          cursor = i;
          break;
        } else if (maskMarked[i - 1] === MARKER) {
          cursor = i;
        }
      }
      if (i > limit && maskMarked[cursor - 1] !== void 0 && maskMarked[cursor - 1] !== MARKER) {
        return moveCursor.left(inp, limit);
      }
      inp.setSelectionRange(cursor, cursor, "forward");
    },
    leftReverse(inp, cursor) {
      const localMaskMarked = getPaddedMaskMarked(inp.value.length);
      let i = Math.max(0, cursor - 1);
      for (; i >= 0; i--) {
        if (localMaskMarked[i - 1] === MARKER) {
          cursor = i;
          break;
        } else if (localMaskMarked[i] === MARKER) {
          cursor = i;
          if (i === 0) {
            break;
          }
        }
      }
      if (i < 0 && localMaskMarked[cursor] !== void 0 && localMaskMarked[cursor] !== MARKER) {
        return moveCursor.rightReverse(inp, 0);
      }
      cursor >= 0 && inp.setSelectionRange(cursor, cursor, "backward");
    },
    rightReverse(inp, cursor) {
      const limit = inp.value.length, localMaskMarked = getPaddedMaskMarked(limit), noMarkBefore = localMaskMarked.slice(0, cursor + 1).indexOf(MARKER) === -1;
      let i = Math.min(limit, cursor + 1);
      for (; i <= limit; i++) {
        if (localMaskMarked[i - 1] === MARKER) {
          cursor = i;
          cursor > 0 && noMarkBefore === true && cursor--;
          break;
        }
      }
      if (i > limit && localMaskMarked[cursor - 1] !== void 0 && localMaskMarked[cursor - 1] !== MARKER) {
        return moveCursor.leftReverse(inp, limit);
      }
      inp.setSelectionRange(cursor, cursor, "forward");
    }
  };
  function onMaskedClick(e2) {
    emit2("click", e2);
    selectionAnchor = void 0;
  }
  function onMaskedKeydown(e2) {
    emit2("keydown", e2);
    if (shouldIgnoreKey(e2) === true || e2.altKey === true) {
      return;
    }
    const inp = inputRef.value, start = inp.selectionStart, end = inp.selectionEnd;
    if (!e2.shiftKey) {
      selectionAnchor = void 0;
    }
    if (e2.keyCode === 37 || e2.keyCode === 39) {
      if (e2.shiftKey && selectionAnchor === void 0) {
        selectionAnchor = inp.selectionDirection === "forward" ? start : end;
      }
      const fn = moveCursor[(e2.keyCode === 39 ? "right" : "left") + (props2.reverseFillMask === true ? "Reverse" : "")];
      e2.preventDefault();
      fn(inp, selectionAnchor === start ? end : start);
      if (e2.shiftKey) {
        const cursor = inp.selectionStart;
        inp.setSelectionRange(Math.min(selectionAnchor, cursor), Math.max(selectionAnchor, cursor), "forward");
      }
    } else if (e2.keyCode === 8 && props2.reverseFillMask !== true && start === end) {
      moveCursor.left(inp, start);
      inp.setSelectionRange(inp.selectionStart, end, "backward");
    } else if (e2.keyCode === 46 && props2.reverseFillMask === true && start === end) {
      moveCursor.rightReverse(inp, end);
      inp.setSelectionRange(start, inp.selectionEnd, "forward");
    }
  }
  function maskValue(val) {
    if (val === void 0 || val === null || val === "") {
      return "";
    }
    if (props2.reverseFillMask === true) {
      return maskValueReverse(val);
    }
    const mask = computedMask;
    let valIndex = 0, output = "";
    for (let maskIndex = 0; maskIndex < mask.length; maskIndex++) {
      const valChar = val[valIndex], maskDef = mask[maskIndex];
      if (typeof maskDef === "string") {
        output += maskDef;
        valChar === maskDef && valIndex++;
      } else if (valChar !== void 0 && maskDef.regex.test(valChar)) {
        output += maskDef.transform !== void 0 ? maskDef.transform(valChar) : valChar;
        valIndex++;
      } else {
        return output;
      }
    }
    return output;
  }
  function maskValueReverse(val) {
    const mask = computedMask, firstTokenIndex = maskMarked.indexOf(MARKER);
    let valIndex = val.length - 1, output = "";
    for (let maskIndex = mask.length - 1; maskIndex >= 0 && valIndex !== -1; maskIndex--) {
      const maskDef = mask[maskIndex];
      let valChar = val[valIndex];
      if (typeof maskDef === "string") {
        output = maskDef + output;
        valChar === maskDef && valIndex--;
      } else if (valChar !== void 0 && maskDef.regex.test(valChar)) {
        do {
          output = (maskDef.transform !== void 0 ? maskDef.transform(valChar) : valChar) + output;
          valIndex--;
          valChar = val[valIndex];
        } while (firstTokenIndex === maskIndex && valChar !== void 0 && maskDef.regex.test(valChar));
      } else {
        return output;
      }
    }
    return output;
  }
  function unmaskValue(val) {
    return typeof val !== "string" || computedUnmask === void 0 ? typeof val === "number" ? computedUnmask("" + val) : val : computedUnmask(val);
  }
  function fillWithMask(val) {
    if (maskReplaced.length - val.length <= 0) {
      return val;
    }
    return props2.reverseFillMask === true && val.length !== 0 ? maskReplaced.slice(0, -val.length) + val : val + maskReplaced.slice(val.length);
  }
  return {
    innerValue,
    hasMask,
    moveCursorForPaste,
    updateMaskValue,
    onMaskedKeydown,
    onMaskedClick
  };
}
const useFormProps = {
  name: String
};
function useFormAttrs(props2) {
  return computed(() => ({
    type: "hidden",
    name: props2.name,
    value: props2.modelValue
  }));
}
function useFormInject(formAttrs = {}) {
  return (child, action, className) => {
    child[action](
      h$1("input", {
        class: "hidden" + (className || ""),
        ...formAttrs.value
      })
    );
  };
}
function useFormInputNameAttr(props2) {
  return computed(() => props2.name || props2.for);
}
function useFileFormDomProps(props2, typeGuard) {
  function getFormDomProps() {
    const model = props2.modelValue;
    try {
      const dt2 = "DataTransfer" in window ? new DataTransfer() : "ClipboardEvent" in window ? new ClipboardEvent("").clipboardData : void 0;
      if (Object(model) === model) {
        ("length" in model ? Array.from(model) : [model]).forEach((file) => {
          dt2.items.add(file);
        });
      }
      return {
        files: dt2.files
      };
    } catch (e2) {
      return {
        files: void 0
      };
    }
  }
  return computed(() => {
    if (props2.type !== "file") {
      return;
    }
    return getFormDomProps();
  });
}
const isJapanese = /[\u3000-\u303f\u3040-\u309f\u30a0-\u30ff\uff00-\uff9f\u4e00-\u9faf\u3400-\u4dbf]/;
const isChinese = /[\u4e00-\u9fff\u3400-\u4dbf\u{20000}-\u{2a6df}\u{2a700}-\u{2b73f}\u{2b740}-\u{2b81f}\u{2b820}-\u{2ceaf}\uf900-\ufaff\u3300-\u33ff\ufe30-\ufe4f\uf900-\ufaff\u{2f800}-\u{2fa1f}]/u;
const isKorean = /[\u3131-\u314e\u314f-\u3163\uac00-\ud7a3]/;
const isPlainText = /[a-z0-9_ -]$/i;
function useKeyComposition(onInput) {
  return function onComposition(e2) {
    if (e2.type === "compositionend" || e2.type === "change") {
      if (e2.target.qComposing !== true) return;
      e2.target.qComposing = false;
      onInput(e2);
    } else if (e2.type === "compositionupdate" && e2.target.qComposing !== true && typeof e2.data === "string") {
      const isComposing = client.is.firefox === true ? isPlainText.test(e2.data) === false : isJapanese.test(e2.data) === true || isChinese.test(e2.data) === true || isKorean.test(e2.data) === true;
      if (isComposing === true) {
        e2.target.qComposing = true;
      }
    }
  };
}
const QInput = createComponent({
  name: "QInput",
  inheritAttrs: false,
  props: {
    ...useFieldProps,
    ...useMaskProps,
    ...useFormProps,
    // override of useFieldProps > modelValue
    modelValue: [String, Number, FileList],
    shadowText: String,
    type: {
      type: String,
      default: "text"
    },
    debounce: [String, Number],
    autogrow: Boolean,
    // makes a textarea
    inputClass: [Array, String, Object],
    inputStyle: [Array, String, Object]
  },
  emits: [
    ...useFieldEmits,
    "paste",
    "change",
    "keydown",
    "click",
    "animationend"
  ],
  setup(props2, { emit: emit2, attrs }) {
    const { proxy } = getCurrentInstance();
    const { $q } = proxy;
    const temp = {};
    let emitCachedValue = NaN, typedNumber, stopValueWatcher, emitTimer = null, emitValueFn;
    const inputRef = ref(null);
    const nameProp = useFormInputNameAttr(props2);
    const {
      innerValue,
      hasMask,
      moveCursorForPaste,
      updateMaskValue,
      onMaskedKeydown,
      onMaskedClick
    } = useMask(props2, emit2, emitValue, inputRef);
    const formDomProps = useFileFormDomProps(
      props2
    );
    const hasValue = computed(() => fieldValueIsFilled(innerValue.value));
    const onComposition = useKeyComposition(onInput);
    const state = useFieldState({ changeEvent: true });
    const isTextarea = computed(
      () => props2.type === "textarea" || props2.autogrow === true
    );
    const isTypeText = computed(
      () => isTextarea.value === true || ["text", "search", "url", "tel", "password"].includes(props2.type)
    );
    const onEvents = computed(() => {
      const evt = {
        ...state.splitAttrs.listeners.value,
        onInput,
        onPaste,
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        onChange,
        onBlur: onFinishEditing,
        onFocus: stop
      };
      evt.onCompositionstart = evt.onCompositionupdate = evt.onCompositionend = onComposition;
      if (hasMask.value === true) {
        evt.onKeydown = onMaskedKeydown;
        evt.onClick = onMaskedClick;
      }
      if (props2.autogrow === true) {
        evt.onAnimationend = onAnimationend;
      }
      return evt;
    });
    const inputAttrs = computed(() => {
      const attrs2 = {
        tabindex: 0,
        "data-autofocus": props2.autofocus === true || void 0,
        rows: props2.type === "textarea" ? 6 : void 0,
        "aria-label": props2.label,
        name: nameProp.value,
        ...state.splitAttrs.attributes.value,
        id: state.targetUid.value,
        maxlength: props2.maxlength,
        disabled: props2.disable === true,
        readonly: props2.readonly === true
      };
      if (isTextarea.value === false) {
        attrs2.type = props2.type;
      }
      if (props2.autogrow === true) {
        attrs2.rows = 1;
      }
      return attrs2;
    });
    watch(() => props2.type, () => {
      if (inputRef.value) {
        inputRef.value.value = props2.modelValue;
      }
    });
    watch(() => props2.modelValue, (v2) => {
      if (hasMask.value === true) {
        if (stopValueWatcher === true) {
          stopValueWatcher = false;
          if (String(v2) === emitCachedValue) {
            return;
          }
        }
        updateMaskValue(v2);
      } else if (innerValue.value !== v2) {
        innerValue.value = v2;
        if (props2.type === "number" && temp.hasOwnProperty("value") === true) {
          if (typedNumber === true) {
            typedNumber = false;
          } else {
            delete temp.value;
          }
        }
      }
      props2.autogrow === true && nextTick$1(adjustHeight);
    });
    watch(() => props2.autogrow, (val) => {
      if (val === true) {
        nextTick$1(adjustHeight);
      } else if (inputRef.value !== null && attrs.rows > 0) {
        inputRef.value.style.height = "auto";
      }
    });
    watch(() => props2.dense, () => {
      props2.autogrow === true && nextTick$1(adjustHeight);
    });
    function focus() {
      addFocusFn(() => {
        const el = document.activeElement;
        if (inputRef.value !== null && inputRef.value !== el && (el === null || el.id !== state.targetUid.value)) {
          inputRef.value.focus({ preventScroll: true });
        }
      });
    }
    function select() {
      inputRef.value !== null && inputRef.value.select();
    }
    function onPaste(e2) {
      if (hasMask.value === true && props2.reverseFillMask !== true) {
        const inp = e2.target;
        moveCursorForPaste(inp, inp.selectionStart, inp.selectionEnd);
      }
      emit2("paste", e2);
    }
    function onInput(e2) {
      if (!e2 || !e2.target) {
        return;
      }
      if (props2.type === "file") {
        emit2("update:modelValue", e2.target.files);
        return;
      }
      const val = e2.target.value;
      if (e2.target.qComposing === true) {
        temp.value = val;
        return;
      }
      if (hasMask.value === true) {
        updateMaskValue(val, false, e2.inputType);
      } else {
        emitValue(val);
        if (isTypeText.value === true && e2.target === document.activeElement) {
          const { selectionStart, selectionEnd } = e2.target;
          if (selectionStart !== void 0 && selectionEnd !== void 0) {
            nextTick$1(() => {
              if (e2.target === document.activeElement && val.indexOf(e2.target.value) === 0) {
                e2.target.setSelectionRange(selectionStart, selectionEnd);
              }
            });
          }
        }
      }
      props2.autogrow === true && adjustHeight();
    }
    function onAnimationend(e2) {
      emit2("animationend", e2);
      adjustHeight();
    }
    function emitValue(val, stopWatcher) {
      emitValueFn = () => {
        emitTimer = null;
        if (props2.type !== "number" && temp.hasOwnProperty("value") === true) {
          delete temp.value;
        }
        if (props2.modelValue !== val && emitCachedValue !== val) {
          emitCachedValue = val;
          stopWatcher === true && (stopValueWatcher = true);
          emit2("update:modelValue", val);
          nextTick$1(() => {
            emitCachedValue === val && (emitCachedValue = NaN);
          });
        }
        emitValueFn = void 0;
      };
      if (props2.type === "number") {
        typedNumber = true;
        temp.value = val;
      }
      if (props2.debounce !== void 0) {
        emitTimer !== null && clearTimeout(emitTimer);
        temp.value = val;
        emitTimer = setTimeout(emitValueFn, props2.debounce);
      } else {
        emitValueFn();
      }
    }
    function adjustHeight() {
      requestAnimationFrame(() => {
        const inp = inputRef.value;
        if (inp !== null) {
          const parentStyle = inp.parentNode.style;
          const { scrollTop } = inp;
          const { overflowY, maxHeight } = $q.platform.is.firefox === true ? {} : window.getComputedStyle(inp);
          const changeOverflow = overflowY !== void 0 && overflowY !== "scroll";
          changeOverflow === true && (inp.style.overflowY = "hidden");
          parentStyle.marginBottom = inp.scrollHeight - 1 + "px";
          inp.style.height = "1px";
          inp.style.height = inp.scrollHeight + "px";
          changeOverflow === true && (inp.style.overflowY = parseInt(maxHeight, 10) < inp.scrollHeight ? "auto" : "hidden");
          parentStyle.marginBottom = "";
          inp.scrollTop = scrollTop;
        }
      });
    }
    function onChange(e2) {
      onComposition(e2);
      if (emitTimer !== null) {
        clearTimeout(emitTimer);
        emitTimer = null;
      }
      emitValueFn !== void 0 && emitValueFn();
      emit2("change", e2.target.value);
    }
    function onFinishEditing(e2) {
      e2 !== void 0 && stop(e2);
      if (emitTimer !== null) {
        clearTimeout(emitTimer);
        emitTimer = null;
      }
      emitValueFn !== void 0 && emitValueFn();
      typedNumber = false;
      stopValueWatcher = false;
      delete temp.value;
      props2.type !== "file" && setTimeout(() => {
        if (inputRef.value !== null) {
          inputRef.value.value = innerValue.value !== void 0 ? innerValue.value : "";
        }
      });
    }
    function getCurValue() {
      return temp.hasOwnProperty("value") === true ? temp.value : innerValue.value !== void 0 ? innerValue.value : "";
    }
    onBeforeUnmount(() => {
      onFinishEditing();
    });
    onMounted(() => {
      props2.autogrow === true && adjustHeight();
    });
    Object.assign(state, {
      innerValue,
      fieldClass: computed(
        () => `q-${isTextarea.value === true ? "textarea" : "input"}` + (props2.autogrow === true ? " q-textarea--autogrow" : "")
      ),
      hasShadow: computed(
        () => props2.type !== "file" && typeof props2.shadowText === "string" && props2.shadowText.length !== 0
      ),
      inputRef,
      emitValue,
      hasValue,
      floatingLabel: computed(
        () => hasValue.value === true && (props2.type !== "number" || isNaN(innerValue.value) === false) || fieldValueIsFilled(props2.displayValue)
      ),
      getControl: () => {
        return h$1(isTextarea.value === true ? "textarea" : "input", {
          ref: inputRef,
          class: [
            "q-field__native q-placeholder",
            props2.inputClass
          ],
          style: props2.inputStyle,
          ...inputAttrs.value,
          ...onEvents.value,
          ...props2.type !== "file" ? { value: getCurValue() } : formDomProps.value
        });
      },
      getShadowControl: () => {
        return h$1("div", {
          class: "q-field__native q-field__shadow absolute-bottom no-pointer-events" + (isTextarea.value === true ? "" : " text-no-wrap")
        }, [
          h$1("span", { class: "invisible" }, getCurValue()),
          h$1("span", props2.shadowText)
        ]);
      }
    });
    const renderFn = useField(state);
    Object.assign(proxy, {
      focus,
      select,
      getNativeElement: () => inputRef.value
      // deprecated
    });
    injectProp(proxy, "nativeEl", () => inputRef.value);
    return renderFn;
  }
});
function useRefocusTarget(props2, rootRef) {
  const refocusRef = ref(null);
  const refocusTargetEl = computed(() => {
    if (props2.disable === true) {
      return null;
    }
    return h$1("span", {
      ref: refocusRef,
      class: "no-outline",
      tabindex: -1
    });
  });
  function refocusTarget(e2) {
    const root = rootRef.value;
    if (e2 !== void 0 && e2.type.indexOf("key") === 0) {
      if (root !== null && document.activeElement !== root && root.contains(document.activeElement) === true) {
        root.focus();
      }
    } else if (refocusRef.value !== null && (e2 === void 0 || root !== null && root.contains(e2.target) === true)) {
      refocusRef.value.focus();
    }
  }
  return {
    refocusTargetEl,
    refocusTarget
  };
}
const optionSizes = {
  xs: 30,
  sm: 35,
  md: 40,
  lg: 50,
  xl: 60
};
const svg$2 = h$1("svg", {
  key: "svg",
  class: "q-radio__bg absolute non-selectable",
  viewBox: "0 0 24 24"
}, [
  h$1("path", {
    d: "M12,22a10,10 0 0 1 -10,-10a10,10 0 0 1 10,-10a10,10 0 0 1 10,10a10,10 0 0 1 -10,10m0,-22a12,12 0 0 0 -12,12a12,12 0 0 0 12,12a12,12 0 0 0 12,-12a12,12 0 0 0 -12,-12"
  }),
  h$1("path", {
    class: "q-radio__check",
    d: "M12,6a6,6 0 0 0 -6,6a6,6 0 0 0 6,6a6,6 0 0 0 6,-6a6,6 0 0 0 -6,-6"
  })
]);
const QRadio = createComponent({
  name: "QRadio",
  props: {
    ...useDarkProps,
    ...useSizeProps,
    ...useFormProps,
    modelValue: { required: true },
    val: { required: true },
    label: String,
    leftLabel: Boolean,
    checkedIcon: String,
    uncheckedIcon: String,
    color: String,
    keepColor: Boolean,
    dense: Boolean,
    disable: Boolean,
    tabindex: [String, Number]
  },
  emits: ["update:modelValue"],
  setup(props2, { slots, emit: emit2 }) {
    const { proxy } = getCurrentInstance();
    const isDark = useDark(props2, proxy.$q);
    const sizeStyle = useSize(props2, optionSizes);
    const rootRef = ref(null);
    const { refocusTargetEl, refocusTarget } = useRefocusTarget(props2, rootRef);
    const isTrue = computed(() => toRaw(props2.modelValue) === toRaw(props2.val));
    const classes = computed(
      () => "q-radio cursor-pointer no-outline row inline no-wrap items-center" + (props2.disable === true ? " disabled" : "") + (isDark.value === true ? " q-radio--dark" : "") + (props2.dense === true ? " q-radio--dense" : "") + (props2.leftLabel === true ? " reverse" : "")
    );
    const innerClass = computed(() => {
      const color2 = props2.color !== void 0 && (props2.keepColor === true || isTrue.value === true) ? ` text-${props2.color}` : "";
      return `q-radio__inner relative-position q-radio__inner--${isTrue.value === true ? "truthy" : "falsy"}${color2}`;
    });
    const icon = computed(
      () => (isTrue.value === true ? props2.checkedIcon : props2.uncheckedIcon) || null
    );
    const tabindex = computed(() => props2.disable === true ? -1 : props2.tabindex || 0);
    const formAttrs = computed(() => {
      const prop = { type: "radio" };
      props2.name !== void 0 && Object.assign(prop, {
        // see https://vuejs.org/guide/extras/render-function.html#creating-vnodes (.prop)
        ".checked": isTrue.value === true,
        "^checked": isTrue.value === true ? "checked" : void 0,
        name: props2.name,
        value: props2.val
      });
      return prop;
    });
    const injectFormInput = useFormInject(formAttrs);
    function onClick(e2) {
      if (e2 !== void 0) {
        stopAndPrevent(e2);
        refocusTarget(e2);
      }
      if (props2.disable !== true && isTrue.value !== true) {
        emit2("update:modelValue", props2.val, e2);
      }
    }
    function onKeydown2(e2) {
      if (e2.keyCode === 13 || e2.keyCode === 32) {
        stopAndPrevent(e2);
      }
    }
    function onKeyup2(e2) {
      if (e2.keyCode === 13 || e2.keyCode === 32) {
        onClick(e2);
      }
    }
    Object.assign(proxy, { set: onClick });
    return () => {
      const content2 = icon.value !== null ? [
        h$1("div", {
          key: "icon",
          class: "q-radio__icon-container absolute-full flex flex-center no-wrap"
        }, [
          h$1(QIcon, {
            class: "q-radio__icon",
            name: icon.value
          })
        ])
      ] : [svg$2];
      props2.disable !== true && injectFormInput(
        content2,
        "unshift",
        " q-radio__native q-ma-none q-pa-none"
      );
      const child = [
        h$1("div", {
          class: innerClass.value,
          style: sizeStyle.value,
          "aria-hidden": "true"
        }, content2)
      ];
      if (refocusTargetEl.value !== null) {
        child.push(refocusTargetEl.value);
      }
      const label = props2.label !== void 0 ? hMergeSlot(slots.default, [props2.label]) : hSlot(slots.default);
      label !== void 0 && child.push(
        h$1("div", {
          class: "q-radio__label q-anchor--skip"
        }, label)
      );
      return h$1("div", {
        ref: rootRef,
        class: classes.value,
        tabindex: tabindex.value,
        role: "radio",
        "aria-label": props2.label,
        "aria-checked": isTrue.value === true ? "true" : "false",
        "aria-disabled": props2.disable === true ? "true" : void 0,
        onClick,
        onKeydown: onKeydown2,
        onKeyup: onKeyup2
      }, child);
    };
  }
});
const useCheckboxProps = {
  ...useDarkProps,
  ...useSizeProps,
  ...useFormProps,
  modelValue: {
    required: true,
    default: null
  },
  val: {},
  trueValue: { default: true },
  falseValue: { default: false },
  indeterminateValue: { default: null },
  checkedIcon: String,
  uncheckedIcon: String,
  indeterminateIcon: String,
  toggleOrder: {
    type: String,
    validator: (v2) => v2 === "tf" || v2 === "ft"
  },
  toggleIndeterminate: Boolean,
  label: String,
  leftLabel: Boolean,
  color: String,
  keepColor: Boolean,
  dense: Boolean,
  disable: Boolean,
  tabindex: [String, Number]
};
const useCheckboxEmits = ["update:modelValue"];
function useCheckbox(type, getInner) {
  const { props: props2, slots, emit: emit2, proxy } = getCurrentInstance();
  const { $q } = proxy;
  const isDark = useDark(props2, $q);
  const rootRef = ref(null);
  const { refocusTargetEl, refocusTarget } = useRefocusTarget(props2, rootRef);
  const sizeStyle = useSize(props2, optionSizes);
  const modelIsArray = computed(
    () => props2.val !== void 0 && Array.isArray(props2.modelValue)
  );
  const index = computed(() => {
    const val = toRaw(props2.val);
    return modelIsArray.value === true ? props2.modelValue.findIndex((opt) => toRaw(opt) === val) : -1;
  });
  const isTrue = computed(() => modelIsArray.value === true ? index.value !== -1 : toRaw(props2.modelValue) === toRaw(props2.trueValue));
  const isFalse = computed(() => modelIsArray.value === true ? index.value === -1 : toRaw(props2.modelValue) === toRaw(props2.falseValue));
  const isIndeterminate = computed(
    () => isTrue.value === false && isFalse.value === false
  );
  const tabindex = computed(() => props2.disable === true ? -1 : props2.tabindex || 0);
  const classes = computed(
    () => `q-${type} cursor-pointer no-outline row inline no-wrap items-center` + (props2.disable === true ? " disabled" : "") + (isDark.value === true ? ` q-${type}--dark` : "") + (props2.dense === true ? ` q-${type}--dense` : "") + (props2.leftLabel === true ? " reverse" : "")
  );
  const innerClass = computed(() => {
    const state = isTrue.value === true ? "truthy" : isFalse.value === true ? "falsy" : "indet";
    const color2 = props2.color !== void 0 && (props2.keepColor === true || (type === "toggle" ? isTrue.value === true : isFalse.value !== true)) ? ` text-${props2.color}` : "";
    return `q-${type}__inner relative-position non-selectable q-${type}__inner--${state}${color2}`;
  });
  const formAttrs = computed(() => {
    const prop = { type: "checkbox" };
    props2.name !== void 0 && Object.assign(prop, {
      // see https://vuejs.org/guide/extras/render-function.html#creating-vnodes (.prop)
      ".checked": isTrue.value,
      "^checked": isTrue.value === true ? "checked" : void 0,
      name: props2.name,
      value: modelIsArray.value === true ? props2.val : props2.trueValue
    });
    return prop;
  });
  const injectFormInput = useFormInject(formAttrs);
  const attributes = computed(() => {
    const attrs = {
      tabindex: tabindex.value,
      role: type === "toggle" ? "switch" : "checkbox",
      "aria-label": props2.label,
      "aria-checked": isIndeterminate.value === true ? "mixed" : isTrue.value === true ? "true" : "false"
    };
    if (props2.disable === true) {
      attrs["aria-disabled"] = "true";
    }
    return attrs;
  });
  function onClick(e2) {
    if (e2 !== void 0) {
      stopAndPrevent(e2);
      refocusTarget(e2);
    }
    if (props2.disable !== true) {
      emit2("update:modelValue", getNextValue(), e2);
    }
  }
  function getNextValue() {
    if (modelIsArray.value === true) {
      if (isTrue.value === true) {
        const val = props2.modelValue.slice();
        val.splice(index.value, 1);
        return val;
      }
      return props2.modelValue.concat([props2.val]);
    }
    if (isTrue.value === true) {
      if (props2.toggleOrder !== "ft" || props2.toggleIndeterminate === false) {
        return props2.falseValue;
      }
    } else if (isFalse.value === true) {
      if (props2.toggleOrder === "ft" || props2.toggleIndeterminate === false) {
        return props2.trueValue;
      }
    } else {
      return props2.toggleOrder !== "ft" ? props2.trueValue : props2.falseValue;
    }
    return props2.indeterminateValue;
  }
  function onKeydown2(e2) {
    if (e2.keyCode === 13 || e2.keyCode === 32) {
      stopAndPrevent(e2);
    }
  }
  function onKeyup2(e2) {
    if (e2.keyCode === 13 || e2.keyCode === 32) {
      onClick(e2);
    }
  }
  const getInnerContent = getInner(isTrue, isIndeterminate);
  Object.assign(proxy, { toggle: onClick });
  return () => {
    const inner = getInnerContent();
    props2.disable !== true && injectFormInput(
      inner,
      "unshift",
      ` q-${type}__native absolute q-ma-none q-pa-none`
    );
    const child = [
      h$1("div", {
        class: innerClass.value,
        style: sizeStyle.value,
        "aria-hidden": "true"
      }, inner)
    ];
    if (refocusTargetEl.value !== null) {
      child.push(refocusTargetEl.value);
    }
    const label = props2.label !== void 0 ? hMergeSlot(slots.default, [props2.label]) : hSlot(slots.default);
    label !== void 0 && child.push(
      h$1("div", {
        class: `q-${type}__label q-anchor--skip`
      }, label)
    );
    return h$1("div", {
      ref: rootRef,
      class: classes.value,
      ...attributes.value,
      onClick,
      onKeydown: onKeydown2,
      onKeyup: onKeyup2
    }, child);
  };
}
const bgNode = h$1("div", {
  key: "svg",
  class: "q-checkbox__bg absolute"
}, [
  h$1("svg", {
    class: "q-checkbox__svg fit absolute-full",
    viewBox: "0 0 24 24"
  }, [
    h$1("path", {
      class: "q-checkbox__truthy",
      fill: "none",
      d: "M1.73,12.91 8.1,19.28 22.79,4.59"
    }),
    h$1("path", {
      class: "q-checkbox__indet",
      d: "M4,14H20V10H4"
    })
  ])
]);
const QCheckbox = createComponent({
  name: "QCheckbox",
  props: useCheckboxProps,
  emits: useCheckboxEmits,
  setup(props2) {
    function getInner(isTrue, isIndeterminate) {
      const icon = computed(
        () => (isTrue.value === true ? props2.checkedIcon : isIndeterminate.value === true ? props2.indeterminateIcon : props2.uncheckedIcon) || null
      );
      return () => icon.value !== null ? [
        h$1("div", {
          key: "icon",
          class: "q-checkbox__icon-container absolute-full flex flex-center no-wrap"
        }, [
          h$1(QIcon, {
            class: "q-checkbox__icon",
            name: icon.value
          })
        ])
      ] : [bgNode];
    }
    return useCheckbox("checkbox", getInner);
  }
});
const QToggle = createComponent({
  name: "QToggle",
  props: {
    ...useCheckboxProps,
    icon: String,
    iconColor: String
  },
  emits: useCheckboxEmits,
  setup(props2) {
    function getInner(isTrue, isIndeterminate) {
      const icon = computed(
        () => (isTrue.value === true ? props2.checkedIcon : isIndeterminate.value === true ? props2.indeterminateIcon : props2.uncheckedIcon) || props2.icon
      );
      const color2 = computed(() => isTrue.value === true ? props2.iconColor : null);
      return () => [
        h$1("div", { class: "q-toggle__track" }),
        h$1(
          "div",
          {
            class: "q-toggle__thumb absolute flex flex-center no-wrap"
          },
          icon.value !== void 0 ? [
            h$1(QIcon, {
              name: icon.value,
              color: color2.value
            })
          ] : void 0
        )
      ];
    }
    return useCheckbox("toggle", getInner);
  }
});
const components = {
  radio: QRadio,
  checkbox: QCheckbox,
  toggle: QToggle
};
const typeValues = Object.keys(components);
const QOptionGroup = createComponent({
  name: "QOptionGroup",
  props: {
    ...useDarkProps,
    modelValue: {
      required: true
    },
    options: {
      type: Array,
      validator: (opts) => opts.every((opt) => "value" in opt && "label" in opt)
    },
    name: String,
    type: {
      type: String,
      default: "radio",
      validator: (v2) => typeValues.includes(v2)
    },
    color: String,
    keepColor: Boolean,
    dense: Boolean,
    size: String,
    leftLabel: Boolean,
    inline: Boolean,
    disable: Boolean
  },
  emits: ["update:modelValue"],
  setup(props2, { emit: emit2, slots }) {
    const { proxy: { $q } } = getCurrentInstance();
    const arrayModel = Array.isArray(props2.modelValue);
    if (props2.type === "radio") {
      if (arrayModel === true) {
        console.error("q-option-group: model should not be array");
      }
    } else if (arrayModel === false) {
      console.error("q-option-group: model should be array in your case");
    }
    const isDark = useDark(props2, $q);
    const component = computed(() => components[props2.type]);
    const classes = computed(
      () => "q-option-group q-gutter-x-sm" + (props2.inline === true ? " q-option-group--inline" : "")
    );
    const attrs = computed(() => {
      const attrs2 = { role: "group" };
      if (props2.type === "radio") {
        attrs2.role = "radiogroup";
        if (props2.disable === true) {
          attrs2["aria-disabled"] = "true";
        }
      }
      return attrs2;
    });
    function onUpdateModelValue(value2) {
      emit2("update:modelValue", value2);
    }
    return () => h$1("div", {
      class: classes.value,
      ...attrs.value
    }, props2.options.map((opt, i) => {
      const child = slots["label-" + i] !== void 0 ? () => slots["label-" + i](opt) : slots.label !== void 0 ? () => slots.label(opt) : void 0;
      return h$1("div", [
        h$1(component.value, {
          modelValue: props2.modelValue,
          val: opt.value,
          name: opt.name === void 0 ? props2.name : opt.name,
          disable: props2.disable || opt.disable,
          label: child === void 0 ? opt.label : null,
          leftLabel: opt.leftLabel === void 0 ? props2.leftLabel : opt.leftLabel,
          color: opt.color === void 0 ? props2.color : opt.color,
          checkedIcon: opt.checkedIcon,
          uncheckedIcon: opt.uncheckedIcon,
          dark: opt.dark || isDark.value,
          size: opt.size === void 0 ? props2.size : opt.size,
          dense: props2.dense,
          keepColor: opt.keepColor === void 0 ? props2.keepColor : opt.keepColor,
          "onUpdate:modelValue": onUpdateModelValue
        }, child)
      ]);
    }));
  }
});
const DialogPlugin = createComponent({
  name: "DialogPluginComponent",
  props: {
    ...useDarkProps,
    title: String,
    message: String,
    prompt: Object,
    options: Object,
    progress: [Boolean, Object],
    html: Boolean,
    ok: {
      type: [String, Object, Boolean],
      default: true
    },
    cancel: [String, Object, Boolean],
    focus: {
      type: String,
      default: "ok",
      validator: (v2) => ["ok", "cancel", "none"].includes(v2)
    },
    stackButtons: Boolean,
    color: String,
    cardClass: [String, Array, Object],
    cardStyle: [String, Array, Object]
  },
  emits: ["ok", "hide"],
  setup(props2, { emit: emit2 }) {
    const { proxy } = getCurrentInstance();
    const { $q } = proxy;
    const isDark = useDark(props2, $q);
    const dialogRef = ref(null);
    const model = ref(
      props2.prompt !== void 0 ? props2.prompt.model : props2.options !== void 0 ? props2.options.model : void 0
    );
    const classes = computed(
      () => "q-dialog-plugin" + (isDark.value === true ? " q-dialog-plugin--dark q-dark" : "") + (props2.progress !== false ? " q-dialog-plugin--progress" : "")
    );
    const vmColor = computed(
      () => props2.color || (isDark.value === true ? "amber" : "primary")
    );
    const spinner = computed(() => props2.progress === false ? null : isObject$3(props2.progress) === true ? {
      component: props2.progress.spinner || QSpinner,
      props: { color: props2.progress.color || vmColor.value }
    } : {
      component: QSpinner,
      props: { color: vmColor.value }
    });
    const hasForm = computed(
      () => props2.prompt !== void 0 || props2.options !== void 0
    );
    const formProps = computed(() => {
      if (hasForm.value !== true) {
        return {};
      }
      const { model: model2, isValid, items, ...formProps2 } = props2.prompt !== void 0 ? props2.prompt : props2.options;
      return formProps2;
    });
    const okLabel = computed(() => isObject$3(props2.ok) === true ? $q.lang.label.ok : props2.ok === true ? $q.lang.label.ok : props2.ok);
    const cancelLabel = computed(() => isObject$3(props2.cancel) === true ? $q.lang.label.cancel : props2.cancel === true ? $q.lang.label.cancel : props2.cancel);
    const okDisabled = computed(() => {
      if (props2.prompt !== void 0) {
        return props2.prompt.isValid !== void 0 && props2.prompt.isValid(model.value) !== true;
      }
      if (props2.options !== void 0) {
        return props2.options.isValid !== void 0 && props2.options.isValid(model.value) !== true;
      }
      return false;
    });
    const okProps = computed(() => ({
      color: vmColor.value,
      label: okLabel.value,
      ripple: false,
      disable: okDisabled.value,
      ...isObject$3(props2.ok) === true ? props2.ok : { flat: true },
      "data-autofocus": props2.focus === "ok" && hasForm.value !== true || void 0,
      onClick: onOk
    }));
    const cancelProps = computed(() => ({
      color: vmColor.value,
      label: cancelLabel.value,
      ripple: false,
      ...isObject$3(props2.cancel) === true ? props2.cancel : { flat: true },
      "data-autofocus": props2.focus === "cancel" && hasForm.value !== true || void 0,
      onClick: onCancel
    }));
    watch(() => props2.prompt && props2.prompt.model, onUpdateModel);
    watch(() => props2.options && props2.options.model, onUpdateModel);
    function show() {
      dialogRef.value.show();
    }
    function hide() {
      dialogRef.value.hide();
    }
    function onOk() {
      emit2("ok", toRaw(model.value));
      hide();
    }
    function onCancel() {
      hide();
    }
    function onDialogHide() {
      emit2("hide");
    }
    function onUpdateModel(val) {
      model.value = val;
    }
    function onInputKeyup(evt) {
      if (okDisabled.value !== true && props2.prompt.type !== "textarea" && isKeyCode(evt, 13) === true) {
        onOk();
      }
    }
    function getSection(classes2, text) {
      return props2.html === true ? h$1(QCardSection, {
        class: classes2,
        innerHTML: text
      }) : h$1(QCardSection, { class: classes2 }, () => text);
    }
    function getPrompt() {
      return [
        h$1(QInput, {
          color: vmColor.value,
          dense: true,
          autofocus: true,
          dark: isDark.value,
          ...formProps.value,
          modelValue: model.value,
          "onUpdate:modelValue": onUpdateModel,
          onKeyup: onInputKeyup
        })
      ];
    }
    function getOptions() {
      return [
        h$1(QOptionGroup, {
          color: vmColor.value,
          options: props2.options.items,
          dark: isDark.value,
          ...formProps.value,
          modelValue: model.value,
          "onUpdate:modelValue": onUpdateModel
        })
      ];
    }
    function getButtons() {
      const child = [];
      props2.cancel && child.push(
        h$1(QBtn, cancelProps.value)
      );
      props2.ok && child.push(
        h$1(QBtn, okProps.value)
      );
      return h$1(QCardActions, {
        class: props2.stackButtons === true ? "items-end" : "",
        vertical: props2.stackButtons,
        align: "right"
      }, () => child);
    }
    function getCardContent() {
      const child = [];
      props2.title && child.push(
        getSection("q-dialog__title", props2.title)
      );
      props2.progress !== false && child.push(
        h$1(
          QCardSection,
          { class: "q-dialog__progress" },
          () => h$1(spinner.value.component, spinner.value.props)
        )
      );
      props2.message && child.push(
        getSection("q-dialog__message", props2.message)
      );
      if (props2.prompt !== void 0) {
        child.push(
          h$1(
            QCardSection,
            { class: "scroll q-dialog-plugin__form" },
            getPrompt
          )
        );
      } else if (props2.options !== void 0) {
        child.push(
          h$1(QSeparator, { dark: isDark.value }),
          h$1(
            QCardSection,
            { class: "scroll q-dialog-plugin__form" },
            getOptions
          ),
          h$1(QSeparator, { dark: isDark.value })
        );
      }
      if (props2.ok || props2.cancel) {
        child.push(getButtons());
      }
      return child;
    }
    function getContent() {
      return [
        h$1(QCard, {
          class: [
            classes.value,
            props2.cardClass
          ],
          style: props2.cardStyle,
          dark: isDark.value
        }, getCardContent)
      ];
    }
    Object.assign(proxy, { show, hide });
    return () => h$1(QDialog, {
      ref: dialogRef,
      onHide: onDialogHide
    }, getContent);
  }
});
function merge$1(target2, source) {
  for (const key in source) {
    if (key !== "spinner" && Object(source[key]) === source[key]) {
      target2[key] = Object(target2[key]) !== target2[key] ? {} : { ...target2[key] };
      merge$1(target2[key], source[key]);
    } else {
      target2[key] = source[key];
    }
  }
}
function globalDialog(DefaultComponent, supportsCustomComponent, parentApp) {
  return (pluginProps) => {
    let DialogComponent, props2;
    const isCustom = pluginProps.component !== void 0;
    if (isCustom === true) {
      const { component, componentProps } = pluginProps;
      DialogComponent = typeof component === "string" ? parentApp.component(component) : component;
      props2 = componentProps || {};
    } else {
      const { class: klass, style, ...otherProps } = pluginProps;
      DialogComponent = DefaultComponent;
      props2 = otherProps;
      klass !== void 0 && (otherProps.cardClass = klass);
      style !== void 0 && (otherProps.cardStyle = style);
    }
    let vm2, emittedOK = false;
    const dialogRef = ref(null);
    const el = createGlobalNode(false, "dialog");
    const applyState = (cmd) => {
      if (dialogRef.value !== null && dialogRef.value[cmd] !== void 0) {
        dialogRef.value[cmd]();
        return;
      }
      const target2 = vm2.$.subTree;
      if (target2 && target2.component) {
        if (target2.component.proxy && target2.component.proxy[cmd]) {
          target2.component.proxy[cmd]();
          return;
        }
        if (target2.component.subTree && target2.component.subTree.component && target2.component.subTree.component.proxy && target2.component.subTree.component.proxy[cmd]) {
          target2.component.subTree.component.proxy[cmd]();
          return;
        }
      }
      console.error("[Quasar] Incorrectly defined Dialog component");
    };
    const okFns = [], cancelFns = [], API = {
      onOk(fn) {
        okFns.push(fn);
        return API;
      },
      onCancel(fn) {
        cancelFns.push(fn);
        return API;
      },
      onDismiss(fn) {
        okFns.push(fn);
        cancelFns.push(fn);
        return API;
      },
      hide() {
        applyState("hide");
        return API;
      },
      update(componentProps) {
        if (vm2 !== null) {
          if (isCustom === true) {
            Object.assign(props2, componentProps);
          } else {
            const { class: klass, style, ...cfg } = componentProps;
            klass !== void 0 && (cfg.cardClass = klass);
            style !== void 0 && (cfg.cardStyle = style);
            merge$1(props2, cfg);
          }
          vm2.$forceUpdate();
        }
        return API;
      }
    };
    const onOk = (data) => {
      emittedOK = true;
      okFns.forEach((fn) => {
        fn(data);
      });
    };
    const onHide = () => {
      app2.unmount(el);
      removeGlobalNode(el);
      app2 = null;
      vm2 = null;
      if (emittedOK !== true) {
        cancelFns.forEach((fn) => {
          fn();
        });
      }
    };
    let app2 = createChildApp({
      name: "QGlobalDialog",
      setup: () => () => h$1(DialogComponent, {
        ...props2,
        ref: dialogRef,
        onOk,
        onHide,
        onVnodeMounted(...args) {
          if (typeof props2.onVnodeMounted === "function") {
            props2.onVnodeMounted(...args);
          }
          nextTick$1(() => applyState("show"));
        }
      })
    }, parentApp);
    vm2 = app2.mount(el);
    return API;
  };
}
const Dialog = {
  install({ $q, parentApp }) {
    $q.dialog = this.create = globalDialog(DialogPlugin, true, parentApp);
  }
};
let app$1, vm, uid$1 = 0, timeout = null, props = {}, activeGroups = {};
const originalDefaults = {
  group: "__default_quasar_group__",
  delay: 0,
  message: false,
  html: false,
  spinnerSize: 80,
  spinnerColor: "",
  messageColor: "",
  backgroundColor: "",
  boxClass: "",
  spinner: QSpinner,
  customClass: ""
};
const defaults$1 = { ...originalDefaults };
function registerProps(opts) {
  if (opts && opts.group !== void 0 && activeGroups[opts.group] !== void 0) {
    return Object.assign(activeGroups[opts.group], opts);
  }
  const newProps = isObject$3(opts) === true && opts.ignoreDefaults === true ? { ...originalDefaults, ...opts } : { ...defaults$1, ...opts };
  activeGroups[newProps.group] = newProps;
  return newProps;
}
const Plugin = createReactivePlugin({
  isActive: false
}, {
  show(opts) {
    props = registerProps(opts);
    const { group } = props;
    Plugin.isActive = true;
    if (app$1 !== void 0) {
      props.uid = uid$1;
      vm.$forceUpdate();
    } else {
      props.uid = ++uid$1;
      timeout !== null && clearTimeout(timeout);
      timeout = setTimeout(() => {
        timeout = null;
        const el = createGlobalNode("q-loading");
        app$1 = createChildApp({
          name: "QLoading",
          setup() {
            onMounted(() => {
              preventScroll(true);
            });
            function onAfterLeave() {
              if (Plugin.isActive !== true && app$1 !== void 0) {
                preventScroll(false);
                app$1.unmount(el);
                removeGlobalNode(el);
                app$1 = void 0;
                vm = void 0;
              }
            }
            function getContent() {
              if (Plugin.isActive !== true) {
                return null;
              }
              const content2 = [
                h$1(props.spinner, {
                  class: "q-loading__spinner",
                  color: props.spinnerColor,
                  size: props.spinnerSize
                })
              ];
              props.message && content2.push(
                h$1("div", {
                  class: "q-loading__message" + (props.messageColor ? ` text-${props.messageColor}` : ""),
                  [props.html === true ? "innerHTML" : "textContent"]: props.message
                })
              );
              return h$1("div", {
                class: "q-loading fullscreen flex flex-center z-max " + props.customClass.trim(),
                key: props.uid
              }, [
                h$1("div", {
                  class: "q-loading__backdrop" + (props.backgroundColor ? ` bg-${props.backgroundColor}` : "")
                }),
                h$1("div", {
                  class: "q-loading__box column items-center " + props.boxClass
                }, content2)
              ]);
            }
            return () => h$1(Transition, {
              name: "q-transition--fade",
              appear: true,
              onAfterLeave
            }, getContent);
          }
        }, Plugin.__parentApp);
        vm = app$1.mount(el);
      }, props.delay);
    }
    return (paramProps) => {
      if (paramProps === void 0 || Object(paramProps) !== paramProps) {
        Plugin.hide(group);
        return;
      }
      Plugin.show({ ...paramProps, group });
    };
  },
  hide(group) {
    if (Plugin.isActive === true) {
      if (group === void 0) {
        activeGroups = {};
      } else if (activeGroups[group] === void 0) {
        return;
      } else {
        delete activeGroups[group];
        const keys = Object.keys(activeGroups);
        if (keys.length !== 0) {
          const lastGroup = keys[keys.length - 1];
          Plugin.show({ group: lastGroup });
          return;
        }
      }
      if (timeout !== null) {
        clearTimeout(timeout);
        timeout = null;
      }
      Plugin.isActive = false;
    }
  },
  setDefaults(opts) {
    {
      isObject$3(opts) === true && Object.assign(defaults$1, opts);
    }
  },
  install({ $q, parentApp }) {
    $q.loading = this;
    {
      Plugin.__parentApp = parentApp;
      if ($q.config.loading !== void 0) {
        this.setDefaults($q.config.loading);
      }
    }
  }
});
var isVue2 = false;
/*!
 * pinia v2.1.7
 * (c) 2023 Eduardo San Martin Morote
 * @license MIT
 */
let activePinia;
const setActivePinia = (pinia2) => activePinia = pinia2;
const piniaSymbol = (
  /* istanbul ignore next */
  Symbol()
);
function isPlainObject$1(o2) {
  return o2 && typeof o2 === "object" && Object.prototype.toString.call(o2) === "[object Object]" && typeof o2.toJSON !== "function";
}
var MutationType;
(function(MutationType2) {
  MutationType2["direct"] = "direct";
  MutationType2["patchObject"] = "patch object";
  MutationType2["patchFunction"] = "patch function";
})(MutationType || (MutationType = {}));
function createPinia() {
  const scope = effectScope(true);
  const state = scope.run(() => ref({}));
  let _p = [];
  let toBeInstalled = [];
  const pinia2 = markRaw({
    install(app2) {
      setActivePinia(pinia2);
      {
        pinia2._a = app2;
        app2.provide(piniaSymbol, pinia2);
        app2.config.globalProperties.$pinia = pinia2;
        toBeInstalled.forEach((plugin) => _p.push(plugin));
        toBeInstalled = [];
      }
    },
    use(plugin) {
      if (!this._a && !isVue2) {
        toBeInstalled.push(plugin);
      } else {
        _p.push(plugin);
      }
      return this;
    },
    _p,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: scope,
    _s: /* @__PURE__ */ new Map(),
    state
  });
  return pinia2;
}
const noop$2 = () => {
};
function addSubscription(subscriptions, callback, detached, onCleanup = noop$2) {
  subscriptions.push(callback);
  const removeSubscription = () => {
    const idx = subscriptions.indexOf(callback);
    if (idx > -1) {
      subscriptions.splice(idx, 1);
      onCleanup();
    }
  };
  if (!detached && getCurrentScope()) {
    onScopeDispose(removeSubscription);
  }
  return removeSubscription;
}
function triggerSubscriptions(subscriptions, ...args) {
  subscriptions.slice().forEach((callback) => {
    callback(...args);
  });
}
const fallbackRunWithContext = (fn) => fn();
function mergeReactiveObjects(target2, patchToApply) {
  if (target2 instanceof Map && patchToApply instanceof Map) {
    patchToApply.forEach((value2, key) => target2.set(key, value2));
  }
  if (target2 instanceof Set && patchToApply instanceof Set) {
    patchToApply.forEach(target2.add, target2);
  }
  for (const key in patchToApply) {
    if (!patchToApply.hasOwnProperty(key))
      continue;
    const subPatch = patchToApply[key];
    const targetValue = target2[key];
    if (isPlainObject$1(targetValue) && isPlainObject$1(subPatch) && target2.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {
      target2[key] = mergeReactiveObjects(targetValue, subPatch);
    } else {
      target2[key] = subPatch;
    }
  }
  return target2;
}
const skipHydrateSymbol = (
  /* istanbul ignore next */
  Symbol()
);
function shouldHydrate(obj) {
  return !isPlainObject$1(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
}
const { assign: assign$2 } = Object;
function isComputed(o2) {
  return !!(isRef(o2) && o2.effect);
}
function createOptionsStore(id2, options, pinia2, hot) {
  const { state, actions, getters } = options;
  const initialState = pinia2.state.value[id2];
  let store;
  function setup() {
    if (!initialState && true) {
      {
        pinia2.state.value[id2] = state ? state() : {};
      }
    }
    const localState = toRefs(pinia2.state.value[id2]);
    return assign$2(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
      computedGetters[name] = markRaw(computed(() => {
        setActivePinia(pinia2);
        const store2 = pinia2._s.get(id2);
        return getters[name].call(store2, store2);
      }));
      return computedGetters;
    }, {}));
  }
  store = createSetupStore(id2, setup, options, pinia2, hot, true);
  return store;
}
function createSetupStore($id, setup, options = {}, pinia2, hot, isOptionsStore) {
  let scope;
  const optionsForPlugin = assign$2({ actions: {} }, options);
  const $subscribeOptions = {
    deep: true
    // flush: 'post',
  };
  let isListening;
  let isSyncListening;
  let subscriptions = [];
  let actionSubscriptions = [];
  let debuggerEvents;
  const initialState = pinia2.state.value[$id];
  if (!isOptionsStore && !initialState && true) {
    {
      pinia2.state.value[$id] = {};
    }
  }
  ref({});
  let activeListener;
  function $patch(partialStateOrMutator) {
    let subscriptionMutation;
    isListening = isSyncListening = false;
    if (typeof partialStateOrMutator === "function") {
      partialStateOrMutator(pinia2.state.value[$id]);
      subscriptionMutation = {
        type: MutationType.patchFunction,
        storeId: $id,
        events: debuggerEvents
      };
    } else {
      mergeReactiveObjects(pinia2.state.value[$id], partialStateOrMutator);
      subscriptionMutation = {
        type: MutationType.patchObject,
        payload: partialStateOrMutator,
        storeId: $id,
        events: debuggerEvents
      };
    }
    const myListenerId = activeListener = Symbol();
    nextTick$1().then(() => {
      if (activeListener === myListenerId) {
        isListening = true;
      }
    });
    isSyncListening = true;
    triggerSubscriptions(subscriptions, subscriptionMutation, pinia2.state.value[$id]);
  }
  const $reset = isOptionsStore ? function $reset2() {
    const { state } = options;
    const newState = state ? state() : {};
    this.$patch(($state) => {
      assign$2($state, newState);
    });
  } : (
    /* istanbul ignore next */
    noop$2
  );
  function $dispose() {
    scope.stop();
    subscriptions = [];
    actionSubscriptions = [];
    pinia2._s.delete($id);
  }
  function wrapAction(name, action) {
    return function() {
      setActivePinia(pinia2);
      const args = Array.from(arguments);
      const afterCallbackList = [];
      const onErrorCallbackList = [];
      function after(callback) {
        afterCallbackList.push(callback);
      }
      function onError(callback) {
        onErrorCallbackList.push(callback);
      }
      triggerSubscriptions(actionSubscriptions, {
        args,
        name,
        store,
        after,
        onError
      });
      let ret;
      try {
        ret = action.apply(this && this.$id === $id ? this : store, args);
      } catch (error) {
        triggerSubscriptions(onErrorCallbackList, error);
        throw error;
      }
      if (ret instanceof Promise) {
        return ret.then((value2) => {
          triggerSubscriptions(afterCallbackList, value2);
          return value2;
        }).catch((error) => {
          triggerSubscriptions(onErrorCallbackList, error);
          return Promise.reject(error);
        });
      }
      triggerSubscriptions(afterCallbackList, ret);
      return ret;
    };
  }
  const partialStore = {
    _p: pinia2,
    // _s: scope,
    $id,
    $onAction: addSubscription.bind(null, actionSubscriptions),
    $patch,
    $reset,
    $subscribe(callback, options2 = {}) {
      const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
      const stopWatcher = scope.run(() => watch(() => pinia2.state.value[$id], (state) => {
        if (options2.flush === "sync" ? isSyncListening : isListening) {
          callback({
            storeId: $id,
            type: MutationType.direct,
            events: debuggerEvents
          }, state);
        }
      }, assign$2({}, $subscribeOptions, options2)));
      return removeSubscription;
    },
    $dispose
  };
  const store = reactive(partialStore);
  pinia2._s.set($id, store);
  const runWithContext = pinia2._a && pinia2._a.runWithContext || fallbackRunWithContext;
  const setupStore = runWithContext(() => pinia2._e.run(() => (scope = effectScope()).run(setup)));
  for (const key in setupStore) {
    const prop = setupStore[key];
    if (isRef(prop) && !isComputed(prop) || isReactive(prop)) {
      if (!isOptionsStore) {
        if (initialState && shouldHydrate(prop)) {
          if (isRef(prop)) {
            prop.value = initialState[key];
          } else {
            mergeReactiveObjects(prop, initialState[key]);
          }
        }
        {
          pinia2.state.value[$id][key] = prop;
        }
      }
    } else if (typeof prop === "function") {
      const actionValue = wrapAction(key, prop);
      {
        setupStore[key] = actionValue;
      }
      optionsForPlugin.actions[key] = prop;
    } else ;
  }
  {
    assign$2(store, setupStore);
    assign$2(toRaw(store), setupStore);
  }
  Object.defineProperty(store, "$state", {
    get: () => pinia2.state.value[$id],
    set: (state) => {
      $patch(($state) => {
        assign$2($state, state);
      });
    }
  });
  pinia2._p.forEach((extender) => {
    {
      assign$2(store, scope.run(() => extender({
        store,
        app: pinia2._a,
        pinia: pinia2,
        options: optionsForPlugin
      })));
    }
  });
  if (initialState && isOptionsStore && options.hydrate) {
    options.hydrate(store.$state, initialState);
  }
  isListening = true;
  isSyncListening = true;
  return store;
}
function defineStore(idOrOptions, setup, setupOptions) {
  let id2;
  let options;
  const isSetupStore = typeof setup === "function";
  {
    id2 = idOrOptions;
    options = isSetupStore ? setupOptions : setup;
  }
  function useStore(pinia2, hot) {
    const hasContext = hasInjectionContext();
    pinia2 = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    pinia2 || (hasContext ? inject(piniaSymbol, null) : null);
    if (pinia2)
      setActivePinia(pinia2);
    pinia2 = activePinia;
    if (!pinia2._s.has(id2)) {
      if (isSetupStore) {
        createSetupStore(id2, setup, options, pinia2);
      } else {
        createOptionsStore(id2, options, pinia2);
      }
    }
    const store = pinia2._s.get(id2);
    return store;
  }
  useStore.$id = id2;
  return useStore;
}
function isObject$2(v2) {
  return typeof v2 === "object" && v2 !== null;
}
function normalizeOptions(options, factoryOptions) {
  options = isObject$2(options) ? options : /* @__PURE__ */ Object.create(null);
  return new Proxy(options, {
    get(target2, key, receiver) {
      if (key === "key")
        return Reflect.get(target2, key, receiver);
      return Reflect.get(target2, key, receiver) || Reflect.get(factoryOptions, key, receiver);
    }
  });
}
function get(state, path) {
  return path.reduce((obj, p2) => {
    return obj == null ? void 0 : obj[p2];
  }, state);
}
function set(state, path, val) {
  return path.slice(0, -1).reduce((obj, p2) => {
    if (/^(__proto__)$/.test(p2))
      return {};
    else
      return obj[p2] = obj[p2] || {};
  }, state)[path[path.length - 1]] = val, state;
}
function pick$1(baseState, paths) {
  return paths.reduce((substate, path) => {
    const pathArray = path.split(".");
    return set(substate, pathArray, get(baseState, pathArray));
  }, {});
}
function parsePersistence(factoryOptions, store) {
  return (o2) => {
    var _a2;
    try {
      const {
        storage = localStorage,
        beforeRestore = void 0,
        afterRestore = void 0,
        serializer = {
          serialize: JSON.stringify,
          deserialize: JSON.parse
        },
        key = store.$id,
        paths = null,
        debug = false
      } = o2;
      return {
        storage,
        beforeRestore,
        afterRestore,
        serializer,
        key: ((_a2 = factoryOptions.key) != null ? _a2 : (k2) => k2)(typeof key == "string" ? key : key(store.$id)),
        paths,
        debug
      };
    } catch (e2) {
      if (o2.debug)
        console.error("[pinia-plugin-persistedstate]", e2);
      return null;
    }
  };
}
function hydrateStore(store, { storage, serializer, key, debug }) {
  try {
    const fromStorage = storage == null ? void 0 : storage.getItem(key);
    if (fromStorage)
      store.$patch(serializer == null ? void 0 : serializer.deserialize(fromStorage));
  } catch (e2) {
    if (debug)
      console.error("[pinia-plugin-persistedstate]", e2);
  }
}
function persistState(state, { storage, serializer, key, paths, debug }) {
  try {
    const toStore = Array.isArray(paths) ? pick$1(state, paths) : state;
    storage.setItem(key, serializer.serialize(toStore));
  } catch (e2) {
    if (debug)
      console.error("[pinia-plugin-persistedstate]", e2);
  }
}
function createPersistedState(factoryOptions = {}) {
  return (context) => {
    const { auto = false } = factoryOptions;
    const {
      options: { persist = auto },
      store,
      pinia: pinia2
    } = context;
    if (!persist)
      return;
    if (!(store.$id in pinia2.state.value)) {
      const original_store = pinia2._s.get(store.$id.replace("__hot:", ""));
      if (original_store)
        Promise.resolve().then(() => original_store.$persist());
      return;
    }
    const persistences = (Array.isArray(persist) ? persist.map((p2) => normalizeOptions(p2, factoryOptions)) : [normalizeOptions(persist, factoryOptions)]).map(parsePersistence(factoryOptions, store)).filter(Boolean);
    store.$persist = () => {
      persistences.forEach((persistence) => {
        persistState(store.$state, persistence);
      });
    };
    store.$hydrate = ({ runHooks = true } = {}) => {
      persistences.forEach((persistence) => {
        const { beforeRestore, afterRestore } = persistence;
        if (runHooks)
          beforeRestore == null ? void 0 : beforeRestore(context);
        hydrateStore(store, persistence);
        if (runHooks)
          afterRestore == null ? void 0 : afterRestore(context);
      });
    };
    persistences.forEach((persistence) => {
      const { beforeRestore, afterRestore } = persistence;
      beforeRestore == null ? void 0 : beforeRestore(context);
      hydrateStore(store, persistence);
      afterRestore == null ? void 0 : afterRestore(context);
      store.$subscribe(
        (_mutation, state) => {
          persistState(state, persistence);
        },
        {
          detached: true
        }
      );
    });
  };
}
const langEs = {
  isoName: "es",
  nativeName: "Español",
  label: {
    clear: "Borrar",
    ok: "OK",
    cancel: "Cancelar",
    close: "Cerrar",
    set: "Establecer",
    select: "Seleccionar",
    reset: "Restablecer",
    remove: "Eliminar",
    update: "Actualizar",
    create: "Crear",
    search: "Buscar",
    filter: "Filtrar",
    refresh: "Actualizar",
    expand: (label) => label ? `Expandir "${label}"` : "Expandir",
    collapse: (label) => label ? `Ocultar "${label}"` : "Colapsar"
  },
  date: {
    days: "Domingo_Lunes_Martes_Miércoles_Jueves_Viernes_Sábado".split("_"),
    daysShort: "Dom_Lun_Mar_Mié_Jue_Vie_Sáb".split("_"),
    months: "Enero_Febrero_Marzo_Abril_Mayo_Junio_Julio_Agosto_Septiembre_Octubre_Noviembre_Diciembre".split("_"),
    monthsShort: "Ene_Feb_Mar_Abr_May_Jun_Jul_Ago_Sep_Oct_Nov_Dic".split("_"),
    firstDayOfWeek: 1,
    // 0-6, 0 - Sunday, 1 Monday, ...
    format24h: true,
    pluralDay: "días"
  },
  table: {
    noData: "Sin datos disponibles",
    noResults: "No se han encontrado resultados",
    loading: "Cargando...",
    selectedRecords: (rows) => rows > 1 ? rows + " filas seleccionadas." : (rows === 0 ? "Sin" : "1") + " fila seleccionada.",
    recordsPerPage: "Filas por página:",
    allRows: "Todas",
    pagination: (start, end, total) => start + "-" + end + " de " + total,
    columns: "Columnas"
  },
  editor: {
    url: "URL",
    bold: "Negrita",
    italic: "Cursiva",
    strikethrough: "Tachada",
    underline: "Subrayada",
    unorderedList: "Lista Desordenada",
    orderedList: "Lista Ordenada",
    subscript: "Subíndice",
    superscript: "Superíndice",
    hyperlink: "Hipervínculo",
    toggleFullscreen: "Alternar pantalla completa",
    quote: "Cita",
    left: "Alineación izquierda",
    center: "Alineación centro",
    right: "Alineación derecha",
    justify: "Justificar alineación",
    print: "Imprimir",
    outdent: "Disminuir indentación",
    indent: "Aumentar indentación",
    removeFormat: "Eliminar formato",
    formatting: "Formato",
    fontSize: "Tamaño de Fuente",
    align: "Alinear",
    hr: "Insertar línea horizontal",
    undo: "Deshacer",
    redo: "Rehacer",
    heading1: "Encabezado 1",
    heading2: "Encabezado 2",
    heading3: "Encabezado 3",
    heading4: "Encabezado 4",
    heading5: "Encabezado 5",
    heading6: "Encabezado 6",
    paragraph: "Párrafo",
    code: "Código",
    size1: "Muy pequeño",
    size2: "Pequeño",
    size3: "Normal",
    size4: "Mediano",
    size5: "Grande",
    size6: "Muy grande",
    size7: "Máximo",
    defaultFont: "Fuente por defecto",
    viewSource: "Ver fuente"
  },
  tree: {
    noNodes: "No hay nodos disponibles",
    noResults: "No se encontraron los nodos correspondientes"
  }
};
function ei(_2) {
  return _2 && _2.__esModule && Object.prototype.hasOwnProperty.call(_2, "default") ? _2.default : _2;
}
var Ue = { exports: {} };
/*!
 * ApexCharts v3.45.2
 * (c) 2018-2024 ApexCharts
 * Released under the MIT License.
 */
(function(_2, Re) {
  function Ae(y2, e2) {
    var t2 = Object.keys(y2);
    if (Object.getOwnPropertySymbols) {
      var i = Object.getOwnPropertySymbols(y2);
      e2 && (i = i.filter(function(a2) {
        return Object.getOwnPropertyDescriptor(y2, a2).enumerable;
      })), t2.push.apply(t2, i);
    }
    return t2;
  }
  function X2(y2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t2 = arguments[e2] != null ? arguments[e2] : {};
      e2 % 2 ? Ae(Object(t2), true).forEach(function(i) {
        ee2(y2, i, t2[i]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(y2, Object.getOwnPropertyDescriptors(t2)) : Ae(Object(t2)).forEach(function(i) {
        Object.defineProperty(y2, i, Object.getOwnPropertyDescriptor(t2, i));
      });
    }
    return y2;
  }
  function U2(y2) {
    return U2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e2) {
      return typeof e2;
    } : function(e2) {
      return e2 && typeof Symbol == "function" && e2.constructor === Symbol && e2 !== Symbol.prototype ? "symbol" : typeof e2;
    }, U2(y2);
  }
  function F2(y2, e2) {
    if (!(y2 instanceof e2))
      throw new TypeError("Cannot call a class as a function");
  }
  function ce2(y2, e2) {
    for (var t2 = 0; t2 < e2.length; t2++) {
      var i = e2[t2];
      i.enumerable = i.enumerable || false, i.configurable = true, "value" in i && (i.writable = true), Object.defineProperty(y2, i.key, i);
    }
  }
  function Y2(y2, e2, t2) {
    return e2 && ce2(y2.prototype, e2), t2 && ce2(y2, t2), y2;
  }
  function ee2(y2, e2, t2) {
    return e2 in y2 ? Object.defineProperty(y2, e2, { value: t2, enumerable: true, configurable: true, writable: true }) : y2[e2] = t2, y2;
  }
  function ge2(y2, e2) {
    if (typeof e2 != "function" && e2 !== null)
      throw new TypeError("Super expression must either be null or a function");
    y2.prototype = Object.create(e2 && e2.prototype, { constructor: { value: y2, writable: true, configurable: true } }), e2 && Se(y2, e2);
  }
  function me2(y2) {
    return me2 = Object.setPrototypeOf ? Object.getPrototypeOf : function(e2) {
      return e2.__proto__ || Object.getPrototypeOf(e2);
    }, me2(y2);
  }
  function Se(y2, e2) {
    return Se = Object.setPrototypeOf || function(t2, i) {
      return t2.__proto__ = i, t2;
    }, Se(y2, e2);
  }
  function ze(y2) {
    if (y2 === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return y2;
  }
  function ue2(y2) {
    var e2 = function() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return false;
      if (typeof Proxy == "function")
        return true;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), true;
      } catch {
        return false;
      }
    }();
    return function() {
      var t2, i = me2(y2);
      if (e2) {
        var a2 = me2(this).constructor;
        t2 = Reflect.construct(i, arguments, a2);
      } else
        t2 = i.apply(this, arguments);
      return function(s2, r) {
        if (r && (typeof r == "object" || typeof r == "function"))
          return r;
        if (r !== void 0)
          throw new TypeError("Derived constructors may only return object or undefined");
        return ze(s2);
      }(this, t2);
    };
  }
  function Me(y2, e2) {
    return function(t2) {
      if (Array.isArray(t2))
        return t2;
    }(y2) || function(t2, i) {
      var a2 = t2 == null ? null : typeof Symbol < "u" && t2[Symbol.iterator] || t2["@@iterator"];
      if (a2 != null) {
        var s2, r, n2 = [], o2 = true, h2 = false;
        try {
          for (a2 = a2.call(t2); !(o2 = (s2 = a2.next()).done) && (n2.push(s2.value), !i || n2.length !== i); o2 = true)
            ;
        } catch (c2) {
          h2 = true, r = c2;
        } finally {
          try {
            o2 || a2.return == null || a2.return();
          } finally {
            if (h2)
              throw r;
          }
        }
        return n2;
      }
    }(y2, e2) || Xe(y2, e2) || function() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }();
  }
  function J2(y2) {
    return function(e2) {
      if (Array.isArray(e2))
        return Ce(e2);
    }(y2) || function(e2) {
      if (typeof Symbol < "u" && e2[Symbol.iterator] != null || e2["@@iterator"] != null)
        return Array.from(e2);
    }(y2) || Xe(y2) || function() {
      throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }();
  }
  function Xe(y2, e2) {
    if (y2) {
      if (typeof y2 == "string")
        return Ce(y2, e2);
      var t2 = Object.prototype.toString.call(y2).slice(8, -1);
      return t2 === "Object" && y2.constructor && (t2 = y2.constructor.name), t2 === "Map" || t2 === "Set" ? Array.from(y2) : t2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? Ce(y2, e2) : void 0;
    }
  }
  function Ce(y2, e2) {
    (e2 == null || e2 > y2.length) && (e2 = y2.length);
    for (var t2 = 0, i = new Array(e2); t2 < e2; t2++)
      i[t2] = y2[t2];
    return i;
  }
  var P2 = function() {
    function y2() {
      F2(this, y2);
    }
    return Y2(y2, [{ key: "shadeRGBColor", value: function(e2, t2) {
      var i = t2.split(","), a2 = e2 < 0 ? 0 : 255, s2 = e2 < 0 ? -1 * e2 : e2, r = parseInt(i[0].slice(4), 10), n2 = parseInt(i[1], 10), o2 = parseInt(i[2], 10);
      return "rgb(" + (Math.round((a2 - r) * s2) + r) + "," + (Math.round((a2 - n2) * s2) + n2) + "," + (Math.round((a2 - o2) * s2) + o2) + ")";
    } }, { key: "shadeHexColor", value: function(e2, t2) {
      var i = parseInt(t2.slice(1), 16), a2 = e2 < 0 ? 0 : 255, s2 = e2 < 0 ? -1 * e2 : e2, r = i >> 16, n2 = i >> 8 & 255, o2 = 255 & i;
      return "#" + (16777216 + 65536 * (Math.round((a2 - r) * s2) + r) + 256 * (Math.round((a2 - n2) * s2) + n2) + (Math.round((a2 - o2) * s2) + o2)).toString(16).slice(1);
    } }, { key: "shadeColor", value: function(e2, t2) {
      return y2.isColorHex(t2) ? this.shadeHexColor(e2, t2) : this.shadeRGBColor(e2, t2);
    } }], [{ key: "bind", value: function(e2, t2) {
      return function() {
        return e2.apply(t2, arguments);
      };
    } }, { key: "isObject", value: function(e2) {
      return e2 && U2(e2) === "object" && !Array.isArray(e2) && e2 != null;
    } }, { key: "is", value: function(e2, t2) {
      return Object.prototype.toString.call(t2) === "[object " + e2 + "]";
    } }, { key: "listToArray", value: function(e2) {
      var t2, i = [];
      for (t2 = 0; t2 < e2.length; t2++)
        i[t2] = e2[t2];
      return i;
    } }, { key: "extend", value: function(e2, t2) {
      var i = this;
      typeof Object.assign != "function" && (Object.assign = function(s2) {
        if (s2 == null)
          throw new TypeError("Cannot convert undefined or null to object");
        for (var r = Object(s2), n2 = 1; n2 < arguments.length; n2++) {
          var o2 = arguments[n2];
          if (o2 != null)
            for (var h2 in o2)
              o2.hasOwnProperty(h2) && (r[h2] = o2[h2]);
        }
        return r;
      });
      var a2 = Object.assign({}, e2);
      return this.isObject(e2) && this.isObject(t2) && Object.keys(t2).forEach(function(s2) {
        i.isObject(t2[s2]) && s2 in e2 ? a2[s2] = i.extend(e2[s2], t2[s2]) : Object.assign(a2, ee2({}, s2, t2[s2]));
      }), a2;
    } }, { key: "extendArray", value: function(e2, t2) {
      var i = [];
      return e2.map(function(a2) {
        i.push(y2.extend(t2, a2));
      }), e2 = i;
    } }, { key: "monthMod", value: function(e2) {
      return e2 % 12;
    } }, { key: "clone", value: function(e2) {
      if (y2.is("Array", e2)) {
        for (var t2 = [], i = 0; i < e2.length; i++)
          t2[i] = this.clone(e2[i]);
        return t2;
      }
      if (y2.is("Null", e2))
        return null;
      if (y2.is("Date", e2))
        return e2;
      if (U2(e2) === "object") {
        var a2 = {};
        for (var s2 in e2)
          e2.hasOwnProperty(s2) && (a2[s2] = this.clone(e2[s2]));
        return a2;
      }
      return e2;
    } }, { key: "log10", value: function(e2) {
      return Math.log(e2) / Math.LN10;
    } }, { key: "roundToBase10", value: function(e2) {
      return Math.pow(10, Math.floor(Math.log10(e2)));
    } }, { key: "roundToBase", value: function(e2, t2) {
      return Math.pow(t2, Math.floor(Math.log(e2) / Math.log(t2)));
    } }, { key: "parseNumber", value: function(e2) {
      return e2 === null ? e2 : parseFloat(e2);
    } }, { key: "stripNumber", value: function(e2) {
      var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
      return Number.isInteger(e2) ? e2 : parseFloat(e2.toPrecision(t2));
    } }, { key: "randomId", value: function() {
      return (Math.random() + 1).toString(36).substring(4);
    } }, { key: "noExponents", value: function(e2) {
      var t2 = String(e2).split(/[eE]/);
      if (t2.length === 1)
        return t2[0];
      var i = "", a2 = e2 < 0 ? "-" : "", s2 = t2[0].replace(".", ""), r = Number(t2[1]) + 1;
      if (r < 0) {
        for (i = a2 + "0."; r++; )
          i += "0";
        return i + s2.replace(/^-/, "");
      }
      for (r -= s2.length; r--; )
        i += "0";
      return s2 + i;
    } }, { key: "getDimensions", value: function(e2) {
      var t2 = getComputedStyle(e2, null), i = e2.clientHeight, a2 = e2.clientWidth;
      return i -= parseFloat(t2.paddingTop) + parseFloat(t2.paddingBottom), [a2 -= parseFloat(t2.paddingLeft) + parseFloat(t2.paddingRight), i];
    } }, { key: "getBoundingClientRect", value: function(e2) {
      var t2 = e2.getBoundingClientRect();
      return { top: t2.top, right: t2.right, bottom: t2.bottom, left: t2.left, width: e2.clientWidth, height: e2.clientHeight, x: t2.left, y: t2.top };
    } }, { key: "getLargestStringFromArr", value: function(e2) {
      return e2.reduce(function(t2, i) {
        return Array.isArray(i) && (i = i.reduce(function(a2, s2) {
          return a2.length > s2.length ? a2 : s2;
        })), t2.length > i.length ? t2 : i;
      }, 0);
    } }, { key: "hexToRgba", value: function() {
      var e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "#999999", t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.6;
      e2.substring(0, 1) !== "#" && (e2 = "#999999");
      var i = e2.replace("#", "");
      i = i.match(new RegExp("(.{" + i.length / 3 + "})", "g"));
      for (var a2 = 0; a2 < i.length; a2++)
        i[a2] = parseInt(i[a2].length === 1 ? i[a2] + i[a2] : i[a2], 16);
      return t2 !== void 0 && i.push(t2), "rgba(" + i.join(",") + ")";
    } }, { key: "getOpacityFromRGBA", value: function(e2) {
      return parseFloat(e2.replace(/^.*,(.+)\)/, "$1"));
    } }, { key: "rgb2hex", value: function(e2) {
      return (e2 = e2.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && e2.length === 4 ? "#" + ("0" + parseInt(e2[1], 10).toString(16)).slice(-2) + ("0" + parseInt(e2[2], 10).toString(16)).slice(-2) + ("0" + parseInt(e2[3], 10).toString(16)).slice(-2) : "";
    } }, { key: "isColorHex", value: function(e2) {
      return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(e2);
    } }, { key: "getPolygonPos", value: function(e2, t2) {
      for (var i = [], a2 = 2 * Math.PI / t2, s2 = 0; s2 < t2; s2++) {
        var r = {};
        r.x = e2 * Math.sin(s2 * a2), r.y = -e2 * Math.cos(s2 * a2), i.push(r);
      }
      return i;
    } }, { key: "polarToCartesian", value: function(e2, t2, i, a2) {
      var s2 = (a2 - 90) * Math.PI / 180;
      return { x: e2 + i * Math.cos(s2), y: t2 + i * Math.sin(s2) };
    } }, { key: "escapeString", value: function(e2) {
      var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "x", i = e2.toString().slice();
      return i = i.replace(/[` ~!@#$%^&*()|+\=?;:'",.<>{}[\]\\/]/gi, t2);
    } }, { key: "negToZero", value: function(e2) {
      return e2 < 0 ? 0 : e2;
    } }, { key: "moveIndexInArray", value: function(e2, t2, i) {
      if (i >= e2.length)
        for (var a2 = i - e2.length + 1; a2--; )
          e2.push(void 0);
      return e2.splice(i, 0, e2.splice(t2, 1)[0]), e2;
    } }, { key: "extractNumber", value: function(e2) {
      return parseFloat(e2.replace(/[^\d.]*/g, ""));
    } }, { key: "findAncestor", value: function(e2, t2) {
      for (; (e2 = e2.parentElement) && !e2.classList.contains(t2); )
        ;
      return e2;
    } }, { key: "setELstyles", value: function(e2, t2) {
      for (var i in t2)
        t2.hasOwnProperty(i) && (e2.style.key = t2[i]);
    } }, { key: "isNumber", value: function(e2) {
      return !isNaN(e2) && parseFloat(Number(e2)) === e2 && !isNaN(parseInt(e2, 10));
    } }, { key: "isFloat", value: function(e2) {
      return Number(e2) === e2 && e2 % 1 != 0;
    } }, { key: "isSafari", value: function() {
      return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    } }, { key: "isFirefox", value: function() {
      return navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
    } }, { key: "isIE11", value: function() {
      if (window.navigator.userAgent.indexOf("MSIE") !== -1 || window.navigator.appVersion.indexOf("Trident/") > -1)
        return true;
    } }, { key: "isIE", value: function() {
      var e2 = window.navigator.userAgent, t2 = e2.indexOf("MSIE ");
      if (t2 > 0)
        return parseInt(e2.substring(t2 + 5, e2.indexOf(".", t2)), 10);
      if (e2.indexOf("Trident/") > 0) {
        var i = e2.indexOf("rv:");
        return parseInt(e2.substring(i + 3, e2.indexOf(".", i)), 10);
      }
      var a2 = e2.indexOf("Edge/");
      return a2 > 0 && parseInt(e2.substring(a2 + 5, e2.indexOf(".", a2)), 10);
    } }]), y2;
  }(), de2 = function() {
    function y2(e2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w, this.setEasingFunctions();
    }
    return Y2(y2, [{ key: "setEasingFunctions", value: function() {
      var e2;
      if (!this.w.globals.easing) {
        switch (this.w.config.chart.animations.easing) {
          case "linear":
            e2 = "-";
            break;
          case "easein":
            e2 = "<";
            break;
          case "easeout":
            e2 = ">";
            break;
          case "easeinout":
          default:
            e2 = "<>";
            break;
          case "swing":
            e2 = function(t2) {
              var i = 1.70158;
              return (t2 -= 1) * t2 * ((i + 1) * t2 + i) + 1;
            };
            break;
          case "bounce":
            e2 = function(t2) {
              return t2 < 1 / 2.75 ? 7.5625 * t2 * t2 : t2 < 2 / 2.75 ? 7.5625 * (t2 -= 1.5 / 2.75) * t2 + 0.75 : t2 < 2.5 / 2.75 ? 7.5625 * (t2 -= 2.25 / 2.75) * t2 + 0.9375 : 7.5625 * (t2 -= 2.625 / 2.75) * t2 + 0.984375;
            };
            break;
          case "elastic":
            e2 = function(t2) {
              return t2 === !!t2 ? t2 : Math.pow(2, -10 * t2) * Math.sin((t2 - 0.075) * (2 * Math.PI) / 0.3) + 1;
            };
        }
        this.w.globals.easing = e2;
      }
    } }, { key: "animateLine", value: function(e2, t2, i, a2) {
      e2.attr(t2).animate(a2).attr(i);
    } }, { key: "animateMarker", value: function(e2, t2, i, a2, s2, r) {
      t2 || (t2 = 0), e2.attr({ r: t2, width: t2, height: t2 }).animate(a2, s2).attr({ r: i, width: i.width, height: i.height }).afterAll(function() {
        r();
      });
    } }, { key: "animateCircle", value: function(e2, t2, i, a2, s2) {
      e2.attr({ r: t2.r, cx: t2.cx, cy: t2.cy }).animate(a2, s2).attr({ r: i.r, cx: i.cx, cy: i.cy });
    } }, { key: "animateRect", value: function(e2, t2, i, a2, s2) {
      e2.attr(t2).animate(a2).attr(i).afterAll(function() {
        return s2();
      });
    } }, { key: "animatePathsGradually", value: function(e2) {
      var t2 = e2.el, i = e2.realIndex, a2 = e2.j, s2 = e2.fill, r = e2.pathFrom, n2 = e2.pathTo, o2 = e2.speed, h2 = e2.delay, c2 = this.w, d2 = 0;
      c2.config.chart.animations.animateGradually.enabled && (d2 = c2.config.chart.animations.animateGradually.delay), c2.config.chart.animations.dynamicAnimation.enabled && c2.globals.dataChanged && c2.config.chart.type !== "bar" && (d2 = 0), this.morphSVG(t2, i, a2, c2.config.chart.type !== "line" || c2.globals.comboCharts ? s2 : "stroke", r, n2, o2, h2 * d2);
    } }, { key: "showDelayedElements", value: function() {
      this.w.globals.delayedElements.forEach(function(e2) {
        var t2 = e2.el;
        t2.classList.remove("apexcharts-element-hidden"), t2.classList.add("apexcharts-hidden-element-shown");
      });
    } }, { key: "animationCompleted", value: function(e2) {
      var t2 = this.w;
      t2.globals.animationEnded || (t2.globals.animationEnded = true, this.showDelayedElements(), typeof t2.config.chart.events.animationEnd == "function" && t2.config.chart.events.animationEnd(this.ctx, { el: e2, w: t2 }));
    } }, { key: "morphSVG", value: function(e2, t2, i, a2, s2, r, n2, o2) {
      var h2 = this, c2 = this.w;
      s2 || (s2 = e2.attr("pathFrom")), r || (r = e2.attr("pathTo"));
      var d2 = function(g2) {
        return c2.config.chart.type === "radar" && (n2 = 1), "M 0 ".concat(c2.globals.gridHeight);
      };
      (!s2 || s2.indexOf("undefined") > -1 || s2.indexOf("NaN") > -1) && (s2 = d2()), (!r || r.indexOf("undefined") > -1 || r.indexOf("NaN") > -1) && (r = d2()), c2.globals.shouldAnimate || (n2 = 1), e2.plot(s2).animate(1, c2.globals.easing, o2).plot(s2).animate(n2, c2.globals.easing, o2).plot(r).afterAll(function() {
        P2.isNumber(i) ? i === c2.globals.series[c2.globals.maxValsInArrayIndex].length - 2 && c2.globals.shouldAnimate && h2.animationCompleted(e2) : a2 !== "none" && c2.globals.shouldAnimate && (!c2.globals.comboCharts && t2 === c2.globals.series.length - 1 || c2.globals.comboCharts) && h2.animationCompleted(e2), h2.showDelayedElements();
      });
    } }]), y2;
  }(), Z2 = function() {
    function y2(e2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w;
    }
    return Y2(y2, [{ key: "getDefaultFilter", value: function(e2, t2) {
      var i = this.w;
      e2.unfilter(true), new window.SVG.Filter().size("120%", "180%", "-5%", "-40%"), i.config.states.normal.filter !== "none" ? this.applyFilter(e2, t2, i.config.states.normal.filter.type, i.config.states.normal.filter.value) : i.config.chart.dropShadow.enabled && this.dropShadow(e2, i.config.chart.dropShadow, t2);
    } }, { key: "addNormalFilter", value: function(e2, t2) {
      var i = this.w;
      i.config.chart.dropShadow.enabled && !e2.node.classList.contains("apexcharts-marker") && this.dropShadow(e2, i.config.chart.dropShadow, t2);
    } }, { key: "addLightenFilter", value: function(e2, t2, i) {
      var a2 = this, s2 = this.w, r = i.intensity;
      e2.unfilter(true), new window.SVG.Filter(), e2.filter(function(n2) {
        var o2 = s2.config.chart.dropShadow;
        (o2.enabled ? a2.addShadow(n2, t2, o2) : n2).componentTransfer({ rgb: { type: "linear", slope: 1.5, intercept: r } });
      }), e2.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(e2.filterer.node);
    } }, { key: "addDarkenFilter", value: function(e2, t2, i) {
      var a2 = this, s2 = this.w, r = i.intensity;
      e2.unfilter(true), new window.SVG.Filter(), e2.filter(function(n2) {
        var o2 = s2.config.chart.dropShadow;
        (o2.enabled ? a2.addShadow(n2, t2, o2) : n2).componentTransfer({ rgb: { type: "linear", slope: r } });
      }), e2.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(e2.filterer.node);
    } }, { key: "applyFilter", value: function(e2, t2, i) {
      var a2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0.5;
      switch (i) {
        case "none":
          this.addNormalFilter(e2, t2);
          break;
        case "lighten":
          this.addLightenFilter(e2, t2, { intensity: a2 });
          break;
        case "darken":
          this.addDarkenFilter(e2, t2, { intensity: a2 });
      }
    } }, { key: "addShadow", value: function(e2, t2, i) {
      var a2 = i.blur, s2 = i.top, r = i.left, n2 = i.color, o2 = i.opacity, h2 = e2.flood(Array.isArray(n2) ? n2[t2] : n2, o2).composite(e2.sourceAlpha, "in").offset(r, s2).gaussianBlur(a2).merge(e2.source);
      return e2.blend(e2.source, h2);
    } }, { key: "dropShadow", value: function(e2, t2) {
      var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, a2 = t2.top, s2 = t2.left, r = t2.blur, n2 = t2.color, o2 = t2.opacity, h2 = t2.noUserSpaceOnUse, c2 = this.w;
      return e2.unfilter(true), P2.isIE() && c2.config.chart.type === "radialBar" || (n2 = Array.isArray(n2) ? n2[i] : n2, e2.filter(function(d2) {
        var g2 = null;
        g2 = P2.isSafari() || P2.isFirefox() || P2.isIE() ? d2.flood(n2, o2).composite(d2.sourceAlpha, "in").offset(s2, a2).gaussianBlur(r) : d2.flood(n2, o2).composite(d2.sourceAlpha, "in").offset(s2, a2).gaussianBlur(r).merge(d2.source), d2.blend(d2.source, g2);
      }), h2 || e2.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(e2.filterer.node)), e2;
    } }, { key: "setSelectionFilter", value: function(e2, t2, i) {
      var a2 = this.w;
      if (a2.globals.selectedDataPoints[t2] !== void 0 && a2.globals.selectedDataPoints[t2].indexOf(i) > -1) {
        e2.node.setAttribute("selected", true);
        var s2 = a2.config.states.active.filter;
        s2 !== "none" && this.applyFilter(e2, t2, s2.type, s2.value);
      }
    } }, { key: "_scaleFilterSize", value: function(e2) {
      (function(t2) {
        for (var i in t2)
          t2.hasOwnProperty(i) && e2.setAttribute(i, t2[i]);
      })({ width: "200%", height: "200%", x: "-50%", y: "-50%" });
    } }]), y2;
  }(), M2 = function() {
    function y2(e2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w;
    }
    return Y2(y2, [{ key: "roundPathCorners", value: function(e2, t2) {
      function i(S2, C2, L2) {
        var I2 = C2.x - S2.x, z2 = C2.y - S2.y, T2 = Math.sqrt(I2 * I2 + z2 * z2);
        return a2(S2, C2, Math.min(1, L2 / T2));
      }
      function a2(S2, C2, L2) {
        return { x: S2.x + (C2.x - S2.x) * L2, y: S2.y + (C2.y - S2.y) * L2 };
      }
      function s2(S2, C2) {
        S2.length > 2 && (S2[S2.length - 2] = C2.x, S2[S2.length - 1] = C2.y);
      }
      function r(S2) {
        return { x: parseFloat(S2[S2.length - 2]), y: parseFloat(S2[S2.length - 1]) };
      }
      e2.indexOf("NaN") > -1 && (e2 = "");
      var n2 = e2.split(/[,\s]/).reduce(function(S2, C2) {
        var L2 = C2.match("([a-zA-Z])(.+)");
        return L2 ? (S2.push(L2[1]), S2.push(L2[2])) : S2.push(C2), S2;
      }, []).reduce(function(S2, C2) {
        return parseFloat(C2) == C2 && S2.length ? S2[S2.length - 1].push(C2) : S2.push([C2]), S2;
      }, []), o2 = [];
      if (n2.length > 1) {
        var h2 = r(n2[0]), c2 = null;
        n2[n2.length - 1][0] == "Z" && n2[0].length > 2 && (c2 = ["L", h2.x, h2.y], n2[n2.length - 1] = c2), o2.push(n2[0]);
        for (var d2 = 1; d2 < n2.length; d2++) {
          var g2 = o2[o2.length - 1], p2 = n2[d2], f2 = p2 == c2 ? n2[1] : n2[d2 + 1];
          if (f2 && g2 && g2.length > 2 && p2[0] == "L" && f2.length > 2 && f2[0] == "L") {
            var b2, m2, w2 = r(g2), A2 = r(p2), l2 = r(f2);
            b2 = i(A2, w2, t2), m2 = i(A2, l2, t2), s2(p2, b2), p2.origPoint = A2, o2.push(p2);
            var u2 = a2(b2, A2, 0.5), x2 = a2(A2, m2, 0.5), v2 = ["C", u2.x, u2.y, x2.x, x2.y, m2.x, m2.y];
            v2.origPoint = A2, o2.push(v2);
          } else
            o2.push(p2);
        }
        if (c2) {
          var k2 = r(o2[o2.length - 1]);
          o2.push(["Z"]), s2(o2[0], k2);
        }
      } else
        o2 = n2;
      return o2.reduce(function(S2, C2) {
        return S2 + C2.join(" ") + " ";
      }, "");
    } }, { key: "drawLine", value: function(e2, t2, i, a2) {
      var s2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "#a8a8a8", r = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0, n2 = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null, o2 = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : "butt";
      return this.w.globals.dom.Paper.line().attr({ x1: e2, y1: t2, x2: i, y2: a2, stroke: s2, "stroke-dasharray": r, "stroke-width": n2, "stroke-linecap": o2 });
    } }, { key: "drawRect", value: function() {
      var e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, a2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, s2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0, r = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "#fefefe", n2 = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 1, o2 = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : null, h2 = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : null, c2 = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : 0, d2 = this.w.globals.dom.Paper.rect();
      return d2.attr({ x: e2, y: t2, width: i > 0 ? i : 0, height: a2 > 0 ? a2 : 0, rx: s2, ry: s2, opacity: n2, "stroke-width": o2 !== null ? o2 : 0, stroke: h2 !== null ? h2 : "none", "stroke-dasharray": c2 }), d2.node.setAttribute("fill", r), d2;
    } }, { key: "drawPolygon", value: function(e2) {
      var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "#e1e1e1", i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, a2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "none";
      return this.w.globals.dom.Paper.polygon(e2).attr({ fill: a2, stroke: t2, "stroke-width": i });
    } }, { key: "drawCircle", value: function(e2) {
      var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      e2 < 0 && (e2 = 0);
      var i = this.w.globals.dom.Paper.circle(2 * e2);
      return t2 !== null && i.attr(t2), i;
    } }, { key: "drawPath", value: function(e2) {
      var t2 = e2.d, i = t2 === void 0 ? "" : t2, a2 = e2.stroke, s2 = a2 === void 0 ? "#a8a8a8" : a2, r = e2.strokeWidth, n2 = r === void 0 ? 1 : r, o2 = e2.fill, h2 = e2.fillOpacity, c2 = h2 === void 0 ? 1 : h2, d2 = e2.strokeOpacity, g2 = d2 === void 0 ? 1 : d2, p2 = e2.classes, f2 = e2.strokeLinecap, b2 = f2 === void 0 ? null : f2, m2 = e2.strokeDashArray, w2 = m2 === void 0 ? 0 : m2, A2 = this.w;
      return b2 === null && (b2 = A2.config.stroke.lineCap), (i.indexOf("undefined") > -1 || i.indexOf("NaN") > -1) && (i = "M 0 ".concat(A2.globals.gridHeight)), A2.globals.dom.Paper.path(i).attr({ fill: o2, "fill-opacity": c2, stroke: s2, "stroke-opacity": g2, "stroke-linecap": b2, "stroke-width": n2, "stroke-dasharray": w2, class: p2 });
    } }, { key: "group", value: function() {
      var e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t2 = this.w.globals.dom.Paper.group();
      return e2 !== null && t2.attr(e2), t2;
    } }, { key: "move", value: function(e2, t2) {
      var i = ["M", e2, t2].join(" ");
      return i;
    } }, { key: "line", value: function(e2, t2) {
      var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, a2 = null;
      return i === null ? a2 = [" L", e2, t2].join(" ") : i === "H" ? a2 = [" H", e2].join(" ") : i === "V" && (a2 = [" V", t2].join(" ")), a2;
    } }, { key: "curve", value: function(e2, t2, i, a2, s2, r) {
      var n2 = ["C", e2, t2, i, a2, s2, r].join(" ");
      return n2;
    } }, { key: "quadraticCurve", value: function(e2, t2, i, a2) {
      return ["Q", e2, t2, i, a2].join(" ");
    } }, { key: "arc", value: function(e2, t2, i, a2, s2, r, n2) {
      var o2 = "A";
      arguments.length > 7 && arguments[7] !== void 0 && arguments[7] && (o2 = "a");
      var h2 = [o2, e2, t2, i, a2, s2, r, n2].join(" ");
      return h2;
    } }, { key: "renderPaths", value: function(e2) {
      var t2, i = e2.j, a2 = e2.realIndex, s2 = e2.pathFrom, r = e2.pathTo, n2 = e2.stroke, o2 = e2.strokeWidth, h2 = e2.strokeLinecap, c2 = e2.fill, d2 = e2.animationDelay, g2 = e2.initialSpeed, p2 = e2.dataChangeSpeed, f2 = e2.className, b2 = e2.shouldClipToGrid, m2 = b2 === void 0 || b2, w2 = e2.bindEventsOnPaths, A2 = w2 === void 0 || w2, l2 = e2.drawShadow, u2 = l2 === void 0 || l2, x2 = this.w, v2 = new Z2(this.ctx), k2 = new de2(this.ctx), S2 = this.w.config.chart.animations.enabled, C2 = S2 && this.w.config.chart.animations.dynamicAnimation.enabled, L2 = !!(S2 && !x2.globals.resized || C2 && x2.globals.dataChanged && x2.globals.shouldAnimate);
      L2 ? t2 = s2 : (t2 = r, x2.globals.animationEnded = true);
      var I2 = x2.config.stroke.dashArray, z2 = 0;
      z2 = Array.isArray(I2) ? I2[a2] : x2.config.stroke.dashArray;
      var T2 = this.drawPath({ d: t2, stroke: n2, strokeWidth: o2, fill: c2, fillOpacity: 1, classes: f2, strokeLinecap: h2, strokeDashArray: z2 });
      if (T2.attr("index", a2), m2 && T2.attr({ "clip-path": "url(#gridRectMask".concat(x2.globals.cuid, ")") }), x2.config.states.normal.filter.type !== "none")
        v2.getDefaultFilter(T2, a2);
      else if (x2.config.chart.dropShadow.enabled && u2 && (!x2.config.chart.dropShadow.enabledOnSeries || x2.config.chart.dropShadow.enabledOnSeries && x2.config.chart.dropShadow.enabledOnSeries.indexOf(a2) !== -1)) {
        var E2 = x2.config.chart.dropShadow;
        v2.dropShadow(T2, E2, a2);
      }
      A2 && (T2.node.addEventListener("mouseenter", this.pathMouseEnter.bind(this, T2)), T2.node.addEventListener("mouseleave", this.pathMouseLeave.bind(this, T2)), T2.node.addEventListener("mousedown", this.pathMouseDown.bind(this, T2))), T2.attr({ pathTo: r, pathFrom: s2 });
      var R2 = { el: T2, j: i, realIndex: a2, pathFrom: s2, pathTo: r, fill: c2, strokeWidth: o2, delay: d2 };
      return !S2 || x2.globals.resized || x2.globals.dataChanged ? !x2.globals.resized && x2.globals.dataChanged || k2.showDelayedElements() : k2.animatePathsGradually(X2(X2({}, R2), {}, { speed: g2 })), x2.globals.dataChanged && C2 && L2 && k2.animatePathsGradually(X2(X2({}, R2), {}, { speed: p2 })), T2;
    } }, { key: "drawPattern", value: function(e2, t2, i) {
      var a2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "#a8a8a8", s2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
      return this.w.globals.dom.Paper.pattern(t2, i, function(r) {
        e2 === "horizontalLines" ? r.line(0, 0, i, 0).stroke({ color: a2, width: s2 + 1 }) : e2 === "verticalLines" ? r.line(0, 0, 0, t2).stroke({ color: a2, width: s2 + 1 }) : e2 === "slantedLines" ? r.line(0, 0, t2, i).stroke({ color: a2, width: s2 }) : e2 === "squares" ? r.rect(t2, i).fill("none").stroke({ color: a2, width: s2 }) : e2 === "circles" && r.circle(t2).fill("none").stroke({ color: a2, width: s2 });
      });
    } }, { key: "drawGradient", value: function(e2, t2, i, a2, s2) {
      var r, n2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null, o2 = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null, h2 = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : null, c2 = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : 0, d2 = this.w;
      t2.length < 9 && t2.indexOf("#") === 0 && (t2 = P2.hexToRgba(t2, a2)), i.length < 9 && i.indexOf("#") === 0 && (i = P2.hexToRgba(i, s2));
      var g2 = 0, p2 = 1, f2 = 1, b2 = null;
      o2 !== null && (g2 = o2[0] !== void 0 ? o2[0] / 100 : 0, p2 = o2[1] !== void 0 ? o2[1] / 100 : 1, f2 = o2[2] !== void 0 ? o2[2] / 100 : 1, b2 = o2[3] !== void 0 ? o2[3] / 100 : null);
      var m2 = !(d2.config.chart.type !== "donut" && d2.config.chart.type !== "pie" && d2.config.chart.type !== "polarArea" && d2.config.chart.type !== "bubble");
      if (r = h2 === null || h2.length === 0 ? d2.globals.dom.Paper.gradient(m2 ? "radial" : "linear", function(l2) {
        l2.at(g2, t2, a2), l2.at(p2, i, s2), l2.at(f2, i, s2), b2 !== null && l2.at(b2, t2, a2);
      }) : d2.globals.dom.Paper.gradient(m2 ? "radial" : "linear", function(l2) {
        (Array.isArray(h2[c2]) ? h2[c2] : h2).forEach(function(u2) {
          l2.at(u2.offset / 100, u2.color, u2.opacity);
        });
      }), m2) {
        var w2 = d2.globals.gridWidth / 2, A2 = d2.globals.gridHeight / 2;
        d2.config.chart.type !== "bubble" ? r.attr({ gradientUnits: "userSpaceOnUse", cx: w2, cy: A2, r: n2 }) : r.attr({ cx: 0.5, cy: 0.5, r: 0.8, fx: 0.2, fy: 0.2 });
      } else
        e2 === "vertical" ? r.from(0, 0).to(0, 1) : e2 === "diagonal" ? r.from(0, 0).to(1, 1) : e2 === "horizontal" ? r.from(0, 1).to(1, 1) : e2 === "diagonal2" && r.from(1, 0).to(0, 1);
      return r;
    } }, { key: "getTextBasedOnMaxWidth", value: function(e2) {
      var t2 = e2.text, i = e2.maxWidth, a2 = e2.fontSize, s2 = e2.fontFamily, r = this.getTextRects(t2, a2, s2), n2 = r.width / t2.length, o2 = Math.floor(i / n2);
      return i < r.width ? t2.slice(0, o2 - 3) + "..." : t2;
    } }, { key: "drawText", value: function(e2) {
      var t2 = this, i = e2.x, a2 = e2.y, s2 = e2.text, r = e2.textAnchor, n2 = e2.fontSize, o2 = e2.fontFamily, h2 = e2.fontWeight, c2 = e2.foreColor, d2 = e2.opacity, g2 = e2.maxWidth, p2 = e2.cssClass, f2 = p2 === void 0 ? "" : p2, b2 = e2.isPlainText, m2 = b2 === void 0 || b2, w2 = e2.dominantBaseline, A2 = w2 === void 0 ? "auto" : w2, l2 = this.w;
      s2 === void 0 && (s2 = "");
      var u2 = s2;
      r || (r = "start"), c2 && c2.length || (c2 = l2.config.chart.foreColor), o2 = o2 || l2.config.chart.fontFamily, h2 = h2 || "regular";
      var x2, v2 = { maxWidth: g2, fontSize: n2 = n2 || "11px", fontFamily: o2 };
      return Array.isArray(s2) ? x2 = l2.globals.dom.Paper.text(function(k2) {
        for (var S2 = 0; S2 < s2.length; S2++)
          u2 = s2[S2], g2 && (u2 = t2.getTextBasedOnMaxWidth(X2({ text: s2[S2] }, v2))), S2 === 0 ? k2.tspan(u2) : k2.tspan(u2).newLine();
      }) : (g2 && (u2 = this.getTextBasedOnMaxWidth(X2({ text: s2 }, v2))), x2 = m2 ? l2.globals.dom.Paper.plain(s2) : l2.globals.dom.Paper.text(function(k2) {
        return k2.tspan(u2);
      })), x2.attr({ x: i, y: a2, "text-anchor": r, "dominant-baseline": A2, "font-size": n2, "font-family": o2, "font-weight": h2, fill: c2, class: "apexcharts-text " + f2 }), x2.node.style.fontFamily = o2, x2.node.style.opacity = d2, x2;
    } }, { key: "drawMarker", value: function(e2, t2, i) {
      e2 = e2 || 0;
      var a2 = i.pSize || 0, s2 = null;
      if (i.shape === "square" || i.shape === "rect") {
        var r = i.pRadius === void 0 ? a2 / 2 : i.pRadius;
        t2 !== null && a2 || (a2 = 0, r = 0);
        var n2 = 1.2 * a2 + r, o2 = this.drawRect(n2, n2, n2, n2, r);
        o2.attr({ x: e2 - n2 / 2, y: t2 - n2 / 2, cx: e2, cy: t2, class: i.class ? i.class : "", fill: i.pointFillColor, "fill-opacity": i.pointFillOpacity ? i.pointFillOpacity : 1, stroke: i.pointStrokeColor, "stroke-width": i.pointStrokeWidth ? i.pointStrokeWidth : 0, "stroke-opacity": i.pointStrokeOpacity ? i.pointStrokeOpacity : 1 }), s2 = o2;
      } else
        i.shape !== "circle" && i.shape || (P2.isNumber(t2) || (a2 = 0, t2 = 0), s2 = this.drawCircle(a2, { cx: e2, cy: t2, class: i.class ? i.class : "", stroke: i.pointStrokeColor, fill: i.pointFillColor, "fill-opacity": i.pointFillOpacity ? i.pointFillOpacity : 1, "stroke-width": i.pointStrokeWidth ? i.pointStrokeWidth : 0, "stroke-opacity": i.pointStrokeOpacity ? i.pointStrokeOpacity : 1 }));
      return s2;
    } }, { key: "pathMouseEnter", value: function(e2, t2) {
      var i = this.w, a2 = new Z2(this.ctx), s2 = parseInt(e2.node.getAttribute("index"), 10), r = parseInt(e2.node.getAttribute("j"), 10);
      if (typeof i.config.chart.events.dataPointMouseEnter == "function" && i.config.chart.events.dataPointMouseEnter(t2, this.ctx, { seriesIndex: s2, dataPointIndex: r, w: i }), this.ctx.events.fireEvent("dataPointMouseEnter", [t2, this.ctx, { seriesIndex: s2, dataPointIndex: r, w: i }]), (i.config.states.active.filter.type === "none" || e2.node.getAttribute("selected") !== "true") && i.config.states.hover.filter.type !== "none" && !i.globals.isTouchDevice) {
        var n2 = i.config.states.hover.filter;
        a2.applyFilter(e2, s2, n2.type, n2.value);
      }
    } }, { key: "pathMouseLeave", value: function(e2, t2) {
      var i = this.w, a2 = new Z2(this.ctx), s2 = parseInt(e2.node.getAttribute("index"), 10), r = parseInt(e2.node.getAttribute("j"), 10);
      typeof i.config.chart.events.dataPointMouseLeave == "function" && i.config.chart.events.dataPointMouseLeave(t2, this.ctx, { seriesIndex: s2, dataPointIndex: r, w: i }), this.ctx.events.fireEvent("dataPointMouseLeave", [t2, this.ctx, { seriesIndex: s2, dataPointIndex: r, w: i }]), i.config.states.active.filter.type !== "none" && e2.node.getAttribute("selected") === "true" || i.config.states.hover.filter.type !== "none" && a2.getDefaultFilter(e2, s2);
    } }, { key: "pathMouseDown", value: function(e2, t2) {
      var i = this.w, a2 = new Z2(this.ctx), s2 = parseInt(e2.node.getAttribute("index"), 10), r = parseInt(e2.node.getAttribute("j"), 10), n2 = "false";
      if (e2.node.getAttribute("selected") === "true") {
        if (e2.node.setAttribute("selected", "false"), i.globals.selectedDataPoints[s2].indexOf(r) > -1) {
          var o2 = i.globals.selectedDataPoints[s2].indexOf(r);
          i.globals.selectedDataPoints[s2].splice(o2, 1);
        }
      } else {
        if (!i.config.states.active.allowMultipleDataPointsSelection && i.globals.selectedDataPoints.length > 0) {
          i.globals.selectedDataPoints = [];
          var h2 = i.globals.dom.Paper.select(".apexcharts-series path").members, c2 = i.globals.dom.Paper.select(".apexcharts-series circle, .apexcharts-series rect").members, d2 = function(f2) {
            Array.prototype.forEach.call(f2, function(b2) {
              b2.node.setAttribute("selected", "false"), a2.getDefaultFilter(b2, s2);
            });
          };
          d2(h2), d2(c2);
        }
        e2.node.setAttribute("selected", "true"), n2 = "true", i.globals.selectedDataPoints[s2] === void 0 && (i.globals.selectedDataPoints[s2] = []), i.globals.selectedDataPoints[s2].push(r);
      }
      if (n2 === "true") {
        var g2 = i.config.states.active.filter;
        if (g2 !== "none")
          a2.applyFilter(e2, s2, g2.type, g2.value);
        else if (i.config.states.hover.filter !== "none" && !i.globals.isTouchDevice) {
          var p2 = i.config.states.hover.filter;
          a2.applyFilter(e2, s2, p2.type, p2.value);
        }
      } else
        i.config.states.active.filter.type !== "none" && (i.config.states.hover.filter.type === "none" || i.globals.isTouchDevice ? a2.getDefaultFilter(e2, s2) : (p2 = i.config.states.hover.filter, a2.applyFilter(e2, s2, p2.type, p2.value)));
      typeof i.config.chart.events.dataPointSelection == "function" && i.config.chart.events.dataPointSelection(t2, this.ctx, { selectedDataPoints: i.globals.selectedDataPoints, seriesIndex: s2, dataPointIndex: r, w: i }), t2 && this.ctx.events.fireEvent("dataPointSelection", [t2, this.ctx, { selectedDataPoints: i.globals.selectedDataPoints, seriesIndex: s2, dataPointIndex: r, w: i }]);
    } }, { key: "rotateAroundCenter", value: function(e2) {
      var t2 = {};
      return e2 && typeof e2.getBBox == "function" && (t2 = e2.getBBox()), { x: t2.x + t2.width / 2, y: t2.y + t2.height / 2 };
    } }, { key: "getTextRects", value: function(e2, t2, i, a2) {
      var s2 = !(arguments.length > 4 && arguments[4] !== void 0) || arguments[4], r = this.w, n2 = this.drawText({ x: -200, y: -200, text: e2, textAnchor: "start", fontSize: t2, fontFamily: i, foreColor: "#fff", opacity: 0 });
      a2 && n2.attr("transform", a2), r.globals.dom.Paper.add(n2);
      var o2 = n2.bbox();
      return s2 || (o2 = n2.node.getBoundingClientRect()), n2.remove(), { width: o2.width, height: o2.height };
    } }, { key: "placeTextWithEllipsis", value: function(e2, t2, i) {
      if (typeof e2.getComputedTextLength == "function" && (e2.textContent = t2, t2.length > 0 && e2.getComputedTextLength() >= i / 1.1)) {
        for (var a2 = t2.length - 3; a2 > 0; a2 -= 3)
          if (e2.getSubStringLength(0, a2) <= i / 1.1)
            return void (e2.textContent = t2.substring(0, a2) + "...");
        e2.textContent = ".";
      }
    } }], [{ key: "setAttrs", value: function(e2, t2) {
      for (var i in t2)
        t2.hasOwnProperty(i) && e2.setAttribute(i, t2[i]);
    } }]), y2;
  }(), q2 = function() {
    function y2(e2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w;
    }
    return Y2(y2, [{ key: "getStackedSeriesTotals", value: function() {
      var e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t2 = this.w, i = [];
      if (t2.globals.series.length === 0)
        return i;
      for (var a2 = 0; a2 < t2.globals.series[t2.globals.maxValsInArrayIndex].length; a2++) {
        for (var s2 = 0, r = 0; r < t2.globals.series.length; r++)
          t2.globals.series[r][a2] !== void 0 && e2.indexOf(r) === -1 && (s2 += t2.globals.series[r][a2]);
        i.push(s2);
      }
      return i;
    } }, { key: "getSeriesTotalByIndex", value: function() {
      var e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      return e2 === null ? this.w.config.series.reduce(function(t2, i) {
        return t2 + i;
      }, 0) : this.w.globals.series[e2].reduce(function(t2, i) {
        return t2 + i;
      }, 0);
    } }, { key: "getStackedSeriesTotalsByGroups", value: function() {
      var e2 = this, t2 = this.w, i = [];
      return t2.globals.seriesGroups.forEach(function(a2) {
        var s2 = [];
        t2.config.series.forEach(function(n2, o2) {
          a2.indexOf(n2.name) > -1 && s2.push(o2);
        });
        var r = t2.globals.series.map(function(n2, o2) {
          return s2.indexOf(o2) === -1 ? o2 : -1;
        }).filter(function(n2) {
          return n2 !== -1;
        });
        i.push(e2.getStackedSeriesTotals(r));
      }), i;
    } }, { key: "isSeriesNull", value: function() {
      var e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      return (e2 === null ? this.w.config.series.filter(function(t2) {
        return t2 !== null;
      }) : this.w.config.series[e2].data.filter(function(t2) {
        return t2 !== null;
      })).length === 0;
    } }, { key: "seriesHaveSameValues", value: function(e2) {
      return this.w.globals.series[e2].every(function(t2, i, a2) {
        return t2 === a2[0];
      });
    } }, { key: "getCategoryLabels", value: function(e2) {
      var t2 = this.w, i = e2.slice();
      return t2.config.xaxis.convertedCatToNumeric && (i = e2.map(function(a2, s2) {
        return t2.config.xaxis.labels.formatter(a2 - t2.globals.minX + 1);
      })), i;
    } }, { key: "getLargestSeries", value: function() {
      var e2 = this.w;
      e2.globals.maxValsInArrayIndex = e2.globals.series.map(function(t2) {
        return t2.length;
      }).indexOf(Math.max.apply(Math, e2.globals.series.map(function(t2) {
        return t2.length;
      })));
    } }, { key: "getLargestMarkerSize", value: function() {
      var e2 = this.w, t2 = 0;
      return e2.globals.markers.size.forEach(function(i) {
        t2 = Math.max(t2, i);
      }), e2.config.markers.discrete && e2.config.markers.discrete.length && e2.config.markers.discrete.forEach(function(i) {
        t2 = Math.max(t2, i.size);
      }), t2 > 0 && (t2 += e2.config.markers.hover.sizeOffset + 1), e2.globals.markers.largestSize = t2, t2;
    } }, { key: "getSeriesTotals", value: function() {
      var e2 = this.w;
      e2.globals.seriesTotals = e2.globals.series.map(function(t2, i) {
        var a2 = 0;
        if (Array.isArray(t2))
          for (var s2 = 0; s2 < t2.length; s2++)
            a2 += t2[s2];
        else
          a2 += t2;
        return a2;
      });
    } }, { key: "getSeriesTotalsXRange", value: function(e2, t2) {
      var i = this.w;
      return i.globals.series.map(function(a2, s2) {
        for (var r = 0, n2 = 0; n2 < a2.length; n2++)
          i.globals.seriesX[s2][n2] > e2 && i.globals.seriesX[s2][n2] < t2 && (r += a2[n2]);
        return r;
      });
    } }, { key: "getPercentSeries", value: function() {
      var e2 = this.w;
      e2.globals.seriesPercent = e2.globals.series.map(function(t2, i) {
        var a2 = [];
        if (Array.isArray(t2))
          for (var s2 = 0; s2 < t2.length; s2++) {
            var r = e2.globals.stackedSeriesTotals[s2], n2 = 0;
            r && (n2 = 100 * t2[s2] / r), a2.push(n2);
          }
        else {
          var o2 = 100 * t2 / e2.globals.seriesTotals.reduce(function(h2, c2) {
            return h2 + c2;
          }, 0);
          a2.push(o2);
        }
        return a2;
      });
    } }, { key: "getCalculatedRatios", value: function() {
      var e2, t2, i, a2 = this.w.globals, s2 = [], r = 0, n2 = [], o2 = 0.1, h2 = 0;
      if (a2.yRange = [], a2.isMultipleYAxis)
        for (var c2 = 0; c2 < a2.minYArr.length; c2++)
          a2.yRange.push(Math.abs(a2.minYArr[c2] - a2.maxYArr[c2])), n2.push(0);
      else
        a2.yRange.push(Math.abs(a2.minY - a2.maxY));
      a2.xRange = Math.abs(a2.maxX - a2.minX), a2.zRange = Math.abs(a2.maxZ - a2.minZ);
      for (var d2 = 0; d2 < a2.yRange.length; d2++)
        s2.push(a2.yRange[d2] / a2.gridHeight);
      if (t2 = a2.xRange / a2.gridWidth, e2 = a2.yRange / a2.gridWidth, i = a2.xRange / a2.gridHeight, (r = a2.zRange / a2.gridHeight * 16) || (r = 1), a2.minY !== Number.MIN_VALUE && Math.abs(a2.minY) !== 0 && (a2.hasNegs = true), a2.isMultipleYAxis) {
        n2 = [];
        for (var g2 = 0; g2 < s2.length; g2++)
          n2.push(-a2.minYArr[g2] / s2[g2]);
      } else
        n2.push(-a2.minY / s2[0]), a2.minY !== Number.MIN_VALUE && Math.abs(a2.minY) !== 0 && (o2 = -a2.minY / e2, h2 = a2.minX / t2);
      return { yRatio: s2, invertedYRatio: e2, zRatio: r, xRatio: t2, invertedXRatio: i, baseLineInvertedY: o2, baseLineY: n2, baseLineX: h2 };
    } }, { key: "getLogSeries", value: function(e2) {
      var t2 = this, i = this.w;
      return i.globals.seriesLog = e2.map(function(a2, s2) {
        return i.config.yaxis[s2] && i.config.yaxis[s2].logarithmic ? a2.map(function(r) {
          return r === null ? null : t2.getLogVal(i.config.yaxis[s2].logBase, r, s2);
        }) : a2;
      }), i.globals.invalidLogScale ? e2 : i.globals.seriesLog;
    } }, { key: "getBaseLog", value: function(e2, t2) {
      return Math.log(t2) / Math.log(e2);
    } }, { key: "getLogVal", value: function(e2, t2, i) {
      if (t2 === 0)
        return 0;
      var a2 = this.w, s2 = a2.globals.minYArr[i] === 0 ? -1 : this.getBaseLog(e2, a2.globals.minYArr[i]), r = (a2.globals.maxYArr[i] === 0 ? 0 : this.getBaseLog(e2, a2.globals.maxYArr[i])) - s2;
      return t2 < 1 ? t2 / r : (this.getBaseLog(e2, t2) - s2) / r;
    } }, { key: "getLogYRatios", value: function(e2) {
      var t2 = this, i = this.w, a2 = this.w.globals;
      return a2.yLogRatio = e2.slice(), a2.logYRange = a2.yRange.map(function(s2, r) {
        if (i.config.yaxis[r] && t2.w.config.yaxis[r].logarithmic) {
          var n2, o2 = -Number.MAX_VALUE, h2 = Number.MIN_VALUE;
          return a2.seriesLog.forEach(function(c2, d2) {
            c2.forEach(function(g2) {
              i.config.yaxis[d2] && i.config.yaxis[d2].logarithmic && (o2 = Math.max(g2, o2), h2 = Math.min(g2, h2));
            });
          }), n2 = Math.pow(a2.yRange[r], Math.abs(h2 - o2) / a2.yRange[r]), a2.yLogRatio[r] = n2 / a2.gridHeight, n2;
        }
      }), a2.invalidLogScale ? e2.slice() : a2.yLogRatio;
    } }], [{ key: "checkComboSeries", value: function(e2) {
      var t2 = false, i = 0, a2 = 0;
      return e2.length && e2[0].type !== void 0 && e2.forEach(function(s2) {
        s2.type !== "bar" && s2.type !== "column" && s2.type !== "candlestick" && s2.type !== "boxPlot" || i++, s2.type !== void 0 && a2++;
      }), a2 > 0 && (t2 = true), { comboBarCount: i, comboCharts: t2 };
    } }, { key: "extendArrayProps", value: function(e2, t2, i) {
      return t2.yaxis && (t2 = e2.extendYAxis(t2, i)), t2.annotations && (t2.annotations.yaxis && (t2 = e2.extendYAxisAnnotations(t2)), t2.annotations.xaxis && (t2 = e2.extendXAxisAnnotations(t2)), t2.annotations.points && (t2 = e2.extendPointAnnotations(t2))), t2;
    } }]), y2;
  }(), ve2 = function() {
    function y2(e2) {
      F2(this, y2), this.w = e2.w, this.annoCtx = e2;
    }
    return Y2(y2, [{ key: "setOrientations", value: function(e2) {
      var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, i = this.w;
      if (e2.label.orientation === "vertical") {
        var a2 = t2 !== null ? t2 : 0, s2 = i.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(a2, "']"));
        if (s2 !== null) {
          var r = s2.getBoundingClientRect();
          s2.setAttribute("x", parseFloat(s2.getAttribute("x")) - r.height + 4), e2.label.position === "top" ? s2.setAttribute("y", parseFloat(s2.getAttribute("y")) + r.width) : s2.setAttribute("y", parseFloat(s2.getAttribute("y")) - r.width);
          var n2 = this.annoCtx.graphics.rotateAroundCenter(s2), o2 = n2.x, h2 = n2.y;
          s2.setAttribute("transform", "rotate(-90 ".concat(o2, " ").concat(h2, ")"));
        }
      }
    } }, { key: "addBackgroundToAnno", value: function(e2, t2) {
      var i = this.w;
      if (!e2 || t2.label.text === void 0 || t2.label.text !== void 0 && !String(t2.label.text).trim())
        return null;
      var a2 = i.globals.dom.baseEl.querySelector(".apexcharts-grid").getBoundingClientRect(), s2 = e2.getBoundingClientRect(), r = t2.label.style.padding.left, n2 = t2.label.style.padding.right, o2 = t2.label.style.padding.top, h2 = t2.label.style.padding.bottom;
      t2.label.orientation === "vertical" && (o2 = t2.label.style.padding.left, h2 = t2.label.style.padding.right, r = t2.label.style.padding.top, n2 = t2.label.style.padding.bottom);
      var c2 = s2.left - a2.left - r, d2 = s2.top - a2.top - o2, g2 = this.annoCtx.graphics.drawRect(c2 - i.globals.barPadForNumericAxis, d2, s2.width + r + n2, s2.height + o2 + h2, t2.label.borderRadius, t2.label.style.background, 1, t2.label.borderWidth, t2.label.borderColor, 0);
      return t2.id && g2.node.classList.add(t2.id), g2;
    } }, { key: "annotationsBackground", value: function() {
      var e2 = this, t2 = this.w, i = function(a2, s2, r) {
        var n2 = t2.globals.dom.baseEl.querySelector(".apexcharts-".concat(r, "-annotations .apexcharts-").concat(r, "-annotation-label[rel='").concat(s2, "']"));
        if (n2) {
          var o2 = n2.parentNode, h2 = e2.addBackgroundToAnno(n2, a2);
          h2 && (o2.insertBefore(h2.node, n2), a2.label.mouseEnter && h2.node.addEventListener("mouseenter", a2.label.mouseEnter.bind(e2, a2)), a2.label.mouseLeave && h2.node.addEventListener("mouseleave", a2.label.mouseLeave.bind(e2, a2)), a2.label.click && h2.node.addEventListener("click", a2.label.click.bind(e2, a2)));
        }
      };
      t2.config.annotations.xaxis.map(function(a2, s2) {
        i(a2, s2, "xaxis");
      }), t2.config.annotations.yaxis.map(function(a2, s2) {
        i(a2, s2, "yaxis");
      }), t2.config.annotations.points.map(function(a2, s2) {
        i(a2, s2, "point");
      });
    } }, { key: "getY1Y2", value: function(e2, t2) {
      var i, a2 = e2 === "y1" ? t2.y : t2.y2, s2 = this.w;
      if (this.annoCtx.invertAxis) {
        var r = s2.globals.labels.indexOf(a2);
        s2.config.xaxis.convertedCatToNumeric && (r = s2.globals.categoryLabels.indexOf(a2));
        var n2 = s2.globals.dom.baseEl.querySelector(".apexcharts-yaxis-texts-g text:nth-child(" + (r + 1) + ")");
        n2 && (i = parseFloat(n2.getAttribute("y"))), t2.seriesIndex !== void 0 && s2.globals.barHeight && (i = i - s2.globals.barHeight / 2 * (s2.globals.series.length - 1) + s2.globals.barHeight * t2.seriesIndex);
      } else {
        var o2;
        s2.config.yaxis[t2.yAxisIndex].logarithmic ? o2 = (a2 = new q2(this.annoCtx.ctx).getLogVal(a2, t2.yAxisIndex)) / s2.globals.yLogRatio[t2.yAxisIndex] : o2 = (a2 - s2.globals.minYArr[t2.yAxisIndex]) / (s2.globals.yRange[t2.yAxisIndex] / s2.globals.gridHeight), i = s2.globals.gridHeight - o2, !t2.marker || t2.y !== void 0 && t2.y !== null || (i = 0), s2.config.yaxis[t2.yAxisIndex] && s2.config.yaxis[t2.yAxisIndex].reversed && (i = o2);
      }
      return typeof a2 == "string" && a2.indexOf("px") > -1 && (i = parseFloat(a2)), i;
    } }, { key: "getX1X2", value: function(e2, t2) {
      var i = this.w, a2 = this.annoCtx.invertAxis ? i.globals.minY : i.globals.minX, s2 = this.annoCtx.invertAxis ? i.globals.maxY : i.globals.maxX, r = this.annoCtx.invertAxis ? i.globals.yRange[0] : i.globals.xRange, n2 = (t2.x - a2) / (r / i.globals.gridWidth);
      this.annoCtx.inversedReversedAxis && (n2 = (s2 - t2.x) / (r / i.globals.gridWidth)), i.config.xaxis.type !== "category" && !i.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || i.globals.dataFormatXNumeric || (n2 = this.getStringX(t2.x));
      var o2 = (t2.x2 - a2) / (r / i.globals.gridWidth);
      return this.annoCtx.inversedReversedAxis && (o2 = (s2 - t2.x2) / (r / i.globals.gridWidth)), i.config.xaxis.type !== "category" && !i.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || i.globals.dataFormatXNumeric || (o2 = this.getStringX(t2.x2)), t2.x !== void 0 && t2.x !== null || !t2.marker || (n2 = i.globals.gridWidth), e2 === "x1" && typeof t2.x == "string" && t2.x.indexOf("px") > -1 && (n2 = parseFloat(t2.x)), e2 === "x2" && typeof t2.x2 == "string" && t2.x2.indexOf("px") > -1 && (o2 = parseFloat(t2.x2)), t2.seriesIndex !== void 0 && i.globals.barWidth && !this.annoCtx.invertAxis && (n2 = n2 - i.globals.barWidth / 2 * (i.globals.series.length - 1) + i.globals.barWidth * t2.seriesIndex), e2 === "x1" ? n2 : o2;
    } }, { key: "getStringX", value: function(e2) {
      var t2 = this.w, i = e2;
      t2.config.xaxis.convertedCatToNumeric && t2.globals.categoryLabels.length && (e2 = t2.globals.categoryLabels.indexOf(e2) + 1);
      var a2 = t2.globals.labels.indexOf(e2), s2 = t2.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g text:nth-child(" + (a2 + 1) + ")");
      return s2 && (i = parseFloat(s2.getAttribute("x"))), i;
    } }]), y2;
  }(), Oe = function() {
    function y2(e2) {
      F2(this, y2), this.w = e2.w, this.annoCtx = e2, this.invertAxis = this.annoCtx.invertAxis, this.helpers = new ve2(this.annoCtx);
    }
    return Y2(y2, [{ key: "addXaxisAnnotation", value: function(e2, t2, i) {
      var a2, s2 = this.w, r = this.helpers.getX1X2("x1", e2), n2 = e2.label.text, o2 = e2.strokeDashArray;
      if (P2.isNumber(r)) {
        if (e2.x2 === null || e2.x2 === void 0) {
          var h2 = this.annoCtx.graphics.drawLine(r + e2.offsetX, 0 + e2.offsetY, r + e2.offsetX, s2.globals.gridHeight + e2.offsetY, e2.borderColor, o2, e2.borderWidth);
          t2.appendChild(h2.node), e2.id && h2.node.classList.add(e2.id);
        } else {
          if ((a2 = this.helpers.getX1X2("x2", e2)) < r) {
            var c2 = r;
            r = a2, a2 = c2;
          }
          var d2 = this.annoCtx.graphics.drawRect(r + e2.offsetX, 0 + e2.offsetY, a2 - r, s2.globals.gridHeight + e2.offsetY, 0, e2.fillColor, e2.opacity, 1, e2.borderColor, o2);
          d2.node.classList.add("apexcharts-annotation-rect"), d2.attr("clip-path", "url(#gridRectMask".concat(s2.globals.cuid, ")")), t2.appendChild(d2.node), e2.id && d2.node.classList.add(e2.id);
        }
        var g2 = this.annoCtx.graphics.getTextRects(n2, parseFloat(e2.label.style.fontSize)), p2 = e2.label.position === "top" ? 4 : e2.label.position === "center" ? s2.globals.gridHeight / 2 + (e2.label.orientation === "vertical" ? g2.width / 2 : 0) : s2.globals.gridHeight, f2 = this.annoCtx.graphics.drawText({ x: r + e2.label.offsetX, y: p2 + e2.label.offsetY - (e2.label.orientation === "vertical" ? e2.label.position === "top" ? g2.width / 2 - 12 : -g2.width / 2 : 0), text: n2, textAnchor: e2.label.textAnchor, fontSize: e2.label.style.fontSize, fontFamily: e2.label.style.fontFamily, fontWeight: e2.label.style.fontWeight, foreColor: e2.label.style.color, cssClass: "apexcharts-xaxis-annotation-label ".concat(e2.label.style.cssClass, " ").concat(e2.id ? e2.id : "") });
        f2.attr({ rel: i }), t2.appendChild(f2.node), this.annoCtx.helpers.setOrientations(e2, i);
      }
    } }, { key: "drawXAxisAnnotations", value: function() {
      var e2 = this, t2 = this.w, i = this.annoCtx.graphics.group({ class: "apexcharts-xaxis-annotations" });
      return t2.config.annotations.xaxis.map(function(a2, s2) {
        e2.addXaxisAnnotation(a2, i.node, s2);
      }), i;
    } }]), y2;
  }(), He = function() {
    function y2(e2) {
      F2(this, y2), this.w = e2.w, this.annoCtx = e2, this.helpers = new ve2(this.annoCtx);
    }
    return Y2(y2, [{ key: "addYaxisAnnotation", value: function(e2, t2, i) {
      var a2, s2 = this.w, r = e2.strokeDashArray, n2 = this.helpers.getY1Y2("y1", e2), o2 = e2.label.text;
      if (e2.y2 === null || e2.y2 === void 0) {
        var h2 = this.annoCtx.graphics.drawLine(0 + e2.offsetX, n2 + e2.offsetY, this._getYAxisAnnotationWidth(e2), n2 + e2.offsetY, e2.borderColor, r, e2.borderWidth);
        t2.appendChild(h2.node), e2.id && h2.node.classList.add(e2.id);
      } else {
        if ((a2 = this.helpers.getY1Y2("y2", e2)) > n2) {
          var c2 = n2;
          n2 = a2, a2 = c2;
        }
        var d2 = this.annoCtx.graphics.drawRect(0 + e2.offsetX, a2 + e2.offsetY, this._getYAxisAnnotationWidth(e2), n2 - a2, 0, e2.fillColor, e2.opacity, 1, e2.borderColor, r);
        d2.node.classList.add("apexcharts-annotation-rect"), d2.attr("clip-path", "url(#gridRectMask".concat(s2.globals.cuid, ")")), t2.appendChild(d2.node), e2.id && d2.node.classList.add(e2.id);
      }
      var g2 = e2.label.position === "right" ? s2.globals.gridWidth : e2.label.position === "center" ? s2.globals.gridWidth / 2 : 0, p2 = this.annoCtx.graphics.drawText({ x: g2 + e2.label.offsetX, y: (a2 ?? n2) + e2.label.offsetY - 3, text: o2, textAnchor: e2.label.textAnchor, fontSize: e2.label.style.fontSize, fontFamily: e2.label.style.fontFamily, fontWeight: e2.label.style.fontWeight, foreColor: e2.label.style.color, cssClass: "apexcharts-yaxis-annotation-label ".concat(e2.label.style.cssClass, " ").concat(e2.id ? e2.id : "") });
      p2.attr({ rel: i }), t2.appendChild(p2.node);
    } }, { key: "_getYAxisAnnotationWidth", value: function(e2) {
      var t2 = this.w;
      return t2.globals.gridWidth, (e2.width.indexOf("%") > -1 ? t2.globals.gridWidth * parseInt(e2.width, 10) / 100 : parseInt(e2.width, 10)) + e2.offsetX;
    } }, { key: "drawYAxisAnnotations", value: function() {
      var e2 = this, t2 = this.w, i = this.annoCtx.graphics.group({ class: "apexcharts-yaxis-annotations" });
      return t2.config.annotations.yaxis.map(function(a2, s2) {
        e2.addYaxisAnnotation(a2, i.node, s2);
      }), i;
    } }]), y2;
  }(), pe2 = function() {
    function y2(e2) {
      F2(this, y2), this.w = e2.w, this.annoCtx = e2, this.helpers = new ve2(this.annoCtx);
    }
    return Y2(y2, [{ key: "addPointAnnotation", value: function(e2, t2, i) {
      this.w;
      var a2 = this.helpers.getX1X2("x1", e2), s2 = this.helpers.getY1Y2("y1", e2);
      if (P2.isNumber(a2)) {
        var r = { pSize: e2.marker.size, pointStrokeWidth: e2.marker.strokeWidth, pointFillColor: e2.marker.fillColor, pointStrokeColor: e2.marker.strokeColor, shape: e2.marker.shape, pRadius: e2.marker.radius, class: "apexcharts-point-annotation-marker ".concat(e2.marker.cssClass, " ").concat(e2.id ? e2.id : "") }, n2 = this.annoCtx.graphics.drawMarker(a2 + e2.marker.offsetX, s2 + e2.marker.offsetY, r);
        t2.appendChild(n2.node);
        var o2 = e2.label.text ? e2.label.text : "", h2 = this.annoCtx.graphics.drawText({ x: a2 + e2.label.offsetX, y: s2 + e2.label.offsetY - e2.marker.size - parseFloat(e2.label.style.fontSize) / 1.6, text: o2, textAnchor: e2.label.textAnchor, fontSize: e2.label.style.fontSize, fontFamily: e2.label.style.fontFamily, fontWeight: e2.label.style.fontWeight, foreColor: e2.label.style.color, cssClass: "apexcharts-point-annotation-label ".concat(e2.label.style.cssClass, " ").concat(e2.id ? e2.id : "") });
        if (h2.attr({ rel: i }), t2.appendChild(h2.node), e2.customSVG.SVG) {
          var c2 = this.annoCtx.graphics.group({ class: "apexcharts-point-annotations-custom-svg " + e2.customSVG.cssClass });
          c2.attr({ transform: "translate(".concat(a2 + e2.customSVG.offsetX, ", ").concat(s2 + e2.customSVG.offsetY, ")") }), c2.node.innerHTML = e2.customSVG.SVG, t2.appendChild(c2.node);
        }
        if (e2.image.path) {
          var d2 = e2.image.width ? e2.image.width : 20, g2 = e2.image.height ? e2.image.height : 20;
          n2 = this.annoCtx.addImage({ x: a2 + e2.image.offsetX - d2 / 2, y: s2 + e2.image.offsetY - g2 / 2, width: d2, height: g2, path: e2.image.path, appendTo: ".apexcharts-point-annotations" });
        }
        e2.mouseEnter && n2.node.addEventListener("mouseenter", e2.mouseEnter.bind(this, e2)), e2.mouseLeave && n2.node.addEventListener("mouseleave", e2.mouseLeave.bind(this, e2)), e2.click && n2.node.addEventListener("click", e2.click.bind(this, e2));
      }
    } }, { key: "drawPointAnnotations", value: function() {
      var e2 = this, t2 = this.w, i = this.annoCtx.graphics.group({ class: "apexcharts-point-annotations" });
      return t2.config.annotations.points.map(function(a2, s2) {
        e2.addPointAnnotation(a2, i.node, s2);
      }), i;
    } }]), y2;
  }(), H4 = { name: "en", options: { months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], toolbar: { exportToSVG: "Download SVG", exportToPNG: "Download PNG", exportToCSV: "Download CSV", menu: "Menu", selection: "Selection", selectionZoom: "Selection Zoom", zoomIn: "Zoom In", zoomOut: "Zoom Out", pan: "Panning", reset: "Reset Zoom" } } }, G2 = function() {
    function y2() {
      F2(this, y2), this.yAxis = { show: true, showAlways: false, showForNullSeries: true, seriesName: void 0, opposite: false, reversed: false, logarithmic: false, logBase: 10, tickAmount: void 0, stepSize: void 0, forceNiceScale: false, max: void 0, min: void 0, floating: false, decimalsInFloat: void 0, labels: { show: true, minWidth: 0, maxWidth: 160, offsetX: 0, offsetY: 0, align: void 0, rotate: 0, padding: 20, style: { colors: [], fontSize: "11px", fontWeight: 400, fontFamily: void 0, cssClass: "" }, formatter: void 0 }, axisBorder: { show: false, color: "#e0e0e0", width: 1, offsetX: 0, offsetY: 0 }, axisTicks: { show: false, color: "#e0e0e0", width: 6, offsetX: 0, offsetY: 0 }, title: { text: void 0, rotate: -90, offsetY: 0, offsetX: 0, style: { color: void 0, fontSize: "11px", fontWeight: 900, fontFamily: void 0, cssClass: "" } }, tooltip: { enabled: false, offsetX: 0 }, crosshairs: { show: true, position: "front", stroke: { color: "#b6b6b6", width: 1, dashArray: 0 } } }, this.pointAnnotation = { id: void 0, x: 0, y: null, yAxisIndex: 0, seriesIndex: void 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, marker: { size: 4, fillColor: "#fff", strokeWidth: 2, strokeColor: "#333", shape: "circle", offsetX: 0, offsetY: 0, radius: 2, cssClass: "" }, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "middle", offsetX: 0, offsetY: 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } }, customSVG: { SVG: void 0, cssClass: void 0, offsetX: 0, offsetY: 0 }, image: { path: void 0, width: 20, height: 20, offsetX: 0, offsetY: 0 } }, this.yAxisAnnotation = { id: void 0, y: 0, y2: null, strokeDashArray: 1, fillColor: "#c2c2c2", borderColor: "#c2c2c2", borderWidth: 1, opacity: 0.3, offsetX: 0, offsetY: 0, width: "100%", yAxisIndex: 0, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "end", position: "right", offsetX: 0, offsetY: -3, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } } }, this.xAxisAnnotation = { id: void 0, x: 0, x2: null, strokeDashArray: 1, fillColor: "#c2c2c2", borderColor: "#c2c2c2", borderWidth: 1, opacity: 0.3, offsetX: 0, offsetY: 0, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "middle", orientation: "vertical", position: "top", offsetX: 0, offsetY: 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } } }, this.text = { x: 0, y: 0, text: "", textAnchor: "start", foreColor: void 0, fontSize: "13px", fontFamily: void 0, fontWeight: 400, appendTo: ".apexcharts-annotations", backgroundColor: "transparent", borderColor: "#c2c2c2", borderRadius: 0, borderWidth: 0, paddingLeft: 4, paddingRight: 4, paddingTop: 2, paddingBottom: 2 };
    }
    return Y2(y2, [{ key: "init", value: function() {
      return { annotations: { yaxis: [this.yAxisAnnotation], xaxis: [this.xAxisAnnotation], points: [this.pointAnnotation], texts: [], images: [], shapes: [] }, chart: { animations: { enabled: true, easing: "easeinout", speed: 800, animateGradually: { delay: 150, enabled: true }, dynamicAnimation: { enabled: true, speed: 350 } }, background: "transparent", locales: [H4], defaultLocale: "en", dropShadow: { enabled: false, enabledOnSeries: void 0, top: 2, left: 2, blur: 4, color: "#000", opacity: 0.35 }, events: { animationEnd: void 0, beforeMount: void 0, mounted: void 0, updated: void 0, click: void 0, mouseMove: void 0, mouseLeave: void 0, xAxisLabelClick: void 0, legendClick: void 0, markerClick: void 0, selection: void 0, dataPointSelection: void 0, dataPointMouseEnter: void 0, dataPointMouseLeave: void 0, beforeZoom: void 0, beforeResetZoom: void 0, zoomed: void 0, scrolled: void 0, brushScrolled: void 0 }, foreColor: "#373d3f", fontFamily: "Helvetica, Arial, sans-serif", height: "auto", parentHeightOffset: 15, redrawOnParentResize: true, redrawOnWindowResize: true, id: void 0, group: void 0, nonce: void 0, offsetX: 0, offsetY: 0, selection: { enabled: false, type: "x", fill: { color: "#24292e", opacity: 0.1 }, stroke: { width: 1, color: "#24292e", opacity: 0.4, dashArray: 3 }, xaxis: { min: void 0, max: void 0 }, yaxis: { min: void 0, max: void 0 } }, sparkline: { enabled: false }, brush: { enabled: false, autoScaleYaxis: true, target: void 0, targets: void 0 }, stacked: false, stackOnlyBar: true, stackType: "normal", toolbar: { show: true, offsetX: 0, offsetY: 0, tools: { download: true, selection: true, zoom: true, zoomin: true, zoomout: true, pan: true, reset: true, customIcons: [] }, export: { csv: { filename: void 0, columnDelimiter: ",", headerCategory: "category", headerValue: "value", dateFormatter: function(e2) {
        return new Date(e2).toDateString();
      } }, png: { filename: void 0 }, svg: { filename: void 0 } }, autoSelected: "zoom" }, type: "line", width: "100%", zoom: { enabled: true, type: "x", autoScaleYaxis: false, zoomedArea: { fill: { color: "#90CAF9", opacity: 0.4 }, stroke: { color: "#0D47A1", opacity: 0.4, width: 1 } } } }, plotOptions: { area: { fillTo: "origin" }, bar: { horizontal: false, columnWidth: "70%", barHeight: "70%", distributed: false, borderRadius: 0, borderRadiusApplication: "around", borderRadiusWhenStacked: "last", rangeBarOverlap: true, rangeBarGroupRows: false, hideZeroBarsWhenGrouped: false, isDumbbell: false, dumbbellColors: void 0, isFunnel: false, isFunnel3d: true, colors: { ranges: [], backgroundBarColors: [], backgroundBarOpacity: 1, backgroundBarRadius: 0 }, dataLabels: { position: "top", maxItems: 100, hideOverflowingLabels: true, orientation: "horizontal", total: { enabled: false, formatter: void 0, offsetX: 0, offsetY: 0, style: { color: "#373d3f", fontSize: "12px", fontFamily: void 0, fontWeight: 600 } } } }, bubble: { zScaling: true, minBubbleRadius: void 0, maxBubbleRadius: void 0 }, candlestick: { colors: { upward: "#00B746", downward: "#EF403C" }, wick: { useFillColor: true } }, boxPlot: { colors: { upper: "#00E396", lower: "#008FFB" } }, heatmap: { radius: 2, enableShades: true, shadeIntensity: 0.5, reverseNegativeShade: false, distributed: false, useFillColorAsStroke: false, colorScale: { inverse: false, ranges: [], min: void 0, max: void 0 } }, treemap: { enableShades: true, shadeIntensity: 0.5, distributed: false, reverseNegativeShade: false, useFillColorAsStroke: false, borderRadius: 4, dataLabels: { format: "scale" }, colorScale: { inverse: false, ranges: [], min: void 0, max: void 0 } }, radialBar: { inverseOrder: false, startAngle: 0, endAngle: 360, offsetX: 0, offsetY: 0, hollow: { margin: 5, size: "50%", background: "transparent", image: void 0, imageWidth: 150, imageHeight: 150, imageOffsetX: 0, imageOffsetY: 0, imageClipped: true, position: "front", dropShadow: { enabled: false, top: 0, left: 0, blur: 3, color: "#000", opacity: 0.5 } }, track: { show: true, startAngle: void 0, endAngle: void 0, background: "#f2f2f2", strokeWidth: "97%", opacity: 1, margin: 5, dropShadow: { enabled: false, top: 0, left: 0, blur: 3, color: "#000", opacity: 0.5 } }, dataLabels: { show: true, name: { show: true, fontSize: "16px", fontFamily: void 0, fontWeight: 600, color: void 0, offsetY: 0, formatter: function(e2) {
        return e2;
      } }, value: { show: true, fontSize: "14px", fontFamily: void 0, fontWeight: 400, color: void 0, offsetY: 16, formatter: function(e2) {
        return e2 + "%";
      } }, total: { show: false, label: "Total", fontSize: "16px", fontWeight: 600, fontFamily: void 0, color: void 0, formatter: function(e2) {
        return e2.globals.seriesTotals.reduce(function(t2, i) {
          return t2 + i;
        }, 0) / e2.globals.series.length + "%";
      } } }, barLabels: { enabled: false, margin: 5, useSeriesColors: true, fontFamily: void 0, fontWeight: 600, fontSize: "16px", formatter: function(e2) {
        return e2;
      }, onClick: void 0 } }, pie: { customScale: 1, offsetX: 0, offsetY: 0, startAngle: 0, endAngle: 360, expandOnClick: true, dataLabels: { offset: 0, minAngleToShowLabel: 10 }, donut: { size: "65%", background: "transparent", labels: { show: false, name: { show: true, fontSize: "16px", fontFamily: void 0, fontWeight: 600, color: void 0, offsetY: -10, formatter: function(e2) {
        return e2;
      } }, value: { show: true, fontSize: "20px", fontFamily: void 0, fontWeight: 400, color: void 0, offsetY: 10, formatter: function(e2) {
        return e2;
      } }, total: { show: false, showAlways: false, label: "Total", fontSize: "16px", fontWeight: 400, fontFamily: void 0, color: void 0, formatter: function(e2) {
        return e2.globals.seriesTotals.reduce(function(t2, i) {
          return t2 + i;
        }, 0);
      } } } } }, polarArea: { rings: { strokeWidth: 1, strokeColor: "#e8e8e8" }, spokes: { strokeWidth: 1, connectorColors: "#e8e8e8" } }, radar: { size: void 0, offsetX: 0, offsetY: 0, polygons: { strokeWidth: 1, strokeColors: "#e8e8e8", connectorColors: "#e8e8e8", fill: { colors: void 0 } } } }, colors: void 0, dataLabels: { enabled: true, enabledOnSeries: void 0, formatter: function(e2) {
        return e2 !== null ? e2 : "";
      }, textAnchor: "middle", distributed: false, offsetX: 0, offsetY: 0, style: { fontSize: "12px", fontFamily: void 0, fontWeight: 600, colors: void 0 }, background: { enabled: true, foreColor: "#fff", borderRadius: 2, padding: 4, opacity: 0.9, borderWidth: 1, borderColor: "#fff", dropShadow: { enabled: false, top: 1, left: 1, blur: 1, color: "#000", opacity: 0.45 } }, dropShadow: { enabled: false, top: 1, left: 1, blur: 1, color: "#000", opacity: 0.45 } }, fill: { type: "solid", colors: void 0, opacity: 0.85, gradient: { shade: "dark", type: "horizontal", shadeIntensity: 0.5, gradientToColors: void 0, inverseColors: true, opacityFrom: 1, opacityTo: 1, stops: [0, 50, 100], colorStops: [] }, image: { src: [], width: void 0, height: void 0 }, pattern: { style: "squares", width: 6, height: 6, strokeWidth: 2 } }, forecastDataPoints: { count: 0, fillOpacity: 0.5, strokeWidth: void 0, dashArray: 4 }, grid: { show: true, borderColor: "#e0e0e0", strokeDashArray: 0, position: "back", xaxis: { lines: { show: false } }, yaxis: { lines: { show: true } }, row: { colors: void 0, opacity: 0.5 }, column: { colors: void 0, opacity: 0.5 }, padding: { top: 0, right: 10, bottom: 0, left: 12 } }, labels: [], legend: { show: true, showForSingleSeries: false, showForNullSeries: true, showForZeroSeries: true, floating: false, position: "bottom", horizontalAlign: "center", inverseOrder: false, fontSize: "12px", fontFamily: void 0, fontWeight: 400, width: void 0, height: void 0, formatter: void 0, tooltipHoverFormatter: void 0, offsetX: -20, offsetY: 4, customLegendItems: [], labels: { colors: void 0, useSeriesColors: false }, markers: { width: 12, height: 12, strokeWidth: 0, fillColors: void 0, strokeColor: "#fff", radius: 12, customHTML: void 0, offsetX: 0, offsetY: 0, onClick: void 0 }, itemMargin: { horizontal: 5, vertical: 2 }, onItemClick: { toggleDataSeries: true }, onItemHover: { highlightDataSeries: true } }, markers: { discrete: [], size: 0, colors: void 0, strokeColors: "#fff", strokeWidth: 2, strokeOpacity: 0.9, strokeDashArray: 0, fillOpacity: 1, shape: "circle", width: 8, height: 8, radius: 2, offsetX: 0, offsetY: 0, onClick: void 0, onDblClick: void 0, showNullDataPoints: true, hover: { size: void 0, sizeOffset: 3 } }, noData: { text: void 0, align: "center", verticalAlign: "middle", offsetX: 0, offsetY: 0, style: { color: void 0, fontSize: "14px", fontFamily: void 0 } }, responsive: [], series: void 0, states: { normal: { filter: { type: "none", value: 0 } }, hover: { filter: { type: "lighten", value: 0.1 } }, active: { allowMultipleDataPointsSelection: false, filter: { type: "darken", value: 0.5 } } }, title: { text: void 0, align: "left", margin: 5, offsetX: 0, offsetY: 0, floating: false, style: { fontSize: "14px", fontWeight: 900, fontFamily: void 0, color: void 0 } }, subtitle: { text: void 0, align: "left", margin: 5, offsetX: 0, offsetY: 30, floating: false, style: { fontSize: "12px", fontWeight: 400, fontFamily: void 0, color: void 0 } }, stroke: { show: true, curve: "smooth", lineCap: "butt", width: 2, colors: void 0, dashArray: 0, fill: { type: "solid", colors: void 0, opacity: 0.85, gradient: { shade: "dark", type: "horizontal", shadeIntensity: 0.5, gradientToColors: void 0, inverseColors: true, opacityFrom: 1, opacityTo: 1, stops: [0, 50, 100], colorStops: [] } } }, tooltip: { enabled: true, enabledOnSeries: void 0, shared: true, hideEmptySeries: false, followCursor: false, intersect: false, inverseOrder: false, custom: void 0, fillSeriesColor: false, theme: "light", cssClass: "", style: { fontSize: "12px", fontFamily: void 0 }, onDatasetHover: { highlightDataSeries: false }, x: { show: true, format: "dd MMM", formatter: void 0 }, y: { formatter: void 0, title: { formatter: function(e2) {
        return e2 ? e2 + ": " : "";
      } } }, z: { formatter: void 0, title: "Size: " }, marker: { show: true, fillColors: void 0 }, items: { display: "flex" }, fixed: { enabled: false, position: "topRight", offsetX: 0, offsetY: 0 } }, xaxis: { type: "category", categories: [], convertedCatToNumeric: false, offsetX: 0, offsetY: 0, overwriteCategories: void 0, labels: { show: true, rotate: -45, rotateAlways: false, hideOverlappingLabels: true, trim: false, minHeight: void 0, maxHeight: 120, showDuplicates: true, style: { colors: [], fontSize: "12px", fontWeight: 400, fontFamily: void 0, cssClass: "" }, offsetX: 0, offsetY: 0, format: void 0, formatter: void 0, datetimeUTC: true, datetimeFormatter: { year: "yyyy", month: "MMM 'yy", day: "dd MMM", hour: "HH:mm", minute: "HH:mm:ss", second: "HH:mm:ss" } }, group: { groups: [], style: { colors: [], fontSize: "12px", fontWeight: 400, fontFamily: void 0, cssClass: "" } }, axisBorder: { show: true, color: "#e0e0e0", width: "100%", height: 1, offsetX: 0, offsetY: 0 }, axisTicks: { show: true, color: "#e0e0e0", height: 6, offsetX: 0, offsetY: 0 }, stepSize: void 0, tickAmount: void 0, tickPlacement: "on", min: void 0, max: void 0, range: void 0, floating: false, decimalsInFloat: void 0, position: "bottom", title: { text: void 0, offsetX: 0, offsetY: 0, style: { color: void 0, fontSize: "12px", fontWeight: 900, fontFamily: void 0, cssClass: "" } }, crosshairs: { show: true, width: 1, position: "back", opacity: 0.9, stroke: { color: "#b6b6b6", width: 1, dashArray: 3 }, fill: { type: "solid", color: "#B1B9C4", gradient: { colorFrom: "#D8E3F0", colorTo: "#BED1E6", stops: [0, 100], opacityFrom: 0.4, opacityTo: 0.5 } }, dropShadow: { enabled: false, left: 0, top: 0, blur: 1, opacity: 0.4 } }, tooltip: { enabled: true, offsetY: 0, formatter: void 0, style: { fontSize: "12px", fontFamily: void 0 } } }, yaxis: this.yAxis, theme: { mode: "light", palette: "palette1", monochrome: { enabled: false, color: "#008FFB", shadeTo: "light", shadeIntensity: 0.65 } } };
    } }]), y2;
  }(), ie2 = function() {
    function y2(e2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w, this.graphics = new M2(this.ctx), this.w.globals.isBarHorizontal && (this.invertAxis = true), this.helpers = new ve2(this), this.xAxisAnnotations = new Oe(this), this.yAxisAnnotations = new He(this), this.pointsAnnotations = new pe2(this), this.w.globals.isBarHorizontal && this.w.config.yaxis[0].reversed && (this.inversedReversedAxis = true), this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints;
    }
    return Y2(y2, [{ key: "drawAxesAnnotations", value: function() {
      var e2 = this.w;
      if (e2.globals.axisCharts) {
        for (var t2 = this.yAxisAnnotations.drawYAxisAnnotations(), i = this.xAxisAnnotations.drawXAxisAnnotations(), a2 = this.pointsAnnotations.drawPointAnnotations(), s2 = e2.config.chart.animations.enabled, r = [t2, i, a2], n2 = [i.node, t2.node, a2.node], o2 = 0; o2 < 3; o2++)
          e2.globals.dom.elGraphical.add(r[o2]), !s2 || e2.globals.resized || e2.globals.dataChanged || e2.config.chart.type !== "scatter" && e2.config.chart.type !== "bubble" && e2.globals.dataPoints > 1 && n2[o2].classList.add("apexcharts-element-hidden"), e2.globals.delayedElements.push({ el: n2[o2], index: 0 });
        this.helpers.annotationsBackground();
      }
    } }, { key: "drawImageAnnos", value: function() {
      var e2 = this;
      this.w.config.annotations.images.map(function(t2, i) {
        e2.addImage(t2, i);
      });
    } }, { key: "drawTextAnnos", value: function() {
      var e2 = this;
      this.w.config.annotations.texts.map(function(t2, i) {
        e2.addText(t2, i);
      });
    } }, { key: "addXaxisAnnotation", value: function(e2, t2, i) {
      this.xAxisAnnotations.addXaxisAnnotation(e2, t2, i);
    } }, { key: "addYaxisAnnotation", value: function(e2, t2, i) {
      this.yAxisAnnotations.addYaxisAnnotation(e2, t2, i);
    } }, { key: "addPointAnnotation", value: function(e2, t2, i) {
      this.pointsAnnotations.addPointAnnotation(e2, t2, i);
    } }, { key: "addText", value: function(e2, t2) {
      var i = e2.x, a2 = e2.y, s2 = e2.text, r = e2.textAnchor, n2 = e2.foreColor, o2 = e2.fontSize, h2 = e2.fontFamily, c2 = e2.fontWeight, d2 = e2.cssClass, g2 = e2.backgroundColor, p2 = e2.borderWidth, f2 = e2.strokeDashArray, b2 = e2.borderRadius, m2 = e2.borderColor, w2 = e2.appendTo, A2 = w2 === void 0 ? ".apexcharts-svg" : w2, l2 = e2.paddingLeft, u2 = l2 === void 0 ? 4 : l2, x2 = e2.paddingRight, v2 = x2 === void 0 ? 4 : x2, k2 = e2.paddingBottom, S2 = k2 === void 0 ? 2 : k2, C2 = e2.paddingTop, L2 = C2 === void 0 ? 2 : C2, I2 = this.w, z2 = this.graphics.drawText({ x: i, y: a2, text: s2, textAnchor: r || "start", fontSize: o2 || "12px", fontWeight: c2 || "regular", fontFamily: h2 || I2.config.chart.fontFamily, foreColor: n2 || I2.config.chart.foreColor, cssClass: d2 }), T2 = I2.globals.dom.baseEl.querySelector(A2);
      T2 && T2.appendChild(z2.node);
      var E2 = z2.bbox();
      if (s2) {
        var R2 = this.graphics.drawRect(E2.x - u2, E2.y - L2, E2.width + u2 + v2, E2.height + S2 + L2, b2, g2 || "transparent", 1, p2, m2, f2);
        T2.insertBefore(R2.node, z2.node);
      }
    } }, { key: "addImage", value: function(e2, t2) {
      var i = this.w, a2 = e2.path, s2 = e2.x, r = s2 === void 0 ? 0 : s2, n2 = e2.y, o2 = n2 === void 0 ? 0 : n2, h2 = e2.width, c2 = h2 === void 0 ? 20 : h2, d2 = e2.height, g2 = d2 === void 0 ? 20 : d2, p2 = e2.appendTo, f2 = p2 === void 0 ? ".apexcharts-svg" : p2, b2 = i.globals.dom.Paper.image(a2);
      b2.size(c2, g2).move(r, o2);
      var m2 = i.globals.dom.baseEl.querySelector(f2);
      return m2 && m2.appendChild(b2.node), b2;
    } }, { key: "addXaxisAnnotationExternal", value: function(e2, t2, i) {
      return this.addAnnotationExternal({ params: e2, pushToMemory: t2, context: i, type: "xaxis", contextMethod: i.addXaxisAnnotation }), i;
    } }, { key: "addYaxisAnnotationExternal", value: function(e2, t2, i) {
      return this.addAnnotationExternal({ params: e2, pushToMemory: t2, context: i, type: "yaxis", contextMethod: i.addYaxisAnnotation }), i;
    } }, { key: "addPointAnnotationExternal", value: function(e2, t2, i) {
      return this.invertAxis === void 0 && (this.invertAxis = i.w.globals.isBarHorizontal), this.addAnnotationExternal({ params: e2, pushToMemory: t2, context: i, type: "point", contextMethod: i.addPointAnnotation }), i;
    } }, { key: "addAnnotationExternal", value: function(e2) {
      var t2 = e2.params, i = e2.pushToMemory, a2 = e2.context, s2 = e2.type, r = e2.contextMethod, n2 = a2, o2 = n2.w, h2 = o2.globals.dom.baseEl.querySelector(".apexcharts-".concat(s2, "-annotations")), c2 = h2.childNodes.length + 1, d2 = new G2(), g2 = Object.assign({}, s2 === "xaxis" ? d2.xAxisAnnotation : s2 === "yaxis" ? d2.yAxisAnnotation : d2.pointAnnotation), p2 = P2.extend(g2, t2);
      switch (s2) {
        case "xaxis":
          this.addXaxisAnnotation(p2, h2, c2);
          break;
        case "yaxis":
          this.addYaxisAnnotation(p2, h2, c2);
          break;
        case "point":
          this.addPointAnnotation(p2, h2, c2);
      }
      var f2 = o2.globals.dom.baseEl.querySelector(".apexcharts-".concat(s2, "-annotations .apexcharts-").concat(s2, "-annotation-label[rel='").concat(c2, "']")), b2 = this.helpers.addBackgroundToAnno(f2, p2);
      return b2 && h2.insertBefore(b2.node, f2), i && o2.globals.memory.methodsToExec.push({ context: n2, id: p2.id ? p2.id : P2.randomId(), method: r, label: "addAnnotation", params: t2 }), a2;
    } }, { key: "clearAnnotations", value: function(e2) {
      var t2 = e2.w, i = t2.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations");
      t2.globals.memory.methodsToExec.map(function(a2, s2) {
        a2.label !== "addText" && a2.label !== "addAnnotation" || t2.globals.memory.methodsToExec.splice(s2, 1);
      }), i = P2.listToArray(i), Array.prototype.forEach.call(i, function(a2) {
        for (; a2.firstChild; )
          a2.removeChild(a2.firstChild);
      });
    } }, { key: "removeAnnotation", value: function(e2, t2) {
      var i = e2.w, a2 = i.globals.dom.baseEl.querySelectorAll(".".concat(t2));
      a2 && (i.globals.memory.methodsToExec.map(function(s2, r) {
        s2.id === t2 && i.globals.memory.methodsToExec.splice(r, 1);
      }), Array.prototype.forEach.call(a2, function(s2) {
        s2.parentElement.removeChild(s2);
      }));
    } }]), y2;
  }(), B3 = function() {
    function y2(e2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w, this.months31 = [1, 3, 5, 7, 8, 10, 12], this.months30 = [2, 4, 6, 9, 11], this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
    }
    return Y2(y2, [{ key: "isValidDate", value: function(e2) {
      return typeof e2 != "number" && !isNaN(this.parseDate(e2));
    } }, { key: "getTimeStamp", value: function(e2) {
      return Date.parse(e2) ? this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(e2).toISOString().substr(0, 25)).getTime() : new Date(e2).getTime() : e2;
    } }, { key: "getDate", value: function(e2) {
      return this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(e2).toUTCString()) : new Date(e2);
    } }, { key: "parseDate", value: function(e2) {
      var t2 = Date.parse(e2);
      if (!isNaN(t2))
        return this.getTimeStamp(e2);
      var i = Date.parse(e2.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
      return i = this.getTimeStamp(i);
    } }, { key: "parseDateWithTimezone", value: function(e2) {
      return Date.parse(e2.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
    } }, { key: "formatDate", value: function(e2, t2) {
      var i = this.w.globals.locale, a2 = this.w.config.xaxis.labels.datetimeUTC, s2 = ["\0"].concat(J2(i.months)), r = [""].concat(J2(i.shortMonths)), n2 = [""].concat(J2(i.days)), o2 = [""].concat(J2(i.shortDays));
      function h2(S2, C2) {
        var L2 = S2 + "";
        for (C2 = C2 || 2; L2.length < C2; )
          L2 = "0" + L2;
        return L2;
      }
      var c2 = a2 ? e2.getUTCFullYear() : e2.getFullYear();
      t2 = (t2 = (t2 = t2.replace(/(^|[^\\])yyyy+/g, "$1" + c2)).replace(/(^|[^\\])yy/g, "$1" + c2.toString().substr(2, 2))).replace(/(^|[^\\])y/g, "$1" + c2);
      var d2 = (a2 ? e2.getUTCMonth() : e2.getMonth()) + 1;
      t2 = (t2 = (t2 = (t2 = t2.replace(/(^|[^\\])MMMM+/g, "$1" + s2[0])).replace(/(^|[^\\])MMM/g, "$1" + r[0])).replace(/(^|[^\\])MM/g, "$1" + h2(d2))).replace(/(^|[^\\])M/g, "$1" + d2);
      var g2 = a2 ? e2.getUTCDate() : e2.getDate();
      t2 = (t2 = (t2 = (t2 = t2.replace(/(^|[^\\])dddd+/g, "$1" + n2[0])).replace(/(^|[^\\])ddd/g, "$1" + o2[0])).replace(/(^|[^\\])dd/g, "$1" + h2(g2))).replace(/(^|[^\\])d/g, "$1" + g2);
      var p2 = a2 ? e2.getUTCHours() : e2.getHours(), f2 = p2 > 12 ? p2 - 12 : p2 === 0 ? 12 : p2;
      t2 = (t2 = (t2 = (t2 = t2.replace(/(^|[^\\])HH+/g, "$1" + h2(p2))).replace(/(^|[^\\])H/g, "$1" + p2)).replace(/(^|[^\\])hh+/g, "$1" + h2(f2))).replace(/(^|[^\\])h/g, "$1" + f2);
      var b2 = a2 ? e2.getUTCMinutes() : e2.getMinutes();
      t2 = (t2 = t2.replace(/(^|[^\\])mm+/g, "$1" + h2(b2))).replace(/(^|[^\\])m/g, "$1" + b2);
      var m2 = a2 ? e2.getUTCSeconds() : e2.getSeconds();
      t2 = (t2 = t2.replace(/(^|[^\\])ss+/g, "$1" + h2(m2))).replace(/(^|[^\\])s/g, "$1" + m2);
      var w2 = a2 ? e2.getUTCMilliseconds() : e2.getMilliseconds();
      t2 = t2.replace(/(^|[^\\])fff+/g, "$1" + h2(w2, 3)), w2 = Math.round(w2 / 10), t2 = t2.replace(/(^|[^\\])ff/g, "$1" + h2(w2)), w2 = Math.round(w2 / 10);
      var A2 = p2 < 12 ? "AM" : "PM";
      t2 = (t2 = (t2 = t2.replace(/(^|[^\\])f/g, "$1" + w2)).replace(/(^|[^\\])TT+/g, "$1" + A2)).replace(/(^|[^\\])T/g, "$1" + A2.charAt(0));
      var l2 = A2.toLowerCase();
      t2 = (t2 = t2.replace(/(^|[^\\])tt+/g, "$1" + l2)).replace(/(^|[^\\])t/g, "$1" + l2.charAt(0));
      var u2 = -e2.getTimezoneOffset(), x2 = a2 || !u2 ? "Z" : u2 > 0 ? "+" : "-";
      if (!a2) {
        var v2 = (u2 = Math.abs(u2)) % 60;
        x2 += h2(Math.floor(u2 / 60)) + ":" + h2(v2);
      }
      t2 = t2.replace(/(^|[^\\])K/g, "$1" + x2);
      var k2 = (a2 ? e2.getUTCDay() : e2.getDay()) + 1;
      return t2 = (t2 = (t2 = (t2 = (t2 = t2.replace(new RegExp(n2[0], "g"), n2[k2])).replace(new RegExp(o2[0], "g"), o2[k2])).replace(new RegExp(s2[0], "g"), s2[d2])).replace(new RegExp(r[0], "g"), r[d2])).replace(/\\(.)/g, "$1");
    } }, { key: "getTimeUnitsfromTimestamp", value: function(e2, t2, i) {
      var a2 = this.w;
      a2.config.xaxis.min !== void 0 && (e2 = a2.config.xaxis.min), a2.config.xaxis.max !== void 0 && (t2 = a2.config.xaxis.max);
      var s2 = this.getDate(e2), r = this.getDate(t2), n2 = this.formatDate(s2, "yyyy MM dd HH mm ss fff").split(" "), o2 = this.formatDate(r, "yyyy MM dd HH mm ss fff").split(" ");
      return { minMillisecond: parseInt(n2[6], 10), maxMillisecond: parseInt(o2[6], 10), minSecond: parseInt(n2[5], 10), maxSecond: parseInt(o2[5], 10), minMinute: parseInt(n2[4], 10), maxMinute: parseInt(o2[4], 10), minHour: parseInt(n2[3], 10), maxHour: parseInt(o2[3], 10), minDate: parseInt(n2[2], 10), maxDate: parseInt(o2[2], 10), minMonth: parseInt(n2[1], 10) - 1, maxMonth: parseInt(o2[1], 10) - 1, minYear: parseInt(n2[0], 10), maxYear: parseInt(o2[0], 10) };
    } }, { key: "isLeapYear", value: function(e2) {
      return e2 % 4 == 0 && e2 % 100 != 0 || e2 % 400 == 0;
    } }, { key: "calculcateLastDaysOfMonth", value: function(e2, t2, i) {
      return this.determineDaysOfMonths(e2, t2) - i;
    } }, { key: "determineDaysOfYear", value: function(e2) {
      var t2 = 365;
      return this.isLeapYear(e2) && (t2 = 366), t2;
    } }, { key: "determineRemainingDaysOfYear", value: function(e2, t2, i) {
      var a2 = this.daysCntOfYear[t2] + i;
      return t2 > 1 && this.isLeapYear() && a2++, a2;
    } }, { key: "determineDaysOfMonths", value: function(e2, t2) {
      var i = 30;
      switch (e2 = P2.monthMod(e2), true) {
        case this.months30.indexOf(e2) > -1:
          e2 === 2 && (i = this.isLeapYear(t2) ? 29 : 28);
          break;
        case this.months31.indexOf(e2) > -1:
        default:
          i = 31;
      }
      return i;
    } }]), y2;
  }(), re2 = function() {
    function y2(e2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w, this.tooltipKeyFormat = "dd MMM";
    }
    return Y2(y2, [{ key: "xLabelFormat", value: function(e2, t2, i, a2) {
      var s2 = this.w;
      if (s2.config.xaxis.type === "datetime" && s2.config.xaxis.labels.formatter === void 0 && s2.config.tooltip.x.formatter === void 0) {
        var r = new B3(this.ctx);
        return r.formatDate(r.getDate(t2), s2.config.tooltip.x.format);
      }
      return e2(t2, i, a2);
    } }, { key: "defaultGeneralFormatter", value: function(e2) {
      return Array.isArray(e2) ? e2.map(function(t2) {
        return t2;
      }) : e2;
    } }, { key: "defaultYFormatter", value: function(e2, t2, i) {
      var a2 = this.w;
      return P2.isNumber(e2) && (e2 = a2.globals.yValueDecimal !== 0 ? e2.toFixed(t2.decimalsInFloat !== void 0 ? t2.decimalsInFloat : a2.globals.yValueDecimal) : a2.globals.maxYArr[i] - a2.globals.minYArr[i] < 5 ? e2.toFixed(1) : e2.toFixed(0)), e2;
    } }, { key: "setLabelFormatters", value: function() {
      var e2 = this, t2 = this.w;
      return t2.globals.xaxisTooltipFormatter = function(i) {
        return e2.defaultGeneralFormatter(i);
      }, t2.globals.ttKeyFormatter = function(i) {
        return e2.defaultGeneralFormatter(i);
      }, t2.globals.ttZFormatter = function(i) {
        return i;
      }, t2.globals.legendFormatter = function(i) {
        return e2.defaultGeneralFormatter(i);
      }, t2.config.xaxis.labels.formatter !== void 0 ? t2.globals.xLabelFormatter = t2.config.xaxis.labels.formatter : t2.globals.xLabelFormatter = function(i) {
        if (P2.isNumber(i)) {
          if (!t2.config.xaxis.convertedCatToNumeric && t2.config.xaxis.type === "numeric") {
            if (P2.isNumber(t2.config.xaxis.decimalsInFloat))
              return i.toFixed(t2.config.xaxis.decimalsInFloat);
            var a2 = t2.globals.maxX - t2.globals.minX;
            return a2 > 0 && a2 < 100 ? i.toFixed(1) : i.toFixed(0);
          }
          return t2.globals.isBarHorizontal && t2.globals.maxY - t2.globals.minYArr < 4 ? i.toFixed(1) : i.toFixed(0);
        }
        return i;
      }, typeof t2.config.tooltip.x.formatter == "function" ? t2.globals.ttKeyFormatter = t2.config.tooltip.x.formatter : t2.globals.ttKeyFormatter = t2.globals.xLabelFormatter, typeof t2.config.xaxis.tooltip.formatter == "function" && (t2.globals.xaxisTooltipFormatter = t2.config.xaxis.tooltip.formatter), (Array.isArray(t2.config.tooltip.y) || t2.config.tooltip.y.formatter !== void 0) && (t2.globals.ttVal = t2.config.tooltip.y), t2.config.tooltip.z.formatter !== void 0 && (t2.globals.ttZFormatter = t2.config.tooltip.z.formatter), t2.config.legend.formatter !== void 0 && (t2.globals.legendFormatter = t2.config.legend.formatter), t2.config.yaxis.forEach(function(i, a2) {
        i.labels.formatter !== void 0 ? t2.globals.yLabelFormatters[a2] = i.labels.formatter : t2.globals.yLabelFormatters[a2] = function(s2) {
          return t2.globals.xyCharts ? Array.isArray(s2) ? s2.map(function(r) {
            return e2.defaultYFormatter(r, i, a2);
          }) : e2.defaultYFormatter(s2, i, a2) : s2;
        };
      }), t2.globals;
    } }, { key: "heatmapLabelFormatters", value: function() {
      var e2 = this.w;
      if (e2.config.chart.type === "heatmap") {
        e2.globals.yAxisScale[0].result = e2.globals.seriesNames.slice();
        var t2 = e2.globals.seriesNames.reduce(function(i, a2) {
          return i.length > a2.length ? i : a2;
        }, 0);
        e2.globals.yAxisScale[0].niceMax = t2, e2.globals.yAxisScale[0].niceMin = t2;
      }
    } }]), y2;
  }(), fe2 = function(y2) {
    var e2, t2 = y2.isTimeline, i = y2.ctx, a2 = y2.seriesIndex, s2 = y2.dataPointIndex, r = y2.y1, n2 = y2.y2, o2 = y2.w, h2 = o2.globals.seriesRangeStart[a2][s2], c2 = o2.globals.seriesRangeEnd[a2][s2], d2 = o2.globals.labels[s2], g2 = o2.config.series[a2].name ? o2.config.series[a2].name : "", p2 = o2.globals.ttKeyFormatter, f2 = o2.config.tooltip.y.title.formatter, b2 = { w: o2, seriesIndex: a2, dataPointIndex: s2, start: h2, end: c2 };
    typeof f2 == "function" && (g2 = f2(g2, b2)), (e2 = o2.config.series[a2].data[s2]) !== null && e2 !== void 0 && e2.x && (d2 = o2.config.series[a2].data[s2].x), t2 || o2.config.xaxis.type === "datetime" && (d2 = new re2(i).xLabelFormat(o2.globals.ttKeyFormatter, d2, d2, { i: void 0, dateFormatter: new B3(i).formatDate, w: o2 })), typeof p2 == "function" && (d2 = p2(d2, b2)), Number.isFinite(r) && Number.isFinite(n2) && (h2 = r, c2 = n2);
    var m2 = "", w2 = "", A2 = o2.globals.colors[a2];
    if (o2.config.tooltip.x.formatter === void 0)
      if (o2.config.xaxis.type === "datetime") {
        var l2 = new B3(i);
        m2 = l2.formatDate(l2.getDate(h2), o2.config.tooltip.x.format), w2 = l2.formatDate(l2.getDate(c2), o2.config.tooltip.x.format);
      } else
        m2 = h2, w2 = c2;
    else
      m2 = o2.config.tooltip.x.formatter(h2), w2 = o2.config.tooltip.x.formatter(c2);
    return { start: h2, end: c2, startVal: m2, endVal: w2, ylabel: d2, color: A2, seriesName: g2 };
  }, ne2 = function(y2) {
    var e2 = y2.color, t2 = y2.seriesName, i = y2.ylabel, a2 = y2.start, s2 = y2.end, r = y2.seriesIndex, n2 = y2.dataPointIndex, o2 = y2.ctx.tooltip.tooltipLabels.getFormatters(r);
    a2 = o2.yLbFormatter(a2), s2 = o2.yLbFormatter(s2);
    var h2 = o2.yLbFormatter(y2.w.globals.series[r][n2]), c2 = `<span class="value start-value">
  `.concat(a2, `
  </span> <span class="separator">-</span> <span class="value end-value">
  `).concat(s2, `
  </span>`);
    return '<div class="apexcharts-tooltip-rangebar"><div> <span class="series-name" style="color: ' + e2 + '">' + (t2 || "") + '</span></div><div> <span class="category">' + i + ": </span> " + (y2.w.globals.comboCharts ? y2.w.config.series[r].type === "rangeArea" || y2.w.config.series[r].type === "rangeBar" ? c2 : "<span>".concat(h2, "</span>") : c2) + " </div></div>";
  }, oe2 = function() {
    function y2(e2) {
      F2(this, y2), this.opts = e2;
    }
    return Y2(y2, [{ key: "hideYAxis", value: function() {
      this.opts.yaxis[0].show = false, this.opts.yaxis[0].title.text = "", this.opts.yaxis[0].axisBorder.show = false, this.opts.yaxis[0].axisTicks.show = false, this.opts.yaxis[0].floating = true;
    } }, { key: "line", value: function() {
      return { chart: { animations: { easing: "swing" } }, dataLabels: { enabled: false }, stroke: { width: 5, curve: "straight" }, markers: { size: 0, hover: { sizeOffset: 6 } }, xaxis: { crosshairs: { width: 1 } } };
    } }, { key: "sparkline", value: function(e2) {
      return this.hideYAxis(), P2.extend(e2, { grid: { show: false, padding: { left: 0, right: 0, top: 0, bottom: 0 } }, legend: { show: false }, xaxis: { labels: { show: false }, tooltip: { enabled: false }, axisBorder: { show: false }, axisTicks: { show: false } }, chart: { toolbar: { show: false }, zoom: { enabled: false } }, dataLabels: { enabled: false } });
    } }, { key: "bar", value: function() {
      return { chart: { stacked: false, animations: { easing: "swing" } }, plotOptions: { bar: { dataLabels: { position: "center" } } }, dataLabels: { style: { colors: ["#fff"] }, background: { enabled: false } }, stroke: { width: 0, lineCap: "round" }, fill: { opacity: 0.85 }, legend: { markers: { shape: "square", radius: 2, size: 8 } }, tooltip: { shared: false, intersect: true }, xaxis: { tooltip: { enabled: false }, tickPlacement: "between", crosshairs: { width: "barWidth", position: "back", fill: { type: "gradient" }, dropShadow: { enabled: false }, stroke: { width: 0 } } } };
    } }, { key: "funnel", value: function() {
      return this.hideYAxis(), X2(X2({}, this.bar()), {}, { chart: { animations: { easing: "linear", speed: 800, animateGradually: { enabled: false } } }, plotOptions: { bar: { horizontal: true, borderRadiusApplication: "around", borderRadius: 0, dataLabels: { position: "center" } } }, grid: { show: false, padding: { left: 0, right: 0 } }, xaxis: { labels: { show: false }, tooltip: { enabled: false }, axisBorder: { show: false }, axisTicks: { show: false } } });
    } }, { key: "candlestick", value: function() {
      var e2 = this;
      return { stroke: { width: 1, colors: ["#333"] }, fill: { opacity: 1 }, dataLabels: { enabled: false }, tooltip: { shared: true, custom: function(t2) {
        var i = t2.seriesIndex, a2 = t2.dataPointIndex, s2 = t2.w;
        return e2._getBoxTooltip(s2, i, a2, ["Open", "High", "", "Low", "Close"], "candlestick");
      } }, states: { active: { filter: { type: "none" } } }, xaxis: { crosshairs: { width: 1 } } };
    } }, { key: "boxPlot", value: function() {
      var e2 = this;
      return { chart: { animations: { dynamicAnimation: { enabled: false } } }, stroke: { width: 1, colors: ["#24292e"] }, dataLabels: { enabled: false }, tooltip: { shared: true, custom: function(t2) {
        var i = t2.seriesIndex, a2 = t2.dataPointIndex, s2 = t2.w;
        return e2._getBoxTooltip(s2, i, a2, ["Minimum", "Q1", "Median", "Q3", "Maximum"], "boxPlot");
      } }, markers: { size: 5, strokeWidth: 1, strokeColors: "#111" }, xaxis: { crosshairs: { width: 1 } } };
    } }, { key: "rangeBar", value: function() {
      return { chart: { animations: { animateGradually: false } }, stroke: { width: 0, lineCap: "square" }, plotOptions: { bar: { borderRadius: 0, dataLabels: { position: "center" } } }, dataLabels: { enabled: false, formatter: function(e2, t2) {
        t2.ctx;
        var i = t2.seriesIndex, a2 = t2.dataPointIndex, s2 = t2.w, r = function() {
          var n2 = s2.globals.seriesRangeStart[i][a2];
          return s2.globals.seriesRangeEnd[i][a2] - n2;
        };
        return s2.globals.comboCharts ? s2.config.series[i].type === "rangeBar" || s2.config.series[i].type === "rangeArea" ? r() : e2 : r();
      }, background: { enabled: false }, style: { colors: ["#fff"] } }, markers: { size: 10 }, tooltip: { shared: false, followCursor: true, custom: function(e2) {
        return e2.w.config.plotOptions && e2.w.config.plotOptions.bar && e2.w.config.plotOptions.bar.horizontal ? function(t2) {
          var i = fe2(X2(X2({}, t2), {}, { isTimeline: true })), a2 = i.color, s2 = i.seriesName, r = i.ylabel, n2 = i.startVal, o2 = i.endVal;
          return ne2(X2(X2({}, t2), {}, { color: a2, seriesName: s2, ylabel: r, start: n2, end: o2 }));
        }(e2) : function(t2) {
          var i = fe2(t2), a2 = i.color, s2 = i.seriesName, r = i.ylabel, n2 = i.start, o2 = i.end;
          return ne2(X2(X2({}, t2), {}, { color: a2, seriesName: s2, ylabel: r, start: n2, end: o2 }));
        }(e2);
      } }, xaxis: { tickPlacement: "between", tooltip: { enabled: false }, crosshairs: { stroke: { width: 0 } } } };
    } }, { key: "dumbbell", value: function(e2) {
      var t2, i;
      return (t2 = e2.plotOptions.bar) !== null && t2 !== void 0 && t2.barHeight || (e2.plotOptions.bar.barHeight = 2), (i = e2.plotOptions.bar) !== null && i !== void 0 && i.columnWidth || (e2.plotOptions.bar.columnWidth = 2), e2;
    } }, { key: "area", value: function() {
      return { stroke: { width: 4, fill: { type: "solid", gradient: { inverseColors: false, shade: "light", type: "vertical", opacityFrom: 0.65, opacityTo: 0.5, stops: [0, 100, 100] } } }, fill: { type: "gradient", gradient: { inverseColors: false, shade: "light", type: "vertical", opacityFrom: 0.65, opacityTo: 0.5, stops: [0, 100, 100] } }, markers: { size: 0, hover: { sizeOffset: 6 } }, tooltip: { followCursor: false } };
    } }, { key: "rangeArea", value: function() {
      return { stroke: { curve: "straight", width: 0 }, fill: { type: "solid", opacity: 0.6 }, markers: { size: 0 }, states: { hover: { filter: { type: "none" } }, active: { filter: { type: "none" } } }, tooltip: { intersect: false, shared: true, followCursor: true, custom: function(e2) {
        return function(t2) {
          var i = fe2(t2), a2 = i.color, s2 = i.seriesName, r = i.ylabel, n2 = i.start, o2 = i.end;
          return ne2(X2(X2({}, t2), {}, { color: a2, seriesName: s2, ylabel: r, start: n2, end: o2 }));
        }(e2);
      } } };
    } }, { key: "brush", value: function(e2) {
      return P2.extend(e2, { chart: { toolbar: { autoSelected: "selection", show: false }, zoom: { enabled: false } }, dataLabels: { enabled: false }, stroke: { width: 1 }, tooltip: { enabled: false }, xaxis: { tooltip: { enabled: false } } });
    } }, { key: "stacked100", value: function(e2) {
      e2.dataLabels = e2.dataLabels || {}, e2.dataLabels.formatter = e2.dataLabels.formatter || void 0;
      var t2 = e2.dataLabels.formatter;
      return e2.yaxis.forEach(function(i, a2) {
        e2.yaxis[a2].min = 0, e2.yaxis[a2].max = 100;
      }), e2.chart.type === "bar" && (e2.dataLabels.formatter = t2 || function(i) {
        return typeof i == "number" && i ? i.toFixed(0) + "%" : i;
      }), e2;
    } }, { key: "stackedBars", value: function() {
      var e2 = this.bar();
      return X2(X2({}, e2), {}, { plotOptions: X2(X2({}, e2.plotOptions), {}, { bar: X2(X2({}, e2.plotOptions.bar), {}, { borderRadiusApplication: "end", borderRadiusWhenStacked: "last" }) }) });
    } }, { key: "convertCatToNumeric", value: function(e2) {
      return e2.xaxis.convertedCatToNumeric = true, e2;
    } }, { key: "convertCatToNumericXaxis", value: function(e2, t2, i) {
      e2.xaxis.type = "numeric", e2.xaxis.labels = e2.xaxis.labels || {}, e2.xaxis.labels.formatter = e2.xaxis.labels.formatter || function(r) {
        return P2.isNumber(r) ? Math.floor(r) : r;
      };
      var a2 = e2.xaxis.labels.formatter, s2 = e2.xaxis.categories && e2.xaxis.categories.length ? e2.xaxis.categories : e2.labels;
      return i && i.length && (s2 = i.map(function(r) {
        return Array.isArray(r) ? r : String(r);
      })), s2 && s2.length && (e2.xaxis.labels.formatter = function(r) {
        return P2.isNumber(r) ? a2(s2[Math.floor(r) - 1]) : a2(r);
      }), e2.xaxis.categories = [], e2.labels = [], e2.xaxis.tickAmount = e2.xaxis.tickAmount || "dataPoints", e2;
    } }, { key: "bubble", value: function() {
      return { dataLabels: { style: { colors: ["#fff"] } }, tooltip: { shared: false, intersect: true }, xaxis: { crosshairs: { width: 0 } }, fill: { type: "solid", gradient: { shade: "light", inverse: true, shadeIntensity: 0.55, opacityFrom: 0.4, opacityTo: 0.8 } } };
    } }, { key: "scatter", value: function() {
      return { dataLabels: { enabled: false }, tooltip: { shared: false, intersect: true }, markers: { size: 6, strokeWidth: 1, hover: { sizeOffset: 2 } } };
    } }, { key: "heatmap", value: function() {
      return { chart: { stacked: false }, fill: { opacity: 1 }, dataLabels: { style: { colors: ["#fff"] } }, stroke: { colors: ["#fff"] }, tooltip: { followCursor: true, marker: { show: false }, x: { show: false } }, legend: { position: "top", markers: { shape: "square", size: 10, offsetY: 2 } }, grid: { padding: { right: 20 } } };
    } }, { key: "treemap", value: function() {
      return { chart: { zoom: { enabled: false } }, dataLabels: { style: { fontSize: 14, fontWeight: 600, colors: ["#fff"] } }, stroke: { show: true, width: 2, colors: ["#fff"] }, legend: { show: false }, fill: { gradient: { stops: [0, 100] } }, tooltip: { followCursor: true, x: { show: false } }, grid: { padding: { left: 0, right: 0 } }, xaxis: { crosshairs: { show: false }, tooltip: { enabled: false } } };
    } }, { key: "pie", value: function() {
      return { chart: { toolbar: { show: false } }, plotOptions: { pie: { donut: { labels: { show: false } } } }, dataLabels: { formatter: function(e2) {
        return e2.toFixed(1) + "%";
      }, style: { colors: ["#fff"] }, background: { enabled: false }, dropShadow: { enabled: true } }, stroke: { colors: ["#fff"] }, fill: { opacity: 1, gradient: { shade: "light", stops: [0, 100] } }, tooltip: { theme: "dark", fillSeriesColor: true }, legend: { position: "right" } };
    } }, { key: "donut", value: function() {
      return { chart: { toolbar: { show: false } }, dataLabels: { formatter: function(e2) {
        return e2.toFixed(1) + "%";
      }, style: { colors: ["#fff"] }, background: { enabled: false }, dropShadow: { enabled: true } }, stroke: { colors: ["#fff"] }, fill: { opacity: 1, gradient: { shade: "light", shadeIntensity: 0.35, stops: [80, 100], opacityFrom: 1, opacityTo: 1 } }, tooltip: { theme: "dark", fillSeriesColor: true }, legend: { position: "right" } };
    } }, { key: "polarArea", value: function() {
      return this.opts.yaxis[0].tickAmount = this.opts.yaxis[0].tickAmount ? this.opts.yaxis[0].tickAmount : 6, { chart: { toolbar: { show: false } }, dataLabels: { formatter: function(e2) {
        return e2.toFixed(1) + "%";
      }, enabled: false }, stroke: { show: true, width: 2 }, fill: { opacity: 0.7 }, tooltip: { theme: "dark", fillSeriesColor: true }, legend: { position: "right" } };
    } }, { key: "radar", value: function() {
      return this.opts.yaxis[0].labels.offsetY = this.opts.yaxis[0].labels.offsetY ? this.opts.yaxis[0].labels.offsetY : 6, { dataLabels: { enabled: false, style: { fontSize: "11px" } }, stroke: { width: 2 }, markers: { size: 3, strokeWidth: 1, strokeOpacity: 1 }, fill: { opacity: 0.2 }, tooltip: { shared: false, intersect: true, followCursor: true }, grid: { show: false }, xaxis: { labels: { formatter: function(e2) {
        return e2;
      }, style: { colors: ["#a8a8a8"], fontSize: "11px" } }, tooltip: { enabled: false }, crosshairs: { show: false } } };
    } }, { key: "radialBar", value: function() {
      return { chart: { animations: { dynamicAnimation: { enabled: true, speed: 800 } }, toolbar: { show: false } }, fill: { gradient: { shade: "dark", shadeIntensity: 0.4, inverseColors: false, type: "diagonal2", opacityFrom: 1, opacityTo: 1, stops: [70, 98, 100] } }, legend: { show: false, position: "right" }, tooltip: { enabled: false, fillSeriesColor: true } };
    } }, { key: "_getBoxTooltip", value: function(e2, t2, i, a2, s2) {
      var r = e2.globals.seriesCandleO[t2][i], n2 = e2.globals.seriesCandleH[t2][i], o2 = e2.globals.seriesCandleM[t2][i], h2 = e2.globals.seriesCandleL[t2][i], c2 = e2.globals.seriesCandleC[t2][i];
      return e2.config.series[t2].type && e2.config.series[t2].type !== s2 ? `<div class="apexcharts-custom-tooltip">
          `.concat(e2.config.series[t2].name ? e2.config.series[t2].name : "series-" + (t2 + 1), ": <strong>").concat(e2.globals.series[t2][i], `</strong>
        </div>`) : '<div class="apexcharts-tooltip-box apexcharts-tooltip-'.concat(e2.config.chart.type, '">') + "<div>".concat(a2[0], ': <span class="value">') + r + "</span></div>" + "<div>".concat(a2[1], ': <span class="value">') + n2 + "</span></div>" + (o2 ? "<div>".concat(a2[2], ': <span class="value">') + o2 + "</span></div>" : "") + "<div>".concat(a2[3], ': <span class="value">') + h2 + "</span></div>" + "<div>".concat(a2[4], ': <span class="value">') + c2 + "</span></div></div>";
    } }]), y2;
  }(), Le2 = function() {
    function y2(e2) {
      F2(this, y2), this.opts = e2;
    }
    return Y2(y2, [{ key: "init", value: function(e2) {
      var t2 = e2.responsiveOverride, i = this.opts, a2 = new G2(), s2 = new oe2(i);
      this.chartType = i.chart.type, i = this.extendYAxis(i), i = this.extendAnnotations(i);
      var r = a2.init(), n2 = {};
      if (i && U2(i) === "object") {
        var o2, h2, c2, d2, g2, p2, f2, b2, m2 = {};
        m2 = ["line", "area", "bar", "candlestick", "boxPlot", "rangeBar", "rangeArea", "bubble", "scatter", "heatmap", "treemap", "pie", "polarArea", "donut", "radar", "radialBar"].indexOf(i.chart.type) !== -1 ? s2[i.chart.type]() : s2.line(), (o2 = i.plotOptions) !== null && o2 !== void 0 && (h2 = o2.bar) !== null && h2 !== void 0 && h2.isFunnel && (m2 = s2.funnel()), i.chart.stacked && i.chart.type === "bar" && (m2 = s2.stackedBars()), (c2 = i.chart.brush) !== null && c2 !== void 0 && c2.enabled && (m2 = s2.brush(m2)), i.chart.stacked && i.chart.stackType === "100%" && (i = s2.stacked100(i)), (d2 = i.plotOptions) !== null && d2 !== void 0 && (g2 = d2.bar) !== null && g2 !== void 0 && g2.isDumbbell && (i = s2.dumbbell(i)), this.checkForDarkTheme(window.Apex), this.checkForDarkTheme(i), i.xaxis = i.xaxis || window.Apex.xaxis || {}, t2 || (i.xaxis.convertedCatToNumeric = false), ((p2 = (i = this.checkForCatToNumericXAxis(this.chartType, m2, i)).chart.sparkline) !== null && p2 !== void 0 && p2.enabled || (f2 = window.Apex.chart) !== null && f2 !== void 0 && (b2 = f2.sparkline) !== null && b2 !== void 0 && b2.enabled) && (m2 = s2.sparkline(m2)), n2 = P2.extend(r, m2);
      }
      var w2 = P2.extend(n2, window.Apex);
      return r = P2.extend(w2, i), r = this.handleUserInputErrors(r);
    } }, { key: "checkForCatToNumericXAxis", value: function(e2, t2, i) {
      var a2, s2, r = new oe2(i), n2 = (e2 === "bar" || e2 === "boxPlot") && ((a2 = i.plotOptions) === null || a2 === void 0 || (s2 = a2.bar) === null || s2 === void 0 ? void 0 : s2.horizontal), o2 = e2 === "pie" || e2 === "polarArea" || e2 === "donut" || e2 === "radar" || e2 === "radialBar" || e2 === "heatmap", h2 = i.xaxis.type !== "datetime" && i.xaxis.type !== "numeric", c2 = i.xaxis.tickPlacement ? i.xaxis.tickPlacement : t2.xaxis && t2.xaxis.tickPlacement;
      return n2 || o2 || !h2 || c2 === "between" || (i = r.convertCatToNumeric(i)), i;
    } }, { key: "extendYAxis", value: function(e2, t2) {
      var i = new G2();
      (e2.yaxis === void 0 || !e2.yaxis || Array.isArray(e2.yaxis) && e2.yaxis.length === 0) && (e2.yaxis = {}), e2.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array && (e2.yaxis = P2.extend(e2.yaxis, window.Apex.yaxis)), e2.yaxis.constructor !== Array ? e2.yaxis = [P2.extend(i.yAxis, e2.yaxis)] : e2.yaxis = P2.extendArray(e2.yaxis, i.yAxis);
      var a2 = false;
      e2.yaxis.forEach(function(r) {
        r.logarithmic && (a2 = true);
      });
      var s2 = e2.series;
      return t2 && !s2 && (s2 = t2.config.series), a2 && s2.length !== e2.yaxis.length && s2.length && (e2.yaxis = s2.map(function(r, n2) {
        if (r.name || (s2[n2].name = "series-".concat(n2 + 1)), e2.yaxis[n2])
          return e2.yaxis[n2].seriesName = s2[n2].name, e2.yaxis[n2];
        var o2 = P2.extend(i.yAxis, e2.yaxis[0]);
        return o2.show = false, o2;
      })), a2 && s2.length > 1 && s2.length !== e2.yaxis.length && console.warn("A multi-series logarithmic chart should have equal number of series and y-axes"), e2;
    } }, { key: "extendAnnotations", value: function(e2) {
      return e2.annotations === void 0 && (e2.annotations = {}, e2.annotations.yaxis = [], e2.annotations.xaxis = [], e2.annotations.points = []), e2 = this.extendYAxisAnnotations(e2), e2 = this.extendXAxisAnnotations(e2), e2 = this.extendPointAnnotations(e2);
    } }, { key: "extendYAxisAnnotations", value: function(e2) {
      var t2 = new G2();
      return e2.annotations.yaxis = P2.extendArray(e2.annotations.yaxis !== void 0 ? e2.annotations.yaxis : [], t2.yAxisAnnotation), e2;
    } }, { key: "extendXAxisAnnotations", value: function(e2) {
      var t2 = new G2();
      return e2.annotations.xaxis = P2.extendArray(e2.annotations.xaxis !== void 0 ? e2.annotations.xaxis : [], t2.xAxisAnnotation), e2;
    } }, { key: "extendPointAnnotations", value: function(e2) {
      var t2 = new G2();
      return e2.annotations.points = P2.extendArray(e2.annotations.points !== void 0 ? e2.annotations.points : [], t2.pointAnnotation), e2;
    } }, { key: "checkForDarkTheme", value: function(e2) {
      e2.theme && e2.theme.mode === "dark" && (e2.tooltip || (e2.tooltip = {}), e2.tooltip.theme !== "light" && (e2.tooltip.theme = "dark"), e2.chart.foreColor || (e2.chart.foreColor = "#f6f7f8"), e2.chart.background || (e2.chart.background = "#424242"), e2.theme.palette || (e2.theme.palette = "palette4"));
    } }, { key: "handleUserInputErrors", value: function(e2) {
      var t2 = e2;
      if (t2.tooltip.shared && t2.tooltip.intersect)
        throw new Error("tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.");
      if (t2.chart.type === "bar" && t2.plotOptions.bar.horizontal) {
        if (t2.yaxis.length > 1)
          throw new Error("Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false");
        t2.yaxis[0].reversed && (t2.yaxis[0].opposite = true), t2.xaxis.tooltip.enabled = false, t2.yaxis[0].tooltip.enabled = false, t2.chart.zoom.enabled = false;
      }
      return t2.chart.type !== "bar" && t2.chart.type !== "rangeBar" || t2.tooltip.shared && t2.xaxis.crosshairs.width === "barWidth" && t2.series.length > 1 && (t2.xaxis.crosshairs.width = "tickWidth"), t2.chart.type !== "candlestick" && t2.chart.type !== "boxPlot" || t2.yaxis[0].reversed && (console.warn("Reversed y-axis in ".concat(t2.chart.type, " chart is not supported.")), t2.yaxis[0].reversed = false), t2;
    } }]), y2;
  }(), Ze = function() {
    function y2() {
      F2(this, y2);
    }
    return Y2(y2, [{ key: "initGlobalVars", value: function(e2) {
      e2.series = [], e2.seriesCandleO = [], e2.seriesCandleH = [], e2.seriesCandleM = [], e2.seriesCandleL = [], e2.seriesCandleC = [], e2.seriesRangeStart = [], e2.seriesRangeEnd = [], e2.seriesRange = [], e2.seriesPercent = [], e2.seriesGoals = [], e2.seriesX = [], e2.seriesZ = [], e2.seriesNames = [], e2.seriesTotals = [], e2.seriesLog = [], e2.seriesColors = [], e2.stackedSeriesTotals = [], e2.seriesXvalues = [], e2.seriesYvalues = [], e2.labels = [], e2.hasXaxisGroups = false, e2.groups = [], e2.hasSeriesGroups = false, e2.seriesGroups = [], e2.categoryLabels = [], e2.timescaleLabels = [], e2.noLabelsProvided = false, e2.resizeTimer = null, e2.selectionResizeTimer = null, e2.delayedElements = [], e2.pointsArray = [], e2.dataLabelsRects = [], e2.isXNumeric = false, e2.skipLastTimelinelabel = false, e2.skipFirstTimelinelabel = false, e2.isDataXYZ = false, e2.isMultiLineX = false, e2.isMultipleYAxis = false, e2.maxY = -Number.MAX_VALUE, e2.minY = Number.MIN_VALUE, e2.minYArr = [], e2.maxYArr = [], e2.maxX = -Number.MAX_VALUE, e2.minX = Number.MAX_VALUE, e2.initialMaxX = -Number.MAX_VALUE, e2.initialMinX = Number.MAX_VALUE, e2.maxDate = 0, e2.minDate = Number.MAX_VALUE, e2.minZ = Number.MAX_VALUE, e2.maxZ = -Number.MAX_VALUE, e2.minXDiff = Number.MAX_VALUE, e2.yAxisScale = [], e2.xAxisScale = null, e2.xAxisTicksPositions = [], e2.yLabelsCoords = [], e2.yTitleCoords = [], e2.barPadForNumericAxis = 0, e2.padHorizontal = 0, e2.xRange = 0, e2.yRange = [], e2.zRange = 0, e2.dataPoints = 0, e2.xTickAmount = 0;
    } }, { key: "globalVars", value: function(e2) {
      return { chartID: null, cuid: null, events: { beforeMount: [], mounted: [], updated: [], clicked: [], selection: [], dataPointSelection: [], zoomed: [], scrolled: [] }, colors: [], clientX: null, clientY: null, fill: { colors: [] }, stroke: { colors: [] }, dataLabels: { style: { colors: [] } }, radarPolygons: { fill: { colors: [] } }, markers: { colors: [], size: e2.markers.size, largestSize: 0 }, animationEnded: false, isTouchDevice: "ontouchstart" in window || navigator.msMaxTouchPoints, isDirty: false, isExecCalled: false, initialConfig: null, initialSeries: [], lastXAxis: [], lastYAxis: [], columnSeries: null, labels: [], timescaleLabels: [], noLabelsProvided: false, allSeriesCollapsed: false, collapsedSeries: [], collapsedSeriesIndices: [], ancillaryCollapsedSeries: [], ancillaryCollapsedSeriesIndices: [], risingSeries: [], dataFormatXNumeric: false, capturedSeriesIndex: -1, capturedDataPointIndex: -1, selectedDataPoints: [], goldenPadding: 35, invalidLogScale: false, ignoreYAxisIndexes: [], yAxisSameScaleIndices: [], maxValsInArrayIndex: 0, radialSize: 0, selection: void 0, zoomEnabled: e2.chart.toolbar.autoSelected === "zoom" && e2.chart.toolbar.tools.zoom && e2.chart.zoom.enabled, panEnabled: e2.chart.toolbar.autoSelected === "pan" && e2.chart.toolbar.tools.pan, selectionEnabled: e2.chart.toolbar.autoSelected === "selection" && e2.chart.toolbar.tools.selection, yaxis: null, mousedown: false, lastClientPosition: {}, visibleXRange: void 0, yValueDecimal: 0, total: 0, SVGNS: "http://www.w3.org/2000/svg", svgWidth: 0, svgHeight: 0, noData: false, locale: {}, dom: {}, memory: { methodsToExec: [] }, shouldAnimate: true, skipLastTimelinelabel: false, skipFirstTimelinelabel: false, delayedElements: [], axisCharts: true, isDataXYZ: false, resized: false, resizeTimer: null, comboCharts: false, dataChanged: false, previousPaths: [], allSeriesHasEqualX: true, pointsArray: [], dataLabelsRects: [], lastDrawnDataLabelsIndexes: [], hasNullValues: false, easing: null, zoomed: false, gridWidth: 0, gridHeight: 0, rotateXLabels: false, defaultLabels: false, xLabelFormatter: void 0, yLabelFormatters: [], xaxisTooltipFormatter: void 0, ttKeyFormatter: void 0, ttVal: void 0, ttZFormatter: void 0, LINE_HEIGHT_RATIO: 1.618, xAxisLabelsHeight: 0, xAxisGroupLabelsHeight: 0, xAxisLabelsWidth: 0, yAxisLabelsWidth: 0, scaleX: 1, scaleY: 1, translateX: 0, translateY: 0, translateYAxisX: [], yAxisWidths: [], translateXAxisY: 0, translateXAxisX: 0, tooltip: null };
    } }, { key: "init", value: function(e2) {
      var t2 = this.globalVars(e2);
      return this.initGlobalVars(t2), t2.initialConfig = P2.extend({}, e2), t2.initialSeries = P2.clone(e2.series), t2.lastXAxis = P2.clone(t2.initialConfig.xaxis), t2.lastYAxis = P2.clone(t2.initialConfig.yaxis), t2;
    } }]), y2;
  }(), ft2 = function() {
    function y2(e2) {
      F2(this, y2), this.opts = e2;
    }
    return Y2(y2, [{ key: "init", value: function() {
      var e2 = new Le2(this.opts).init({ responsiveOverride: false });
      return { config: e2, globals: new Ze().init(e2) };
    } }]), y2;
  }(), ae2 = function() {
    function y2(e2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w, this.opts = null, this.seriesIndex = 0;
    }
    return Y2(y2, [{ key: "clippedImgArea", value: function(e2) {
      var t2 = this.w, i = t2.config, a2 = parseInt(t2.globals.gridWidth, 10), s2 = parseInt(t2.globals.gridHeight, 10), r = a2 > s2 ? a2 : s2, n2 = e2.image, o2 = 0, h2 = 0;
      e2.width === void 0 && e2.height === void 0 ? i.fill.image.width !== void 0 && i.fill.image.height !== void 0 ? (o2 = i.fill.image.width + 1, h2 = i.fill.image.height) : (o2 = r + 1, h2 = r) : (o2 = e2.width, h2 = e2.height);
      var c2 = document.createElementNS(t2.globals.SVGNS, "pattern");
      M2.setAttrs(c2, { id: e2.patternID, patternUnits: e2.patternUnits ? e2.patternUnits : "userSpaceOnUse", width: o2 + "px", height: h2 + "px" });
      var d2 = document.createElementNS(t2.globals.SVGNS, "image");
      c2.appendChild(d2), d2.setAttributeNS(window.SVG.xlink, "href", n2), M2.setAttrs(d2, { x: 0, y: 0, preserveAspectRatio: "none", width: o2 + "px", height: h2 + "px" }), d2.style.opacity = e2.opacity, t2.globals.dom.elDefs.node.appendChild(c2);
    } }, { key: "getSeriesIndex", value: function(e2) {
      var t2 = this.w, i = t2.config.chart.type;
      return (i === "bar" || i === "rangeBar") && t2.config.plotOptions.bar.distributed || i === "heatmap" || i === "treemap" ? this.seriesIndex = e2.seriesNumber : this.seriesIndex = e2.seriesNumber % t2.globals.series.length, this.seriesIndex;
    } }, { key: "fillPath", value: function(e2) {
      var t2 = this.w;
      this.opts = e2;
      var i, a2, s2, r = this.w.config;
      this.seriesIndex = this.getSeriesIndex(e2);
      var n2 = this.getFillColors()[this.seriesIndex];
      t2.globals.seriesColors[this.seriesIndex] !== void 0 && (n2 = t2.globals.seriesColors[this.seriesIndex]), typeof n2 == "function" && (n2 = n2({ seriesIndex: this.seriesIndex, dataPointIndex: e2.dataPointIndex, value: e2.value, w: t2 }));
      var o2 = e2.fillType ? e2.fillType : this.getFillType(this.seriesIndex), h2 = Array.isArray(r.fill.opacity) ? r.fill.opacity[this.seriesIndex] : r.fill.opacity;
      e2.color && (n2 = e2.color), n2 || (n2 = "#fff", console.warn("undefined color - ApexCharts"));
      var c2 = n2;
      if (n2.indexOf("rgb") === -1 ? n2.length < 9 && (c2 = P2.hexToRgba(n2, h2)) : n2.indexOf("rgba") > -1 && (h2 = P2.getOpacityFromRGBA(n2)), e2.opacity && (h2 = e2.opacity), o2 === "pattern" && (a2 = this.handlePatternFill({ fillConfig: e2.fillConfig, patternFill: a2, fillColor: n2, fillOpacity: h2, defaultColor: c2 })), o2 === "gradient" && (s2 = this.handleGradientFill({ fillConfig: e2.fillConfig, fillColor: n2, fillOpacity: h2, i: this.seriesIndex })), o2 === "image") {
        var d2 = r.fill.image.src, g2 = e2.patternID ? e2.patternID : "";
        this.clippedImgArea({ opacity: h2, image: Array.isArray(d2) ? e2.seriesNumber < d2.length ? d2[e2.seriesNumber] : d2[0] : d2, width: e2.width ? e2.width : void 0, height: e2.height ? e2.height : void 0, patternUnits: e2.patternUnits, patternID: "pattern".concat(t2.globals.cuid).concat(e2.seriesNumber + 1).concat(g2) }), i = "url(#pattern".concat(t2.globals.cuid).concat(e2.seriesNumber + 1).concat(g2, ")");
      } else
        i = o2 === "gradient" ? s2 : o2 === "pattern" ? a2 : c2;
      return e2.solid && (i = c2), i;
    } }, { key: "getFillType", value: function(e2) {
      var t2 = this.w;
      return Array.isArray(t2.config.fill.type) ? t2.config.fill.type[e2] : t2.config.fill.type;
    } }, { key: "getFillColors", value: function() {
      var e2 = this.w, t2 = e2.config, i = this.opts, a2 = [];
      return e2.globals.comboCharts ? e2.config.series[this.seriesIndex].type === "line" ? Array.isArray(e2.globals.stroke.colors) ? a2 = e2.globals.stroke.colors : a2.push(e2.globals.stroke.colors) : Array.isArray(e2.globals.fill.colors) ? a2 = e2.globals.fill.colors : a2.push(e2.globals.fill.colors) : t2.chart.type === "line" ? Array.isArray(e2.globals.stroke.colors) ? a2 = e2.globals.stroke.colors : a2.push(e2.globals.stroke.colors) : Array.isArray(e2.globals.fill.colors) ? a2 = e2.globals.fill.colors : a2.push(e2.globals.fill.colors), i.fillColors !== void 0 && (a2 = [], Array.isArray(i.fillColors) ? a2 = i.fillColors.slice() : a2.push(i.fillColors)), a2;
    } }, { key: "handlePatternFill", value: function(e2) {
      var t2 = e2.fillConfig, i = e2.patternFill, a2 = e2.fillColor, s2 = e2.fillOpacity, r = e2.defaultColor, n2 = this.w.config.fill;
      t2 && (n2 = t2);
      var o2 = this.opts, h2 = new M2(this.ctx), c2 = Array.isArray(n2.pattern.strokeWidth) ? n2.pattern.strokeWidth[this.seriesIndex] : n2.pattern.strokeWidth, d2 = a2;
      return Array.isArray(n2.pattern.style) ? i = n2.pattern.style[o2.seriesNumber] !== void 0 ? h2.drawPattern(n2.pattern.style[o2.seriesNumber], n2.pattern.width, n2.pattern.height, d2, c2, s2) : r : i = h2.drawPattern(n2.pattern.style, n2.pattern.width, n2.pattern.height, d2, c2, s2), i;
    } }, { key: "handleGradientFill", value: function(e2) {
      var t2 = e2.fillColor, i = e2.fillOpacity, a2 = e2.fillConfig, s2 = e2.i, r = this.w.config.fill;
      a2 && (r = X2(X2({}, r), a2));
      var n2, o2 = this.opts, h2 = new M2(this.ctx), c2 = new P2(), d2 = r.gradient.type, g2 = t2, p2 = r.gradient.opacityFrom === void 0 ? i : Array.isArray(r.gradient.opacityFrom) ? r.gradient.opacityFrom[s2] : r.gradient.opacityFrom;
      g2.indexOf("rgba") > -1 && (p2 = P2.getOpacityFromRGBA(g2));
      var f2 = r.gradient.opacityTo === void 0 ? i : Array.isArray(r.gradient.opacityTo) ? r.gradient.opacityTo[s2] : r.gradient.opacityTo;
      if (r.gradient.gradientToColors === void 0 || r.gradient.gradientToColors.length === 0)
        n2 = r.gradient.shade === "dark" ? c2.shadeColor(-1 * parseFloat(r.gradient.shadeIntensity), t2.indexOf("rgb") > -1 ? P2.rgb2hex(t2) : t2) : c2.shadeColor(parseFloat(r.gradient.shadeIntensity), t2.indexOf("rgb") > -1 ? P2.rgb2hex(t2) : t2);
      else if (r.gradient.gradientToColors[o2.seriesNumber]) {
        var b2 = r.gradient.gradientToColors[o2.seriesNumber];
        n2 = b2, b2.indexOf("rgba") > -1 && (f2 = P2.getOpacityFromRGBA(b2));
      } else
        n2 = t2;
      if (r.gradient.gradientFrom && (g2 = r.gradient.gradientFrom), r.gradient.gradientTo && (n2 = r.gradient.gradientTo), r.gradient.inverseColors) {
        var m2 = g2;
        g2 = n2, n2 = m2;
      }
      return g2.indexOf("rgb") > -1 && (g2 = P2.rgb2hex(g2)), n2.indexOf("rgb") > -1 && (n2 = P2.rgb2hex(n2)), h2.drawGradient(d2, g2, n2, p2, f2, o2.size, r.gradient.stops, r.gradient.colorStops, s2);
    } }]), y2;
  }(), Pe = function() {
    function y2(e2, t2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w;
    }
    return Y2(y2, [{ key: "setGlobalMarkerSize", value: function() {
      var e2 = this.w;
      if (e2.globals.markers.size = Array.isArray(e2.config.markers.size) ? e2.config.markers.size : [e2.config.markers.size], e2.globals.markers.size.length > 0) {
        if (e2.globals.markers.size.length < e2.globals.series.length + 1)
          for (var t2 = 0; t2 <= e2.globals.series.length; t2++)
            e2.globals.markers.size[t2] === void 0 && e2.globals.markers.size.push(e2.globals.markers.size[0]);
      } else
        e2.globals.markers.size = e2.config.series.map(function(i) {
          return e2.config.markers.size;
        });
    } }, { key: "plotChartMarkers", value: function(e2, t2, i, a2) {
      var s2, r = arguments.length > 4 && arguments[4] !== void 0 && arguments[4], n2 = this.w, o2 = t2, h2 = e2, c2 = null, d2 = new M2(this.ctx), g2 = n2.config.markers.discrete && n2.config.markers.discrete.length;
      if ((n2.globals.markers.size[t2] > 0 || r || g2) && (c2 = d2.group({ class: r || g2 ? "" : "apexcharts-series-markers" })).attr("clip-path", "url(#gridRectMarkerMask".concat(n2.globals.cuid, ")")), Array.isArray(h2.x))
        for (var p2 = 0; p2 < h2.x.length; p2++) {
          var f2 = i;
          i === 1 && p2 === 0 && (f2 = 0), i === 1 && p2 === 1 && (f2 = 1);
          var b2 = "apexcharts-marker";
          if (n2.config.chart.type !== "line" && n2.config.chart.type !== "area" || n2.globals.comboCharts || n2.config.tooltip.intersect || (b2 += " no-pointer-events"), (Array.isArray(n2.config.markers.size) ? n2.globals.markers.size[t2] > 0 : n2.config.markers.size > 0) || r || g2) {
            P2.isNumber(h2.y[p2]) ? b2 += " w".concat(P2.randomId()) : b2 = "apexcharts-nullpoint";
            var m2 = this.getMarkerConfig({ cssClass: b2, seriesIndex: t2, dataPointIndex: f2 });
            n2.config.series[o2].data[f2] && (n2.config.series[o2].data[f2].fillColor && (m2.pointFillColor = n2.config.series[o2].data[f2].fillColor), n2.config.series[o2].data[f2].strokeColor && (m2.pointStrokeColor = n2.config.series[o2].data[f2].strokeColor)), a2 && (m2.pSize = a2), (h2.x[p2] < 0 || h2.x[p2] > n2.globals.gridWidth || h2.y[p2] < -n2.globals.markers.largestSize || h2.y[p2] > n2.globals.gridHeight + n2.globals.markers.largestSize) && (m2.pSize = 0), (s2 = d2.drawMarker(h2.x[p2], h2.y[p2], m2)).attr("rel", f2), s2.attr("j", f2), s2.attr("index", t2), s2.node.setAttribute("default-marker-size", m2.pSize), new Z2(this.ctx).setSelectionFilter(s2, t2, f2), this.addEvents(s2), c2 && c2.add(s2);
          } else
            n2.globals.pointsArray[t2] === void 0 && (n2.globals.pointsArray[t2] = []), n2.globals.pointsArray[t2].push([h2.x[p2], h2.y[p2]]);
        }
      return c2;
    } }, { key: "getMarkerConfig", value: function(e2) {
      var t2 = e2.cssClass, i = e2.seriesIndex, a2 = e2.dataPointIndex, s2 = a2 === void 0 ? null : a2, r = e2.finishRadius, n2 = r === void 0 ? null : r, o2 = this.w, h2 = this.getMarkerStyle(i), c2 = o2.globals.markers.size[i], d2 = o2.config.markers;
      return s2 !== null && d2.discrete.length && d2.discrete.map(function(g2) {
        g2.seriesIndex === i && g2.dataPointIndex === s2 && (h2.pointStrokeColor = g2.strokeColor, h2.pointFillColor = g2.fillColor, c2 = g2.size, h2.pointShape = g2.shape);
      }), { pSize: n2 === null ? c2 : n2, pRadius: d2.radius, width: Array.isArray(d2.width) ? d2.width[i] : d2.width, height: Array.isArray(d2.height) ? d2.height[i] : d2.height, pointStrokeWidth: Array.isArray(d2.strokeWidth) ? d2.strokeWidth[i] : d2.strokeWidth, pointStrokeColor: h2.pointStrokeColor, pointFillColor: h2.pointFillColor, shape: h2.pointShape || (Array.isArray(d2.shape) ? d2.shape[i] : d2.shape), class: t2, pointStrokeOpacity: Array.isArray(d2.strokeOpacity) ? d2.strokeOpacity[i] : d2.strokeOpacity, pointStrokeDashArray: Array.isArray(d2.strokeDashArray) ? d2.strokeDashArray[i] : d2.strokeDashArray, pointFillOpacity: Array.isArray(d2.fillOpacity) ? d2.fillOpacity[i] : d2.fillOpacity, seriesIndex: i };
    } }, { key: "addEvents", value: function(e2) {
      var t2 = this.w, i = new M2(this.ctx);
      e2.node.addEventListener("mouseenter", i.pathMouseEnter.bind(this.ctx, e2)), e2.node.addEventListener("mouseleave", i.pathMouseLeave.bind(this.ctx, e2)), e2.node.addEventListener("mousedown", i.pathMouseDown.bind(this.ctx, e2)), e2.node.addEventListener("click", t2.config.markers.onClick), e2.node.addEventListener("dblclick", t2.config.markers.onDblClick), e2.node.addEventListener("touchstart", i.pathMouseDown.bind(this.ctx, e2), { passive: true });
    } }, { key: "getMarkerStyle", value: function(e2) {
      var t2 = this.w, i = t2.globals.markers.colors, a2 = t2.config.markers.strokeColor || t2.config.markers.strokeColors;
      return { pointStrokeColor: Array.isArray(a2) ? a2[e2] : a2, pointFillColor: Array.isArray(i) ? i[e2] : i };
    } }]), y2;
  }(), $e = function() {
    function y2(e2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled;
    }
    return Y2(y2, [{ key: "draw", value: function(e2, t2, i) {
      var a2 = this.w, s2 = new M2(this.ctx), r = i.realIndex, n2 = i.pointsPos, o2 = i.zRatio, h2 = i.elParent, c2 = s2.group({ class: "apexcharts-series-markers apexcharts-series-".concat(a2.config.chart.type) });
      if (c2.attr("clip-path", "url(#gridRectMarkerMask".concat(a2.globals.cuid, ")")), Array.isArray(n2.x))
        for (var d2 = 0; d2 < n2.x.length; d2++) {
          var g2 = t2 + 1, p2 = true;
          t2 === 0 && d2 === 0 && (g2 = 0), t2 === 0 && d2 === 1 && (g2 = 1);
          var f2 = 0, b2 = a2.globals.markers.size[r];
          if (o2 !== 1 / 0) {
            var m2 = a2.config.plotOptions.bubble;
            b2 = a2.globals.seriesZ[r][g2], m2.zScaling && (b2 /= o2), m2.minBubbleRadius && b2 < m2.minBubbleRadius && (b2 = m2.minBubbleRadius), m2.maxBubbleRadius && b2 > m2.maxBubbleRadius && (b2 = m2.maxBubbleRadius);
          }
          a2.config.chart.animations.enabled || (f2 = b2);
          var w2 = n2.x[d2], A2 = n2.y[d2];
          if (f2 = f2 || 0, A2 !== null && a2.globals.series[r][g2] !== void 0 || (p2 = false), p2) {
            var l2 = this.drawPoint(w2, A2, f2, b2, r, g2, t2);
            c2.add(l2);
          }
          h2.add(c2);
        }
    } }, { key: "drawPoint", value: function(e2, t2, i, a2, s2, r, n2) {
      var o2 = this.w, h2 = s2, c2 = new de2(this.ctx), d2 = new Z2(this.ctx), g2 = new ae2(this.ctx), p2 = new Pe(this.ctx), f2 = new M2(this.ctx), b2 = p2.getMarkerConfig({ cssClass: "apexcharts-marker", seriesIndex: h2, dataPointIndex: r, finishRadius: o2.config.chart.type === "bubble" || o2.globals.comboCharts && o2.config.series[s2] && o2.config.series[s2].type === "bubble" ? a2 : null });
      a2 = b2.pSize;
      var m2, w2 = g2.fillPath({ seriesNumber: s2, dataPointIndex: r, color: b2.pointFillColor, patternUnits: "objectBoundingBox", value: o2.globals.series[s2][n2] });
      if (b2.shape === "circle" ? m2 = f2.drawCircle(i) : b2.shape !== "square" && b2.shape !== "rect" || (m2 = f2.drawRect(0, 0, b2.width - b2.pointStrokeWidth / 2, b2.height - b2.pointStrokeWidth / 2, b2.pRadius)), o2.config.series[h2].data[r] && o2.config.series[h2].data[r].fillColor && (w2 = o2.config.series[h2].data[r].fillColor), m2.attr({ x: e2 - b2.width / 2 - b2.pointStrokeWidth / 2, y: t2 - b2.height / 2 - b2.pointStrokeWidth / 2, cx: e2, cy: t2, fill: w2, "fill-opacity": b2.pointFillOpacity, stroke: b2.pointStrokeColor, r: a2, "stroke-width": b2.pointStrokeWidth, "stroke-dasharray": b2.pointStrokeDashArray, "stroke-opacity": b2.pointStrokeOpacity }), o2.config.chart.dropShadow.enabled) {
        var A2 = o2.config.chart.dropShadow;
        d2.dropShadow(m2, A2, s2);
      }
      if (!this.initialAnim || o2.globals.dataChanged || o2.globals.resized)
        o2.globals.animationEnded = true;
      else {
        var l2 = o2.config.chart.animations.speed;
        c2.animateMarker(m2, 0, b2.shape === "circle" ? a2 : { width: b2.width, height: b2.height }, l2, o2.globals.easing, function() {
          window.setTimeout(function() {
            c2.animationCompleted(m2);
          }, 100);
        });
      }
      if (o2.globals.dataChanged && b2.shape === "circle")
        if (this.dynamicAnim) {
          var u2, x2, v2, k2, S2 = o2.config.chart.animations.dynamicAnimation.speed;
          (k2 = o2.globals.previousPaths[s2] && o2.globals.previousPaths[s2][n2]) != null && (u2 = k2.x, x2 = k2.y, v2 = k2.r !== void 0 ? k2.r : a2);
          for (var C2 = 0; C2 < o2.globals.collapsedSeries.length; C2++)
            o2.globals.collapsedSeries[C2].index === s2 && (S2 = 1, a2 = 0);
          e2 === 0 && t2 === 0 && (a2 = 0), c2.animateCircle(m2, { cx: u2, cy: x2, r: v2 }, { cx: e2, cy: t2, r: a2 }, S2, o2.globals.easing);
        } else
          m2.attr({ r: a2 });
      return m2.attr({ rel: r, j: r, index: s2, "default-marker-size": a2 }), d2.setSelectionFilter(m2, s2, r), p2.addEvents(m2), m2.node.classList.add("apexcharts-marker"), m2;
    } }, { key: "centerTextInBubble", value: function(e2) {
      var t2 = this.w;
      return { y: e2 += parseInt(t2.config.dataLabels.style.fontSize, 10) / 4 };
    } }]), y2;
  }(), ye2 = function() {
    function y2(e2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w;
    }
    return Y2(y2, [{ key: "dataLabelsCorrection", value: function(e2, t2, i, a2, s2, r, n2) {
      var o2 = this.w, h2 = false, c2 = new M2(this.ctx).getTextRects(i, n2), d2 = c2.width, g2 = c2.height;
      t2 < 0 && (t2 = 0), t2 > o2.globals.gridHeight + g2 && (t2 = o2.globals.gridHeight + g2 / 2), o2.globals.dataLabelsRects[a2] === void 0 && (o2.globals.dataLabelsRects[a2] = []), o2.globals.dataLabelsRects[a2].push({ x: e2, y: t2, width: d2, height: g2 });
      var p2 = o2.globals.dataLabelsRects[a2].length - 2, f2 = o2.globals.lastDrawnDataLabelsIndexes[a2] !== void 0 ? o2.globals.lastDrawnDataLabelsIndexes[a2][o2.globals.lastDrawnDataLabelsIndexes[a2].length - 1] : 0;
      if (o2.globals.dataLabelsRects[a2][p2] !== void 0) {
        var b2 = o2.globals.dataLabelsRects[a2][f2];
        (e2 > b2.x + b2.width || t2 > b2.y + b2.height || t2 + g2 < b2.y || e2 + d2 < b2.x) && (h2 = true);
      }
      return (s2 === 0 || r) && (h2 = true), { x: e2, y: t2, textRects: c2, drawnextLabel: h2 };
    } }, { key: "drawDataLabel", value: function(e2) {
      var t2 = this, i = e2.type, a2 = e2.pos, s2 = e2.i, r = e2.j, n2 = e2.isRangeStart, o2 = e2.strokeWidth, h2 = o2 === void 0 ? 2 : o2, c2 = this.w, d2 = new M2(this.ctx), g2 = c2.config.dataLabels, p2 = 0, f2 = 0, b2 = r, m2 = null;
      if (!g2.enabled || !Array.isArray(a2.x))
        return m2;
      m2 = d2.group({ class: "apexcharts-data-labels" });
      for (var w2 = 0; w2 < a2.x.length; w2++)
        if (p2 = a2.x[w2] + g2.offsetX, f2 = a2.y[w2] + g2.offsetY + h2, !isNaN(p2)) {
          r === 1 && w2 === 0 && (b2 = 0), r === 1 && w2 === 1 && (b2 = 1);
          var A2 = c2.globals.series[s2][b2];
          i === "rangeArea" && (A2 = n2 ? c2.globals.seriesRangeStart[s2][b2] : c2.globals.seriesRangeEnd[s2][b2]);
          var l2 = "", u2 = function(x2) {
            return c2.config.dataLabels.formatter(x2, { ctx: t2.ctx, seriesIndex: s2, dataPointIndex: b2, w: c2 });
          };
          c2.config.chart.type === "bubble" ? (l2 = u2(A2 = c2.globals.seriesZ[s2][b2]), f2 = a2.y[w2], f2 = new $e(this.ctx).centerTextInBubble(f2, s2, b2).y) : A2 !== void 0 && (l2 = u2(A2)), this.plotDataLabelsText({ x: p2, y: f2, text: l2, i: s2, j: b2, parent: m2, offsetCorrection: true, dataLabelsConfig: c2.config.dataLabels });
        }
      return m2;
    } }, { key: "plotDataLabelsText", value: function(e2) {
      var t2 = this.w, i = new M2(this.ctx), a2 = e2.x, s2 = e2.y, r = e2.i, n2 = e2.j, o2 = e2.text, h2 = e2.textAnchor, c2 = e2.fontSize, d2 = e2.parent, g2 = e2.dataLabelsConfig, p2 = e2.color, f2 = e2.alwaysDrawDataLabel, b2 = e2.offsetCorrection;
      if (!(Array.isArray(t2.config.dataLabels.enabledOnSeries) && t2.config.dataLabels.enabledOnSeries.indexOf(r) < 0)) {
        var m2 = { x: a2, y: s2, drawnextLabel: true, textRects: null };
        b2 && (m2 = this.dataLabelsCorrection(a2, s2, o2, r, n2, f2, parseInt(g2.style.fontSize, 10))), t2.globals.zoomed || (a2 = m2.x, s2 = m2.y), m2.textRects && (a2 < -20 - m2.textRects.width || a2 > t2.globals.gridWidth + m2.textRects.width + 30) && (o2 = "");
        var w2 = t2.globals.dataLabels.style.colors[r];
        ((t2.config.chart.type === "bar" || t2.config.chart.type === "rangeBar") && t2.config.plotOptions.bar.distributed || t2.config.dataLabels.distributed) && (w2 = t2.globals.dataLabels.style.colors[n2]), typeof w2 == "function" && (w2 = w2({ series: t2.globals.series, seriesIndex: r, dataPointIndex: n2, w: t2 })), p2 && (w2 = p2);
        var A2 = g2.offsetX, l2 = g2.offsetY;
        if (t2.config.chart.type !== "bar" && t2.config.chart.type !== "rangeBar" || (A2 = 0, l2 = 0), m2.drawnextLabel) {
          var u2 = i.drawText({ width: 100, height: parseInt(g2.style.fontSize, 10), x: a2 + A2, y: s2 + l2, foreColor: w2, textAnchor: h2 || g2.textAnchor, text: o2, fontSize: c2 || g2.style.fontSize, fontFamily: g2.style.fontFamily, fontWeight: g2.style.fontWeight || "normal" });
          if (u2.attr({ class: "apexcharts-datalabel", cx: a2, cy: s2 }), g2.dropShadow.enabled) {
            var x2 = g2.dropShadow;
            new Z2(this.ctx).dropShadow(u2, x2);
          }
          d2.add(u2), t2.globals.lastDrawnDataLabelsIndexes[r] === void 0 && (t2.globals.lastDrawnDataLabelsIndexes[r] = []), t2.globals.lastDrawnDataLabelsIndexes[r].push(n2);
        }
      }
    } }, { key: "addBackgroundToDataLabel", value: function(e2, t2) {
      var i = this.w, a2 = i.config.dataLabels.background, s2 = a2.padding, r = a2.padding / 2, n2 = t2.width, o2 = t2.height, h2 = new M2(this.ctx).drawRect(t2.x - s2, t2.y - r / 2, n2 + 2 * s2, o2 + r, a2.borderRadius, i.config.chart.background === "transparent" ? "#fff" : i.config.chart.background, a2.opacity, a2.borderWidth, a2.borderColor);
      return a2.dropShadow.enabled && new Z2(this.ctx).dropShadow(h2, a2.dropShadow), h2;
    } }, { key: "dataLabelsBackground", value: function() {
      var e2 = this.w;
      if (e2.config.chart.type !== "bubble")
        for (var t2 = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels text"), i = 0; i < t2.length; i++) {
          var a2 = t2[i], s2 = a2.getBBox(), r = null;
          if (s2.width && s2.height && (r = this.addBackgroundToDataLabel(a2, s2)), r) {
            a2.parentNode.insertBefore(r.node, a2);
            var n2 = a2.getAttribute("fill");
            e2.config.chart.animations.enabled && !e2.globals.resized && !e2.globals.dataChanged ? r.animate().attr({ fill: n2 }) : r.attr({ fill: n2 }), a2.setAttribute("fill", e2.config.dataLabels.background.foreColor);
          }
        }
    } }, { key: "bringForward", value: function() {
      for (var e2 = this.w, t2 = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels"), i = e2.globals.dom.baseEl.querySelector(".apexcharts-plot-series:last-child"), a2 = 0; a2 < t2.length; a2++)
        i && i.insertBefore(t2[a2], i.nextSibling);
    } }]), y2;
  }(), te2 = function() {
    function y2(e2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w, this.legendInactiveClass = "legend-mouseover-inactive";
    }
    return Y2(y2, [{ key: "getAllSeriesEls", value: function() {
      return this.w.globals.dom.baseEl.getElementsByClassName("apexcharts-series");
    } }, { key: "getSeriesByName", value: function(e2) {
      return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner .apexcharts-series[seriesName='".concat(P2.escapeString(e2), "']"));
    } }, { key: "isSeriesHidden", value: function(e2) {
      var t2 = this.getSeriesByName(e2), i = parseInt(t2.getAttribute("data:realIndex"), 10);
      return { isHidden: t2.classList.contains("apexcharts-series-collapsed"), realIndex: i };
    } }, { key: "addCollapsedClassToSeries", value: function(e2, t2) {
      var i = this.w;
      function a2(s2) {
        for (var r = 0; r < s2.length; r++)
          s2[r].index === t2 && e2.node.classList.add("apexcharts-series-collapsed");
      }
      a2(i.globals.collapsedSeries), a2(i.globals.ancillaryCollapsedSeries);
    } }, { key: "toggleSeries", value: function(e2) {
      var t2 = this.isSeriesHidden(e2);
      return this.ctx.legend.legendHelpers.toggleDataSeries(t2.realIndex, t2.isHidden), t2.isHidden;
    } }, { key: "showSeries", value: function(e2) {
      var t2 = this.isSeriesHidden(e2);
      t2.isHidden && this.ctx.legend.legendHelpers.toggleDataSeries(t2.realIndex, true);
    } }, { key: "hideSeries", value: function(e2) {
      var t2 = this.isSeriesHidden(e2);
      t2.isHidden || this.ctx.legend.legendHelpers.toggleDataSeries(t2.realIndex, false);
    } }, { key: "resetSeries", value: function() {
      var e2 = !(arguments.length > 0 && arguments[0] !== void 0) || arguments[0], t2 = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2], a2 = this.w, s2 = P2.clone(a2.globals.initialSeries);
      a2.globals.previousPaths = [], i ? (a2.globals.collapsedSeries = [], a2.globals.ancillaryCollapsedSeries = [], a2.globals.collapsedSeriesIndices = [], a2.globals.ancillaryCollapsedSeriesIndices = []) : s2 = this.emptyCollapsedSeries(s2), a2.config.series = s2, e2 && (t2 && (a2.globals.zoomed = false, this.ctx.updateHelpers.revertDefaultAxisMinMax()), this.ctx.updateHelpers._updateSeries(s2, a2.config.chart.animations.dynamicAnimation.enabled));
    } }, { key: "emptyCollapsedSeries", value: function(e2) {
      for (var t2 = this.w, i = 0; i < e2.length; i++)
        t2.globals.collapsedSeriesIndices.indexOf(i) > -1 && (e2[i].data = []);
      return e2;
    } }, { key: "toggleSeriesOnHover", value: function(e2, t2) {
      var i = this.w;
      t2 || (t2 = e2.target);
      var a2 = i.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels");
      if (e2.type === "mousemove") {
        var s2 = parseInt(t2.getAttribute("rel"), 10) - 1, r = null, n2 = null;
        i.globals.axisCharts || i.config.chart.type === "radialBar" ? i.globals.axisCharts ? (r = i.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(s2, "']")), n2 = i.globals.dom.baseEl.querySelector(".apexcharts-datalabels[data\\:realIndex='".concat(s2, "']"))) : r = i.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(s2 + 1, "']")) : r = i.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(s2 + 1, "'] path"));
        for (var o2 = 0; o2 < a2.length; o2++)
          a2[o2].classList.add(this.legendInactiveClass);
        r !== null && (i.globals.axisCharts || r.parentNode.classList.remove(this.legendInactiveClass), r.classList.remove(this.legendInactiveClass), n2 !== null && n2.classList.remove(this.legendInactiveClass));
      } else if (e2.type === "mouseout")
        for (var h2 = 0; h2 < a2.length; h2++)
          a2[h2].classList.remove(this.legendInactiveClass);
    } }, { key: "highlightRangeInSeries", value: function(e2, t2) {
      var i = this, a2 = this.w, s2 = a2.globals.dom.baseEl.getElementsByClassName("apexcharts-heatmap-rect"), r = function(o2) {
        for (var h2 = 0; h2 < s2.length; h2++)
          s2[h2].classList[o2](i.legendInactiveClass);
      };
      if (e2.type === "mousemove") {
        var n2 = parseInt(t2.getAttribute("rel"), 10) - 1;
        r("add"), function(o2) {
          for (var h2 = 0; h2 < s2.length; h2++) {
            var c2 = parseInt(s2[h2].getAttribute("val"), 10);
            c2 >= o2.from && c2 <= o2.to && s2[h2].classList.remove(i.legendInactiveClass);
          }
        }(a2.config.plotOptions.heatmap.colorScale.ranges[n2]);
      } else
        e2.type === "mouseout" && r("remove");
    } }, { key: "getActiveConfigSeriesIndex", value: function() {
      var e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "asc", t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], i = this.w, a2 = 0;
      if (i.config.series.length > 1) {
        for (var s2 = i.config.series.map(function(n2, o2) {
          return n2.data && n2.data.length > 0 && i.globals.collapsedSeriesIndices.indexOf(o2) === -1 && (!i.globals.comboCharts || t2.length === 0 || t2.length && t2.indexOf(i.config.series[o2].type) > -1) ? o2 : -1;
        }), r = e2 === "asc" ? 0 : s2.length - 1; e2 === "asc" ? r < s2.length : r >= 0; e2 === "asc" ? r++ : r--)
          if (s2[r] !== -1) {
            a2 = s2[r];
            break;
          }
      }
      return a2;
    } }, { key: "getBarSeriesIndices", value: function() {
      return this.w.globals.comboCharts ? this.w.config.series.map(function(e2, t2) {
        return e2.type === "bar" || e2.type === "column" ? t2 : -1;
      }).filter(function(e2) {
        return e2 !== -1;
      }) : this.w.config.series.map(function(e2, t2) {
        return t2;
      });
    } }, { key: "getPreviousPaths", value: function() {
      var e2 = this.w;
      function t2(r, n2, o2) {
        for (var h2 = r[n2].childNodes, c2 = { type: o2, paths: [], realIndex: r[n2].getAttribute("data:realIndex") }, d2 = 0; d2 < h2.length; d2++)
          if (h2[d2].hasAttribute("pathTo")) {
            var g2 = h2[d2].getAttribute("pathTo");
            c2.paths.push({ d: g2 });
          }
        e2.globals.previousPaths.push(c2);
      }
      e2.globals.previousPaths = [], ["line", "area", "bar", "rangebar", "rangeArea", "candlestick", "radar"].forEach(function(r) {
        for (var n2, o2 = (n2 = r, e2.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(n2, "-series .apexcharts-series"))), h2 = 0; h2 < o2.length; h2++)
          t2(o2, h2, r);
      }), this.handlePrevBubbleScatterPaths("bubble"), this.handlePrevBubbleScatterPaths("scatter");
      var i = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(e2.config.chart.type, " .apexcharts-series"));
      if (i.length > 0)
        for (var a2 = function(r) {
          for (var n2 = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(e2.config.chart.type, " .apexcharts-series[data\\:realIndex='").concat(r, "'] rect")), o2 = [], h2 = function(d2) {
            var g2 = function(f2) {
              return n2[d2].getAttribute(f2);
            }, p2 = { x: parseFloat(g2("x")), y: parseFloat(g2("y")), width: parseFloat(g2("width")), height: parseFloat(g2("height")) };
            o2.push({ rect: p2, color: n2[d2].getAttribute("color") });
          }, c2 = 0; c2 < n2.length; c2++)
            h2(c2);
          e2.globals.previousPaths.push(o2);
        }, s2 = 0; s2 < i.length; s2++)
          a2(s2);
      e2.globals.axisCharts || (e2.globals.previousPaths = e2.globals.series);
    } }, { key: "handlePrevBubbleScatterPaths", value: function(e2) {
      var t2 = this.w, i = t2.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(e2, "-series .apexcharts-series"));
      if (i.length > 0)
        for (var a2 = 0; a2 < i.length; a2++) {
          for (var s2 = t2.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(e2, "-series .apexcharts-series[data\\:realIndex='").concat(a2, "'] circle")), r = [], n2 = 0; n2 < s2.length; n2++)
            r.push({ x: s2[n2].getAttribute("cx"), y: s2[n2].getAttribute("cy"), r: s2[n2].getAttribute("r") });
          t2.globals.previousPaths.push(r);
        }
    } }, { key: "clearPreviousPaths", value: function() {
      var e2 = this.w;
      e2.globals.previousPaths = [], e2.globals.allSeriesCollapsed = false;
    } }, { key: "handleNoData", value: function() {
      var e2 = this.w, t2 = e2.config.noData, i = new M2(this.ctx), a2 = e2.globals.svgWidth / 2, s2 = e2.globals.svgHeight / 2, r = "middle";
      if (e2.globals.noData = true, e2.globals.animationEnded = true, t2.align === "left" ? (a2 = 10, r = "start") : t2.align === "right" && (a2 = e2.globals.svgWidth - 10, r = "end"), t2.verticalAlign === "top" ? s2 = 50 : t2.verticalAlign === "bottom" && (s2 = e2.globals.svgHeight - 50), a2 += t2.offsetX, s2 = s2 + parseInt(t2.style.fontSize, 10) + 2 + t2.offsetY, t2.text !== void 0 && t2.text !== "") {
        var n2 = i.drawText({ x: a2, y: s2, text: t2.text, textAnchor: r, fontSize: t2.style.fontSize, fontFamily: t2.style.fontFamily, foreColor: t2.style.color, opacity: 1, class: "apexcharts-text-nodata" });
        e2.globals.dom.Paper.add(n2);
      }
    } }, { key: "setNullSeriesToZeroValues", value: function(e2) {
      for (var t2 = this.w, i = 0; i < e2.length; i++)
        if (e2[i].length === 0)
          for (var a2 = 0; a2 < e2[t2.globals.maxValsInArrayIndex].length; a2++)
            e2[i].push(0);
      return e2;
    } }, { key: "hasAllSeriesEqualX", value: function() {
      for (var e2 = true, t2 = this.w, i = this.filteredSeriesX(), a2 = 0; a2 < i.length - 1; a2++)
        if (i[a2][0] !== i[a2 + 1][0]) {
          e2 = false;
          break;
        }
      return t2.globals.allSeriesHasEqualX = e2, e2;
    } }, { key: "filteredSeriesX", value: function() {
      var e2 = this.w.globals.seriesX.map(function(t2) {
        return t2.length > 0 ? t2 : [];
      });
      return e2;
    } }]), y2;
  }(), Je = function() {
    function y2(e2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w, this.twoDSeries = [], this.threeDSeries = [], this.twoDSeriesX = [], this.seriesGoals = [], this.coreUtils = new q2(this.ctx);
    }
    return Y2(y2, [{ key: "isMultiFormat", value: function() {
      return this.isFormatXY() || this.isFormat2DArray();
    } }, { key: "isFormatXY", value: function() {
      var e2 = this.w.config.series.slice(), t2 = new te2(this.ctx);
      if (this.activeSeriesIndex = t2.getActiveConfigSeriesIndex(), e2[this.activeSeriesIndex].data !== void 0 && e2[this.activeSeriesIndex].data.length > 0 && e2[this.activeSeriesIndex].data[0] !== null && e2[this.activeSeriesIndex].data[0].x !== void 0 && e2[this.activeSeriesIndex].data[0] !== null)
        return true;
    } }, { key: "isFormat2DArray", value: function() {
      var e2 = this.w.config.series.slice(), t2 = new te2(this.ctx);
      if (this.activeSeriesIndex = t2.getActiveConfigSeriesIndex(), e2[this.activeSeriesIndex].data !== void 0 && e2[this.activeSeriesIndex].data.length > 0 && e2[this.activeSeriesIndex].data[0] !== void 0 && e2[this.activeSeriesIndex].data[0] !== null && e2[this.activeSeriesIndex].data[0].constructor === Array)
        return true;
    } }, { key: "handleFormat2DArray", value: function(e2, t2) {
      for (var i = this.w.config, a2 = this.w.globals, s2 = i.chart.type === "boxPlot" || i.series[t2].type === "boxPlot", r = 0; r < e2[t2].data.length; r++)
        if (e2[t2].data[r][1] !== void 0 && (Array.isArray(e2[t2].data[r][1]) && e2[t2].data[r][1].length === 4 && !s2 ? this.twoDSeries.push(P2.parseNumber(e2[t2].data[r][1][3])) : e2[t2].data[r].length >= 5 ? this.twoDSeries.push(P2.parseNumber(e2[t2].data[r][4])) : this.twoDSeries.push(P2.parseNumber(e2[t2].data[r][1])), a2.dataFormatXNumeric = true), i.xaxis.type === "datetime") {
          var n2 = new Date(e2[t2].data[r][0]);
          n2 = new Date(n2).getTime(), this.twoDSeriesX.push(n2);
        } else
          this.twoDSeriesX.push(e2[t2].data[r][0]);
      for (var o2 = 0; o2 < e2[t2].data.length; o2++)
        e2[t2].data[o2][2] !== void 0 && (this.threeDSeries.push(e2[t2].data[o2][2]), a2.isDataXYZ = true);
    } }, { key: "handleFormatXY", value: function(e2, t2) {
      var i = this.w.config, a2 = this.w.globals, s2 = new B3(this.ctx), r = t2;
      a2.collapsedSeriesIndices.indexOf(t2) > -1 && (r = this.activeSeriesIndex);
      for (var n2 = 0; n2 < e2[t2].data.length; n2++)
        e2[t2].data[n2].y !== void 0 && (Array.isArray(e2[t2].data[n2].y) ? this.twoDSeries.push(P2.parseNumber(e2[t2].data[n2].y[e2[t2].data[n2].y.length - 1])) : this.twoDSeries.push(P2.parseNumber(e2[t2].data[n2].y))), e2[t2].data[n2].goals !== void 0 && Array.isArray(e2[t2].data[n2].goals) ? (this.seriesGoals[t2] === void 0 && (this.seriesGoals[t2] = []), this.seriesGoals[t2].push(e2[t2].data[n2].goals)) : (this.seriesGoals[t2] === void 0 && (this.seriesGoals[t2] = []), this.seriesGoals[t2].push(null));
      for (var o2 = 0; o2 < e2[r].data.length; o2++) {
        var h2 = typeof e2[r].data[o2].x == "string", c2 = Array.isArray(e2[r].data[o2].x), d2 = !c2 && !!s2.isValidDate(e2[r].data[o2].x);
        if (h2 || d2)
          if (h2 || i.xaxis.convertedCatToNumeric) {
            var g2 = a2.isBarHorizontal && a2.isRangeData;
            i.xaxis.type !== "datetime" || g2 ? (this.fallbackToCategory = true, this.twoDSeriesX.push(e2[r].data[o2].x), isNaN(e2[r].data[o2].x) || this.w.config.xaxis.type === "category" || typeof e2[r].data[o2].x == "string" || (a2.isXNumeric = true)) : this.twoDSeriesX.push(s2.parseDate(e2[r].data[o2].x));
          } else
            i.xaxis.type === "datetime" ? this.twoDSeriesX.push(s2.parseDate(e2[r].data[o2].x.toString())) : (a2.dataFormatXNumeric = true, a2.isXNumeric = true, this.twoDSeriesX.push(parseFloat(e2[r].data[o2].x)));
        else
          c2 ? (this.fallbackToCategory = true, this.twoDSeriesX.push(e2[r].data[o2].x)) : (a2.isXNumeric = true, a2.dataFormatXNumeric = true, this.twoDSeriesX.push(e2[r].data[o2].x));
      }
      if (e2[t2].data[0] && e2[t2].data[0].z !== void 0) {
        for (var p2 = 0; p2 < e2[t2].data.length; p2++)
          this.threeDSeries.push(e2[t2].data[p2].z);
        a2.isDataXYZ = true;
      }
    } }, { key: "handleRangeData", value: function(e2, t2) {
      var i = this.w.globals, a2 = {};
      return this.isFormat2DArray() ? a2 = this.handleRangeDataFormat("array", e2, t2) : this.isFormatXY() && (a2 = this.handleRangeDataFormat("xy", e2, t2)), i.seriesRangeStart.push(a2.start), i.seriesRangeEnd.push(a2.end), i.seriesRange.push(a2.rangeUniques), i.seriesRange.forEach(function(s2, r) {
        s2 && s2.forEach(function(n2, o2) {
          n2.y.forEach(function(h2, c2) {
            for (var d2 = 0; d2 < n2.y.length; d2++)
              if (c2 !== d2) {
                var g2 = h2.y1, p2 = h2.y2, f2 = n2.y[d2].y1;
                g2 <= n2.y[d2].y2 && f2 <= p2 && (n2.overlaps.indexOf(h2.rangeName) < 0 && n2.overlaps.push(h2.rangeName), n2.overlaps.indexOf(n2.y[d2].rangeName) < 0 && n2.overlaps.push(n2.y[d2].rangeName));
              }
          });
        });
      }), a2;
    } }, { key: "handleCandleStickBoxData", value: function(e2, t2) {
      var i = this.w.globals, a2 = {};
      return this.isFormat2DArray() ? a2 = this.handleCandleStickBoxDataFormat("array", e2, t2) : this.isFormatXY() && (a2 = this.handleCandleStickBoxDataFormat("xy", e2, t2)), i.seriesCandleO[t2] = a2.o, i.seriesCandleH[t2] = a2.h, i.seriesCandleM[t2] = a2.m, i.seriesCandleL[t2] = a2.l, i.seriesCandleC[t2] = a2.c, a2;
    } }, { key: "handleRangeDataFormat", value: function(e2, t2, i) {
      var a2 = [], s2 = [], r = t2[i].data.filter(function(c2, d2, g2) {
        return d2 === g2.findIndex(function(p2) {
          return p2.x === c2.x;
        });
      }).map(function(c2, d2) {
        return { x: c2.x, overlaps: [], y: [] };
      });
      if (e2 === "array")
        for (var n2 = 0; n2 < t2[i].data.length; n2++)
          Array.isArray(t2[i].data[n2]) ? (a2.push(t2[i].data[n2][1][0]), s2.push(t2[i].data[n2][1][1])) : (a2.push(t2[i].data[n2]), s2.push(t2[i].data[n2]));
      else if (e2 === "xy")
        for (var o2 = function(c2) {
          var d2 = Array.isArray(t2[i].data[c2].y), g2 = P2.randomId(), p2 = t2[i].data[c2].x, f2 = { y1: d2 ? t2[i].data[c2].y[0] : t2[i].data[c2].y, y2: d2 ? t2[i].data[c2].y[1] : t2[i].data[c2].y, rangeName: g2 };
          t2[i].data[c2].rangeName = g2;
          var b2 = r.findIndex(function(m2) {
            return m2.x === p2;
          });
          r[b2].y.push(f2), a2.push(f2.y1), s2.push(f2.y2);
        }, h2 = 0; h2 < t2[i].data.length; h2++)
          o2(h2);
      return { start: a2, end: s2, rangeUniques: r };
    } }, { key: "handleCandleStickBoxDataFormat", value: function(e2, t2, i) {
      var a2 = this.w, s2 = a2.config.chart.type === "boxPlot" || a2.config.series[i].type === "boxPlot", r = [], n2 = [], o2 = [], h2 = [], c2 = [];
      if (e2 === "array")
        if (s2 && t2[i].data[0].length === 6 || !s2 && t2[i].data[0].length === 5)
          for (var d2 = 0; d2 < t2[i].data.length; d2++)
            r.push(t2[i].data[d2][1]), n2.push(t2[i].data[d2][2]), s2 ? (o2.push(t2[i].data[d2][3]), h2.push(t2[i].data[d2][4]), c2.push(t2[i].data[d2][5])) : (h2.push(t2[i].data[d2][3]), c2.push(t2[i].data[d2][4]));
        else
          for (var g2 = 0; g2 < t2[i].data.length; g2++)
            Array.isArray(t2[i].data[g2][1]) && (r.push(t2[i].data[g2][1][0]), n2.push(t2[i].data[g2][1][1]), s2 ? (o2.push(t2[i].data[g2][1][2]), h2.push(t2[i].data[g2][1][3]), c2.push(t2[i].data[g2][1][4])) : (h2.push(t2[i].data[g2][1][2]), c2.push(t2[i].data[g2][1][3])));
      else if (e2 === "xy")
        for (var p2 = 0; p2 < t2[i].data.length; p2++)
          Array.isArray(t2[i].data[p2].y) && (r.push(t2[i].data[p2].y[0]), n2.push(t2[i].data[p2].y[1]), s2 ? (o2.push(t2[i].data[p2].y[2]), h2.push(t2[i].data[p2].y[3]), c2.push(t2[i].data[p2].y[4])) : (h2.push(t2[i].data[p2].y[2]), c2.push(t2[i].data[p2].y[3])));
      return { o: r, h: n2, m: o2, l: h2, c: c2 };
    } }, { key: "parseDataAxisCharts", value: function(e2) {
      var t2, i = this, a2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.ctx, s2 = this.w.config, r = this.w.globals, n2 = new B3(a2), o2 = s2.labels.length > 0 ? s2.labels.slice() : s2.xaxis.categories.slice();
      if (r.isRangeBar = s2.chart.type === "rangeBar" && r.isBarHorizontal, r.hasXaxisGroups = s2.xaxis.type === "category" && s2.xaxis.group.groups.length > 0, r.hasXaxisGroups && (r.groups = s2.xaxis.group.groups), r.hasSeriesGroups = (t2 = e2[0]) === null || t2 === void 0 ? void 0 : t2.group, r.hasSeriesGroups) {
        var h2 = [], c2 = J2(new Set(e2.map(function(f2) {
          return f2.group;
        })));
        e2.forEach(function(f2, b2) {
          var m2 = c2.indexOf(f2.group);
          h2[m2] || (h2[m2] = []), h2[m2].push(f2.name);
        }), r.seriesGroups = h2;
      }
      for (var d2 = function() {
        for (var f2 = 0; f2 < o2.length; f2++)
          if (typeof o2[f2] == "string") {
            if (!n2.isValidDate(o2[f2]))
              throw new Error("You have provided invalid Date format. Please provide a valid JavaScript Date");
            i.twoDSeriesX.push(n2.parseDate(o2[f2]));
          } else
            i.twoDSeriesX.push(o2[f2]);
      }, g2 = 0; g2 < e2.length; g2++) {
        if (this.twoDSeries = [], this.twoDSeriesX = [], this.threeDSeries = [], e2[g2].data === void 0)
          return void console.error("It is a possibility that you may have not included 'data' property in series.");
        if (s2.chart.type !== "rangeBar" && s2.chart.type !== "rangeArea" && e2[g2].type !== "rangeBar" && e2[g2].type !== "rangeArea" || (r.isRangeData = true, s2.chart.type !== "rangeBar" && s2.chart.type !== "rangeArea" || this.handleRangeData(e2, g2)), this.isMultiFormat())
          this.isFormat2DArray() ? this.handleFormat2DArray(e2, g2) : this.isFormatXY() && this.handleFormatXY(e2, g2), s2.chart.type !== "candlestick" && e2[g2].type !== "candlestick" && s2.chart.type !== "boxPlot" && e2[g2].type !== "boxPlot" || this.handleCandleStickBoxData(e2, g2), r.series.push(this.twoDSeries), r.labels.push(this.twoDSeriesX), r.seriesX.push(this.twoDSeriesX), r.seriesGoals = this.seriesGoals, g2 !== this.activeSeriesIndex || this.fallbackToCategory || (r.isXNumeric = true);
        else {
          s2.xaxis.type === "datetime" ? (r.isXNumeric = true, d2(), r.seriesX.push(this.twoDSeriesX)) : s2.xaxis.type === "numeric" && (r.isXNumeric = true, o2.length > 0 && (this.twoDSeriesX = o2, r.seriesX.push(this.twoDSeriesX))), r.labels.push(this.twoDSeriesX);
          var p2 = e2[g2].data.map(function(f2) {
            return P2.parseNumber(f2);
          });
          r.series.push(p2);
        }
        r.seriesZ.push(this.threeDSeries), e2[g2].name !== void 0 ? r.seriesNames.push(e2[g2].name) : r.seriesNames.push("series-" + parseInt(g2 + 1, 10)), e2[g2].color !== void 0 ? r.seriesColors.push(e2[g2].color) : r.seriesColors.push(void 0);
      }
      return this.w;
    } }, { key: "parseDataNonAxisCharts", value: function(e2) {
      var t2 = this.w.globals, i = this.w.config;
      t2.series = e2.slice(), t2.seriesNames = i.labels.slice();
      for (var a2 = 0; a2 < t2.series.length; a2++)
        t2.seriesNames[a2] === void 0 && t2.seriesNames.push("series-" + (a2 + 1));
      return this.w;
    } }, { key: "handleExternalLabelsData", value: function(e2) {
      var t2 = this.w.config, i = this.w.globals;
      t2.xaxis.categories.length > 0 ? i.labels = t2.xaxis.categories : t2.labels.length > 0 ? i.labels = t2.labels.slice() : this.fallbackToCategory ? (i.labels = i.labels[0], i.seriesRange.length && (i.seriesRange.map(function(a2) {
        a2.forEach(function(s2) {
          i.labels.indexOf(s2.x) < 0 && s2.x && i.labels.push(s2.x);
        });
      }), i.labels = Array.from(new Set(i.labels.map(JSON.stringify)), JSON.parse)), t2.xaxis.convertedCatToNumeric && (new oe2(t2).convertCatToNumericXaxis(t2, this.ctx, i.seriesX[0]), this._generateExternalLabels(e2))) : this._generateExternalLabels(e2);
    } }, { key: "_generateExternalLabels", value: function(e2) {
      var t2 = this.w.globals, i = this.w.config, a2 = [];
      if (t2.axisCharts) {
        if (t2.series.length > 0)
          if (this.isFormatXY())
            for (var s2 = i.series.map(function(d2, g2) {
              return d2.data.filter(function(p2, f2, b2) {
                return b2.findIndex(function(m2) {
                  return m2.x === p2.x;
                }) === f2;
              });
            }), r = s2.reduce(function(d2, g2, p2, f2) {
              return f2[d2].length > g2.length ? d2 : p2;
            }, 0), n2 = 0; n2 < s2[r].length; n2++)
              a2.push(n2 + 1);
          else
            for (var o2 = 0; o2 < t2.series[t2.maxValsInArrayIndex].length; o2++)
              a2.push(o2 + 1);
        t2.seriesX = [];
        for (var h2 = 0; h2 < e2.length; h2++)
          t2.seriesX.push(a2);
        this.w.globals.isBarHorizontal || (t2.isXNumeric = true);
      }
      if (a2.length === 0) {
        a2 = t2.axisCharts ? [] : t2.series.map(function(d2, g2) {
          return g2 + 1;
        });
        for (var c2 = 0; c2 < e2.length; c2++)
          t2.seriesX.push(a2);
      }
      t2.labels = a2, i.xaxis.convertedCatToNumeric && (t2.categoryLabels = a2.map(function(d2) {
        return i.xaxis.labels.formatter(d2);
      })), t2.noLabelsProvided = true;
    } }, { key: "parseData", value: function(e2) {
      var t2 = this.w, i = t2.config, a2 = t2.globals;
      if (this.excludeCollapsedSeriesInYAxis(), this.fallbackToCategory = false, this.ctx.core.resetGlobals(), this.ctx.core.isMultipleY(), a2.axisCharts ? (this.parseDataAxisCharts(e2), this.coreUtils.getLargestSeries()) : this.parseDataNonAxisCharts(e2), i.chart.stacked) {
        var s2 = new te2(this.ctx);
        a2.series = s2.setNullSeriesToZeroValues(a2.series);
      }
      this.coreUtils.getSeriesTotals(), a2.axisCharts && (a2.stackedSeriesTotals = this.coreUtils.getStackedSeriesTotals(), a2.stackedSeriesTotalsByGroups = this.coreUtils.getStackedSeriesTotalsByGroups()), this.coreUtils.getPercentSeries(), a2.dataFormatXNumeric || a2.isXNumeric && (i.xaxis.type !== "numeric" || i.labels.length !== 0 || i.xaxis.categories.length !== 0) || this.handleExternalLabelsData(e2);
      for (var r = this.coreUtils.getCategoryLabels(a2.labels), n2 = 0; n2 < r.length; n2++)
        if (Array.isArray(r[n2])) {
          a2.isMultiLineX = true;
          break;
        }
    } }, { key: "excludeCollapsedSeriesInYAxis", value: function() {
      var e2 = this, t2 = this.w;
      t2.globals.ignoreYAxisIndexes = t2.globals.collapsedSeries.map(function(i, a2) {
        if (e2.w.globals.isMultipleYAxis && !t2.config.chart.stacked)
          return i.index;
      });
    } }]), y2;
  }(), xe = function() {
    function y2(e2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w;
    }
    return Y2(y2, [{ key: "getLabel", value: function(e2, t2, i, a2) {
      var s2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [], r = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "12px", n2 = !(arguments.length > 6 && arguments[6] !== void 0) || arguments[6], o2 = this.w, h2 = e2[a2] === void 0 ? "" : e2[a2], c2 = h2, d2 = o2.globals.xLabelFormatter, g2 = o2.config.xaxis.labels.formatter, p2 = false, f2 = new re2(this.ctx), b2 = h2;
      n2 && (c2 = f2.xLabelFormat(d2, h2, b2, { i: a2, dateFormatter: new B3(this.ctx).formatDate, w: o2 }), g2 !== void 0 && (c2 = g2(h2, e2[a2], { i: a2, dateFormatter: new B3(this.ctx).formatDate, w: o2 })));
      var m2, w2;
      t2.length > 0 ? (m2 = t2[a2].unit, w2 = null, t2.forEach(function(x2) {
        x2.unit === "month" ? w2 = "year" : x2.unit === "day" ? w2 = "month" : x2.unit === "hour" ? w2 = "day" : x2.unit === "minute" && (w2 = "hour");
      }), p2 = w2 === m2, i = t2[a2].position, c2 = t2[a2].value) : o2.config.xaxis.type === "datetime" && g2 === void 0 && (c2 = ""), c2 === void 0 && (c2 = ""), c2 = Array.isArray(c2) ? c2 : c2.toString();
      var A2 = new M2(this.ctx), l2 = {};
      l2 = o2.globals.rotateXLabels && n2 ? A2.getTextRects(c2, parseInt(r, 10), null, "rotate(".concat(o2.config.xaxis.labels.rotate, " 0 0)"), false) : A2.getTextRects(c2, parseInt(r, 10));
      var u2 = !o2.config.xaxis.labels.showDuplicates && this.ctx.timeScale;
      return !Array.isArray(c2) && (c2.indexOf("NaN") === 0 || c2.toLowerCase().indexOf("invalid") === 0 || c2.toLowerCase().indexOf("infinity") >= 0 || s2.indexOf(c2) >= 0 && u2) && (c2 = ""), { x: i, text: c2, textRect: l2, isBold: p2 };
    } }, { key: "checkLabelBasedOnTickamount", value: function(e2, t2, i) {
      var a2 = this.w, s2 = a2.config.xaxis.tickAmount;
      return s2 === "dataPoints" && (s2 = Math.round(a2.globals.gridWidth / 120)), s2 > i || e2 % Math.round(i / (s2 + 1)) == 0 || (t2.text = ""), t2;
    } }, { key: "checkForOverflowingLabels", value: function(e2, t2, i, a2, s2) {
      var r = this.w;
      if (e2 === 0 && r.globals.skipFirstTimelinelabel && (t2.text = ""), e2 === i - 1 && r.globals.skipLastTimelinelabel && (t2.text = ""), r.config.xaxis.labels.hideOverlappingLabels && a2.length > 0) {
        var n2 = s2[s2.length - 1];
        t2.x < n2.textRect.width / (r.globals.rotateXLabels ? Math.abs(r.config.xaxis.labels.rotate) / 12 : 1.01) + n2.x && (t2.text = "");
      }
      return t2;
    } }, { key: "checkForReversedLabels", value: function(e2, t2) {
      var i = this.w;
      return i.config.yaxis[e2] && i.config.yaxis[e2].reversed && t2.reverse(), t2;
    } }, { key: "isYAxisHidden", value: function(e2) {
      var t2 = this.w, i = new q2(this.ctx);
      return !t2.config.yaxis[e2].show || !t2.config.yaxis[e2].showForNullSeries && i.isSeriesNull(e2) && t2.globals.collapsedSeriesIndices.indexOf(e2) === -1;
    } }, { key: "getYAxisForeColor", value: function(e2, t2) {
      var i = this.w;
      return Array.isArray(e2) && i.globals.yAxisScale[t2] && this.ctx.theme.pushExtraColors(e2, i.globals.yAxisScale[t2].result.length, false), e2;
    } }, { key: "drawYAxisTicks", value: function(e2, t2, i, a2, s2, r, n2) {
      var o2 = this.w, h2 = new M2(this.ctx), c2 = o2.globals.translateY;
      if (a2.show && t2 > 0) {
        o2.config.yaxis[s2].opposite === true && (e2 += a2.width);
        for (var d2 = t2; d2 >= 0; d2--) {
          var g2 = c2 + t2 / 10 + o2.config.yaxis[s2].labels.offsetY - 1;
          o2.globals.isBarHorizontal && (g2 = r * d2), o2.config.chart.type === "heatmap" && (g2 += r / 2);
          var p2 = h2.drawLine(e2 + i.offsetX - a2.width + a2.offsetX, g2 + a2.offsetY, e2 + i.offsetX + a2.offsetX, g2 + a2.offsetY, a2.color);
          n2.add(p2), c2 += r;
        }
      }
    } }]), y2;
  }(), Ee = function() {
    function y2(e2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w;
    }
    return Y2(y2, [{ key: "scaleSvgNode", value: function(e2, t2) {
      var i = parseFloat(e2.getAttributeNS(null, "width")), a2 = parseFloat(e2.getAttributeNS(null, "height"));
      e2.setAttributeNS(null, "width", i * t2), e2.setAttributeNS(null, "height", a2 * t2), e2.setAttributeNS(null, "viewBox", "0 0 " + i + " " + a2);
    } }, { key: "fixSvgStringForIe11", value: function(e2) {
      if (!P2.isIE11())
        return e2.replace(/&nbsp;/g, "&#160;");
      var t2 = 0, i = e2.replace(/xmlns="http:\/\/www.w3.org\/2000\/svg"/g, function(a2) {
        return ++t2 === 2 ? 'xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.dev"' : a2;
      });
      return i = (i = i.replace(/xmlns:NS\d+=""/g, "")).replace(/NS\d+:(\w+:\w+=")/g, "$1");
    } }, { key: "getSvgString", value: function(e2) {
      e2 == null && (e2 = 1);
      var t2 = this.w.globals.dom.Paper.svg();
      if (e2 !== 1) {
        var i = this.w.globals.dom.Paper.node.cloneNode(true);
        this.scaleSvgNode(i, e2), t2 = new XMLSerializer().serializeToString(i);
      }
      return this.fixSvgStringForIe11(t2);
    } }, { key: "cleanup", value: function() {
      var e2 = this.w, t2 = e2.globals.dom.baseEl.getElementsByClassName("apexcharts-xcrosshairs"), i = e2.globals.dom.baseEl.getElementsByClassName("apexcharts-ycrosshairs"), a2 = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-zoom-rect, .apexcharts-selection-rect");
      Array.prototype.forEach.call(a2, function(s2) {
        s2.setAttribute("width", 0);
      }), t2 && t2[0] && (t2[0].setAttribute("x", -500), t2[0].setAttribute("x1", -500), t2[0].setAttribute("x2", -500)), i && i[0] && (i[0].setAttribute("y", -100), i[0].setAttribute("y1", -100), i[0].setAttribute("y2", -100));
    } }, { key: "svgUrl", value: function() {
      this.cleanup();
      var e2 = this.getSvgString(), t2 = new Blob([e2], { type: "image/svg+xml;charset=utf-8" });
      return URL.createObjectURL(t2);
    } }, { key: "dataURI", value: function(e2) {
      var t2 = this;
      return new Promise(function(i) {
        var a2 = t2.w, s2 = e2 ? e2.scale || e2.width / a2.globals.svgWidth : 1;
        t2.cleanup();
        var r = document.createElement("canvas");
        r.width = a2.globals.svgWidth * s2, r.height = parseInt(a2.globals.dom.elWrap.style.height, 10) * s2;
        var n2 = a2.config.chart.background === "transparent" ? "#fff" : a2.config.chart.background, o2 = r.getContext("2d");
        o2.fillStyle = n2, o2.fillRect(0, 0, r.width * s2, r.height * s2);
        var h2 = t2.getSvgString(s2);
        if (window.canvg && P2.isIE11()) {
          var c2 = window.canvg.Canvg.fromString(o2, h2, { ignoreClear: true, ignoreDimensions: true });
          c2.start();
          var d2 = r.msToBlob();
          c2.stop(), i({ blob: d2 });
        } else {
          var g2 = "data:image/svg+xml," + encodeURIComponent(h2), p2 = new Image();
          p2.crossOrigin = "anonymous", p2.onload = function() {
            if (o2.drawImage(p2, 0, 0), r.msToBlob) {
              var f2 = r.msToBlob();
              i({ blob: f2 });
            } else {
              var b2 = r.toDataURL("image/png");
              i({ imgURI: b2 });
            }
          }, p2.src = g2;
        }
      });
    } }, { key: "exportToSVG", value: function() {
      this.triggerDownload(this.svgUrl(), this.w.config.chart.toolbar.export.svg.filename, ".svg");
    } }, { key: "exportToPng", value: function() {
      var e2 = this;
      this.dataURI().then(function(t2) {
        var i = t2.imgURI, a2 = t2.blob;
        a2 ? navigator.msSaveOrOpenBlob(a2, e2.w.globals.chartID + ".png") : e2.triggerDownload(i, e2.w.config.chart.toolbar.export.png.filename, ".png");
      });
    } }, { key: "exportToCSV", value: function(e2) {
      var t2 = this, i = e2.series, a2 = e2.fileName, s2 = e2.columnDelimiter, r = s2 === void 0 ? "," : s2, n2 = e2.lineDelimiter, o2 = n2 === void 0 ? `
` : n2, h2 = this.w;
      i || (i = h2.config.series);
      var c2, d2, g2 = [], p2 = [], f2 = "", b2 = h2.globals.series.map(function(v2, k2) {
        return h2.globals.collapsedSeriesIndices.indexOf(k2) === -1 ? v2 : [];
      }), m2 = function(v2) {
        return h2.config.xaxis.type === "datetime" && String(v2).length >= 10;
      }, w2 = Math.max.apply(Math, J2(i.map(function(v2) {
        return v2.data ? v2.data.length : 0;
      }))), A2 = new Je(this.ctx), l2 = new xe(this.ctx), u2 = function(v2) {
        var k2 = "";
        if (h2.globals.axisCharts) {
          if (h2.config.xaxis.type === "category" || h2.config.xaxis.convertedCatToNumeric)
            if (h2.globals.isBarHorizontal) {
              var S2 = h2.globals.yLabelFormatters[0], C2 = new te2(t2.ctx).getActiveConfigSeriesIndex();
              k2 = S2(h2.globals.labels[v2], { seriesIndex: C2, dataPointIndex: v2, w: h2 });
            } else
              k2 = l2.getLabel(h2.globals.labels, h2.globals.timescaleLabels, 0, v2).text;
          h2.config.xaxis.type === "datetime" && (h2.config.xaxis.categories.length ? k2 = h2.config.xaxis.categories[v2] : h2.config.labels.length && (k2 = h2.config.labels[v2]));
        } else
          k2 = h2.config.labels[v2];
        return Array.isArray(k2) && (k2 = k2.join(" ")), P2.isNumber(k2) ? k2 : k2.split(r).join("");
      }, x2 = function(v2, k2) {
        if (g2.length && k2 === 0 && p2.push(g2.join(r)), v2.data) {
          v2.data = v2.data.length && v2.data || J2(Array(w2)).map(function() {
            return "";
          });
          for (var S2 = 0; S2 < v2.data.length; S2++) {
            g2 = [];
            var C2 = u2(S2);
            if (C2 || (A2.isFormatXY() ? C2 = i[k2].data[S2].x : A2.isFormat2DArray() && (C2 = i[k2].data[S2] ? i[k2].data[S2][0] : "")), k2 === 0) {
              g2.push(m2(C2) ? h2.config.chart.toolbar.export.csv.dateFormatter(C2) : P2.isNumber(C2) ? C2 : C2.split(r).join(""));
              for (var L2 = 0; L2 < h2.globals.series.length; L2++) {
                var I2;
                A2.isFormatXY() ? g2.push((I2 = i[L2].data[S2]) === null || I2 === void 0 ? void 0 : I2.y) : g2.push(b2[L2][S2]);
              }
            }
            (h2.config.chart.type === "candlestick" || v2.type && v2.type === "candlestick") && (g2.pop(), g2.push(h2.globals.seriesCandleO[k2][S2]), g2.push(h2.globals.seriesCandleH[k2][S2]), g2.push(h2.globals.seriesCandleL[k2][S2]), g2.push(h2.globals.seriesCandleC[k2][S2])), (h2.config.chart.type === "boxPlot" || v2.type && v2.type === "boxPlot") && (g2.pop(), g2.push(h2.globals.seriesCandleO[k2][S2]), g2.push(h2.globals.seriesCandleH[k2][S2]), g2.push(h2.globals.seriesCandleM[k2][S2]), g2.push(h2.globals.seriesCandleL[k2][S2]), g2.push(h2.globals.seriesCandleC[k2][S2])), h2.config.chart.type === "rangeBar" && (g2.pop(), g2.push(h2.globals.seriesRangeStart[k2][S2]), g2.push(h2.globals.seriesRangeEnd[k2][S2])), g2.length && p2.push(g2.join(r));
          }
        }
      };
      g2.push(h2.config.chart.toolbar.export.csv.headerCategory), h2.config.chart.type === "boxPlot" ? (g2.push("minimum"), g2.push("q1"), g2.push("median"), g2.push("q3"), g2.push("maximum")) : h2.config.chart.type === "candlestick" ? (g2.push("open"), g2.push("high"), g2.push("low"), g2.push("close")) : h2.config.chart.type === "rangeBar" ? (g2.push("minimum"), g2.push("maximum")) : i.map(function(v2, k2) {
        var S2 = (v2.name ? v2.name : "series-".concat(k2)) + "";
        h2.globals.axisCharts && g2.push(S2.split(r).join("") ? S2.split(r).join("") : "series-".concat(k2));
      }), h2.globals.axisCharts || (g2.push(h2.config.chart.toolbar.export.csv.headerValue), p2.push(g2.join(r))), h2.globals.allSeriesHasEqualX || !h2.globals.axisCharts || h2.config.xaxis.categories.length || h2.config.labels.length ? i.map(function(v2, k2) {
        h2.globals.axisCharts ? x2(v2, k2) : ((g2 = []).push(h2.globals.labels[k2].split(r).join("")), g2.push(b2[k2]), p2.push(g2.join(r)));
      }) : (c2 = /* @__PURE__ */ new Set(), d2 = {}, i.forEach(function(v2, k2) {
        v2 == null || v2.data.forEach(function(S2) {
          var C2, L2;
          if (A2.isFormatXY())
            C2 = S2.x, L2 = S2.y;
          else {
            if (!A2.isFormat2DArray())
              return;
            C2 = S2[0], L2 = S2[1];
          }
          d2[C2] || (d2[C2] = Array(i.length).fill("")), d2[C2][k2] = L2, c2.add(C2);
        });
      }), g2.length && p2.push(g2.join(r)), Array.from(c2).sort().forEach(function(v2) {
        p2.push([m2(v2) && h2.config.xaxis.type === "datetime" ? h2.config.chart.toolbar.export.csv.dateFormatter(v2) : P2.isNumber(v2) ? v2 : v2.split(r).join(""), d2[v2].join(r)]);
      })), f2 += p2.join(o2), this.triggerDownload("data:text/csv; charset=utf-8," + encodeURIComponent("\uFEFF" + f2), a2 || h2.config.chart.toolbar.export.csv.filename, ".csv");
    } }, { key: "triggerDownload", value: function(e2, t2, i) {
      var a2 = document.createElement("a");
      a2.href = e2, a2.download = (t2 || this.w.globals.chartID) + i, document.body.appendChild(a2), a2.click(), document.body.removeChild(a2);
    } }]), y2;
  }(), Ie = function() {
    function y2(e2, t2) {
      F2(this, y2), this.ctx = e2, this.elgrid = t2, this.w = e2.w;
      var i = this.w;
      this.axesUtils = new xe(e2), this.xaxisLabels = i.globals.labels.slice(), i.globals.timescaleLabels.length > 0 && !i.globals.isBarHorizontal && (this.xaxisLabels = i.globals.timescaleLabels.slice()), i.config.xaxis.overwriteCategories && (this.xaxisLabels = i.config.xaxis.overwriteCategories), this.drawnLabels = [], this.drawnLabelsRects = [], i.config.xaxis.position === "top" ? this.offY = 0 : this.offY = i.globals.gridHeight + 1, this.offY = this.offY + i.config.xaxis.axisBorder.offsetY, this.isCategoryBarHorizontal = i.config.chart.type === "bar" && i.config.plotOptions.bar.horizontal, this.xaxisFontSize = i.config.xaxis.labels.style.fontSize, this.xaxisFontFamily = i.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = i.config.xaxis.labels.style.colors, this.xaxisBorderWidth = i.config.xaxis.axisBorder.width, this.isCategoryBarHorizontal && (this.xaxisBorderWidth = i.config.yaxis[0].axisBorder.width.toString()), this.xaxisBorderWidth.indexOf("%") > -1 ? this.xaxisBorderWidth = i.globals.gridWidth * parseInt(this.xaxisBorderWidth, 10) / 100 : this.xaxisBorderWidth = parseInt(this.xaxisBorderWidth, 10), this.xaxisBorderHeight = i.config.xaxis.axisBorder.height, this.yaxis = i.config.yaxis[0];
    }
    return Y2(y2, [{ key: "drawXaxis", value: function() {
      var e2 = this.w, t2 = new M2(this.ctx), i = t2.group({ class: "apexcharts-xaxis", transform: "translate(".concat(e2.config.xaxis.offsetX, ", ").concat(e2.config.xaxis.offsetY, ")") }), a2 = t2.group({ class: "apexcharts-xaxis-texts-g", transform: "translate(".concat(e2.globals.translateXAxisX, ", ").concat(e2.globals.translateXAxisY, ")") });
      i.add(a2);
      for (var s2 = [], r = 0; r < this.xaxisLabels.length; r++)
        s2.push(this.xaxisLabels[r]);
      if (this.drawXAxisLabelAndGroup(true, t2, a2, s2, e2.globals.isXNumeric, function(f2, b2) {
        return b2;
      }), e2.globals.hasXaxisGroups) {
        var n2 = e2.globals.groups;
        s2 = [];
        for (var o2 = 0; o2 < n2.length; o2++)
          s2.push(n2[o2].title);
        var h2 = {};
        e2.config.xaxis.group.style && (h2.xaxisFontSize = e2.config.xaxis.group.style.fontSize, h2.xaxisFontFamily = e2.config.xaxis.group.style.fontFamily, h2.xaxisForeColors = e2.config.xaxis.group.style.colors, h2.fontWeight = e2.config.xaxis.group.style.fontWeight, h2.cssClass = e2.config.xaxis.group.style.cssClass), this.drawXAxisLabelAndGroup(false, t2, a2, s2, false, function(f2, b2) {
          return n2[f2].cols * b2;
        }, h2);
      }
      if (e2.config.xaxis.title.text !== void 0) {
        var c2 = t2.group({ class: "apexcharts-xaxis-title" }), d2 = t2.drawText({ x: e2.globals.gridWidth / 2 + e2.config.xaxis.title.offsetX, y: this.offY + parseFloat(this.xaxisFontSize) + (e2.config.xaxis.position === "bottom" ? e2.globals.xAxisLabelsHeight : -e2.globals.xAxisLabelsHeight - 10) + e2.config.xaxis.title.offsetY, text: e2.config.xaxis.title.text, textAnchor: "middle", fontSize: e2.config.xaxis.title.style.fontSize, fontFamily: e2.config.xaxis.title.style.fontFamily, fontWeight: e2.config.xaxis.title.style.fontWeight, foreColor: e2.config.xaxis.title.style.color, cssClass: "apexcharts-xaxis-title-text " + e2.config.xaxis.title.style.cssClass });
        c2.add(d2), i.add(c2);
      }
      if (e2.config.xaxis.axisBorder.show) {
        var g2 = e2.globals.barPadForNumericAxis, p2 = t2.drawLine(e2.globals.padHorizontal + e2.config.xaxis.axisBorder.offsetX - g2, this.offY, this.xaxisBorderWidth + g2, this.offY, e2.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight);
        this.elgrid && this.elgrid.elGridBorders && e2.config.grid.show ? this.elgrid.elGridBorders.add(p2) : i.add(p2);
      }
      return i;
    } }, { key: "drawXAxisLabelAndGroup", value: function(e2, t2, i, a2, s2, r) {
      var n2, o2 = this, h2 = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : {}, c2 = [], d2 = [], g2 = this.w, p2 = h2.xaxisFontSize || this.xaxisFontSize, f2 = h2.xaxisFontFamily || this.xaxisFontFamily, b2 = h2.xaxisForeColors || this.xaxisForeColors, m2 = h2.fontWeight || g2.config.xaxis.labels.style.fontWeight, w2 = h2.cssClass || g2.config.xaxis.labels.style.cssClass, A2 = g2.globals.padHorizontal, l2 = a2.length, u2 = g2.config.xaxis.type === "category" ? g2.globals.dataPoints : l2;
      if (u2 === 0 && l2 > u2 && (u2 = l2), s2) {
        var x2 = u2 > 1 ? u2 - 1 : u2;
        n2 = g2.globals.gridWidth / Math.min(x2, l2 - 1), A2 = A2 + r(0, n2) / 2 + g2.config.xaxis.labels.offsetX;
      } else
        n2 = g2.globals.gridWidth / u2, A2 = A2 + r(0, n2) + g2.config.xaxis.labels.offsetX;
      for (var v2 = function(S2) {
        var C2 = A2 - r(S2, n2) / 2 + g2.config.xaxis.labels.offsetX;
        S2 === 0 && l2 === 1 && n2 / 2 === A2 && u2 === 1 && (C2 = g2.globals.gridWidth / 2);
        var L2 = o2.axesUtils.getLabel(a2, g2.globals.timescaleLabels, C2, S2, c2, p2, e2), I2 = 28;
        if (g2.globals.rotateXLabels && e2 && (I2 = 22), g2.config.xaxis.title.text && g2.config.xaxis.position === "top" && (I2 += parseFloat(g2.config.xaxis.title.style.fontSize) + 2), e2 || (I2 = I2 + parseFloat(p2) + (g2.globals.xAxisLabelsHeight - g2.globals.xAxisGroupLabelsHeight) + (g2.globals.rotateXLabels ? 10 : 0)), L2 = g2.config.xaxis.tickAmount !== void 0 && g2.config.xaxis.tickAmount !== "dataPoints" && g2.config.xaxis.type !== "datetime" ? o2.axesUtils.checkLabelBasedOnTickamount(S2, L2, l2) : o2.axesUtils.checkForOverflowingLabels(S2, L2, l2, c2, d2), g2.config.xaxis.labels.show) {
          var z2 = t2.drawText({ x: L2.x, y: o2.offY + g2.config.xaxis.labels.offsetY + I2 - (g2.config.xaxis.position === "top" ? g2.globals.xAxisHeight + g2.config.xaxis.axisTicks.height - 2 : 0), text: L2.text, textAnchor: "middle", fontWeight: L2.isBold ? 600 : m2, fontSize: p2, fontFamily: f2, foreColor: Array.isArray(b2) ? e2 && g2.config.xaxis.convertedCatToNumeric ? b2[g2.globals.minX + S2 - 1] : b2[S2] : b2, isPlainText: false, cssClass: (e2 ? "apexcharts-xaxis-label " : "apexcharts-xaxis-group-label ") + w2 });
          if (i.add(z2), z2.on("click", function(E2) {
            if (typeof g2.config.chart.events.xAxisLabelClick == "function") {
              var R2 = Object.assign({}, g2, { labelIndex: S2 });
              g2.config.chart.events.xAxisLabelClick(E2, o2.ctx, R2);
            }
          }), e2) {
            var T2 = document.createElementNS(g2.globals.SVGNS, "title");
            T2.textContent = Array.isArray(L2.text) ? L2.text.join(" ") : L2.text, z2.node.appendChild(T2), L2.text !== "" && (c2.push(L2.text), d2.push(L2));
          }
        }
        S2 < l2 - 1 && (A2 += r(S2 + 1, n2));
      }, k2 = 0; k2 <= l2 - 1; k2++)
        v2(k2);
    } }, { key: "drawXaxisInversed", value: function(e2) {
      var t2, i, a2 = this, s2 = this.w, r = new M2(this.ctx), n2 = s2.config.yaxis[0].opposite ? s2.globals.translateYAxisX[e2] : 0, o2 = r.group({ class: "apexcharts-yaxis apexcharts-xaxis-inversed", rel: e2 }), h2 = r.group({ class: "apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g", transform: "translate(" + n2 + ", 0)" });
      o2.add(h2);
      var c2 = [];
      if (s2.config.yaxis[e2].show)
        for (var d2 = 0; d2 < this.xaxisLabels.length; d2++)
          c2.push(this.xaxisLabels[d2]);
      t2 = s2.globals.gridHeight / c2.length, i = -t2 / 2.2;
      var g2 = s2.globals.yLabelFormatters[0], p2 = s2.config.yaxis[0].labels;
      if (p2.show)
        for (var f2 = function(x2) {
          var v2 = c2[x2] === void 0 ? "" : c2[x2];
          v2 = g2(v2, { seriesIndex: e2, dataPointIndex: x2, w: s2 });
          var k2 = a2.axesUtils.getYAxisForeColor(p2.style.colors, e2), S2 = 0;
          Array.isArray(v2) && (S2 = v2.length / 2 * parseInt(p2.style.fontSize, 10));
          var C2 = p2.offsetX - 15, L2 = "end";
          a2.yaxis.opposite && (L2 = "start"), s2.config.yaxis[0].labels.align === "left" ? (C2 = p2.offsetX, L2 = "start") : s2.config.yaxis[0].labels.align === "center" ? (C2 = p2.offsetX, L2 = "middle") : s2.config.yaxis[0].labels.align === "right" && (L2 = "end");
          var I2 = r.drawText({ x: C2, y: i + t2 + p2.offsetY - S2, text: v2, textAnchor: L2, foreColor: Array.isArray(k2) ? k2[x2] : k2, fontSize: p2.style.fontSize, fontFamily: p2.style.fontFamily, fontWeight: p2.style.fontWeight, isPlainText: false, cssClass: "apexcharts-yaxis-label " + p2.style.cssClass, maxWidth: p2.maxWidth });
          h2.add(I2), I2.on("click", function(E2) {
            if (typeof s2.config.chart.events.xAxisLabelClick == "function") {
              var R2 = Object.assign({}, s2, { labelIndex: x2 });
              s2.config.chart.events.xAxisLabelClick(E2, a2.ctx, R2);
            }
          });
          var z2 = document.createElementNS(s2.globals.SVGNS, "title");
          if (z2.textContent = Array.isArray(v2) ? v2.join(" ") : v2, I2.node.appendChild(z2), s2.config.yaxis[e2].labels.rotate !== 0) {
            var T2 = r.rotateAroundCenter(I2.node);
            I2.node.setAttribute("transform", "rotate(".concat(s2.config.yaxis[e2].labels.rotate, " 0 ").concat(T2.y, ")"));
          }
          i += t2;
        }, b2 = 0; b2 <= c2.length - 1; b2++)
          f2(b2);
      if (s2.config.yaxis[0].title.text !== void 0) {
        var m2 = r.group({ class: "apexcharts-yaxis-title apexcharts-xaxis-title-inversed", transform: "translate(" + n2 + ", 0)" }), w2 = r.drawText({ x: s2.config.yaxis[0].title.offsetX, y: s2.globals.gridHeight / 2 + s2.config.yaxis[0].title.offsetY, text: s2.config.yaxis[0].title.text, textAnchor: "middle", foreColor: s2.config.yaxis[0].title.style.color, fontSize: s2.config.yaxis[0].title.style.fontSize, fontWeight: s2.config.yaxis[0].title.style.fontWeight, fontFamily: s2.config.yaxis[0].title.style.fontFamily, cssClass: "apexcharts-yaxis-title-text " + s2.config.yaxis[0].title.style.cssClass });
        m2.add(w2), o2.add(m2);
      }
      var A2 = 0;
      this.isCategoryBarHorizontal && s2.config.yaxis[0].opposite && (A2 = s2.globals.gridWidth);
      var l2 = s2.config.xaxis.axisBorder;
      if (l2.show) {
        var u2 = r.drawLine(s2.globals.padHorizontal + l2.offsetX + A2, 1 + l2.offsetY, s2.globals.padHorizontal + l2.offsetX + A2, s2.globals.gridHeight + l2.offsetY, l2.color, 0);
        this.elgrid && this.elgrid.elGridBorders && s2.config.grid.show ? this.elgrid.elGridBorders.add(u2) : o2.add(u2);
      }
      return s2.config.yaxis[0].axisTicks.show && this.axesUtils.drawYAxisTicks(A2, c2.length, s2.config.yaxis[0].axisBorder, s2.config.yaxis[0].axisTicks, 0, t2, o2), o2;
    } }, { key: "drawXaxisTicks", value: function(e2, t2, i) {
      var a2 = this.w, s2 = e2;
      if (!(e2 < 0 || e2 - 2 > a2.globals.gridWidth)) {
        var r = this.offY + a2.config.xaxis.axisTicks.offsetY;
        if (t2 = t2 + r + a2.config.xaxis.axisTicks.height, a2.config.xaxis.position === "top" && (t2 = r - a2.config.xaxis.axisTicks.height), a2.config.xaxis.axisTicks.show) {
          var n2 = new M2(this.ctx).drawLine(e2 + a2.config.xaxis.axisTicks.offsetX, r + a2.config.xaxis.offsetY, s2 + a2.config.xaxis.axisTicks.offsetX, t2 + a2.config.xaxis.offsetY, a2.config.xaxis.axisTicks.color);
          i.add(n2), n2.node.classList.add("apexcharts-xaxis-tick");
        }
      }
    } }, { key: "getXAxisTicksPositions", value: function() {
      var e2 = this.w, t2 = [], i = this.xaxisLabels.length, a2 = e2.globals.padHorizontal;
      if (e2.globals.timescaleLabels.length > 0)
        for (var s2 = 0; s2 < i; s2++)
          a2 = this.xaxisLabels[s2].position, t2.push(a2);
      else
        for (var r = i, n2 = 0; n2 < r; n2++) {
          var o2 = r;
          e2.globals.isXNumeric && e2.config.chart.type !== "bar" && (o2 -= 1), a2 += e2.globals.gridWidth / o2, t2.push(a2);
        }
      return t2;
    } }, { key: "xAxisLabelCorrections", value: function() {
      var e2 = this.w, t2 = new M2(this.ctx), i = e2.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g"), a2 = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-texts-g text:not(.apexcharts-xaxis-group-label)"), s2 = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-inversed text"), r = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-inversed-texts-g text tspan");
      if (e2.globals.rotateXLabels || e2.config.xaxis.labels.rotateAlways)
        for (var n2 = 0; n2 < a2.length; n2++) {
          var o2 = t2.rotateAroundCenter(a2[n2]);
          o2.y = o2.y - 1, o2.x = o2.x + 1, a2[n2].setAttribute("transform", "rotate(".concat(e2.config.xaxis.labels.rotate, " ").concat(o2.x, " ").concat(o2.y, ")")), a2[n2].setAttribute("text-anchor", "end"), i.setAttribute("transform", "translate(0, ".concat(-10, ")"));
          var h2 = a2[n2].childNodes;
          e2.config.xaxis.labels.trim && Array.prototype.forEach.call(h2, function(p2) {
            t2.placeTextWithEllipsis(p2, p2.textContent, e2.globals.xAxisLabelsHeight - (e2.config.legend.position === "bottom" ? 20 : 10));
          });
        }
      else
        (function() {
          for (var p2 = e2.globals.gridWidth / (e2.globals.labels.length + 1), f2 = 0; f2 < a2.length; f2++) {
            var b2 = a2[f2].childNodes;
            e2.config.xaxis.labels.trim && e2.config.xaxis.type !== "datetime" && Array.prototype.forEach.call(b2, function(m2) {
              t2.placeTextWithEllipsis(m2, m2.textContent, p2);
            });
          }
        })();
      if (s2.length > 0) {
        var c2 = s2[s2.length - 1].getBBox(), d2 = s2[0].getBBox();
        c2.x < -20 && s2[s2.length - 1].parentNode.removeChild(s2[s2.length - 1]), d2.x + d2.width > e2.globals.gridWidth && !e2.globals.isBarHorizontal && s2[0].parentNode.removeChild(s2[0]);
        for (var g2 = 0; g2 < r.length; g2++)
          t2.placeTextWithEllipsis(r[g2], r[g2].textContent, e2.config.yaxis[0].labels.maxWidth - (e2.config.yaxis[0].title.text ? 2 * parseFloat(e2.config.yaxis[0].title.style.fontSize) : 0) - 15);
      }
    } }]), y2;
  }(), Qe = function() {
    function y2(e2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w;
      var t2 = this.w;
      this.xaxisLabels = t2.globals.labels.slice(), this.axesUtils = new xe(e2), this.isRangeBar = t2.globals.seriesRange.length && t2.globals.isBarHorizontal, t2.globals.timescaleLabels.length > 0 && (this.xaxisLabels = t2.globals.timescaleLabels.slice());
    }
    return Y2(y2, [{ key: "drawGridArea", value: function() {
      var e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t2 = this.w, i = new M2(this.ctx);
      e2 === null && (e2 = i.group({ class: "apexcharts-grid" }));
      var a2 = i.drawLine(t2.globals.padHorizontal, 1, t2.globals.padHorizontal, t2.globals.gridHeight, "transparent"), s2 = i.drawLine(t2.globals.padHorizontal, t2.globals.gridHeight, t2.globals.gridWidth, t2.globals.gridHeight, "transparent");
      return e2.add(s2), e2.add(a2), e2;
    } }, { key: "drawGrid", value: function() {
      var e2 = null;
      return this.w.globals.axisCharts && (e2 = this.renderGrid(), this.drawGridArea(e2.el)), e2;
    } }, { key: "createGridMask", value: function() {
      var e2 = this.w, t2 = e2.globals, i = new M2(this.ctx), a2 = Array.isArray(e2.config.stroke.width) ? 0 : e2.config.stroke.width;
      if (Array.isArray(e2.config.stroke.width)) {
        var s2 = 0;
        e2.config.stroke.width.forEach(function(d2) {
          s2 = Math.max(s2, d2);
        }), a2 = s2;
      }
      t2.dom.elGridRectMask = document.createElementNS(t2.SVGNS, "clipPath"), t2.dom.elGridRectMask.setAttribute("id", "gridRectMask".concat(t2.cuid)), t2.dom.elGridRectMarkerMask = document.createElementNS(t2.SVGNS, "clipPath"), t2.dom.elGridRectMarkerMask.setAttribute("id", "gridRectMarkerMask".concat(t2.cuid)), t2.dom.elForecastMask = document.createElementNS(t2.SVGNS, "clipPath"), t2.dom.elForecastMask.setAttribute("id", "forecastMask".concat(t2.cuid)), t2.dom.elNonForecastMask = document.createElementNS(t2.SVGNS, "clipPath"), t2.dom.elNonForecastMask.setAttribute("id", "nonForecastMask".concat(t2.cuid));
      var r = e2.config.chart.type, n2 = 0, o2 = 0;
      (r === "bar" || r === "rangeBar" || r === "candlestick" || r === "boxPlot" || e2.globals.comboBarCount > 0) && e2.globals.isXNumeric && !e2.globals.isBarHorizontal && (n2 = e2.config.grid.padding.left, o2 = e2.config.grid.padding.right, t2.barPadForNumericAxis > n2 && (n2 = t2.barPadForNumericAxis, o2 = t2.barPadForNumericAxis)), t2.dom.elGridRect = i.drawRect(-a2 - n2 - 2, 2 * -a2 - 2, t2.gridWidth + a2 + o2 + n2 + 4, t2.gridHeight + 4 * a2 + 4, 0, "#fff");
      var h2 = e2.globals.markers.largestSize + 1;
      t2.dom.elGridRectMarker = i.drawRect(2 * -h2, 2 * -h2, t2.gridWidth + 4 * h2, t2.gridHeight + 4 * h2, 0, "#fff"), t2.dom.elGridRectMask.appendChild(t2.dom.elGridRect.node), t2.dom.elGridRectMarkerMask.appendChild(t2.dom.elGridRectMarker.node);
      var c2 = t2.dom.baseEl.querySelector("defs");
      c2.appendChild(t2.dom.elGridRectMask), c2.appendChild(t2.dom.elForecastMask), c2.appendChild(t2.dom.elNonForecastMask), c2.appendChild(t2.dom.elGridRectMarkerMask);
    } }, { key: "_drawGridLines", value: function(e2) {
      var t2 = e2.i, i = e2.x1, a2 = e2.y1, s2 = e2.x2, r = e2.y2, n2 = e2.xCount, o2 = e2.parent, h2 = this.w;
      if (!(t2 === 0 && h2.globals.skipFirstTimelinelabel || t2 === n2 - 1 && h2.globals.skipLastTimelinelabel && !h2.config.xaxis.labels.formatter || h2.config.chart.type === "radar")) {
        h2.config.grid.xaxis.lines.show && this._drawGridLine({ i: t2, x1: i, y1: a2, x2: s2, y2: r, xCount: n2, parent: o2 });
        var c2 = 0;
        if (h2.globals.hasXaxisGroups && h2.config.xaxis.tickPlacement === "between") {
          var d2 = h2.globals.groups;
          if (d2) {
            for (var g2 = 0, p2 = 0; g2 < t2 && p2 < d2.length; p2++)
              g2 += d2[p2].cols;
            g2 === t2 && (c2 = 0.6 * h2.globals.xAxisLabelsHeight);
          }
        }
        new Ie(this.ctx).drawXaxisTicks(i, c2, h2.globals.dom.elGraphical);
      }
    } }, { key: "_drawGridLine", value: function(e2) {
      var t2 = e2.i, i = e2.x1, a2 = e2.y1, s2 = e2.x2, r = e2.y2, n2 = e2.xCount, o2 = e2.parent, h2 = this.w, c2 = false, d2 = o2.node.classList.contains("apexcharts-gridlines-horizontal"), g2 = h2.config.grid.strokeDashArray, p2 = h2.globals.barPadForNumericAxis;
      (a2 === 0 && r === 0 || i === 0 && s2 === 0) && (c2 = true), a2 === h2.globals.gridHeight && r === h2.globals.gridHeight && (c2 = true), !h2.globals.isBarHorizontal || t2 !== 0 && t2 !== n2 - 1 || (c2 = true);
      var f2 = new M2(this).drawLine(i - (d2 ? p2 : 0), a2, s2 + (d2 ? p2 : 0), r, h2.config.grid.borderColor, g2);
      f2.node.classList.add("apexcharts-gridline"), c2 && h2.config.grid.show ? this.elGridBorders.add(f2) : o2.add(f2);
    } }, { key: "_drawGridBandRect", value: function(e2) {
      var t2 = e2.c, i = e2.x1, a2 = e2.y1, s2 = e2.x2, r = e2.y2, n2 = e2.type, o2 = this.w, h2 = new M2(this.ctx), c2 = o2.globals.barPadForNumericAxis;
      if (n2 !== "column" || o2.config.xaxis.type !== "datetime") {
        var d2 = o2.config.grid[n2].colors[t2], g2 = h2.drawRect(i - (n2 === "row" ? c2 : 0), a2, s2 + (n2 === "row" ? 2 * c2 : 0), r, 0, d2, o2.config.grid[n2].opacity);
        this.elg.add(g2), g2.attr("clip-path", "url(#gridRectMask".concat(o2.globals.cuid, ")")), g2.node.classList.add("apexcharts-grid-".concat(n2));
      }
    } }, { key: "_drawXYLines", value: function(e2) {
      var t2 = this, i = e2.xCount, a2 = e2.tickAmount, s2 = this.w;
      if (s2.config.grid.xaxis.lines.show || s2.config.xaxis.axisTicks.show) {
        var r, n2 = s2.globals.padHorizontal, o2 = s2.globals.gridHeight;
        s2.globals.timescaleLabels.length ? function(f2) {
          for (var b2 = f2.xC, m2 = f2.x1, w2 = f2.y1, A2 = f2.x2, l2 = f2.y2, u2 = 0; u2 < b2; u2++)
            m2 = t2.xaxisLabels[u2].position, A2 = t2.xaxisLabels[u2].position, t2._drawGridLines({ i: u2, x1: m2, y1: w2, x2: A2, y2: l2, xCount: i, parent: t2.elgridLinesV });
        }({ xC: i, x1: n2, y1: 0, x2: r, y2: o2 }) : (s2.globals.isXNumeric && (i = s2.globals.xAxisScale.result.length), function(f2) {
          for (var b2 = f2.xC, m2 = f2.x1, w2 = f2.y1, A2 = f2.x2, l2 = f2.y2, u2 = 0; u2 < b2 + (s2.globals.isXNumeric ? 0 : 1); u2++)
            u2 === 0 && b2 === 1 && s2.globals.dataPoints === 1 && (A2 = m2 = s2.globals.gridWidth / 2), t2._drawGridLines({ i: u2, x1: m2, y1: w2, x2: A2, y2: l2, xCount: i, parent: t2.elgridLinesV }), A2 = m2 += s2.globals.gridWidth / (s2.globals.isXNumeric ? b2 - 1 : b2);
        }({ xC: i, x1: n2, y1: 0, x2: r, y2: o2 }));
      }
      if (s2.config.grid.yaxis.lines.show) {
        var h2 = 0, c2 = 0, d2 = s2.globals.gridWidth, g2 = a2 + 1;
        this.isRangeBar && (g2 = s2.globals.labels.length);
        for (var p2 = 0; p2 < g2 + (this.isRangeBar ? 1 : 0); p2++)
          this._drawGridLine({ i: p2, xCount: g2 + (this.isRangeBar ? 1 : 0), x1: 0, y1: h2, x2: d2, y2: c2, parent: this.elgridLinesH }), c2 = h2 += s2.globals.gridHeight / (this.isRangeBar ? g2 : a2);
      }
    } }, { key: "_drawInvertedXYLines", value: function(e2) {
      var t2 = e2.xCount, i = this.w;
      if (i.config.grid.xaxis.lines.show || i.config.xaxis.axisTicks.show)
        for (var a2, s2 = i.globals.padHorizontal, r = i.globals.gridHeight, n2 = 0; n2 < t2 + 1; n2++)
          i.config.grid.xaxis.lines.show && this._drawGridLine({ i: n2, xCount: t2 + 1, x1: s2, y1: 0, x2: a2, y2: r, parent: this.elgridLinesV }), new Ie(this.ctx).drawXaxisTicks(s2, 0, i.globals.dom.elGraphical), a2 = s2 = s2 + i.globals.gridWidth / t2 + 0.3;
      if (i.config.grid.yaxis.lines.show)
        for (var o2 = 0, h2 = 0, c2 = i.globals.gridWidth, d2 = 0; d2 < i.globals.dataPoints + 1; d2++)
          this._drawGridLine({ i: d2, xCount: i.globals.dataPoints + 1, x1: 0, y1: o2, x2: c2, y2: h2, parent: this.elgridLinesH }), h2 = o2 += i.globals.gridHeight / i.globals.dataPoints;
    } }, { key: "renderGrid", value: function() {
      var e2 = this.w, t2 = new M2(this.ctx);
      this.elg = t2.group({ class: "apexcharts-grid" }), this.elgridLinesH = t2.group({ class: "apexcharts-gridlines-horizontal" }), this.elgridLinesV = t2.group({ class: "apexcharts-gridlines-vertical" }), this.elGridBorders = t2.group({ class: "apexcharts-grid-borders" }), this.elg.add(this.elgridLinesH), this.elg.add(this.elgridLinesV), e2.config.grid.show || (this.elgridLinesV.hide(), this.elgridLinesH.hide(), this.elGridBorders.hide());
      for (var i, a2 = e2.globals.yAxisScale.length ? e2.globals.yAxisScale[0].result.length - 1 : 5, s2 = 0; s2 < e2.globals.series.length && (e2.globals.yAxisScale[s2] !== void 0 && (a2 = e2.globals.yAxisScale[s2].result.length - 1), !(a2 > 2)); s2++)
        ;
      if (!e2.globals.isBarHorizontal || this.isRangeBar) {
        var r, n2, o2;
        i = this.xaxisLabels.length, this.isRangeBar && (i--, a2 = e2.globals.labels.length, e2.config.xaxis.tickAmount && e2.config.xaxis.labels.formatter && (i = e2.config.xaxis.tickAmount), ((r = e2.globals.yAxisScale) === null || r === void 0 || (n2 = r[0]) === null || n2 === void 0 || (o2 = n2.result) === null || o2 === void 0 ? void 0 : o2.length) > 0 && e2.config.xaxis.type !== "datetime" && (i = e2.globals.yAxisScale[0].result.length - 1)), this._drawXYLines({ xCount: i, tickAmount: a2 });
      } else
        i = a2, a2 = e2.globals.xTickAmount, this._drawInvertedXYLines({ xCount: i, tickAmount: a2 });
      return this.drawGridBands(i, a2), { el: this.elg, elGridBorders: this.elGridBorders, xAxisTickWidth: e2.globals.gridWidth / i };
    } }, { key: "drawGridBands", value: function(e2, t2) {
      var i = this.w;
      if (i.config.grid.row.colors !== void 0 && i.config.grid.row.colors.length > 0)
        for (var a2 = 0, s2 = i.globals.gridHeight / t2, r = i.globals.gridWidth, n2 = 0, o2 = 0; n2 < t2; n2++, o2++)
          o2 >= i.config.grid.row.colors.length && (o2 = 0), this._drawGridBandRect({ c: o2, x1: 0, y1: a2, x2: r, y2: s2, type: "row" }), a2 += i.globals.gridHeight / t2;
      if (i.config.grid.column.colors !== void 0 && i.config.grid.column.colors.length > 0)
        for (var h2 = i.globals.isBarHorizontal || i.config.xaxis.tickPlacement !== "on" || i.config.xaxis.type !== "category" && !i.config.xaxis.convertedCatToNumeric ? e2 : e2 - 1, c2 = i.globals.padHorizontal, d2 = i.globals.padHorizontal + i.globals.gridWidth / h2, g2 = i.globals.gridHeight, p2 = 0, f2 = 0; p2 < e2; p2++, f2++)
          f2 >= i.config.grid.column.colors.length && (f2 = 0), this._drawGridBandRect({ c: f2, x1: c2, y1: 0, x2: d2, y2: g2, type: "column" }), c2 += i.globals.gridWidth / h2;
    } }]), y2;
  }(), we2 = function() {
    function y2(e2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w;
    }
    return Y2(y2, [{ key: "niceScale", value: function(e2, t2) {
      var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 5, a2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, s2 = arguments.length > 4 ? arguments[4] : void 0, r = this.w, n2 = Math.abs(t2 - e2);
      if ((i = this._adjustTicksForSmallRange(i, a2, n2)) === "dataPoints" && (i = r.globals.dataPoints - 1), e2 === Number.MIN_VALUE && t2 === 0 || !P2.isNumber(e2) && !P2.isNumber(t2) || e2 === Number.MIN_VALUE && t2 === -Number.MAX_VALUE)
        return e2 = 0, t2 = i, this.linearScale(e2, t2, i, a2, r.config.yaxis[a2].stepSize);
      e2 > t2 ? (console.warn("axis.min cannot be greater than axis.max"), t2 = e2 + 0.1) : e2 === t2 && (e2 = e2 === 0 ? 0 : e2 - 0.5, t2 = t2 === 0 ? 2 : t2 + 0.5);
      var o2 = [];
      n2 < 1 && s2 && (r.config.chart.type === "candlestick" || r.config.series[a2].type === "candlestick" || r.config.chart.type === "boxPlot" || r.config.series[a2].type === "boxPlot" || r.globals.isRangeData) && (t2 *= 1.01);
      var h2 = i + 1;
      h2 < 2 ? h2 = 2 : h2 > 2 && (h2 -= 2);
      var c2 = n2 / h2, d2 = Math.floor(P2.log10(c2)), g2 = Math.pow(10, d2), p2 = Math.round(c2 / g2);
      p2 < 1 && (p2 = 1);
      var f2 = p2 * g2;
      r.config.yaxis[a2].stepSize && (f2 = r.config.yaxis[a2].stepSize), r.globals.isBarHorizontal && r.config.xaxis.stepSize && r.config.xaxis.type !== "datetime" && (f2 = r.config.xaxis.stepSize);
      var b2 = f2 * Math.floor(e2 / f2), m2 = f2 * Math.ceil(t2 / f2), w2 = b2;
      if (s2 && n2 > 2) {
        for (; o2.push(P2.stripNumber(w2, 7)), !((w2 += f2) > m2); )
          ;
        return { result: o2, niceMin: o2[0], niceMax: o2[o2.length - 1] };
      }
      var A2 = e2;
      (o2 = []).push(P2.stripNumber(A2, 7));
      for (var l2 = Math.abs(t2 - e2) / i, u2 = 0; u2 <= i; u2++)
        A2 += l2, o2.push(A2);
      return o2[o2.length - 2] >= t2 && o2.pop(), { result: o2, niceMin: o2[0], niceMax: o2[o2.length - 1] };
    } }, { key: "linearScale", value: function(e2, t2) {
      var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 5, a2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, s2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : void 0, r = Math.abs(t2 - e2);
      (i = this._adjustTicksForSmallRange(i, a2, r)) === "dataPoints" && (i = this.w.globals.dataPoints - 1), s2 || (s2 = r / i), i === Number.MAX_VALUE && (i = 5, s2 = 1);
      for (var n2 = [], o2 = e2; i >= 0; )
        n2.push(o2), o2 += s2, i -= 1;
      return { result: n2, niceMin: n2[0], niceMax: n2[n2.length - 1] };
    } }, { key: "logarithmicScaleNice", value: function(e2, t2, i) {
      t2 <= 0 && (t2 = Math.max(e2, i)), e2 <= 0 && (e2 = Math.min(t2, i));
      for (var a2 = [], s2 = Math.ceil(Math.log(t2) / Math.log(i) + 1), r = Math.floor(Math.log(e2) / Math.log(i)); r < s2; r++)
        a2.push(Math.pow(i, r));
      return { result: a2, niceMin: a2[0], niceMax: a2[a2.length - 1] };
    } }, { key: "logarithmicScale", value: function(e2, t2, i) {
      t2 <= 0 && (t2 = Math.max(e2, i)), e2 <= 0 && (e2 = Math.min(t2, i));
      for (var a2 = [], s2 = Math.log(t2) / Math.log(i), r = Math.log(e2) / Math.log(i), n2 = s2 - r, o2 = Math.round(n2), h2 = n2 / o2, c2 = 0, d2 = r; c2 < o2; c2++, d2 += h2)
        a2.push(Math.pow(i, d2));
      return a2.push(Math.pow(i, s2)), { result: a2, niceMin: e2, niceMax: t2 };
    } }, { key: "_adjustTicksForSmallRange", value: function(e2, t2, i) {
      var a2 = e2;
      if (t2 !== void 0 && this.w.config.yaxis[t2].labels.formatter && this.w.config.yaxis[t2].tickAmount === void 0) {
        var s2 = Number(this.w.config.yaxis[t2].labels.formatter(1));
        P2.isNumber(s2) && this.w.globals.yValueDecimal === 0 && (a2 = Math.ceil(i));
      }
      return a2 < e2 ? a2 : e2;
    } }, { key: "setYScaleForIndex", value: function(e2, t2, i) {
      var a2 = this.w.globals, s2 = this.w.config, r = a2.isBarHorizontal ? s2.xaxis : s2.yaxis[e2];
      a2.yAxisScale[e2] === void 0 && (a2.yAxisScale[e2] = []);
      var n2 = Math.abs(i - t2);
      if (r.logarithmic && n2 <= 5 && (a2.invalidLogScale = true), r.logarithmic && n2 > 5)
        a2.allSeriesCollapsed = false, a2.yAxisScale[e2] = this.logarithmicScale(t2, i, r.logBase), a2.yAxisScale[e2] = r.forceNiceScale ? this.logarithmicScaleNice(t2, i, r.logBase) : this.logarithmicScale(t2, i, r.logBase);
      else if (i !== -Number.MAX_VALUE && P2.isNumber(i))
        if (a2.allSeriesCollapsed = false, r.min === void 0 && r.max === void 0 || r.forceNiceScale) {
          var o2 = s2.yaxis[e2].max === void 0 && s2.yaxis[e2].min === void 0 || s2.yaxis[e2].forceNiceScale;
          a2.yAxisScale[e2] = this.niceScale(t2, i, r.tickAmount ? r.tickAmount : n2 < 5 && n2 > 1 ? n2 + 1 : 5, e2, o2);
        } else
          a2.yAxisScale[e2] = this.linearScale(t2, i, r.tickAmount, e2, s2.yaxis[e2].stepSize);
      else
        a2.yAxisScale[e2] = this.linearScale(0, 5, 5, e2, s2.yaxis[e2].stepSize);
    } }, { key: "setXScale", value: function(e2, t2) {
      var i = this.w, a2 = i.globals, s2 = Math.abs(t2 - e2);
      return t2 !== -Number.MAX_VALUE && P2.isNumber(t2) ? a2.xAxisScale = this.linearScale(e2, t2, i.config.xaxis.tickAmount ? i.config.xaxis.tickAmount : s2 < 5 && s2 > 1 ? s2 + 1 : 5, 0, i.config.xaxis.stepSize) : a2.xAxisScale = this.linearScale(0, 5, 5), a2.xAxisScale;
    } }, { key: "setMultipleYScales", value: function() {
      var e2 = this, t2 = this.w.globals, i = this.w.config, a2 = t2.minYArr.concat([]), s2 = t2.maxYArr.concat([]), r = [];
      i.yaxis.forEach(function(n2, o2) {
        var h2 = o2;
        i.series.forEach(function(g2, p2) {
          g2.name === n2.seriesName && (h2 = p2, o2 !== p2 ? r.push({ index: p2, similarIndex: o2, alreadyExists: true }) : r.push({ index: p2 }));
        });
        var c2 = a2[h2], d2 = s2[h2];
        e2.setYScaleForIndex(o2, c2, d2);
      }), this.sameScaleInMultipleAxes(a2, s2, r);
    } }, { key: "sameScaleInMultipleAxes", value: function(e2, t2, i) {
      var a2 = this, s2 = this.w.config, r = this.w.globals, n2 = [];
      i.forEach(function(b2) {
        b2.alreadyExists && (n2[b2.index] === void 0 && (n2[b2.index] = []), n2[b2.index].push(b2.index), n2[b2.index].push(b2.similarIndex));
      }), r.yAxisSameScaleIndices = n2, n2.forEach(function(b2, m2) {
        n2.forEach(function(w2, A2) {
          var l2, u2;
          m2 !== A2 && (l2 = b2, u2 = w2, l2.filter(function(x2) {
            return u2.indexOf(x2) !== -1;
          })).length > 0 && (n2[m2] = n2[m2].concat(n2[A2]));
        });
      });
      var o2 = n2.map(function(b2) {
        return b2.filter(function(m2, w2) {
          return b2.indexOf(m2) === w2;
        });
      }).map(function(b2) {
        return b2.sort();
      });
      n2 = n2.filter(function(b2) {
        return !!b2;
      });
      var h2 = o2.slice(), c2 = h2.map(function(b2) {
        return JSON.stringify(b2);
      });
      h2 = h2.filter(function(b2, m2) {
        return c2.indexOf(JSON.stringify(b2)) === m2;
      });
      var d2 = [], g2 = [];
      e2.forEach(function(b2, m2) {
        h2.forEach(function(w2, A2) {
          w2.indexOf(m2) > -1 && (d2[A2] === void 0 && (d2[A2] = [], g2[A2] = []), d2[A2].push({ key: m2, value: b2 }), g2[A2].push({ key: m2, value: t2[m2] }));
        });
      });
      var p2 = Array.apply(null, Array(h2.length)).map(Number.prototype.valueOf, Number.MIN_VALUE), f2 = Array.apply(null, Array(h2.length)).map(Number.prototype.valueOf, -Number.MAX_VALUE);
      d2.forEach(function(b2, m2) {
        b2.forEach(function(w2, A2) {
          p2[m2] = Math.min(w2.value, p2[m2]);
        });
      }), g2.forEach(function(b2, m2) {
        b2.forEach(function(w2, A2) {
          f2[m2] = Math.max(w2.value, f2[m2]);
        });
      }), e2.forEach(function(b2, m2) {
        g2.forEach(function(w2, A2) {
          var l2 = p2[A2], u2 = f2[A2];
          s2.chart.stacked && (u2 = 0, w2.forEach(function(x2, v2) {
            x2.value !== -Number.MAX_VALUE && (u2 += x2.value), l2 !== Number.MIN_VALUE && (l2 += d2[A2][v2].value);
          })), w2.forEach(function(x2, v2) {
            w2[v2].key === m2 && (s2.yaxis[m2].min !== void 0 && (l2 = typeof s2.yaxis[m2].min == "function" ? s2.yaxis[m2].min(r.minY) : s2.yaxis[m2].min), s2.yaxis[m2].max !== void 0 && (u2 = typeof s2.yaxis[m2].max == "function" ? s2.yaxis[m2].max(r.maxY) : s2.yaxis[m2].max), a2.setYScaleForIndex(m2, l2, u2));
          });
        });
      });
    } }, { key: "autoScaleY", value: function(e2, t2, i) {
      e2 || (e2 = this);
      var a2 = e2.w;
      if (a2.globals.isMultipleYAxis || a2.globals.collapsedSeries.length)
        return console.warn("autoScaleYaxis not supported in a multi-yaxis chart."), t2;
      var s2 = a2.globals.seriesX[0], r = a2.config.chart.stacked;
      return t2.forEach(function(n2, o2) {
        for (var h2 = 0, c2 = 0; c2 < s2.length; c2++)
          if (s2[c2] >= i.xaxis.min) {
            h2 = c2;
            break;
          }
        var d2, g2, p2 = a2.globals.minYArr[o2], f2 = a2.globals.maxYArr[o2], b2 = a2.globals.stackedSeriesTotals;
        a2.globals.series.forEach(function(m2, w2) {
          var A2 = m2[h2];
          r ? (A2 = b2[h2], d2 = g2 = A2, b2.forEach(function(l2, u2) {
            s2[u2] <= i.xaxis.max && s2[u2] >= i.xaxis.min && (l2 > g2 && l2 !== null && (g2 = l2), m2[u2] < d2 && m2[u2] !== null && (d2 = m2[u2]));
          })) : (d2 = g2 = A2, m2.forEach(function(l2, u2) {
            if (s2[u2] <= i.xaxis.max && s2[u2] >= i.xaxis.min) {
              var x2 = l2, v2 = l2;
              a2.globals.series.forEach(function(k2, S2) {
                l2 !== null && (x2 = Math.min(k2[u2], x2), v2 = Math.max(k2[u2], v2));
              }), v2 > g2 && v2 !== null && (g2 = v2), x2 < d2 && x2 !== null && (d2 = x2);
            }
          })), d2 === void 0 && g2 === void 0 && (d2 = p2, g2 = f2), g2 *= g2 < 0 ? 0.9 : 1.1, (d2 *= d2 < 0 ? 1.1 : 0.9) === 0 && g2 === 0 && (d2 = -1, g2 = 1), g2 < 0 && g2 < f2 && (g2 = f2), d2 < 0 && d2 > p2 && (d2 = p2), t2.length > 1 ? (t2[w2].min = n2.min === void 0 ? d2 : n2.min, t2[w2].max = n2.max === void 0 ? g2 : n2.max) : (t2[0].min = n2.min === void 0 ? d2 : n2.min, t2[0].max = n2.max === void 0 ? g2 : n2.max);
        });
      }), t2;
    } }]), y2;
  }(), De = function() {
    function y2(e2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w, this.scales = new we2(e2);
    }
    return Y2(y2, [{ key: "init", value: function() {
      this.setYRange(), this.setXRange(), this.setZRange();
    } }, { key: "getMinYMaxY", value: function(e2) {
      var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.MAX_VALUE, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -Number.MAX_VALUE, a2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, s2 = this.w.config, r = this.w.globals, n2 = -Number.MAX_VALUE, o2 = Number.MIN_VALUE;
      a2 === null && (a2 = e2 + 1);
      var h2 = r.series, c2 = h2, d2 = h2;
      s2.chart.type === "candlestick" ? (c2 = r.seriesCandleL, d2 = r.seriesCandleH) : s2.chart.type === "boxPlot" ? (c2 = r.seriesCandleO, d2 = r.seriesCandleC) : r.isRangeData && (c2 = r.seriesRangeStart, d2 = r.seriesRangeEnd);
      for (var g2 = e2; g2 < a2; g2++) {
        r.dataPoints = Math.max(r.dataPoints, h2[g2].length), r.categoryLabels.length && (r.dataPoints = r.categoryLabels.filter(function(b2) {
          return b2 !== void 0;
        }).length), r.labels.length && s2.xaxis.type !== "datetime" && r.series.reduce(function(b2, m2) {
          return b2 + m2.length;
        }, 0) !== 0 && (r.dataPoints = Math.max(r.dataPoints, r.labels.length));
        for (var p2 = 0; p2 < r.series[g2].length; p2++) {
          var f2 = h2[g2][p2];
          f2 !== null && P2.isNumber(f2) ? (d2[g2][p2] !== void 0 && (n2 = Math.max(n2, d2[g2][p2]), t2 = Math.min(t2, d2[g2][p2])), c2[g2][p2] !== void 0 && (t2 = Math.min(t2, c2[g2][p2]), i = Math.max(i, c2[g2][p2])), this.w.config.chart.type !== "candlestick" && this.w.config.chart.type !== "boxPlot" && this.w.config.chart.type === "rangeArea" && this.w.config.chart.type === "rangeBar" || (this.w.config.chart.type !== "candlestick" && this.w.config.chart.type !== "boxPlot" || r.seriesCandleC[g2][p2] !== void 0 && (n2 = Math.max(n2, r.seriesCandleO[g2][p2]), n2 = Math.max(n2, r.seriesCandleH[g2][p2]), n2 = Math.max(n2, r.seriesCandleL[g2][p2]), n2 = Math.max(n2, r.seriesCandleC[g2][p2]), this.w.config.chart.type === "boxPlot" && (n2 = Math.max(n2, r.seriesCandleM[g2][p2]))), !s2.series[g2].type || s2.series[g2].type === "candlestick" && s2.series[g2].type === "boxPlot" && s2.series[g2].type === "rangeArea" && s2.series[g2].type === "rangeBar" || (n2 = Math.max(n2, r.series[g2][p2]), t2 = Math.min(t2, r.series[g2][p2])), i = n2), r.seriesGoals[g2] && r.seriesGoals[g2][p2] && Array.isArray(r.seriesGoals[g2][p2]) && r.seriesGoals[g2][p2].forEach(function(b2) {
            o2 !== Number.MIN_VALUE && (o2 = Math.min(o2, b2.value), t2 = o2), n2 = Math.max(n2, b2.value), i = n2;
          }), P2.isFloat(f2) && (f2 = P2.noExponents(f2), r.yValueDecimal = Math.max(r.yValueDecimal, f2.toString().split(".")[1].length)), o2 > c2[g2][p2] && c2[g2][p2] < 0 && (o2 = c2[g2][p2])) : r.hasNullValues = true;
        }
      }
      return s2.chart.type === "rangeBar" && r.seriesRangeStart.length && r.isBarHorizontal && (o2 = t2), s2.chart.type === "bar" && (o2 < 0 && n2 < 0 && (n2 = 0), o2 === Number.MIN_VALUE && (o2 = 0)), { minY: o2, maxY: n2, lowestY: t2, highestY: i };
    } }, { key: "setYRange", value: function() {
      var e2 = this.w.globals, t2 = this.w.config;
      e2.maxY = -Number.MAX_VALUE, e2.minY = Number.MIN_VALUE;
      var i = Number.MAX_VALUE;
      if (e2.isMultipleYAxis)
        for (var a2 = 0; a2 < e2.series.length; a2++) {
          var s2 = this.getMinYMaxY(a2, i, null, a2 + 1);
          e2.minYArr.push(s2.minY), e2.maxYArr.push(s2.maxY), i = s2.lowestY;
        }
      var r = this.getMinYMaxY(0, i, null, e2.series.length);
      if (e2.minY = r.minY, e2.maxY = r.maxY, i = r.lowestY, t2.chart.stacked && this._setStackedMinMax(), (t2.chart.type === "line" || t2.chart.type === "area" || t2.chart.type === "candlestick" || t2.chart.type === "boxPlot" || t2.chart.type === "rangeBar" && !e2.isBarHorizontal) && e2.minY === Number.MIN_VALUE && i !== -Number.MAX_VALUE && i !== e2.maxY) {
        var n2 = e2.maxY - i;
        (i >= 0 && i <= 10 || t2.yaxis[0].min !== void 0 || t2.yaxis[0].max !== void 0) && (n2 = 0), e2.minY = i - 5 * n2 / 100, i > 0 && e2.minY < 0 && (e2.minY = 0), e2.maxY = e2.maxY + 5 * n2 / 100;
      }
      return t2.yaxis.forEach(function(o2, h2) {
        o2.max !== void 0 && (typeof o2.max == "number" ? e2.maxYArr[h2] = o2.max : typeof o2.max == "function" && (e2.maxYArr[h2] = o2.max(e2.isMultipleYAxis ? e2.maxYArr[h2] : e2.maxY)), e2.maxY = e2.maxYArr[h2]), o2.min !== void 0 && (typeof o2.min == "number" ? e2.minYArr[h2] = o2.min : typeof o2.min == "function" && (e2.minYArr[h2] = o2.min(e2.isMultipleYAxis ? e2.minYArr[h2] === Number.MIN_VALUE ? 0 : e2.minYArr[h2] : e2.minY)), e2.minY = e2.minYArr[h2]);
      }), e2.isBarHorizontal && ["min", "max"].forEach(function(o2) {
        t2.xaxis[o2] !== void 0 && typeof t2.xaxis[o2] == "number" && (o2 === "min" ? e2.minY = t2.xaxis[o2] : e2.maxY = t2.xaxis[o2]);
      }), e2.isMultipleYAxis ? (this.scales.setMultipleYScales(), e2.minY = i, e2.yAxisScale.forEach(function(o2, h2) {
        e2.minYArr[h2] = o2.niceMin, e2.maxYArr[h2] = o2.niceMax;
      })) : (this.scales.setYScaleForIndex(0, e2.minY, e2.maxY), e2.minY = e2.yAxisScale[0].niceMin, e2.maxY = e2.yAxisScale[0].niceMax, e2.minYArr[0] = e2.yAxisScale[0].niceMin, e2.maxYArr[0] = e2.yAxisScale[0].niceMax), { minY: e2.minY, maxY: e2.maxY, minYArr: e2.minYArr, maxYArr: e2.maxYArr, yAxisScale: e2.yAxisScale };
    } }, { key: "setXRange", value: function() {
      var e2 = this.w.globals, t2 = this.w.config, i = t2.xaxis.type === "numeric" || t2.xaxis.type === "datetime" || t2.xaxis.type === "category" && !e2.noLabelsProvided || e2.noLabelsProvided || e2.isXNumeric;
      if (e2.isXNumeric && function() {
        for (var n2 = 0; n2 < e2.series.length; n2++)
          if (e2.labels[n2])
            for (var o2 = 0; o2 < e2.labels[n2].length; o2++)
              e2.labels[n2][o2] !== null && P2.isNumber(e2.labels[n2][o2]) && (e2.maxX = Math.max(e2.maxX, e2.labels[n2][o2]), e2.initialMaxX = Math.max(e2.maxX, e2.labels[n2][o2]), e2.minX = Math.min(e2.minX, e2.labels[n2][o2]), e2.initialMinX = Math.min(e2.minX, e2.labels[n2][o2]));
      }(), e2.noLabelsProvided && t2.xaxis.categories.length === 0 && (e2.maxX = e2.labels[e2.labels.length - 1], e2.initialMaxX = e2.labels[e2.labels.length - 1], e2.minX = 1, e2.initialMinX = 1), e2.isXNumeric || e2.noLabelsProvided || e2.dataFormatXNumeric) {
        var a2;
        if (t2.xaxis.tickAmount === void 0 ? (a2 = Math.round(e2.svgWidth / 150), t2.xaxis.type === "numeric" && e2.dataPoints < 30 && (a2 = e2.dataPoints - 1), a2 > e2.dataPoints && e2.dataPoints !== 0 && (a2 = e2.dataPoints - 1)) : t2.xaxis.tickAmount === "dataPoints" ? (e2.series.length > 1 && (a2 = e2.series[e2.maxValsInArrayIndex].length - 1), e2.isXNumeric && (a2 = e2.maxX - e2.minX - 1)) : a2 = t2.xaxis.tickAmount, e2.xTickAmount = a2, t2.xaxis.max !== void 0 && typeof t2.xaxis.max == "number" && (e2.maxX = t2.xaxis.max), t2.xaxis.min !== void 0 && typeof t2.xaxis.min == "number" && (e2.minX = t2.xaxis.min), t2.xaxis.range !== void 0 && (e2.minX = e2.maxX - t2.xaxis.range), e2.minX !== Number.MAX_VALUE && e2.maxX !== -Number.MAX_VALUE)
          if (t2.xaxis.convertedCatToNumeric && !e2.dataFormatXNumeric) {
            for (var s2 = [], r = e2.minX - 1; r < e2.maxX; r++)
              s2.push(r + 1);
            e2.xAxisScale = { result: s2, niceMin: s2[0], niceMax: s2[s2.length - 1] };
          } else
            e2.xAxisScale = this.scales.setXScale(e2.minX, e2.maxX);
        else
          e2.xAxisScale = this.scales.linearScale(0, a2, a2, 0, t2.xaxis.stepSize), e2.noLabelsProvided && e2.labels.length > 0 && (e2.xAxisScale = this.scales.linearScale(1, e2.labels.length, a2 - 1, 0, t2.xaxis.stepSize), e2.seriesX = e2.labels.slice());
        i && (e2.labels = e2.xAxisScale.result.slice());
      }
      return e2.isBarHorizontal && e2.labels.length && (e2.xTickAmount = e2.labels.length), this._handleSingleDataPoint(), this._getMinXDiff(), { minX: e2.minX, maxX: e2.maxX };
    } }, { key: "setZRange", value: function() {
      var e2 = this.w.globals;
      if (e2.isDataXYZ) {
        for (var t2 = 0; t2 < e2.series.length; t2++)
          if (e2.seriesZ[t2] !== void 0)
            for (var i = 0; i < e2.seriesZ[t2].length; i++)
              e2.seriesZ[t2][i] !== null && P2.isNumber(e2.seriesZ[t2][i]) && (e2.maxZ = Math.max(e2.maxZ, e2.seriesZ[t2][i]), e2.minZ = Math.min(e2.minZ, e2.seriesZ[t2][i]));
      }
    } }, { key: "_handleSingleDataPoint", value: function() {
      var e2 = this.w.globals, t2 = this.w.config;
      if (e2.minX === e2.maxX) {
        var i = new B3(this.ctx);
        if (t2.xaxis.type === "datetime") {
          var a2 = i.getDate(e2.minX);
          t2.xaxis.labels.datetimeUTC ? a2.setUTCDate(a2.getUTCDate() - 2) : a2.setDate(a2.getDate() - 2), e2.minX = new Date(a2).getTime();
          var s2 = i.getDate(e2.maxX);
          t2.xaxis.labels.datetimeUTC ? s2.setUTCDate(s2.getUTCDate() + 2) : s2.setDate(s2.getDate() + 2), e2.maxX = new Date(s2).getTime();
        } else
          (t2.xaxis.type === "numeric" || t2.xaxis.type === "category" && !e2.noLabelsProvided) && (e2.minX = e2.minX - 2, e2.initialMinX = e2.minX, e2.maxX = e2.maxX + 2, e2.initialMaxX = e2.maxX);
      }
    } }, { key: "_getMinXDiff", value: function() {
      var e2 = this.w.globals;
      e2.isXNumeric && e2.seriesX.forEach(function(t2, i) {
        t2.length === 1 && t2.push(e2.seriesX[e2.maxValsInArrayIndex][e2.seriesX[e2.maxValsInArrayIndex].length - 1]);
        var a2 = t2.slice();
        a2.sort(function(s2, r) {
          return s2 - r;
        }), a2.forEach(function(s2, r) {
          if (r > 0) {
            var n2 = s2 - a2[r - 1];
            n2 > 0 && (e2.minXDiff = Math.min(n2, e2.minXDiff));
          }
        }), e2.dataPoints !== 1 && e2.minXDiff !== Number.MAX_VALUE || (e2.minXDiff = 0.5);
      });
    } }, { key: "_setStackedMinMax", value: function() {
      var e2 = this, t2 = this.w.globals;
      if (t2.series.length) {
        var i = t2.seriesGroups;
        i.length || (i = [this.w.config.series.map(function(r) {
          return r.name;
        })]);
        var a2 = {}, s2 = {};
        i.forEach(function(r) {
          a2[r] = [], s2[r] = [], e2.w.config.series.map(function(n2, o2) {
            return r.indexOf(n2.name) > -1 ? o2 : null;
          }).filter(function(n2) {
            return n2 !== null;
          }).forEach(function(n2) {
            for (var o2 = 0; o2 < t2.series[t2.maxValsInArrayIndex].length; o2++) {
              var h2, c2;
              a2[r][o2] === void 0 && (a2[r][o2] = 0, s2[r][o2] = 0), (e2.w.config.chart.stacked && !t2.comboCharts || e2.w.config.chart.stacked && t2.comboCharts && (!e2.w.config.chart.stackOnlyBar || ((h2 = e2.w.config.series) === null || h2 === void 0 || (c2 = h2[n2]) === null || c2 === void 0 ? void 0 : c2.type) === "bar")) && t2.series[n2][o2] !== null && P2.isNumber(t2.series[n2][o2]) && (t2.series[n2][o2] > 0 ? a2[r][o2] += parseFloat(t2.series[n2][o2]) + 1e-4 : s2[r][o2] += parseFloat(t2.series[n2][o2]));
            }
          });
        }), Object.entries(a2).forEach(function(r) {
          var n2 = Me(r, 1)[0];
          a2[n2].forEach(function(o2, h2) {
            t2.maxY = Math.max(t2.maxY, a2[n2][h2]), t2.minY = Math.min(t2.minY, s2[n2][h2]);
          });
        });
      }
    } }]), y2;
  }(), Ne2 = function() {
    function y2(e2, t2) {
      F2(this, y2), this.ctx = e2, this.elgrid = t2, this.w = e2.w;
      var i = this.w;
      this.xaxisFontSize = i.config.xaxis.labels.style.fontSize, this.axisFontFamily = i.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = i.config.xaxis.labels.style.colors, this.isCategoryBarHorizontal = i.config.chart.type === "bar" && i.config.plotOptions.bar.horizontal, this.xAxisoffX = 0, i.config.xaxis.position === "bottom" && (this.xAxisoffX = i.globals.gridHeight), this.drawnLabels = [], this.axesUtils = new xe(e2);
    }
    return Y2(y2, [{ key: "drawYaxis", value: function(e2) {
      var t2 = this, i = this.w, a2 = new M2(this.ctx), s2 = i.config.yaxis[e2].labels.style, r = s2.fontSize, n2 = s2.fontFamily, o2 = s2.fontWeight, h2 = a2.group({ class: "apexcharts-yaxis", rel: e2, transform: "translate(" + i.globals.translateYAxisX[e2] + ", 0)" });
      if (this.axesUtils.isYAxisHidden(e2))
        return h2;
      var c2 = a2.group({ class: "apexcharts-yaxis-texts-g" });
      h2.add(c2);
      var d2 = i.globals.yAxisScale[e2].result.length - 1, g2 = i.globals.gridHeight / d2, p2 = i.globals.translateY, f2 = i.globals.yLabelFormatters[e2], b2 = i.globals.yAxisScale[e2].result.slice();
      b2 = this.axesUtils.checkForReversedLabels(e2, b2);
      var m2 = "";
      if (i.config.yaxis[e2].labels.show)
        for (var w2 = function(C2) {
          var L2 = b2[C2];
          L2 = f2(L2, C2, i);
          var I2 = i.config.yaxis[e2].labels.padding;
          i.config.yaxis[e2].opposite && i.config.yaxis.length !== 0 && (I2 *= -1);
          var z2 = "end";
          i.config.yaxis[e2].opposite && (z2 = "start"), i.config.yaxis[e2].labels.align === "left" ? z2 = "start" : i.config.yaxis[e2].labels.align === "center" ? z2 = "middle" : i.config.yaxis[e2].labels.align === "right" && (z2 = "end");
          var T2 = t2.axesUtils.getYAxisForeColor(s2.colors, e2), E2 = i.config.yaxis[e2].labels.offsetY;
          i.config.chart.type === "heatmap" && (E2 -= (i.globals.gridHeight / i.globals.series.length - 1) / 2);
          var R2 = a2.drawText({ x: I2, y: p2 + d2 / 10 + E2 + 1, text: L2, textAnchor: z2, fontSize: r, fontFamily: n2, fontWeight: o2, maxWidth: i.config.yaxis[e2].labels.maxWidth, foreColor: Array.isArray(T2) ? T2[C2] : T2, isPlainText: false, cssClass: "apexcharts-yaxis-label " + s2.cssClass });
          C2 === d2 && (m2 = R2), c2.add(R2);
          var O2 = document.createElementNS(i.globals.SVGNS, "title");
          if (O2.textContent = Array.isArray(L2) ? L2.join(" ") : L2, R2.node.appendChild(O2), i.config.yaxis[e2].labels.rotate !== 0) {
            var D2 = a2.rotateAroundCenter(m2.node), W2 = a2.rotateAroundCenter(R2.node);
            R2.node.setAttribute("transform", "rotate(".concat(i.config.yaxis[e2].labels.rotate, " ").concat(D2.x, " ").concat(W2.y, ")"));
          }
          p2 += g2;
        }, A2 = d2; A2 >= 0; A2--)
          w2(A2);
      if (i.config.yaxis[e2].title.text !== void 0) {
        var l2 = a2.group({ class: "apexcharts-yaxis-title" }), u2 = 0;
        i.config.yaxis[e2].opposite && (u2 = i.globals.translateYAxisX[e2]);
        var x2 = a2.drawText({ x: u2, y: i.globals.gridHeight / 2 + i.globals.translateY + i.config.yaxis[e2].title.offsetY, text: i.config.yaxis[e2].title.text, textAnchor: "end", foreColor: i.config.yaxis[e2].title.style.color, fontSize: i.config.yaxis[e2].title.style.fontSize, fontWeight: i.config.yaxis[e2].title.style.fontWeight, fontFamily: i.config.yaxis[e2].title.style.fontFamily, cssClass: "apexcharts-yaxis-title-text " + i.config.yaxis[e2].title.style.cssClass });
        l2.add(x2), h2.add(l2);
      }
      var v2 = i.config.yaxis[e2].axisBorder, k2 = 31 + v2.offsetX;
      if (i.config.yaxis[e2].opposite && (k2 = -31 - v2.offsetX), v2.show) {
        var S2 = a2.drawLine(k2, i.globals.translateY + v2.offsetY - 2, k2, i.globals.gridHeight + i.globals.translateY + v2.offsetY + 2, v2.color, 0, v2.width);
        h2.add(S2);
      }
      return i.config.yaxis[e2].axisTicks.show && this.axesUtils.drawYAxisTicks(k2, d2, v2, i.config.yaxis[e2].axisTicks, e2, g2, h2), h2;
    } }, { key: "drawYaxisInversed", value: function(e2) {
      var t2 = this.w, i = new M2(this.ctx), a2 = i.group({ class: "apexcharts-xaxis apexcharts-yaxis-inversed" }), s2 = i.group({ class: "apexcharts-xaxis-texts-g", transform: "translate(".concat(t2.globals.translateXAxisX, ", ").concat(t2.globals.translateXAxisY, ")") });
      a2.add(s2);
      var r = t2.globals.yAxisScale[e2].result.length - 1, n2 = t2.globals.gridWidth / r + 0.1, o2 = n2 + t2.config.xaxis.labels.offsetX, h2 = t2.globals.xLabelFormatter, c2 = t2.globals.yAxisScale[e2].result.slice(), d2 = t2.globals.timescaleLabels;
      d2.length > 0 && (this.xaxisLabels = d2.slice(), r = (c2 = d2.slice()).length), c2 = this.axesUtils.checkForReversedLabels(e2, c2);
      var g2 = d2.length;
      if (t2.config.xaxis.labels.show)
        for (var p2 = g2 ? 0 : r; g2 ? p2 < g2 : p2 >= 0; g2 ? p2++ : p2--) {
          var f2 = c2[p2];
          f2 = h2(f2, p2, t2);
          var b2 = t2.globals.gridWidth + t2.globals.padHorizontal - (o2 - n2 + t2.config.xaxis.labels.offsetX);
          if (d2.length) {
            var m2 = this.axesUtils.getLabel(c2, d2, b2, p2, this.drawnLabels, this.xaxisFontSize);
            b2 = m2.x, f2 = m2.text, this.drawnLabels.push(m2.text), p2 === 0 && t2.globals.skipFirstTimelinelabel && (f2 = ""), p2 === c2.length - 1 && t2.globals.skipLastTimelinelabel && (f2 = "");
          }
          var w2 = i.drawText({ x: b2, y: this.xAxisoffX + t2.config.xaxis.labels.offsetY + 30 - (t2.config.xaxis.position === "top" ? t2.globals.xAxisHeight + t2.config.xaxis.axisTicks.height - 2 : 0), text: f2, textAnchor: "middle", foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[e2] : this.xaxisForeColors, fontSize: this.xaxisFontSize, fontFamily: this.xaxisFontFamily, fontWeight: t2.config.xaxis.labels.style.fontWeight, isPlainText: false, cssClass: "apexcharts-xaxis-label " + t2.config.xaxis.labels.style.cssClass });
          s2.add(w2), w2.tspan(f2);
          var A2 = document.createElementNS(t2.globals.SVGNS, "title");
          A2.textContent = f2, w2.node.appendChild(A2), o2 += n2;
        }
      return this.inversedYAxisTitleText(a2), this.inversedYAxisBorder(a2), a2;
    } }, { key: "inversedYAxisBorder", value: function(e2) {
      var t2 = this.w, i = new M2(this.ctx), a2 = t2.config.xaxis.axisBorder;
      if (a2.show) {
        var s2 = 0;
        t2.config.chart.type === "bar" && t2.globals.isXNumeric && (s2 -= 15);
        var r = i.drawLine(t2.globals.padHorizontal + s2 + a2.offsetX, this.xAxisoffX, t2.globals.gridWidth, this.xAxisoffX, a2.color, 0, a2.height);
        this.elgrid && this.elgrid.elGridBorders && t2.config.grid.show ? this.elgrid.elGridBorders.add(r) : e2.add(r);
      }
    } }, { key: "inversedYAxisTitleText", value: function(e2) {
      var t2 = this.w, i = new M2(this.ctx);
      if (t2.config.xaxis.title.text !== void 0) {
        var a2 = i.group({ class: "apexcharts-xaxis-title apexcharts-yaxis-title-inversed" }), s2 = i.drawText({ x: t2.globals.gridWidth / 2 + t2.config.xaxis.title.offsetX, y: this.xAxisoffX + parseFloat(this.xaxisFontSize) + parseFloat(t2.config.xaxis.title.style.fontSize) + t2.config.xaxis.title.offsetY + 20, text: t2.config.xaxis.title.text, textAnchor: "middle", fontSize: t2.config.xaxis.title.style.fontSize, fontFamily: t2.config.xaxis.title.style.fontFamily, fontWeight: t2.config.xaxis.title.style.fontWeight, foreColor: t2.config.xaxis.title.style.color, cssClass: "apexcharts-xaxis-title-text " + t2.config.xaxis.title.style.cssClass });
        a2.add(s2), e2.add(a2);
      }
    } }, { key: "yAxisTitleRotate", value: function(e2, t2) {
      var i = this.w, a2 = new M2(this.ctx), s2 = { width: 0, height: 0 }, r = { width: 0, height: 0 }, n2 = i.globals.dom.baseEl.querySelector(" .apexcharts-yaxis[rel='".concat(e2, "'] .apexcharts-yaxis-texts-g"));
      n2 !== null && (s2 = n2.getBoundingClientRect());
      var o2 = i.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(e2, "'] .apexcharts-yaxis-title text"));
      if (o2 !== null && (r = o2.getBoundingClientRect()), o2 !== null) {
        var h2 = this.xPaddingForYAxisTitle(e2, s2, r, t2);
        o2.setAttribute("x", h2.xPos - (t2 ? 10 : 0));
      }
      if (o2 !== null) {
        var c2 = a2.rotateAroundCenter(o2);
        o2.setAttribute("transform", "rotate(".concat(t2 ? -1 * i.config.yaxis[e2].title.rotate : i.config.yaxis[e2].title.rotate, " ").concat(c2.x, " ").concat(c2.y, ")"));
      }
    } }, { key: "xPaddingForYAxisTitle", value: function(e2, t2, i, a2) {
      var s2 = this.w, r = 0, n2 = 0, o2 = 10;
      return s2.config.yaxis[e2].title.text === void 0 || e2 < 0 ? { xPos: n2, padd: 0 } : (a2 ? (n2 = t2.width + s2.config.yaxis[e2].title.offsetX + i.width / 2 + o2 / 2, (r += 1) === 0 && (n2 -= o2 / 2)) : (n2 = -1 * t2.width + s2.config.yaxis[e2].title.offsetX + o2 / 2 + i.width / 2, s2.globals.isBarHorizontal && (o2 = 25, n2 = -1 * t2.width - s2.config.yaxis[e2].title.offsetX - o2)), { xPos: n2, padd: o2 });
    } }, { key: "setYAxisXPosition", value: function(e2, t2) {
      var i = this.w, a2 = 0, s2 = 0, r = 18, n2 = 1;
      i.config.yaxis.length > 1 && (this.multipleYs = true), i.config.yaxis.map(function(o2, h2) {
        var c2 = i.globals.ignoreYAxisIndexes.indexOf(h2) > -1 || !o2.show || o2.floating || e2[h2].width === 0, d2 = e2[h2].width + t2[h2].width;
        o2.opposite ? i.globals.isBarHorizontal ? (s2 = i.globals.gridWidth + i.globals.translateX - 1, i.globals.translateYAxisX[h2] = s2 - o2.labels.offsetX) : (s2 = i.globals.gridWidth + i.globals.translateX + n2, c2 || (n2 = n2 + d2 + 20), i.globals.translateYAxisX[h2] = s2 - o2.labels.offsetX + 20) : (a2 = i.globals.translateX - r, c2 || (r = r + d2 + 20), i.globals.translateYAxisX[h2] = a2 + o2.labels.offsetX);
      });
    } }, { key: "setYAxisTextAlignments", value: function() {
      var e2 = this.w, t2 = e2.globals.dom.baseEl.getElementsByClassName("apexcharts-yaxis");
      (t2 = P2.listToArray(t2)).forEach(function(i, a2) {
        var s2 = e2.config.yaxis[a2];
        if (s2 && !s2.floating && s2.labels.align !== void 0) {
          var r = e2.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(a2, "'] .apexcharts-yaxis-texts-g")), n2 = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(a2, "'] .apexcharts-yaxis-label"));
          n2 = P2.listToArray(n2);
          var o2 = r.getBoundingClientRect();
          s2.labels.align === "left" ? (n2.forEach(function(h2, c2) {
            h2.setAttribute("text-anchor", "start");
          }), s2.opposite || r.setAttribute("transform", "translate(-".concat(o2.width, ", 0)"))) : s2.labels.align === "center" ? (n2.forEach(function(h2, c2) {
            h2.setAttribute("text-anchor", "middle");
          }), r.setAttribute("transform", "translate(".concat(o2.width / 2 * (s2.opposite ? 1 : -1), ", 0)"))) : s2.labels.align === "right" && (n2.forEach(function(h2, c2) {
            h2.setAttribute("text-anchor", "end");
          }), s2.opposite && r.setAttribute("transform", "translate(".concat(o2.width, ", 0)")));
        }
      });
    } }]), y2;
  }(), xt2 = function() {
    function y2(e2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w, this.documentEvent = P2.bind(this.documentEvent, this);
    }
    return Y2(y2, [{ key: "addEventListener", value: function(e2, t2) {
      var i = this.w;
      i.globals.events.hasOwnProperty(e2) ? i.globals.events[e2].push(t2) : i.globals.events[e2] = [t2];
    } }, { key: "removeEventListener", value: function(e2, t2) {
      var i = this.w;
      if (i.globals.events.hasOwnProperty(e2)) {
        var a2 = i.globals.events[e2].indexOf(t2);
        a2 !== -1 && i.globals.events[e2].splice(a2, 1);
      }
    } }, { key: "fireEvent", value: function(e2, t2) {
      var i = this.w;
      if (i.globals.events.hasOwnProperty(e2)) {
        t2 && t2.length || (t2 = []);
        for (var a2 = i.globals.events[e2], s2 = a2.length, r = 0; r < s2; r++)
          a2[r].apply(null, t2);
      }
    } }, { key: "setupEventHandlers", value: function() {
      var e2 = this, t2 = this.w, i = this.ctx, a2 = t2.globals.dom.baseEl.querySelector(t2.globals.chartClass);
      this.ctx.eventList.forEach(function(s2) {
        a2.addEventListener(s2, function(r) {
          var n2 = Object.assign({}, t2, { seriesIndex: t2.globals.capturedSeriesIndex, dataPointIndex: t2.globals.capturedDataPointIndex });
          r.type === "mousemove" || r.type === "touchmove" ? typeof t2.config.chart.events.mouseMove == "function" && t2.config.chart.events.mouseMove(r, i, n2) : r.type === "mouseleave" || r.type === "touchleave" ? typeof t2.config.chart.events.mouseLeave == "function" && t2.config.chart.events.mouseLeave(r, i, n2) : (r.type === "mouseup" && r.which === 1 || r.type === "touchend") && (typeof t2.config.chart.events.click == "function" && t2.config.chart.events.click(r, i, n2), i.ctx.events.fireEvent("click", [r, i, n2]));
        }, { capture: false, passive: true });
      }), this.ctx.eventList.forEach(function(s2) {
        t2.globals.dom.baseEl.addEventListener(s2, e2.documentEvent, { passive: true });
      }), this.ctx.core.setupBrushHandler();
    } }, { key: "documentEvent", value: function(e2) {
      var t2 = this.w, i = e2.target.className;
      if (e2.type === "click") {
        var a2 = t2.globals.dom.baseEl.querySelector(".apexcharts-menu");
        a2 && a2.classList.contains("apexcharts-menu-open") && i !== "apexcharts-menu-icon" && a2.classList.remove("apexcharts-menu-open");
      }
      t2.globals.clientX = e2.type === "touchmove" ? e2.touches[0].clientX : e2.clientX, t2.globals.clientY = e2.type === "touchmove" ? e2.touches[0].clientY : e2.clientY;
    } }]), y2;
  }(), bt2 = function() {
    function y2(e2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w;
    }
    return Y2(y2, [{ key: "setCurrentLocaleValues", value: function(e2) {
      var t2 = this.w.config.chart.locales;
      window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0 && (t2 = this.w.config.chart.locales.concat(window.Apex.chart.locales));
      var i = t2.filter(function(s2) {
        return s2.name === e2;
      })[0];
      if (!i)
        throw new Error("Wrong locale name provided. Please make sure you set the correct locale name in options");
      var a2 = P2.extend(H4, i);
      this.w.globals.locale = a2.options;
    } }]), y2;
  }(), mt2 = function() {
    function y2(e2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w;
    }
    return Y2(y2, [{ key: "drawAxis", value: function(e2, t2) {
      var i, a2, s2 = this, r = this.w.globals, n2 = this.w.config, o2 = new Ie(this.ctx, t2), h2 = new Ne2(this.ctx, t2);
      r.axisCharts && e2 !== "radar" && (r.isBarHorizontal ? (a2 = h2.drawYaxisInversed(0), i = o2.drawXaxisInversed(0), r.dom.elGraphical.add(i), r.dom.elGraphical.add(a2)) : (i = o2.drawXaxis(), r.dom.elGraphical.add(i), n2.yaxis.map(function(c2, d2) {
        if (r.ignoreYAxisIndexes.indexOf(d2) === -1 && (a2 = h2.drawYaxis(d2), r.dom.Paper.add(a2), s2.w.config.grid.position === "back")) {
          var g2 = r.dom.Paper.children()[1];
          g2.remove(), r.dom.Paper.add(g2);
        }
      })));
    } }]), y2;
  }(), We = function() {
    function y2(e2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w;
    }
    return Y2(y2, [{ key: "drawXCrosshairs", value: function() {
      var e2 = this.w, t2 = new M2(this.ctx), i = new Z2(this.ctx), a2 = e2.config.xaxis.crosshairs.fill.gradient, s2 = e2.config.xaxis.crosshairs.dropShadow, r = e2.config.xaxis.crosshairs.fill.type, n2 = a2.colorFrom, o2 = a2.colorTo, h2 = a2.opacityFrom, c2 = a2.opacityTo, d2 = a2.stops, g2 = s2.enabled, p2 = s2.left, f2 = s2.top, b2 = s2.blur, m2 = s2.color, w2 = s2.opacity, A2 = e2.config.xaxis.crosshairs.fill.color;
      if (e2.config.xaxis.crosshairs.show) {
        r === "gradient" && (A2 = t2.drawGradient("vertical", n2, o2, h2, c2, null, d2, null));
        var l2 = t2.drawRect();
        e2.config.xaxis.crosshairs.width === 1 && (l2 = t2.drawLine());
        var u2 = e2.globals.gridHeight;
        (!P2.isNumber(u2) || u2 < 0) && (u2 = 0);
        var x2 = e2.config.xaxis.crosshairs.width;
        (!P2.isNumber(x2) || x2 < 0) && (x2 = 0), l2.attr({ class: "apexcharts-xcrosshairs", x: 0, y: 0, y2: u2, width: x2, height: u2, fill: A2, filter: "none", "fill-opacity": e2.config.xaxis.crosshairs.opacity, stroke: e2.config.xaxis.crosshairs.stroke.color, "stroke-width": e2.config.xaxis.crosshairs.stroke.width, "stroke-dasharray": e2.config.xaxis.crosshairs.stroke.dashArray }), g2 && (l2 = i.dropShadow(l2, { left: p2, top: f2, blur: b2, color: m2, opacity: w2 })), e2.globals.dom.elGraphical.add(l2);
      }
    } }, { key: "drawYCrosshairs", value: function() {
      var e2 = this.w, t2 = new M2(this.ctx), i = e2.config.yaxis[0].crosshairs, a2 = e2.globals.barPadForNumericAxis;
      if (e2.config.yaxis[0].crosshairs.show) {
        var s2 = t2.drawLine(-a2, 0, e2.globals.gridWidth + a2, 0, i.stroke.color, i.stroke.dashArray, i.stroke.width);
        s2.attr({ class: "apexcharts-ycrosshairs" }), e2.globals.dom.elGraphical.add(s2);
      }
      var r = t2.drawLine(-a2, 0, e2.globals.gridWidth + a2, 0, i.stroke.color, 0, 0);
      r.attr({ class: "apexcharts-ycrosshairs-hidden" }), e2.globals.dom.elGraphical.add(r);
    } }]), y2;
  }(), vt2 = function() {
    function y2(e2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w;
    }
    return Y2(y2, [{ key: "checkResponsiveConfig", value: function(e2) {
      var t2 = this, i = this.w, a2 = i.config;
      if (a2.responsive.length !== 0) {
        var s2 = a2.responsive.slice();
        s2.sort(function(h2, c2) {
          return h2.breakpoint > c2.breakpoint ? 1 : c2.breakpoint > h2.breakpoint ? -1 : 0;
        }).reverse();
        var r = new Le2({}), n2 = function() {
          var h2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, c2 = s2[0].breakpoint, d2 = window.innerWidth > 0 ? window.innerWidth : screen.width;
          if (d2 > c2) {
            var g2 = q2.extendArrayProps(r, i.globals.initialConfig, i);
            h2 = P2.extend(g2, h2), h2 = P2.extend(i.config, h2), t2.overrideResponsiveOptions(h2);
          } else
            for (var p2 = 0; p2 < s2.length; p2++)
              d2 < s2[p2].breakpoint && (h2 = q2.extendArrayProps(r, s2[p2].options, i), h2 = P2.extend(i.config, h2), t2.overrideResponsiveOptions(h2));
        };
        if (e2) {
          var o2 = q2.extendArrayProps(r, e2, i);
          o2 = P2.extend(i.config, o2), n2(o2 = P2.extend(o2, e2));
        } else
          n2({});
      }
    } }, { key: "overrideResponsiveOptions", value: function(e2) {
      var t2 = new Le2(e2).init({ responsiveOverride: true });
      this.w.config = t2;
    } }]), y2;
  }(), yt2 = function() {
    function y2(e2) {
      F2(this, y2), this.ctx = e2, this.colors = [], this.w = e2.w;
      var t2 = this.w;
      this.isColorFn = false, this.isHeatmapDistributed = t2.config.chart.type === "treemap" && t2.config.plotOptions.treemap.distributed || t2.config.chart.type === "heatmap" && t2.config.plotOptions.heatmap.distributed, this.isBarDistributed = t2.config.plotOptions.bar.distributed && (t2.config.chart.type === "bar" || t2.config.chart.type === "rangeBar");
    }
    return Y2(y2, [{ key: "init", value: function() {
      this.setDefaultColors();
    } }, { key: "setDefaultColors", value: function() {
      var e2, t2 = this, i = this.w, a2 = new P2();
      if (i.globals.dom.elWrap.classList.add("apexcharts-theme-".concat(i.config.theme.mode)), i.config.colors === void 0 || ((e2 = i.config.colors) === null || e2 === void 0 ? void 0 : e2.length) === 0 ? i.globals.colors = this.predefined() : (i.globals.colors = i.config.colors, Array.isArray(i.config.colors) && i.config.colors.length > 0 && typeof i.config.colors[0] == "function" && (i.globals.colors = i.config.series.map(function(f2, b2) {
        var m2 = i.config.colors[b2];
        return m2 || (m2 = i.config.colors[0]), typeof m2 == "function" ? (t2.isColorFn = true, m2({ value: i.globals.axisCharts ? i.globals.series[b2][0] ? i.globals.series[b2][0] : 0 : i.globals.series[b2], seriesIndex: b2, dataPointIndex: b2, w: i })) : m2;
      }))), i.globals.seriesColors.map(function(f2, b2) {
        f2 && (i.globals.colors[b2] = f2);
      }), i.config.theme.monochrome.enabled) {
        var s2 = [], r = i.globals.series.length;
        (this.isBarDistributed || this.isHeatmapDistributed) && (r = i.globals.series[0].length * i.globals.series.length);
        for (var n2 = i.config.theme.monochrome.color, o2 = 1 / (r / i.config.theme.monochrome.shadeIntensity), h2 = i.config.theme.monochrome.shadeTo, c2 = 0, d2 = 0; d2 < r; d2++) {
          var g2 = void 0;
          h2 === "dark" ? (g2 = a2.shadeColor(-1 * c2, n2), c2 += o2) : (g2 = a2.shadeColor(c2, n2), c2 += o2), s2.push(g2);
        }
        i.globals.colors = s2.slice();
      }
      var p2 = i.globals.colors.slice();
      this.pushExtraColors(i.globals.colors), ["fill", "stroke"].forEach(function(f2) {
        i.config[f2].colors === void 0 ? i.globals[f2].colors = t2.isColorFn ? i.config.colors : p2 : i.globals[f2].colors = i.config[f2].colors.slice(), t2.pushExtraColors(i.globals[f2].colors);
      }), i.config.dataLabels.style.colors === void 0 ? i.globals.dataLabels.style.colors = p2 : i.globals.dataLabels.style.colors = i.config.dataLabels.style.colors.slice(), this.pushExtraColors(i.globals.dataLabels.style.colors, 50), i.config.plotOptions.radar.polygons.fill.colors === void 0 ? i.globals.radarPolygons.fill.colors = [i.config.theme.mode === "dark" ? "#424242" : "none"] : i.globals.radarPolygons.fill.colors = i.config.plotOptions.radar.polygons.fill.colors.slice(), this.pushExtraColors(i.globals.radarPolygons.fill.colors, 20), i.config.markers.colors === void 0 ? i.globals.markers.colors = p2 : i.globals.markers.colors = i.config.markers.colors.slice(), this.pushExtraColors(i.globals.markers.colors);
    } }, { key: "pushExtraColors", value: function(e2, t2) {
      var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, a2 = this.w, s2 = t2 || a2.globals.series.length;
      if (i === null && (i = this.isBarDistributed || this.isHeatmapDistributed || a2.config.chart.type === "heatmap" && a2.config.plotOptions.heatmap.colorScale.inverse), i && a2.globals.series.length && (s2 = a2.globals.series[a2.globals.maxValsInArrayIndex].length * a2.globals.series.length), e2.length < s2)
        for (var r = s2 - e2.length, n2 = 0; n2 < r; n2++)
          e2.push(e2[n2]);
    } }, { key: "updateThemeOptions", value: function(e2) {
      e2.chart = e2.chart || {}, e2.tooltip = e2.tooltip || {};
      var t2 = e2.theme.mode || "light", i = e2.theme.palette ? e2.theme.palette : t2 === "dark" ? "palette4" : "palette1", a2 = e2.chart.foreColor ? e2.chart.foreColor : t2 === "dark" ? "#f6f7f8" : "#373d3f";
      return e2.tooltip.theme = t2, e2.chart.foreColor = a2, e2.theme.palette = i, e2;
    } }, { key: "predefined", value: function() {
      switch (this.w.config.theme.palette) {
        case "palette1":
        default:
          this.colors = ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"];
          break;
        case "palette2":
          this.colors = ["#3f51b5", "#03a9f4", "#4caf50", "#f9ce1d", "#FF9800"];
          break;
        case "palette3":
          this.colors = ["#33b2df", "#546E7A", "#d4526e", "#13d8aa", "#A5978B"];
          break;
        case "palette4":
          this.colors = ["#4ecdc4", "#c7f464", "#81D4FA", "#fd6a6a", "#546E7A"];
          break;
        case "palette5":
          this.colors = ["#2b908f", "#f9a3a4", "#90ee7e", "#fa4443", "#69d2e7"];
          break;
        case "palette6":
          this.colors = ["#449DD1", "#F86624", "#EA3546", "#662E9B", "#C5D86D"];
          break;
        case "palette7":
          this.colors = ["#D7263D", "#1B998B", "#2E294E", "#F46036", "#E2C044"];
          break;
        case "palette8":
          this.colors = ["#662E9B", "#F86624", "#F9C80E", "#EA3546", "#43BCCD"];
          break;
        case "palette9":
          this.colors = ["#5C4742", "#A5978B", "#8D5B4C", "#5A2A27", "#C4BBAF"];
          break;
        case "palette10":
          this.colors = ["#A300D6", "#7D02EB", "#5653FE", "#2983FF", "#00B1F2"];
      }
      return this.colors;
    } }]), y2;
  }(), wt2 = function() {
    function y2(e2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w;
    }
    return Y2(y2, [{ key: "draw", value: function() {
      this.drawTitleSubtitle("title"), this.drawTitleSubtitle("subtitle");
    } }, { key: "drawTitleSubtitle", value: function(e2) {
      var t2 = this.w, i = e2 === "title" ? t2.config.title : t2.config.subtitle, a2 = t2.globals.svgWidth / 2, s2 = i.offsetY, r = "middle";
      if (i.align === "left" ? (a2 = 10, r = "start") : i.align === "right" && (a2 = t2.globals.svgWidth - 10, r = "end"), a2 += i.offsetX, s2 = s2 + parseInt(i.style.fontSize, 10) + i.margin / 2, i.text !== void 0) {
        var n2 = new M2(this.ctx).drawText({ x: a2, y: s2, text: i.text, textAnchor: r, fontSize: i.style.fontSize, fontFamily: i.style.fontFamily, fontWeight: i.style.fontWeight, foreColor: i.style.color, opacity: 1 });
        n2.node.setAttribute("class", "apexcharts-".concat(e2, "-text")), t2.globals.dom.Paper.add(n2);
      }
    } }]), y2;
  }(), kt2 = function() {
    function y2(e2) {
      F2(this, y2), this.w = e2.w, this.dCtx = e2;
    }
    return Y2(y2, [{ key: "getTitleSubtitleCoords", value: function(e2) {
      var t2 = this.w, i = 0, a2 = 0, s2 = e2 === "title" ? t2.config.title.floating : t2.config.subtitle.floating, r = t2.globals.dom.baseEl.querySelector(".apexcharts-".concat(e2, "-text"));
      if (r !== null && !s2) {
        var n2 = r.getBoundingClientRect();
        i = n2.width, a2 = t2.globals.axisCharts ? n2.height + 5 : n2.height;
      }
      return { width: i, height: a2 };
    } }, { key: "getLegendsRect", value: function() {
      var e2 = this.w, t2 = e2.globals.dom.elLegendWrap;
      e2.config.legend.height || e2.config.legend.position !== "top" && e2.config.legend.position !== "bottom" || (t2.style.maxHeight = e2.globals.svgHeight / 2 + "px");
      var i = Object.assign({}, P2.getBoundingClientRect(t2));
      return t2 !== null && !e2.config.legend.floating && e2.config.legend.show ? this.dCtx.lgRect = { x: i.x, y: i.y, height: i.height, width: i.height === 0 ? 0 : i.width } : this.dCtx.lgRect = { x: 0, y: 0, height: 0, width: 0 }, e2.config.legend.position !== "left" && e2.config.legend.position !== "right" || 1.5 * this.dCtx.lgRect.width > e2.globals.svgWidth && (this.dCtx.lgRect.width = e2.globals.svgWidth / 1.5), this.dCtx.lgRect;
    } }, { key: "getLargestStringFromMultiArr", value: function(e2, t2) {
      var i = e2;
      if (this.w.globals.isMultiLineX) {
        var a2 = t2.map(function(r, n2) {
          return Array.isArray(r) ? r.length : 1;
        }), s2 = Math.max.apply(Math, J2(a2));
        i = t2[a2.indexOf(s2)];
      }
      return i;
    } }]), y2;
  }(), At2 = function() {
    function y2(e2) {
      F2(this, y2), this.w = e2.w, this.dCtx = e2;
    }
    return Y2(y2, [{ key: "getxAxisLabelsCoords", value: function() {
      var e2, t2 = this.w, i = t2.globals.labels.slice();
      if (t2.config.xaxis.convertedCatToNumeric && i.length === 0 && (i = t2.globals.categoryLabels), t2.globals.timescaleLabels.length > 0) {
        var a2 = this.getxAxisTimeScaleLabelsCoords();
        e2 = { width: a2.width, height: a2.height }, t2.globals.rotateXLabels = false;
      } else {
        this.dCtx.lgWidthForSideLegends = t2.config.legend.position !== "left" && t2.config.legend.position !== "right" || t2.config.legend.floating ? 0 : this.dCtx.lgRect.width;
        var s2 = t2.globals.xLabelFormatter, r = P2.getLargestStringFromArr(i), n2 = this.dCtx.dimHelpers.getLargestStringFromMultiArr(r, i);
        t2.globals.isBarHorizontal && (n2 = r = t2.globals.yAxisScale[0].result.reduce(function(f2, b2) {
          return f2.length > b2.length ? f2 : b2;
        }, 0));
        var o2 = new re2(this.dCtx.ctx), h2 = r;
        r = o2.xLabelFormat(s2, r, h2, { i: void 0, dateFormatter: new B3(this.dCtx.ctx).formatDate, w: t2 }), n2 = o2.xLabelFormat(s2, n2, h2, { i: void 0, dateFormatter: new B3(this.dCtx.ctx).formatDate, w: t2 }), (t2.config.xaxis.convertedCatToNumeric && r === void 0 || String(r).trim() === "") && (n2 = r = "1");
        var c2 = new M2(this.dCtx.ctx), d2 = c2.getTextRects(r, t2.config.xaxis.labels.style.fontSize), g2 = d2;
        if (r !== n2 && (g2 = c2.getTextRects(n2, t2.config.xaxis.labels.style.fontSize)), (e2 = { width: d2.width >= g2.width ? d2.width : g2.width, height: d2.height >= g2.height ? d2.height : g2.height }).width * i.length > t2.globals.svgWidth - this.dCtx.lgWidthForSideLegends - this.dCtx.yAxisWidth - this.dCtx.gridPad.left - this.dCtx.gridPad.right && t2.config.xaxis.labels.rotate !== 0 || t2.config.xaxis.labels.rotateAlways) {
          if (!t2.globals.isBarHorizontal) {
            t2.globals.rotateXLabels = true;
            var p2 = function(f2) {
              return c2.getTextRects(f2, t2.config.xaxis.labels.style.fontSize, t2.config.xaxis.labels.style.fontFamily, "rotate(".concat(t2.config.xaxis.labels.rotate, " 0 0)"), false);
            };
            d2 = p2(r), r !== n2 && (g2 = p2(n2)), e2.height = (d2.height > g2.height ? d2.height : g2.height) / 1.5, e2.width = d2.width > g2.width ? d2.width : g2.width;
          }
        } else
          t2.globals.rotateXLabels = false;
      }
      return t2.config.xaxis.labels.show || (e2 = { width: 0, height: 0 }), { width: e2.width, height: e2.height };
    } }, { key: "getxAxisGroupLabelsCoords", value: function() {
      var e2, t2 = this.w;
      if (!t2.globals.hasXaxisGroups)
        return { width: 0, height: 0 };
      var i, a2 = ((e2 = t2.config.xaxis.group.style) === null || e2 === void 0 ? void 0 : e2.fontSize) || t2.config.xaxis.labels.style.fontSize, s2 = t2.globals.groups.map(function(d2) {
        return d2.title;
      }), r = P2.getLargestStringFromArr(s2), n2 = this.dCtx.dimHelpers.getLargestStringFromMultiArr(r, s2), o2 = new M2(this.dCtx.ctx), h2 = o2.getTextRects(r, a2), c2 = h2;
      return r !== n2 && (c2 = o2.getTextRects(n2, a2)), i = { width: h2.width >= c2.width ? h2.width : c2.width, height: h2.height >= c2.height ? h2.height : c2.height }, t2.config.xaxis.labels.show || (i = { width: 0, height: 0 }), { width: i.width, height: i.height };
    } }, { key: "getxAxisTitleCoords", value: function() {
      var e2 = this.w, t2 = 0, i = 0;
      if (e2.config.xaxis.title.text !== void 0) {
        var a2 = new M2(this.dCtx.ctx).getTextRects(e2.config.xaxis.title.text, e2.config.xaxis.title.style.fontSize);
        t2 = a2.width, i = a2.height;
      }
      return { width: t2, height: i };
    } }, { key: "getxAxisTimeScaleLabelsCoords", value: function() {
      var e2, t2 = this.w;
      this.dCtx.timescaleLabels = t2.globals.timescaleLabels.slice();
      var i = this.dCtx.timescaleLabels.map(function(s2) {
        return s2.value;
      }), a2 = i.reduce(function(s2, r) {
        return s2 === void 0 ? (console.error("You have possibly supplied invalid Date format. Please supply a valid JavaScript Date"), 0) : s2.length > r.length ? s2 : r;
      }, 0);
      return 1.05 * (e2 = new M2(this.dCtx.ctx).getTextRects(a2, t2.config.xaxis.labels.style.fontSize)).width * i.length > t2.globals.gridWidth && t2.config.xaxis.labels.rotate !== 0 && (t2.globals.overlappingXLabels = true), e2;
    } }, { key: "additionalPaddingXLabels", value: function(e2) {
      var t2 = this, i = this.w, a2 = i.globals, s2 = i.config, r = s2.xaxis.type, n2 = e2.width;
      a2.skipLastTimelinelabel = false, a2.skipFirstTimelinelabel = false;
      var o2 = i.config.yaxis[0].opposite && i.globals.isBarHorizontal, h2 = function(c2, d2) {
        s2.yaxis.length > 1 && function(g2) {
          return a2.collapsedSeriesIndices.indexOf(g2) !== -1;
        }(d2) || function(g2) {
          if (t2.dCtx.timescaleLabels && t2.dCtx.timescaleLabels.length) {
            var p2 = t2.dCtx.timescaleLabels[0], f2 = t2.dCtx.timescaleLabels[t2.dCtx.timescaleLabels.length - 1].position + n2 / 1.75 - t2.dCtx.yAxisWidthRight, b2 = p2.position - n2 / 1.75 + t2.dCtx.yAxisWidthLeft, m2 = i.config.legend.position === "right" && t2.dCtx.lgRect.width > 0 ? t2.dCtx.lgRect.width : 0;
            f2 > a2.svgWidth - a2.translateX - m2 && (a2.skipLastTimelinelabel = true), b2 < -(g2.show && !g2.floating || s2.chart.type !== "bar" && s2.chart.type !== "candlestick" && s2.chart.type !== "rangeBar" && s2.chart.type !== "boxPlot" ? 10 : n2 / 1.75) && (a2.skipFirstTimelinelabel = true);
          } else
            r === "datetime" ? t2.dCtx.gridPad.right < n2 && !a2.rotateXLabels && (a2.skipLastTimelinelabel = true) : r !== "datetime" && t2.dCtx.gridPad.right < n2 / 2 - t2.dCtx.yAxisWidthRight && !a2.rotateXLabels && !i.config.xaxis.labels.trim && (i.config.xaxis.tickPlacement !== "between" || i.globals.isBarHorizontal) && (t2.dCtx.xPadRight = n2 / 2 + 1);
        }(c2);
      };
      s2.yaxis.forEach(function(c2, d2) {
        o2 ? (t2.dCtx.gridPad.left < n2 && (t2.dCtx.xPadLeft = n2 / 2 + 1), t2.dCtx.xPadRight = n2 / 2 + 1) : h2(c2, d2);
      });
    } }]), y2;
  }(), St = function() {
    function y2(e2) {
      F2(this, y2), this.w = e2.w, this.dCtx = e2;
    }
    return Y2(y2, [{ key: "getyAxisLabelsCoords", value: function() {
      var e2 = this, t2 = this.w, i = [], a2 = 10, s2 = new xe(this.dCtx.ctx);
      return t2.config.yaxis.map(function(r, n2) {
        var o2 = { seriesIndex: n2, dataPointIndex: -1, w: t2 }, h2 = t2.globals.yAxisScale[n2], c2 = 0;
        if (!s2.isYAxisHidden(n2) && r.labels.show && r.labels.minWidth !== void 0 && (c2 = r.labels.minWidth), !s2.isYAxisHidden(n2) && r.labels.show && h2.result.length) {
          var d2 = t2.globals.yLabelFormatters[n2], g2 = h2.niceMin === Number.MIN_VALUE ? 0 : h2.niceMin, p2 = h2.result.reduce(function(u2, x2) {
            var v2, k2;
            return ((v2 = String(d2(u2, o2))) === null || v2 === void 0 ? void 0 : v2.length) > ((k2 = String(d2(x2, o2))) === null || k2 === void 0 ? void 0 : k2.length) ? u2 : x2;
          }, g2), f2 = p2 = d2(p2, o2);
          if (p2 !== void 0 && p2.length !== 0 || (p2 = h2.niceMax), t2.globals.isBarHorizontal) {
            a2 = 0;
            var b2 = t2.globals.labels.slice();
            p2 = P2.getLargestStringFromArr(b2), p2 = d2(p2, { seriesIndex: n2, dataPointIndex: -1, w: t2 }), f2 = e2.dCtx.dimHelpers.getLargestStringFromMultiArr(p2, b2);
          }
          var m2 = new M2(e2.dCtx.ctx), w2 = "rotate(".concat(r.labels.rotate, " 0 0)"), A2 = m2.getTextRects(p2, r.labels.style.fontSize, r.labels.style.fontFamily, w2, false), l2 = A2;
          p2 !== f2 && (l2 = m2.getTextRects(f2, r.labels.style.fontSize, r.labels.style.fontFamily, w2, false)), i.push({ width: (c2 > l2.width || c2 > A2.width ? c2 : l2.width > A2.width ? l2.width : A2.width) + a2, height: l2.height > A2.height ? l2.height : A2.height });
        } else
          i.push({ width: 0, height: 0 });
      }), i;
    } }, { key: "getyAxisTitleCoords", value: function() {
      var e2 = this, t2 = this.w, i = [];
      return t2.config.yaxis.map(function(a2, s2) {
        if (a2.show && a2.title.text !== void 0) {
          var r = new M2(e2.dCtx.ctx), n2 = "rotate(".concat(a2.title.rotate, " 0 0)"), o2 = r.getTextRects(a2.title.text, a2.title.style.fontSize, a2.title.style.fontFamily, n2, false);
          i.push({ width: o2.width, height: o2.height });
        } else
          i.push({ width: 0, height: 0 });
      }), i;
    } }, { key: "getTotalYAxisWidth", value: function() {
      var e2 = this.w, t2 = 0, i = 0, a2 = 0, s2 = e2.globals.yAxisScale.length > 1 ? 10 : 0, r = new xe(this.dCtx.ctx), n2 = function(o2, h2) {
        var c2 = e2.config.yaxis[h2].floating, d2 = 0;
        o2.width > 0 && !c2 ? (d2 = o2.width + s2, function(g2) {
          return e2.globals.ignoreYAxisIndexes.indexOf(g2) > -1;
        }(h2) && (d2 = d2 - o2.width - s2)) : d2 = c2 || r.isYAxisHidden(h2) ? 0 : 5, e2.config.yaxis[h2].opposite ? a2 += d2 : i += d2, t2 += d2;
      };
      return e2.globals.yLabelsCoords.map(function(o2, h2) {
        n2(o2, h2);
      }), e2.globals.yTitleCoords.map(function(o2, h2) {
        n2(o2, h2);
      }), e2.globals.isBarHorizontal && !e2.config.yaxis[0].floating && (t2 = e2.globals.yLabelsCoords[0].width + e2.globals.yTitleCoords[0].width + 15), this.dCtx.yAxisWidthLeft = i, this.dCtx.yAxisWidthRight = a2, t2;
    } }]), y2;
  }(), Ct2 = function() {
    function y2(e2) {
      F2(this, y2), this.w = e2.w, this.dCtx = e2;
    }
    return Y2(y2, [{ key: "gridPadForColumnsInNumericAxis", value: function(e2) {
      var t2 = this.w;
      if (t2.globals.noData || t2.globals.allSeriesCollapsed)
        return 0;
      var i = function(c2) {
        return c2 === "bar" || c2 === "rangeBar" || c2 === "candlestick" || c2 === "boxPlot";
      }, a2 = t2.config.chart.type, s2 = 0, r = i(a2) ? t2.config.series.length : 1;
      if (t2.globals.comboBarCount > 0 && (r = t2.globals.comboBarCount), t2.globals.collapsedSeries.forEach(function(c2) {
        i(c2.type) && (r -= 1);
      }), t2.config.chart.stacked && (r = 1), (i(a2) || t2.globals.comboBarCount > 0) && t2.globals.isXNumeric && !t2.globals.isBarHorizontal && r > 0) {
        var n2, o2, h2 = Math.abs(t2.globals.initialMaxX - t2.globals.initialMinX);
        h2 <= 3 && (h2 = t2.globals.dataPoints), n2 = h2 / e2, t2.globals.minXDiff && t2.globals.minXDiff / n2 > 0 && (o2 = t2.globals.minXDiff / n2), o2 > e2 / 2 && (o2 /= 2), (s2 = o2 / r * parseInt(t2.config.plotOptions.bar.columnWidth, 10) / 100) < 1 && (s2 = 1), s2 = s2 / (r > 1 ? 1 : 1.5) + 5, t2.globals.barPadForNumericAxis = s2;
      }
      return s2;
    } }, { key: "gridPadFortitleSubtitle", value: function() {
      var e2 = this, t2 = this.w, i = t2.globals, a2 = this.dCtx.isSparkline || !t2.globals.axisCharts ? 0 : 10;
      ["title", "subtitle"].forEach(function(n2) {
        t2.config[n2].text !== void 0 ? a2 += t2.config[n2].margin : a2 += e2.dCtx.isSparkline || !t2.globals.axisCharts ? 0 : 5;
      }), !t2.config.legend.show || t2.config.legend.position !== "bottom" || t2.config.legend.floating || t2.globals.axisCharts || (a2 += 10);
      var s2 = this.dCtx.dimHelpers.getTitleSubtitleCoords("title"), r = this.dCtx.dimHelpers.getTitleSubtitleCoords("subtitle");
      i.gridHeight = i.gridHeight - s2.height - r.height - a2, i.translateY = i.translateY + s2.height + r.height + a2;
    } }, { key: "setGridXPosForDualYAxis", value: function(e2, t2) {
      var i = this.w, a2 = new xe(this.dCtx.ctx);
      i.config.yaxis.map(function(s2, r) {
        i.globals.ignoreYAxisIndexes.indexOf(r) !== -1 || s2.floating || a2.isYAxisHidden(r) || (s2.opposite && (i.globals.translateX = i.globals.translateX - (t2[r].width + e2[r].width) - parseInt(i.config.yaxis[r].labels.style.fontSize, 10) / 1.2 - 12), i.globals.translateX < 2 && (i.globals.translateX = 2));
      });
    } }]), y2;
  }(), Ye = function() {
    function y2(e2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w, this.lgRect = {}, this.yAxisWidth = 0, this.yAxisWidthLeft = 0, this.yAxisWidthRight = 0, this.xAxisHeight = 0, this.isSparkline = this.w.config.chart.sparkline.enabled, this.dimHelpers = new kt2(this), this.dimYAxis = new St(this), this.dimXAxis = new At2(this), this.dimGrid = new Ct2(this), this.lgWidthForSideLegends = 0, this.gridPad = this.w.config.grid.padding, this.xPadRight = 0, this.xPadLeft = 0;
    }
    return Y2(y2, [{ key: "plotCoords", value: function() {
      var e2 = this, t2 = this.w, i = t2.globals;
      this.lgRect = this.dimHelpers.getLegendsRect(), this.isSparkline && ((t2.config.markers.discrete.length > 0 || t2.config.markers.size > 0) && Object.entries(this.gridPad).forEach(function(s2) {
        var r = Me(s2, 2), n2 = r[0], o2 = r[1];
        e2.gridPad[n2] = Math.max(o2, e2.w.globals.markers.largestSize / 1.5);
      }), this.gridPad.top = Math.max(t2.config.stroke.width / 2, this.gridPad.top), this.gridPad.bottom = Math.max(t2.config.stroke.width / 2, this.gridPad.bottom)), i.axisCharts ? this.setDimensionsForAxisCharts() : this.setDimensionsForNonAxisCharts(), this.dimGrid.gridPadFortitleSubtitle(), i.gridHeight = i.gridHeight - this.gridPad.top - this.gridPad.bottom, i.gridWidth = i.gridWidth - this.gridPad.left - this.gridPad.right - this.xPadRight - this.xPadLeft;
      var a2 = this.dimGrid.gridPadForColumnsInNumericAxis(i.gridWidth);
      i.gridWidth = i.gridWidth - 2 * a2, i.translateX = i.translateX + this.gridPad.left + this.xPadLeft + (a2 > 0 ? a2 + 4 : 0), i.translateY = i.translateY + this.gridPad.top;
    } }, { key: "setDimensionsForAxisCharts", value: function() {
      var e2 = this, t2 = this.w, i = t2.globals, a2 = this.dimYAxis.getyAxisLabelsCoords(), s2 = this.dimYAxis.getyAxisTitleCoords();
      t2.globals.yLabelsCoords = [], t2.globals.yTitleCoords = [], t2.config.yaxis.map(function(p2, f2) {
        t2.globals.yLabelsCoords.push({ width: a2[f2].width, index: f2 }), t2.globals.yTitleCoords.push({ width: s2[f2].width, index: f2 });
      }), this.yAxisWidth = this.dimYAxis.getTotalYAxisWidth();
      var r = this.dimXAxis.getxAxisLabelsCoords(), n2 = this.dimXAxis.getxAxisGroupLabelsCoords(), o2 = this.dimXAxis.getxAxisTitleCoords();
      this.conditionalChecksForAxisCoords(r, o2, n2), i.translateXAxisY = t2.globals.rotateXLabels ? this.xAxisHeight / 8 : -4, i.translateXAxisX = t2.globals.rotateXLabels && t2.globals.isXNumeric && t2.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0, t2.globals.isBarHorizontal && (i.rotateXLabels = false, i.translateXAxisY = parseInt(t2.config.xaxis.labels.style.fontSize, 10) / 1.5 * -1), i.translateXAxisY = i.translateXAxisY + t2.config.xaxis.labels.offsetY, i.translateXAxisX = i.translateXAxisX + t2.config.xaxis.labels.offsetX;
      var h2 = this.yAxisWidth, c2 = this.xAxisHeight;
      i.xAxisLabelsHeight = this.xAxisHeight - o2.height, i.xAxisGroupLabelsHeight = i.xAxisLabelsHeight - r.height, i.xAxisLabelsWidth = this.xAxisWidth, i.xAxisHeight = this.xAxisHeight;
      var d2 = 10;
      (t2.config.chart.type === "radar" || this.isSparkline) && (h2 = 0, c2 = i.goldenPadding), this.isSparkline && (this.lgRect = { height: 0, width: 0 }), (this.isSparkline || t2.config.chart.type === "treemap") && (h2 = 0, c2 = 0, d2 = 0), this.isSparkline || this.dimXAxis.additionalPaddingXLabels(r);
      var g2 = function() {
        i.translateX = h2, i.gridHeight = i.svgHeight - e2.lgRect.height - c2 - (e2.isSparkline || t2.config.chart.type === "treemap" ? 0 : t2.globals.rotateXLabels ? 10 : 15), i.gridWidth = i.svgWidth - h2;
      };
      switch (t2.config.xaxis.position === "top" && (d2 = i.xAxisHeight - t2.config.xaxis.axisTicks.height - 5), t2.config.legend.position) {
        case "bottom":
          i.translateY = d2, g2();
          break;
        case "top":
          i.translateY = this.lgRect.height + d2, g2();
          break;
        case "left":
          i.translateY = d2, i.translateX = this.lgRect.width + h2, i.gridHeight = i.svgHeight - c2 - 12, i.gridWidth = i.svgWidth - this.lgRect.width - h2;
          break;
        case "right":
          i.translateY = d2, i.translateX = h2, i.gridHeight = i.svgHeight - c2 - 12, i.gridWidth = i.svgWidth - this.lgRect.width - h2 - 5;
          break;
        default:
          throw new Error("Legend position not supported");
      }
      this.dimGrid.setGridXPosForDualYAxis(s2, a2), new Ne2(this.ctx).setYAxisXPosition(a2, s2);
    } }, { key: "setDimensionsForNonAxisCharts", value: function() {
      var e2 = this.w, t2 = e2.globals, i = e2.config, a2 = 0;
      e2.config.legend.show && !e2.config.legend.floating && (a2 = 20);
      var s2 = i.chart.type === "pie" || i.chart.type === "polarArea" || i.chart.type === "donut" ? "pie" : "radialBar", r = i.plotOptions[s2].offsetY, n2 = i.plotOptions[s2].offsetX;
      if (!i.legend.show || i.legend.floating)
        return t2.gridHeight = t2.svgHeight - i.grid.padding.left + i.grid.padding.right, t2.gridWidth = t2.gridHeight, t2.translateY = r, void (t2.translateX = n2 + (t2.svgWidth - t2.gridWidth) / 2);
      switch (i.legend.position) {
        case "bottom":
          t2.gridHeight = t2.svgHeight - this.lgRect.height - t2.goldenPadding, t2.gridWidth = t2.svgWidth, t2.translateY = r - 10, t2.translateX = n2 + (t2.svgWidth - t2.gridWidth) / 2;
          break;
        case "top":
          t2.gridHeight = t2.svgHeight - this.lgRect.height - t2.goldenPadding, t2.gridWidth = t2.svgWidth, t2.translateY = this.lgRect.height + r + 10, t2.translateX = n2 + (t2.svgWidth - t2.gridWidth) / 2;
          break;
        case "left":
          t2.gridWidth = t2.svgWidth - this.lgRect.width - a2, t2.gridHeight = i.chart.height !== "auto" ? t2.svgHeight : t2.gridWidth, t2.translateY = r, t2.translateX = n2 + this.lgRect.width + a2;
          break;
        case "right":
          t2.gridWidth = t2.svgWidth - this.lgRect.width - a2 - 5, t2.gridHeight = i.chart.height !== "auto" ? t2.svgHeight : t2.gridWidth, t2.translateY = r, t2.translateX = n2 + 10;
          break;
        default:
          throw new Error("Legend position not supported");
      }
    } }, { key: "conditionalChecksForAxisCoords", value: function(e2, t2, i) {
      var a2 = this.w, s2 = a2.globals.hasXaxisGroups ? 2 : 1, r = i.height + e2.height + t2.height, n2 = a2.globals.isMultiLineX ? 1.2 : a2.globals.LINE_HEIGHT_RATIO, o2 = a2.globals.rotateXLabels ? 22 : 10, h2 = a2.globals.rotateXLabels && a2.config.legend.position === "bottom" ? 10 : 0;
      this.xAxisHeight = r * n2 + s2 * o2 + h2, this.xAxisWidth = e2.width, this.xAxisHeight - t2.height > a2.config.xaxis.labels.maxHeight && (this.xAxisHeight = a2.config.xaxis.labels.maxHeight), a2.config.xaxis.labels.minHeight && this.xAxisHeight < a2.config.xaxis.labels.minHeight && (this.xAxisHeight = a2.config.xaxis.labels.minHeight), a2.config.xaxis.floating && (this.xAxisHeight = 0);
      var c2 = 0, d2 = 0;
      a2.config.yaxis.forEach(function(g2) {
        c2 += g2.labels.minWidth, d2 += g2.labels.maxWidth;
      }), this.yAxisWidth < c2 && (this.yAxisWidth = c2), this.yAxisWidth > d2 && (this.yAxisWidth = d2);
    } }]), y2;
  }(), Lt2 = function() {
    function y2(e2) {
      F2(this, y2), this.w = e2.w, this.lgCtx = e2;
    }
    return Y2(y2, [{ key: "getLegendStyles", value: function() {
      var e2, t2, i, a2 = document.createElement("style");
      a2.setAttribute("type", "text/css");
      var s2 = ((e2 = this.lgCtx.ctx) === null || e2 === void 0 || (t2 = e2.opts) === null || t2 === void 0 || (i = t2.chart) === null || i === void 0 ? void 0 : i.nonce) || this.w.config.chart.nonce;
      s2 && a2.setAttribute("nonce", s2);
      var r = document.createTextNode(`
      .apexcharts-legend {
        display: flex;
        overflow: auto;
        padding: 0 10px;
      }
      .apexcharts-legend.apx-legend-position-bottom, .apexcharts-legend.apx-legend-position-top {
        flex-wrap: wrap
      }
      .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {
        flex-direction: column;
        bottom: 0;
      }
      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-left, .apexcharts-legend.apx-legend-position-top.apexcharts-align-left, .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {
        justify-content: flex-start;
      }
      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-center, .apexcharts-legend.apx-legend-position-top.apexcharts-align-center {
        justify-content: center;
      }
      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-right, .apexcharts-legend.apx-legend-position-top.apexcharts-align-right {
        justify-content: flex-end;
      }
      .apexcharts-legend-series {
        cursor: pointer;
        line-height: normal;
      }
      .apexcharts-legend.apx-legend-position-bottom .apexcharts-legend-series, .apexcharts-legend.apx-legend-position-top .apexcharts-legend-series{
        display: flex;
        align-items: center;
      }
      .apexcharts-legend-text {
        position: relative;
        font-size: 14px;
      }
      .apexcharts-legend-text *, .apexcharts-legend-marker * {
        pointer-events: none;
      }
      .apexcharts-legend-marker {
        position: relative;
        display: inline-block;
        cursor: pointer;
        margin-right: 3px;
        border-style: solid;
      }

      .apexcharts-legend.apexcharts-align-right .apexcharts-legend-series, .apexcharts-legend.apexcharts-align-left .apexcharts-legend-series{
        display: inline-block;
      }
      .apexcharts-legend-series.apexcharts-no-click {
        cursor: auto;
      }
      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {
        display: none !important;
      }
      .apexcharts-inactive-legend {
        opacity: 0.45;
      }`);
      return a2.appendChild(r), a2;
    } }, { key: "getLegendBBox", value: function() {
      var e2 = this.w.globals.dom.baseEl.querySelector(".apexcharts-legend").getBoundingClientRect(), t2 = e2.width;
      return { clwh: e2.height, clww: t2 };
    } }, { key: "appendToForeignObject", value: function() {
      this.w.globals.dom.elLegendForeign.appendChild(this.getLegendStyles());
    } }, { key: "toggleDataSeries", value: function(e2, t2) {
      var i = this, a2 = this.w;
      if (a2.globals.axisCharts || a2.config.chart.type === "radialBar") {
        a2.globals.resized = true;
        var s2 = null, r = null;
        a2.globals.risingSeries = [], a2.globals.axisCharts ? (s2 = a2.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(e2, "']")), r = parseInt(s2.getAttribute("data:realIndex"), 10)) : (s2 = a2.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(e2 + 1, "']")), r = parseInt(s2.getAttribute("rel"), 10) - 1), t2 ? [{ cs: a2.globals.collapsedSeries, csi: a2.globals.collapsedSeriesIndices }, { cs: a2.globals.ancillaryCollapsedSeries, csi: a2.globals.ancillaryCollapsedSeriesIndices }].forEach(function(c2) {
          i.riseCollapsedSeries(c2.cs, c2.csi, r);
        }) : this.hideSeries({ seriesEl: s2, realIndex: r });
      } else {
        var n2 = a2.globals.dom.Paper.select(" .apexcharts-series[rel='".concat(e2 + 1, "'] path")), o2 = a2.config.chart.type;
        if (o2 === "pie" || o2 === "polarArea" || o2 === "donut") {
          var h2 = a2.config.plotOptions.pie.donut.labels;
          new M2(this.lgCtx.ctx).pathMouseDown(n2.members[0], null), this.lgCtx.ctx.pie.printDataLabelsInner(n2.members[0].node, h2);
        }
        n2.fire("click");
      }
    } }, { key: "hideSeries", value: function(e2) {
      var t2 = e2.seriesEl, i = e2.realIndex, a2 = this.w, s2 = P2.clone(a2.config.series);
      if (a2.globals.axisCharts) {
        var r = false;
        if (a2.config.yaxis[i] && a2.config.yaxis[i].show && a2.config.yaxis[i].showAlways && (r = true, a2.globals.ancillaryCollapsedSeriesIndices.indexOf(i) < 0 && (a2.globals.ancillaryCollapsedSeries.push({ index: i, data: s2[i].data.slice(), type: t2.parentNode.className.baseVal.split("-")[1] }), a2.globals.ancillaryCollapsedSeriesIndices.push(i))), !r) {
          a2.globals.collapsedSeries.push({ index: i, data: s2[i].data.slice(), type: t2.parentNode.className.baseVal.split("-")[1] }), a2.globals.collapsedSeriesIndices.push(i);
          var n2 = a2.globals.risingSeries.indexOf(i);
          a2.globals.risingSeries.splice(n2, 1);
        }
      } else
        a2.globals.collapsedSeries.push({ index: i, data: s2[i] }), a2.globals.collapsedSeriesIndices.push(i);
      for (var o2 = t2.childNodes, h2 = 0; h2 < o2.length; h2++)
        o2[h2].classList.contains("apexcharts-series-markers-wrap") && (o2[h2].classList.contains("apexcharts-hide") ? o2[h2].classList.remove("apexcharts-hide") : o2[h2].classList.add("apexcharts-hide"));
      a2.globals.allSeriesCollapsed = a2.globals.collapsedSeries.length === a2.config.series.length, s2 = this._getSeriesBasedOnCollapsedState(s2), this.lgCtx.ctx.updateHelpers._updateSeries(s2, a2.config.chart.animations.dynamicAnimation.enabled);
    } }, { key: "riseCollapsedSeries", value: function(e2, t2, i) {
      var a2 = this.w, s2 = P2.clone(a2.config.series);
      if (e2.length > 0) {
        for (var r = 0; r < e2.length; r++)
          e2[r].index === i && (a2.globals.axisCharts ? (s2[i].data = e2[r].data.slice(), e2.splice(r, 1), t2.splice(r, 1), a2.globals.risingSeries.push(i)) : (s2[i] = e2[r].data, e2.splice(r, 1), t2.splice(r, 1), a2.globals.risingSeries.push(i)));
        s2 = this._getSeriesBasedOnCollapsedState(s2), this.lgCtx.ctx.updateHelpers._updateSeries(s2, a2.config.chart.animations.dynamicAnimation.enabled);
      }
    } }, { key: "_getSeriesBasedOnCollapsedState", value: function(e2) {
      var t2 = this.w;
      return t2.globals.axisCharts ? e2.forEach(function(i, a2) {
        t2.globals.collapsedSeriesIndices.indexOf(a2) > -1 && (e2[a2].data = []);
      }) : e2.forEach(function(i, a2) {
        t2.globals.collapsedSeriesIndices.indexOf(a2) > -1 && (e2[a2] = 0);
      }), e2;
    } }]), y2;
  }(), Ke = function() {
    function y2(e2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w, this.onLegendClick = this.onLegendClick.bind(this), this.onLegendHovered = this.onLegendHovered.bind(this), this.isBarsDistributed = this.w.config.chart.type === "bar" && this.w.config.plotOptions.bar.distributed && this.w.config.series.length === 1, this.legendHelpers = new Lt2(this);
    }
    return Y2(y2, [{ key: "init", value: function() {
      var e2 = this.w, t2 = e2.globals, i = e2.config;
      if ((i.legend.showForSingleSeries && t2.series.length === 1 || this.isBarsDistributed || t2.series.length > 1 || !t2.axisCharts) && i.legend.show) {
        for (; t2.dom.elLegendWrap.firstChild; )
          t2.dom.elLegendWrap.removeChild(t2.dom.elLegendWrap.firstChild);
        this.drawLegends(), P2.isIE11() ? document.getElementsByTagName("head")[0].appendChild(this.legendHelpers.getLegendStyles()) : this.legendHelpers.appendToForeignObject(), i.legend.position === "bottom" || i.legend.position === "top" ? this.legendAlignHorizontal() : i.legend.position !== "right" && i.legend.position !== "left" || this.legendAlignVertical();
      }
    } }, { key: "drawLegends", value: function() {
      var e2 = this, t2 = this.w, i = t2.config.legend.fontFamily, a2 = t2.globals.seriesNames, s2 = t2.globals.colors.slice();
      if (t2.config.chart.type === "heatmap") {
        var r = t2.config.plotOptions.heatmap.colorScale.ranges;
        a2 = r.map(function(T2) {
          return T2.name ? T2.name : T2.from + " - " + T2.to;
        }), s2 = r.map(function(T2) {
          return T2.color;
        });
      } else
        this.isBarsDistributed && (a2 = t2.globals.labels.slice());
      t2.config.legend.customLegendItems.length && (a2 = t2.config.legend.customLegendItems);
      for (var n2 = t2.globals.legendFormatter, o2 = t2.config.legend.inverseOrder, h2 = o2 ? a2.length - 1 : 0; o2 ? h2 >= 0 : h2 <= a2.length - 1; o2 ? h2-- : h2++) {
        var c2, d2 = n2(a2[h2], { seriesIndex: h2, w: t2 }), g2 = false, p2 = false;
        if (t2.globals.collapsedSeries.length > 0)
          for (var f2 = 0; f2 < t2.globals.collapsedSeries.length; f2++)
            t2.globals.collapsedSeries[f2].index === h2 && (g2 = true);
        if (t2.globals.ancillaryCollapsedSeriesIndices.length > 0)
          for (var b2 = 0; b2 < t2.globals.ancillaryCollapsedSeriesIndices.length; b2++)
            t2.globals.ancillaryCollapsedSeriesIndices[b2] === h2 && (p2 = true);
        var m2 = document.createElement("span");
        m2.classList.add("apexcharts-legend-marker");
        var w2 = t2.config.legend.markers.offsetX, A2 = t2.config.legend.markers.offsetY, l2 = t2.config.legend.markers.height, u2 = t2.config.legend.markers.width, x2 = t2.config.legend.markers.strokeWidth, v2 = t2.config.legend.markers.strokeColor, k2 = t2.config.legend.markers.radius, S2 = m2.style;
        S2.background = s2[h2], S2.color = s2[h2], S2.setProperty("background", s2[h2], "important"), t2.config.legend.markers.fillColors && t2.config.legend.markers.fillColors[h2] && (S2.background = t2.config.legend.markers.fillColors[h2]), t2.globals.seriesColors[h2] !== void 0 && (S2.background = t2.globals.seriesColors[h2], S2.color = t2.globals.seriesColors[h2]), S2.height = Array.isArray(l2) ? parseFloat(l2[h2]) + "px" : parseFloat(l2) + "px", S2.width = Array.isArray(u2) ? parseFloat(u2[h2]) + "px" : parseFloat(u2) + "px", S2.left = (Array.isArray(w2) ? parseFloat(w2[h2]) : parseFloat(w2)) + "px", S2.top = (Array.isArray(A2) ? parseFloat(A2[h2]) : parseFloat(A2)) + "px", S2.borderWidth = Array.isArray(x2) ? x2[h2] : x2, S2.borderColor = Array.isArray(v2) ? v2[h2] : v2, S2.borderRadius = Array.isArray(k2) ? parseFloat(k2[h2]) + "px" : parseFloat(k2) + "px", t2.config.legend.markers.customHTML && (Array.isArray(t2.config.legend.markers.customHTML) ? t2.config.legend.markers.customHTML[h2] && (m2.innerHTML = t2.config.legend.markers.customHTML[h2]()) : m2.innerHTML = t2.config.legend.markers.customHTML()), M2.setAttrs(m2, { rel: h2 + 1, "data:collapsed": g2 || p2 }), (g2 || p2) && m2.classList.add("apexcharts-inactive-legend");
        var C2 = document.createElement("div"), L2 = document.createElement("span");
        L2.classList.add("apexcharts-legend-text"), L2.innerHTML = Array.isArray(d2) ? d2.join(" ") : d2;
        var I2 = t2.config.legend.labels.useSeriesColors ? t2.globals.colors[h2] : Array.isArray(t2.config.legend.labels.colors) ? (c2 = t2.config.legend.labels.colors) === null || c2 === void 0 ? void 0 : c2[h2] : t2.config.legend.labels.colors;
        I2 || (I2 = t2.config.chart.foreColor), L2.style.color = I2, L2.style.fontSize = parseFloat(t2.config.legend.fontSize) + "px", L2.style.fontWeight = t2.config.legend.fontWeight, L2.style.fontFamily = i || t2.config.chart.fontFamily, M2.setAttrs(L2, { rel: h2 + 1, i: h2, "data:default-text": encodeURIComponent(d2), "data:collapsed": g2 || p2 }), C2.appendChild(m2), C2.appendChild(L2);
        var z2 = new q2(this.ctx);
        t2.config.legend.showForZeroSeries || z2.getSeriesTotalByIndex(h2) === 0 && z2.seriesHaveSameValues(h2) && !z2.isSeriesNull(h2) && t2.globals.collapsedSeriesIndices.indexOf(h2) === -1 && t2.globals.ancillaryCollapsedSeriesIndices.indexOf(h2) === -1 && C2.classList.add("apexcharts-hidden-zero-series"), t2.config.legend.showForNullSeries || z2.isSeriesNull(h2) && t2.globals.collapsedSeriesIndices.indexOf(h2) === -1 && t2.globals.ancillaryCollapsedSeriesIndices.indexOf(h2) === -1 && C2.classList.add("apexcharts-hidden-null-series"), t2.globals.dom.elLegendWrap.appendChild(C2), t2.globals.dom.elLegendWrap.classList.add("apexcharts-align-".concat(t2.config.legend.horizontalAlign)), t2.globals.dom.elLegendWrap.classList.add("apx-legend-position-" + t2.config.legend.position), C2.classList.add("apexcharts-legend-series"), C2.style.margin = "".concat(t2.config.legend.itemMargin.vertical, "px ").concat(t2.config.legend.itemMargin.horizontal, "px"), t2.globals.dom.elLegendWrap.style.width = t2.config.legend.width ? t2.config.legend.width + "px" : "", t2.globals.dom.elLegendWrap.style.height = t2.config.legend.height ? t2.config.legend.height + "px" : "", M2.setAttrs(C2, { rel: h2 + 1, seriesName: P2.escapeString(a2[h2]), "data:collapsed": g2 || p2 }), (g2 || p2) && C2.classList.add("apexcharts-inactive-legend"), t2.config.legend.onItemClick.toggleDataSeries || C2.classList.add("apexcharts-no-click");
      }
      t2.globals.dom.elWrap.addEventListener("click", e2.onLegendClick, true), t2.config.legend.onItemHover.highlightDataSeries && t2.config.legend.customLegendItems.length === 0 && (t2.globals.dom.elWrap.addEventListener("mousemove", e2.onLegendHovered, true), t2.globals.dom.elWrap.addEventListener("mouseout", e2.onLegendHovered, true));
    } }, { key: "setLegendWrapXY", value: function(e2, t2) {
      var i = this.w, a2 = i.globals.dom.elLegendWrap, s2 = a2.getBoundingClientRect(), r = 0, n2 = 0;
      if (i.config.legend.position === "bottom")
        n2 += i.globals.svgHeight - s2.height / 2;
      else if (i.config.legend.position === "top") {
        var o2 = new Ye(this.ctx), h2 = o2.dimHelpers.getTitleSubtitleCoords("title").height, c2 = o2.dimHelpers.getTitleSubtitleCoords("subtitle").height;
        n2 = n2 + (h2 > 0 ? h2 - 10 : 0) + (c2 > 0 ? c2 - 10 : 0);
      }
      a2.style.position = "absolute", r = r + e2 + i.config.legend.offsetX, n2 = n2 + t2 + i.config.legend.offsetY, a2.style.left = r + "px", a2.style.top = n2 + "px", i.config.legend.position === "bottom" ? (a2.style.top = "auto", a2.style.bottom = 5 - i.config.legend.offsetY + "px") : i.config.legend.position === "right" && (a2.style.left = "auto", a2.style.right = 25 + i.config.legend.offsetX + "px"), ["width", "height"].forEach(function(d2) {
        a2.style[d2] && (a2.style[d2] = parseInt(i.config.legend[d2], 10) + "px");
      });
    } }, { key: "legendAlignHorizontal", value: function() {
      var e2 = this.w;
      e2.globals.dom.elLegendWrap.style.right = 0;
      var t2 = this.legendHelpers.getLegendBBox(), i = new Ye(this.ctx), a2 = i.dimHelpers.getTitleSubtitleCoords("title"), s2 = i.dimHelpers.getTitleSubtitleCoords("subtitle"), r = 0;
      e2.config.legend.position === "bottom" ? r = -t2.clwh / 1.8 : e2.config.legend.position === "top" && (r = a2.height + s2.height + e2.config.title.margin + e2.config.subtitle.margin - 10), this.setLegendWrapXY(20, r);
    } }, { key: "legendAlignVertical", value: function() {
      var e2 = this.w, t2 = this.legendHelpers.getLegendBBox(), i = 0;
      e2.config.legend.position === "left" && (i = 20), e2.config.legend.position === "right" && (i = e2.globals.svgWidth - t2.clww - 10), this.setLegendWrapXY(i, 20);
    } }, { key: "onLegendHovered", value: function(e2) {
      var t2 = this.w, i = e2.target.classList.contains("apexcharts-legend-series") || e2.target.classList.contains("apexcharts-legend-text") || e2.target.classList.contains("apexcharts-legend-marker");
      if (t2.config.chart.type === "heatmap" || this.isBarsDistributed) {
        if (i) {
          var a2 = parseInt(e2.target.getAttribute("rel"), 10) - 1;
          this.ctx.events.fireEvent("legendHover", [this.ctx, a2, this.w]), new te2(this.ctx).highlightRangeInSeries(e2, e2.target);
        }
      } else
        !e2.target.classList.contains("apexcharts-inactive-legend") && i && new te2(this.ctx).toggleSeriesOnHover(e2, e2.target);
    } }, { key: "onLegendClick", value: function(e2) {
      var t2 = this.w;
      if (!t2.config.legend.customLegendItems.length && (e2.target.classList.contains("apexcharts-legend-series") || e2.target.classList.contains("apexcharts-legend-text") || e2.target.classList.contains("apexcharts-legend-marker"))) {
        var i = parseInt(e2.target.getAttribute("rel"), 10) - 1, a2 = e2.target.getAttribute("data:collapsed") === "true", s2 = this.w.config.chart.events.legendClick;
        typeof s2 == "function" && s2(this.ctx, i, this.w), this.ctx.events.fireEvent("legendClick", [this.ctx, i, this.w]);
        var r = this.w.config.legend.markers.onClick;
        typeof r == "function" && e2.target.classList.contains("apexcharts-legend-marker") && (r(this.ctx, i, this.w), this.ctx.events.fireEvent("legendMarkerClick", [this.ctx, i, this.w])), t2.config.chart.type !== "treemap" && t2.config.chart.type !== "heatmap" && !this.isBarsDistributed && t2.config.legend.onItemClick.toggleDataSeries && this.legendHelpers.toggleDataSeries(i, a2);
      }
    } }]), y2;
  }(), et2 = function() {
    function y2(e2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w;
      var t2 = this.w;
      this.ev = this.w.config.chart.events, this.selectedClass = "apexcharts-selected", this.localeValues = this.w.globals.locale.toolbar, this.minX = t2.globals.minX, this.maxX = t2.globals.maxX;
    }
    return Y2(y2, [{ key: "createToolbar", value: function() {
      var e2 = this, t2 = this.w, i = function() {
        return document.createElement("div");
      }, a2 = i();
      if (a2.setAttribute("class", "apexcharts-toolbar"), a2.style.top = t2.config.chart.toolbar.offsetY + "px", a2.style.right = 3 - t2.config.chart.toolbar.offsetX + "px", t2.globals.dom.elWrap.appendChild(a2), this.elZoom = i(), this.elZoomIn = i(), this.elZoomOut = i(), this.elPan = i(), this.elSelection = i(), this.elZoomReset = i(), this.elMenuIcon = i(), this.elMenu = i(), this.elCustomIcons = [], this.t = t2.config.chart.toolbar.tools, Array.isArray(this.t.customIcons))
        for (var s2 = 0; s2 < this.t.customIcons.length; s2++)
          this.elCustomIcons.push(i());
      var r = [], n2 = function(d2, g2, p2) {
        var f2 = d2.toLowerCase();
        e2.t[f2] && t2.config.chart.zoom.enabled && r.push({ el: g2, icon: typeof e2.t[f2] == "string" ? e2.t[f2] : p2, title: e2.localeValues[d2], class: "apexcharts-".concat(f2, "-icon") });
      };
      n2("zoomIn", this.elZoomIn, `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>
</svg>
`), n2("zoomOut", this.elZoomOut, `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>
</svg>
`);
      var o2 = function(d2) {
        e2.t[d2] && t2.config.chart[d2].enabled && r.push({ el: d2 === "zoom" ? e2.elZoom : e2.elSelection, icon: typeof e2.t[d2] == "string" ? e2.t[d2] : d2 === "zoom" ? `<svg xmlns="http://www.w3.org/2000/svg" fill="#000000" height="24" viewBox="0 0 24 24" width="24">
    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
    <path d="M0 0h24v24H0V0z" fill="none"/>
    <path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"/>
</svg>` : `<svg fill="#6E8192" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z"/>
</svg>`, title: e2.localeValues[d2 === "zoom" ? "selectionZoom" : "selection"], class: t2.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-".concat(d2, "-icon") });
      };
      o2("zoom"), o2("selection"), this.t.pan && t2.config.chart.zoom.enabled && r.push({ el: this.elPan, icon: typeof this.t.pan == "string" ? this.t.pan : `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000" height="24" viewBox="0 0 24 24" width="24">
    <defs>
        <path d="M0 0h24v24H0z" id="a"/>
    </defs>
    <clipPath id="b">
        <use overflow="visible" xlink:href="#a"/>
    </clipPath>
    <path clip-path="url(#b)" d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"/>
</svg>`, title: this.localeValues.pan, class: t2.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-pan-icon" }), n2("reset", this.elZoomReset, `<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
</svg>`), this.t.download && r.push({ el: this.elMenuIcon, icon: typeof this.t.download == "string" ? this.t.download : '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>', title: this.localeValues.menu, class: "apexcharts-menu-icon" });
      for (var h2 = 0; h2 < this.elCustomIcons.length; h2++)
        r.push({ el: this.elCustomIcons[h2], icon: this.t.customIcons[h2].icon, title: this.t.customIcons[h2].title, index: this.t.customIcons[h2].index, class: "apexcharts-toolbar-custom-icon " + this.t.customIcons[h2].class });
      r.forEach(function(d2, g2) {
        d2.index && P2.moveIndexInArray(r, g2, d2.index);
      });
      for (var c2 = 0; c2 < r.length; c2++)
        M2.setAttrs(r[c2].el, { class: r[c2].class, title: r[c2].title }), r[c2].el.innerHTML = r[c2].icon, a2.appendChild(r[c2].el);
      this._createHamburgerMenu(a2), t2.globals.zoomEnabled ? this.elZoom.classList.add(this.selectedClass) : t2.globals.panEnabled ? this.elPan.classList.add(this.selectedClass) : t2.globals.selectionEnabled && this.elSelection.classList.add(this.selectedClass), this.addToolbarEventListeners();
    } }, { key: "_createHamburgerMenu", value: function(e2) {
      this.elMenuItems = [], e2.appendChild(this.elMenu), M2.setAttrs(this.elMenu, { class: "apexcharts-menu" });
      for (var t2 = [{ name: "exportSVG", title: this.localeValues.exportToSVG }, { name: "exportPNG", title: this.localeValues.exportToPNG }, { name: "exportCSV", title: this.localeValues.exportToCSV }], i = 0; i < t2.length; i++)
        this.elMenuItems.push(document.createElement("div")), this.elMenuItems[i].innerHTML = t2[i].title, M2.setAttrs(this.elMenuItems[i], { class: "apexcharts-menu-item ".concat(t2[i].name), title: t2[i].title }), this.elMenu.appendChild(this.elMenuItems[i]);
    } }, { key: "addToolbarEventListeners", value: function() {
      var e2 = this;
      this.elZoomReset.addEventListener("click", this.handleZoomReset.bind(this)), this.elSelection.addEventListener("click", this.toggleZoomSelection.bind(this, "selection")), this.elZoom.addEventListener("click", this.toggleZoomSelection.bind(this, "zoom")), this.elZoomIn.addEventListener("click", this.handleZoomIn.bind(this)), this.elZoomOut.addEventListener("click", this.handleZoomOut.bind(this)), this.elPan.addEventListener("click", this.togglePanning.bind(this)), this.elMenuIcon.addEventListener("click", this.toggleMenu.bind(this)), this.elMenuItems.forEach(function(i) {
        i.classList.contains("exportSVG") ? i.addEventListener("click", e2.handleDownload.bind(e2, "svg")) : i.classList.contains("exportPNG") ? i.addEventListener("click", e2.handleDownload.bind(e2, "png")) : i.classList.contains("exportCSV") && i.addEventListener("click", e2.handleDownload.bind(e2, "csv"));
      });
      for (var t2 = 0; t2 < this.t.customIcons.length; t2++)
        this.elCustomIcons[t2].addEventListener("click", this.t.customIcons[t2].click.bind(this, this.ctx, this.ctx.w));
    } }, { key: "toggleZoomSelection", value: function(e2) {
      this.ctx.getSyncedCharts().forEach(function(t2) {
        t2.ctx.toolbar.toggleOtherControls();
        var i = e2 === "selection" ? t2.ctx.toolbar.elSelection : t2.ctx.toolbar.elZoom, a2 = e2 === "selection" ? "selectionEnabled" : "zoomEnabled";
        t2.w.globals[a2] = !t2.w.globals[a2], i.classList.contains(t2.ctx.toolbar.selectedClass) ? i.classList.remove(t2.ctx.toolbar.selectedClass) : i.classList.add(t2.ctx.toolbar.selectedClass);
      });
    } }, { key: "getToolbarIconsReference", value: function() {
      var e2 = this.w;
      this.elZoom || (this.elZoom = e2.globals.dom.baseEl.querySelector(".apexcharts-zoom-icon")), this.elPan || (this.elPan = e2.globals.dom.baseEl.querySelector(".apexcharts-pan-icon")), this.elSelection || (this.elSelection = e2.globals.dom.baseEl.querySelector(".apexcharts-selection-icon"));
    } }, { key: "enableZoomPanFromToolbar", value: function(e2) {
      this.toggleOtherControls(), e2 === "pan" ? this.w.globals.panEnabled = true : this.w.globals.zoomEnabled = true;
      var t2 = e2 === "pan" ? this.elPan : this.elZoom, i = e2 === "pan" ? this.elZoom : this.elPan;
      t2 && t2.classList.add(this.selectedClass), i && i.classList.remove(this.selectedClass);
    } }, { key: "togglePanning", value: function() {
      this.ctx.getSyncedCharts().forEach(function(e2) {
        e2.ctx.toolbar.toggleOtherControls(), e2.w.globals.panEnabled = !e2.w.globals.panEnabled, e2.ctx.toolbar.elPan.classList.contains(e2.ctx.toolbar.selectedClass) ? e2.ctx.toolbar.elPan.classList.remove(e2.ctx.toolbar.selectedClass) : e2.ctx.toolbar.elPan.classList.add(e2.ctx.toolbar.selectedClass);
      });
    } }, { key: "toggleOtherControls", value: function() {
      var e2 = this, t2 = this.w;
      t2.globals.panEnabled = false, t2.globals.zoomEnabled = false, t2.globals.selectionEnabled = false, this.getToolbarIconsReference(), [this.elPan, this.elSelection, this.elZoom].forEach(function(i) {
        i && i.classList.remove(e2.selectedClass);
      });
    } }, { key: "handleZoomIn", value: function() {
      var e2 = this.w;
      e2.globals.isRangeBar && (this.minX = e2.globals.minY, this.maxX = e2.globals.maxY);
      var t2 = (this.minX + this.maxX) / 2, i = (this.minX + t2) / 2, a2 = (this.maxX + t2) / 2, s2 = this._getNewMinXMaxX(i, a2);
      e2.globals.disableZoomIn || this.zoomUpdateOptions(s2.minX, s2.maxX);
    } }, { key: "handleZoomOut", value: function() {
      var e2 = this.w;
      if (e2.globals.isRangeBar && (this.minX = e2.globals.minY, this.maxX = e2.globals.maxY), !(e2.config.xaxis.type === "datetime" && new Date(this.minX).getUTCFullYear() < 1e3)) {
        var t2 = (this.minX + this.maxX) / 2, i = this.minX - (t2 - this.minX), a2 = this.maxX - (t2 - this.maxX), s2 = this._getNewMinXMaxX(i, a2);
        e2.globals.disableZoomOut || this.zoomUpdateOptions(s2.minX, s2.maxX);
      }
    } }, { key: "_getNewMinXMaxX", value: function(e2, t2) {
      var i = this.w.config.xaxis.convertedCatToNumeric;
      return { minX: i ? Math.floor(e2) : e2, maxX: i ? Math.floor(t2) : t2 };
    } }, { key: "zoomUpdateOptions", value: function(e2, t2) {
      var i = this.w;
      if (e2 !== void 0 || t2 !== void 0) {
        if (!(i.config.xaxis.convertedCatToNumeric && (e2 < 1 && (e2 = 1, t2 = i.globals.dataPoints), t2 - e2 < 2))) {
          var a2 = { min: e2, max: t2 }, s2 = this.getBeforeZoomRange(a2);
          s2 && (a2 = s2.xaxis);
          var r = { xaxis: a2 }, n2 = P2.clone(i.globals.initialConfig.yaxis);
          i.config.chart.zoom.autoScaleYaxis && (n2 = new we2(this.ctx).autoScaleY(this.ctx, n2, { xaxis: a2 })), i.config.chart.group || (r.yaxis = n2), this.w.globals.zoomed = true, this.ctx.updateHelpers._updateOptions(r, false, this.w.config.chart.animations.dynamicAnimation.enabled), this.zoomCallback(a2, n2);
        }
      } else
        this.handleZoomReset();
    } }, { key: "zoomCallback", value: function(e2, t2) {
      typeof this.ev.zoomed == "function" && this.ev.zoomed(this.ctx, { xaxis: e2, yaxis: t2 });
    } }, { key: "getBeforeZoomRange", value: function(e2, t2) {
      var i = null;
      return typeof this.ev.beforeZoom == "function" && (i = this.ev.beforeZoom(this, { xaxis: e2, yaxis: t2 })), i;
    } }, { key: "toggleMenu", value: function() {
      var e2 = this;
      window.setTimeout(function() {
        e2.elMenu.classList.contains("apexcharts-menu-open") ? e2.elMenu.classList.remove("apexcharts-menu-open") : e2.elMenu.classList.add("apexcharts-menu-open");
      }, 0);
    } }, { key: "handleDownload", value: function(e2) {
      var t2 = this.w, i = new Ee(this.ctx);
      switch (e2) {
        case "svg":
          i.exportToSVG(this.ctx);
          break;
        case "png":
          i.exportToPng(this.ctx);
          break;
        case "csv":
          i.exportToCSV({ series: t2.config.series, columnDelimiter: t2.config.chart.toolbar.export.csv.columnDelimiter });
      }
    } }, { key: "handleZoomReset", value: function(e2) {
      this.ctx.getSyncedCharts().forEach(function(t2) {
        var i = t2.w;
        if (i.globals.lastXAxis.min = i.globals.initialConfig.xaxis.min, i.globals.lastXAxis.max = i.globals.initialConfig.xaxis.max, t2.updateHelpers.revertDefaultAxisMinMax(), typeof i.config.chart.events.beforeResetZoom == "function") {
          var a2 = i.config.chart.events.beforeResetZoom(t2, i);
          a2 && t2.updateHelpers.revertDefaultAxisMinMax(a2);
        }
        typeof i.config.chart.events.zoomed == "function" && t2.ctx.toolbar.zoomCallback({ min: i.config.xaxis.min, max: i.config.xaxis.max }), i.globals.zoomed = false;
        var s2 = t2.ctx.series.emptyCollapsedSeries(P2.clone(i.globals.initialSeries));
        t2.updateHelpers._updateSeries(s2, i.config.chart.animations.dynamicAnimation.enabled);
      });
    } }, { key: "destroy", value: function() {
      this.elZoom = null, this.elZoomIn = null, this.elZoomOut = null, this.elPan = null, this.elSelection = null, this.elZoomReset = null, this.elMenuIcon = null;
    } }]), y2;
  }(), Pt2 = function(y2) {
    ge2(t2, et2);
    var e2 = ue2(t2);
    function t2(i) {
      var a2;
      return F2(this, t2), (a2 = e2.call(this, i)).ctx = i, a2.w = i.w, a2.dragged = false, a2.graphics = new M2(a2.ctx), a2.eventList = ["mousedown", "mouseleave", "mousemove", "touchstart", "touchmove", "mouseup", "touchend"], a2.clientX = 0, a2.clientY = 0, a2.startX = 0, a2.endX = 0, a2.dragX = 0, a2.startY = 0, a2.endY = 0, a2.dragY = 0, a2.moveDirection = "none", a2;
    }
    return Y2(t2, [{ key: "init", value: function(i) {
      var a2 = this, s2 = i.xyRatios, r = this.w, n2 = this;
      this.xyRatios = s2, this.zoomRect = this.graphics.drawRect(0, 0, 0, 0), this.selectionRect = this.graphics.drawRect(0, 0, 0, 0), this.gridRect = r.globals.dom.baseEl.querySelector(".apexcharts-grid"), this.zoomRect.node.classList.add("apexcharts-zoom-rect"), this.selectionRect.node.classList.add("apexcharts-selection-rect"), r.globals.dom.elGraphical.add(this.zoomRect), r.globals.dom.elGraphical.add(this.selectionRect), r.config.chart.selection.type === "x" ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, minY: 0, maxX: r.globals.gridWidth, maxY: r.globals.gridHeight }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : r.config.chart.selection.type === "y" ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, maxX: r.globals.gridWidth }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : this.slDraggableRect = this.selectionRect.draggable().on("dragmove", this.selectionDragging.bind(this, "dragging")), this.preselectedSelection(), this.hoverArea = r.globals.dom.baseEl.querySelector("".concat(r.globals.chartClass, " .apexcharts-svg")), this.hoverArea.classList.add("apexcharts-zoomable"), this.eventList.forEach(function(o2) {
        a2.hoverArea.addEventListener(o2, n2.svgMouseEvents.bind(n2, s2), { capture: false, passive: true });
      });
    } }, { key: "destroy", value: function() {
      this.slDraggableRect && (this.slDraggableRect.draggable(false), this.slDraggableRect.off(), this.selectionRect.off()), this.selectionRect = null, this.zoomRect = null, this.gridRect = null;
    } }, { key: "svgMouseEvents", value: function(i, a2) {
      var s2 = this.w, r = this, n2 = this.ctx.toolbar, o2 = s2.globals.zoomEnabled ? s2.config.chart.zoom.type : s2.config.chart.selection.type, h2 = s2.config.chart.toolbar.autoSelected;
      if (a2.shiftKey ? (this.shiftWasPressed = true, n2.enableZoomPanFromToolbar(h2 === "pan" ? "zoom" : "pan")) : this.shiftWasPressed && (n2.enableZoomPanFromToolbar(h2), this.shiftWasPressed = false), a2.target) {
        var c2, d2 = a2.target.classList;
        if (a2.target.parentNode && a2.target.parentNode !== null && (c2 = a2.target.parentNode.classList), !(d2.contains("apexcharts-selection-rect") || d2.contains("apexcharts-legend-marker") || d2.contains("apexcharts-legend-text") || c2 && c2.contains("apexcharts-toolbar"))) {
          if (r.clientX = a2.type === "touchmove" || a2.type === "touchstart" ? a2.touches[0].clientX : a2.type === "touchend" ? a2.changedTouches[0].clientX : a2.clientX, r.clientY = a2.type === "touchmove" || a2.type === "touchstart" ? a2.touches[0].clientY : a2.type === "touchend" ? a2.changedTouches[0].clientY : a2.clientY, a2.type === "mousedown" && a2.which === 1) {
            var g2 = r.gridRect.getBoundingClientRect();
            r.startX = r.clientX - g2.left, r.startY = r.clientY - g2.top, r.dragged = false, r.w.globals.mousedown = true;
          }
          if ((a2.type === "mousemove" && a2.which === 1 || a2.type === "touchmove") && (r.dragged = true, s2.globals.panEnabled ? (s2.globals.selection = null, r.w.globals.mousedown && r.panDragging({ context: r, zoomtype: o2, xyRatios: i })) : (r.w.globals.mousedown && s2.globals.zoomEnabled || r.w.globals.mousedown && s2.globals.selectionEnabled) && (r.selection = r.selectionDrawing({ context: r, zoomtype: o2 }))), a2.type === "mouseup" || a2.type === "touchend" || a2.type === "mouseleave") {
            var p2 = r.gridRect.getBoundingClientRect();
            r.w.globals.mousedown && (r.endX = r.clientX - p2.left, r.endY = r.clientY - p2.top, r.dragX = Math.abs(r.endX - r.startX), r.dragY = Math.abs(r.endY - r.startY), (s2.globals.zoomEnabled || s2.globals.selectionEnabled) && r.selectionDrawn({ context: r, zoomtype: o2 }), s2.globals.panEnabled && s2.config.xaxis.convertedCatToNumeric && r.delayedPanScrolled()), s2.globals.zoomEnabled && r.hideSelectionRect(this.selectionRect), r.dragged = false, r.w.globals.mousedown = false;
          }
          this.makeSelectionRectDraggable();
        }
      }
    } }, { key: "makeSelectionRectDraggable", value: function() {
      var i = this.w;
      if (this.selectionRect) {
        var a2 = this.selectionRect.node.getBoundingClientRect();
        a2.width > 0 && a2.height > 0 && this.slDraggableRect.selectize({ points: "l, r", pointSize: 8, pointType: "rect" }).resize({ constraint: { minX: 0, minY: 0, maxX: i.globals.gridWidth, maxY: i.globals.gridHeight } }).on("resizing", this.selectionDragging.bind(this, "resizing"));
      }
    } }, { key: "preselectedSelection", value: function() {
      var i = this.w, a2 = this.xyRatios;
      if (!i.globals.zoomEnabled) {
        if (i.globals.selection !== void 0 && i.globals.selection !== null)
          this.drawSelectionRect(i.globals.selection);
        else if (i.config.chart.selection.xaxis.min !== void 0 && i.config.chart.selection.xaxis.max !== void 0) {
          var s2 = (i.config.chart.selection.xaxis.min - i.globals.minX) / a2.xRatio, r = i.globals.gridWidth - (i.globals.maxX - i.config.chart.selection.xaxis.max) / a2.xRatio - s2;
          i.globals.isRangeBar && (s2 = (i.config.chart.selection.xaxis.min - i.globals.yAxisScale[0].niceMin) / a2.invertedYRatio, r = (i.config.chart.selection.xaxis.max - i.config.chart.selection.xaxis.min) / a2.invertedYRatio);
          var n2 = { x: s2, y: 0, width: r, height: i.globals.gridHeight, translateX: 0, translateY: 0, selectionEnabled: true };
          this.drawSelectionRect(n2), this.makeSelectionRectDraggable(), typeof i.config.chart.events.selection == "function" && i.config.chart.events.selection(this.ctx, { xaxis: { min: i.config.chart.selection.xaxis.min, max: i.config.chart.selection.xaxis.max }, yaxis: {} });
        }
      }
    } }, { key: "drawSelectionRect", value: function(i) {
      var a2 = i.x, s2 = i.y, r = i.width, n2 = i.height, o2 = i.translateX, h2 = o2 === void 0 ? 0 : o2, c2 = i.translateY, d2 = c2 === void 0 ? 0 : c2, g2 = this.w, p2 = this.zoomRect, f2 = this.selectionRect;
      if (this.dragged || g2.globals.selection !== null) {
        var b2 = { transform: "translate(" + h2 + ", " + d2 + ")" };
        g2.globals.zoomEnabled && this.dragged && (r < 0 && (r = 1), p2.attr({ x: a2, y: s2, width: r, height: n2, fill: g2.config.chart.zoom.zoomedArea.fill.color, "fill-opacity": g2.config.chart.zoom.zoomedArea.fill.opacity, stroke: g2.config.chart.zoom.zoomedArea.stroke.color, "stroke-width": g2.config.chart.zoom.zoomedArea.stroke.width, "stroke-opacity": g2.config.chart.zoom.zoomedArea.stroke.opacity }), M2.setAttrs(p2.node, b2)), g2.globals.selectionEnabled && (f2.attr({ x: a2, y: s2, width: r > 0 ? r : 0, height: n2 > 0 ? n2 : 0, fill: g2.config.chart.selection.fill.color, "fill-opacity": g2.config.chart.selection.fill.opacity, stroke: g2.config.chart.selection.stroke.color, "stroke-width": g2.config.chart.selection.stroke.width, "stroke-dasharray": g2.config.chart.selection.stroke.dashArray, "stroke-opacity": g2.config.chart.selection.stroke.opacity }), M2.setAttrs(f2.node, b2));
      }
    } }, { key: "hideSelectionRect", value: function(i) {
      i && i.attr({ x: 0, y: 0, width: 0, height: 0 });
    } }, { key: "selectionDrawing", value: function(i) {
      var a2 = i.context, s2 = i.zoomtype, r = this.w, n2 = a2, o2 = this.gridRect.getBoundingClientRect(), h2 = n2.startX - 1, c2 = n2.startY, d2 = false, g2 = false, p2 = n2.clientX - o2.left - h2, f2 = n2.clientY - o2.top - c2, b2 = {};
      return Math.abs(p2 + h2) > r.globals.gridWidth ? p2 = r.globals.gridWidth - h2 : n2.clientX - o2.left < 0 && (p2 = h2), h2 > n2.clientX - o2.left && (d2 = true, p2 = Math.abs(p2)), c2 > n2.clientY - o2.top && (g2 = true, f2 = Math.abs(f2)), b2 = s2 === "x" ? { x: d2 ? h2 - p2 : h2, y: 0, width: p2, height: r.globals.gridHeight } : s2 === "y" ? { x: 0, y: g2 ? c2 - f2 : c2, width: r.globals.gridWidth, height: f2 } : { x: d2 ? h2 - p2 : h2, y: g2 ? c2 - f2 : c2, width: p2, height: f2 }, n2.drawSelectionRect(b2), n2.selectionDragging("resizing"), b2;
    } }, { key: "selectionDragging", value: function(i, a2) {
      var s2 = this, r = this.w, n2 = this.xyRatios, o2 = this.selectionRect, h2 = 0;
      i === "resizing" && (h2 = 30);
      var c2 = function(g2) {
        return parseFloat(o2.node.getAttribute(g2));
      }, d2 = { x: c2("x"), y: c2("y"), width: c2("width"), height: c2("height") };
      r.globals.selection = d2, typeof r.config.chart.events.selection == "function" && r.globals.selectionEnabled && (clearTimeout(this.w.globals.selectionResizeTimer), this.w.globals.selectionResizeTimer = window.setTimeout(function() {
        var g2, p2, f2, b2, m2 = s2.gridRect.getBoundingClientRect(), w2 = o2.node.getBoundingClientRect();
        r.globals.isRangeBar ? (g2 = r.globals.yAxisScale[0].niceMin + (w2.left - m2.left) * n2.invertedYRatio, p2 = r.globals.yAxisScale[0].niceMin + (w2.right - m2.left) * n2.invertedYRatio, f2 = 0, b2 = 1) : (g2 = r.globals.xAxisScale.niceMin + (w2.left - m2.left) * n2.xRatio, p2 = r.globals.xAxisScale.niceMin + (w2.right - m2.left) * n2.xRatio, f2 = r.globals.yAxisScale[0].niceMin + (m2.bottom - w2.bottom) * n2.yRatio[0], b2 = r.globals.yAxisScale[0].niceMax - (w2.top - m2.top) * n2.yRatio[0]);
        var A2 = { xaxis: { min: g2, max: p2 }, yaxis: { min: f2, max: b2 } };
        r.config.chart.events.selection(s2.ctx, A2), r.config.chart.brush.enabled && r.config.chart.events.brushScrolled !== void 0 && r.config.chart.events.brushScrolled(s2.ctx, A2);
      }, h2));
    } }, { key: "selectionDrawn", value: function(i) {
      var a2 = i.context, s2 = i.zoomtype, r = this.w, n2 = a2, o2 = this.xyRatios, h2 = this.ctx.toolbar;
      if (n2.startX > n2.endX) {
        var c2 = n2.startX;
        n2.startX = n2.endX, n2.endX = c2;
      }
      if (n2.startY > n2.endY) {
        var d2 = n2.startY;
        n2.startY = n2.endY, n2.endY = d2;
      }
      var g2 = void 0, p2 = void 0;
      r.globals.isRangeBar ? (g2 = r.globals.yAxisScale[0].niceMin + n2.startX * o2.invertedYRatio, p2 = r.globals.yAxisScale[0].niceMin + n2.endX * o2.invertedYRatio) : (g2 = r.globals.xAxisScale.niceMin + n2.startX * o2.xRatio, p2 = r.globals.xAxisScale.niceMin + n2.endX * o2.xRatio);
      var f2 = [], b2 = [];
      if (r.config.yaxis.forEach(function(k2, S2) {
        f2.push(r.globals.yAxisScale[S2].niceMax - o2.yRatio[S2] * n2.startY), b2.push(r.globals.yAxisScale[S2].niceMax - o2.yRatio[S2] * n2.endY);
      }), n2.dragged && (n2.dragX > 10 || n2.dragY > 10) && g2 !== p2) {
        if (r.globals.zoomEnabled) {
          var m2 = P2.clone(r.globals.initialConfig.yaxis), w2 = P2.clone(r.globals.initialConfig.xaxis);
          if (r.globals.zoomed = true, r.config.xaxis.convertedCatToNumeric && (g2 = Math.floor(g2), p2 = Math.floor(p2), g2 < 1 && (g2 = 1, p2 = r.globals.dataPoints), p2 - g2 < 2 && (p2 = g2 + 1)), s2 !== "xy" && s2 !== "x" || (w2 = { min: g2, max: p2 }), s2 !== "xy" && s2 !== "y" || m2.forEach(function(k2, S2) {
            m2[S2].min = b2[S2], m2[S2].max = f2[S2];
          }), r.config.chart.zoom.autoScaleYaxis) {
            var A2 = new we2(n2.ctx);
            m2 = A2.autoScaleY(n2.ctx, m2, { xaxis: w2 });
          }
          if (h2) {
            var l2 = h2.getBeforeZoomRange(w2, m2);
            l2 && (w2 = l2.xaxis ? l2.xaxis : w2, m2 = l2.yaxis ? l2.yaxis : m2);
          }
          var u2 = { xaxis: w2 };
          r.config.chart.group || (u2.yaxis = m2), n2.ctx.updateHelpers._updateOptions(u2, false, n2.w.config.chart.animations.dynamicAnimation.enabled), typeof r.config.chart.events.zoomed == "function" && h2.zoomCallback(w2, m2);
        } else if (r.globals.selectionEnabled) {
          var x2, v2 = null;
          x2 = { min: g2, max: p2 }, s2 !== "xy" && s2 !== "y" || (v2 = P2.clone(r.config.yaxis)).forEach(function(k2, S2) {
            v2[S2].min = b2[S2], v2[S2].max = f2[S2];
          }), r.globals.selection = n2.selection, typeof r.config.chart.events.selection == "function" && r.config.chart.events.selection(n2.ctx, { xaxis: x2, yaxis: v2 });
        }
      }
    } }, { key: "panDragging", value: function(i) {
      var a2 = i.context, s2 = this.w, r = a2;
      if (s2.globals.lastClientPosition.x !== void 0) {
        var n2 = s2.globals.lastClientPosition.x - r.clientX, o2 = s2.globals.lastClientPosition.y - r.clientY;
        Math.abs(n2) > Math.abs(o2) && n2 > 0 ? this.moveDirection = "left" : Math.abs(n2) > Math.abs(o2) && n2 < 0 ? this.moveDirection = "right" : Math.abs(o2) > Math.abs(n2) && o2 > 0 ? this.moveDirection = "up" : Math.abs(o2) > Math.abs(n2) && o2 < 0 && (this.moveDirection = "down");
      }
      s2.globals.lastClientPosition = { x: r.clientX, y: r.clientY };
      var h2 = s2.globals.isRangeBar ? s2.globals.minY : s2.globals.minX, c2 = s2.globals.isRangeBar ? s2.globals.maxY : s2.globals.maxX;
      s2.config.xaxis.convertedCatToNumeric || r.panScrolled(h2, c2);
    } }, { key: "delayedPanScrolled", value: function() {
      var i = this.w, a2 = i.globals.minX, s2 = i.globals.maxX, r = (i.globals.maxX - i.globals.minX) / 2;
      this.moveDirection === "left" ? (a2 = i.globals.minX + r, s2 = i.globals.maxX + r) : this.moveDirection === "right" && (a2 = i.globals.minX - r, s2 = i.globals.maxX - r), a2 = Math.floor(a2), s2 = Math.floor(s2), this.updateScrolledChart({ xaxis: { min: a2, max: s2 } }, a2, s2);
    } }, { key: "panScrolled", value: function(i, a2) {
      var s2 = this.w, r = this.xyRatios, n2 = P2.clone(s2.globals.initialConfig.yaxis), o2 = r.xRatio, h2 = s2.globals.minX, c2 = s2.globals.maxX;
      s2.globals.isRangeBar && (o2 = r.invertedYRatio, h2 = s2.globals.minY, c2 = s2.globals.maxY), this.moveDirection === "left" ? (i = h2 + s2.globals.gridWidth / 15 * o2, a2 = c2 + s2.globals.gridWidth / 15 * o2) : this.moveDirection === "right" && (i = h2 - s2.globals.gridWidth / 15 * o2, a2 = c2 - s2.globals.gridWidth / 15 * o2), s2.globals.isRangeBar || (i < s2.globals.initialMinX || a2 > s2.globals.initialMaxX) && (i = h2, a2 = c2);
      var d2 = { min: i, max: a2 };
      s2.config.chart.zoom.autoScaleYaxis && (n2 = new we2(this.ctx).autoScaleY(this.ctx, n2, { xaxis: d2 }));
      var g2 = { xaxis: { min: i, max: a2 } };
      s2.config.chart.group || (g2.yaxis = n2), this.updateScrolledChart(g2, i, a2);
    } }, { key: "updateScrolledChart", value: function(i, a2, s2) {
      var r = this.w;
      this.ctx.updateHelpers._updateOptions(i, false, false), typeof r.config.chart.events.scrolled == "function" && r.config.chart.events.scrolled(this.ctx, { xaxis: { min: a2, max: s2 } });
    } }]), t2;
  }(), tt2 = function() {
    function y2(e2) {
      F2(this, y2), this.w = e2.w, this.ttCtx = e2, this.ctx = e2.ctx;
    }
    return Y2(y2, [{ key: "getNearestValues", value: function(e2) {
      var t2 = e2.hoverArea, i = e2.elGrid, a2 = e2.clientX, s2 = e2.clientY, r = this.w, n2 = i.getBoundingClientRect(), o2 = n2.width, h2 = n2.height, c2 = o2 / (r.globals.dataPoints - 1), d2 = h2 / r.globals.dataPoints, g2 = this.hasBars();
      !r.globals.comboCharts && !g2 || r.config.xaxis.convertedCatToNumeric || (c2 = o2 / r.globals.dataPoints);
      var p2 = a2 - n2.left - r.globals.barPadForNumericAxis, f2 = s2 - n2.top;
      p2 < 0 || f2 < 0 || p2 > o2 || f2 > h2 ? (t2.classList.remove("hovering-zoom"), t2.classList.remove("hovering-pan")) : r.globals.zoomEnabled ? (t2.classList.remove("hovering-pan"), t2.classList.add("hovering-zoom")) : r.globals.panEnabled && (t2.classList.remove("hovering-zoom"), t2.classList.add("hovering-pan"));
      var b2 = Math.round(p2 / c2), m2 = Math.floor(f2 / d2);
      g2 && !r.config.xaxis.convertedCatToNumeric && (b2 = Math.ceil(p2 / c2), b2 -= 1);
      var w2 = null, A2 = null, l2 = r.globals.seriesXvalues.map(function(S2) {
        return S2.filter(function(C2) {
          return P2.isNumber(C2);
        });
      }), u2 = r.globals.seriesYvalues.map(function(S2) {
        return S2.filter(function(C2) {
          return P2.isNumber(C2);
        });
      });
      if (r.globals.isXNumeric) {
        var x2 = this.ttCtx.getElGrid().getBoundingClientRect(), v2 = p2 * (x2.width / o2), k2 = f2 * (x2.height / h2);
        w2 = (A2 = this.closestInMultiArray(v2, k2, l2, u2)).index, b2 = A2.j, w2 !== null && (l2 = r.globals.seriesXvalues[w2], b2 = (A2 = this.closestInArray(v2, l2)).index);
      }
      return r.globals.capturedSeriesIndex = w2 === null ? -1 : w2, (!b2 || b2 < 1) && (b2 = 0), r.globals.isBarHorizontal ? r.globals.capturedDataPointIndex = m2 : r.globals.capturedDataPointIndex = b2, { capturedSeries: w2, j: r.globals.isBarHorizontal ? m2 : b2, hoverX: p2, hoverY: f2 };
    } }, { key: "closestInMultiArray", value: function(e2, t2, i, a2) {
      var s2 = this.w, r = 0, n2 = null, o2 = -1;
      s2.globals.series.length > 1 ? r = this.getFirstActiveXArray(i) : n2 = 0;
      var h2 = i[r][0], c2 = Math.abs(e2 - h2);
      if (i.forEach(function(p2) {
        p2.forEach(function(f2, b2) {
          var m2 = Math.abs(e2 - f2);
          m2 <= c2 && (c2 = m2, o2 = b2);
        });
      }), o2 !== -1) {
        var d2 = a2[r][o2], g2 = Math.abs(t2 - d2);
        n2 = r, a2.forEach(function(p2, f2) {
          var b2 = Math.abs(t2 - p2[o2]);
          b2 <= g2 && (g2 = b2, n2 = f2);
        });
      }
      return { index: n2, j: o2 };
    } }, { key: "getFirstActiveXArray", value: function(e2) {
      for (var t2 = this.w, i = 0, a2 = e2.map(function(r, n2) {
        return r.length > 0 ? n2 : -1;
      }), s2 = 0; s2 < a2.length; s2++)
        if (a2[s2] !== -1 && t2.globals.collapsedSeriesIndices.indexOf(s2) === -1 && t2.globals.ancillaryCollapsedSeriesIndices.indexOf(s2) === -1) {
          i = a2[s2];
          break;
        }
      return i;
    } }, { key: "closestInArray", value: function(e2, t2) {
      for (var i = t2[0], a2 = null, s2 = Math.abs(e2 - i), r = 0; r < t2.length; r++) {
        var n2 = Math.abs(e2 - t2[r]);
        n2 < s2 && (s2 = n2, a2 = r);
      }
      return { index: a2 };
    } }, { key: "isXoverlap", value: function(e2) {
      var t2 = [], i = this.w.globals.seriesX.filter(function(s2) {
        return s2[0] !== void 0;
      });
      if (i.length > 0)
        for (var a2 = 0; a2 < i.length - 1; a2++)
          i[a2][e2] !== void 0 && i[a2 + 1][e2] !== void 0 && i[a2][e2] !== i[a2 + 1][e2] && t2.push("unEqual");
      return t2.length === 0;
    } }, { key: "isInitialSeriesSameLen", value: function() {
      for (var e2 = true, t2 = this.w.globals.initialSeries, i = 0; i < t2.length - 1; i++)
        if (t2[i].data.length !== t2[i + 1].data.length) {
          e2 = false;
          break;
        }
      return e2;
    } }, { key: "getBarsHeight", value: function(e2) {
      return J2(e2).reduce(function(t2, i) {
        return t2 + i.getBBox().height;
      }, 0);
    } }, { key: "getElMarkers", value: function(e2) {
      return typeof e2 == "number" ? this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:realIndex='".concat(e2, "'] .apexcharts-series-markers-wrap > *")) : this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap > *");
    } }, { key: "getAllMarkers", value: function() {
      var e2 = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap");
      (e2 = J2(e2)).sort(function(i, a2) {
        var s2 = Number(i.getAttribute("data:realIndex")), r = Number(a2.getAttribute("data:realIndex"));
        return r < s2 ? 1 : r > s2 ? -1 : 0;
      });
      var t2 = [];
      return e2.forEach(function(i) {
        t2.push(i.querySelector(".apexcharts-marker"));
      }), t2;
    } }, { key: "hasMarkers", value: function(e2) {
      return this.getElMarkers(e2).length > 0;
    } }, { key: "getElBars", value: function() {
      return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-boxPlot-series, .apexcharts-rangebar-series");
    } }, { key: "hasBars", value: function() {
      return this.getElBars().length > 0;
    } }, { key: "getHoverMarkerSize", value: function(e2) {
      var t2 = this.w, i = t2.config.markers.hover.size;
      return i === void 0 && (i = t2.globals.markers.size[e2] + t2.config.markers.hover.sizeOffset), i;
    } }, { key: "toggleAllTooltipSeriesGroups", value: function(e2) {
      var t2 = this.w, i = this.ttCtx;
      i.allTooltipSeriesGroups.length === 0 && (i.allTooltipSeriesGroups = t2.globals.dom.baseEl.querySelectorAll(".apexcharts-tooltip-series-group"));
      for (var a2 = i.allTooltipSeriesGroups, s2 = 0; s2 < a2.length; s2++)
        e2 === "enable" ? (a2[s2].classList.add("apexcharts-active"), a2[s2].style.display = t2.config.tooltip.items.display) : (a2[s2].classList.remove("apexcharts-active"), a2[s2].style.display = "none");
    } }]), y2;
  }(), It2 = function() {
    function y2(e2) {
      F2(this, y2), this.w = e2.w, this.ctx = e2.ctx, this.ttCtx = e2, this.tooltipUtil = new tt2(e2);
    }
    return Y2(y2, [{ key: "drawSeriesTexts", value: function(e2) {
      var t2 = e2.shared, i = t2 === void 0 || t2, a2 = e2.ttItems, s2 = e2.i, r = s2 === void 0 ? 0 : s2, n2 = e2.j, o2 = n2 === void 0 ? null : n2, h2 = e2.y1, c2 = e2.y2, d2 = e2.e, g2 = this.w;
      g2.config.tooltip.custom !== void 0 ? this.handleCustomTooltip({ i: r, j: o2, y1: h2, y2: c2, w: g2 }) : this.toggleActiveInactiveSeries(i);
      var p2 = this.getValuesToPrint({ i: r, j: o2 });
      this.printLabels({ i: r, j: o2, values: p2, ttItems: a2, shared: i, e: d2 });
      var f2 = this.ttCtx.getElTooltip();
      this.ttCtx.tooltipRect.ttWidth = f2.getBoundingClientRect().width, this.ttCtx.tooltipRect.ttHeight = f2.getBoundingClientRect().height;
    } }, { key: "printLabels", value: function(e2) {
      var t2, i = this, a2 = e2.i, s2 = e2.j, r = e2.values, n2 = e2.ttItems, o2 = e2.shared, h2 = e2.e, c2 = this.w, d2 = [], g2 = function(x2) {
        return c2.globals.seriesGoals[x2] && c2.globals.seriesGoals[x2][s2] && Array.isArray(c2.globals.seriesGoals[x2][s2]);
      }, p2 = r.xVal, f2 = r.zVal, b2 = r.xAxisTTVal, m2 = "", w2 = c2.globals.colors[a2];
      s2 !== null && c2.config.plotOptions.bar.distributed && (w2 = c2.globals.colors[s2]);
      for (var A2 = function(x2, v2) {
        var k2 = i.getFormatters(a2);
        m2 = i.getSeriesName({ fn: k2.yLbTitleFormatter, index: a2, seriesIndex: a2, j: s2 }), c2.config.chart.type === "treemap" && (m2 = k2.yLbTitleFormatter(String(c2.config.series[a2].data[s2].x), { series: c2.globals.series, seriesIndex: a2, dataPointIndex: s2, w: c2 }));
        var S2 = c2.config.tooltip.inverseOrder ? v2 : x2;
        if (c2.globals.axisCharts) {
          var C2 = function(z2) {
            var T2, E2, R2, O2;
            return c2.globals.isRangeData ? k2.yLbFormatter((T2 = c2.globals.seriesRangeStart) === null || T2 === void 0 || (E2 = T2[z2]) === null || E2 === void 0 ? void 0 : E2[s2], { series: c2.globals.seriesRangeStart, seriesIndex: z2, dataPointIndex: s2, w: c2 }) + " - " + k2.yLbFormatter((R2 = c2.globals.seriesRangeEnd) === null || R2 === void 0 || (O2 = R2[z2]) === null || O2 === void 0 ? void 0 : O2[s2], { series: c2.globals.seriesRangeEnd, seriesIndex: z2, dataPointIndex: s2, w: c2 }) : k2.yLbFormatter(c2.globals.series[z2][s2], { series: c2.globals.series, seriesIndex: z2, dataPointIndex: s2, w: c2 });
          };
          if (o2)
            k2 = i.getFormatters(S2), m2 = i.getSeriesName({ fn: k2.yLbTitleFormatter, index: S2, seriesIndex: a2, j: s2 }), w2 = c2.globals.colors[S2], t2 = C2(S2), g2(S2) && (d2 = c2.globals.seriesGoals[S2][s2].map(function(z2) {
              return { attrs: z2, val: k2.yLbFormatter(z2.value, { seriesIndex: S2, dataPointIndex: s2, w: c2 }) };
            }));
          else {
            var L2, I2 = h2 == null || (L2 = h2.target) === null || L2 === void 0 ? void 0 : L2.getAttribute("fill");
            I2 && (w2 = I2.indexOf("url") !== -1 ? document.querySelector(I2.substr(4).slice(0, -1)).childNodes[0].getAttribute("stroke") : I2), t2 = C2(a2), g2(a2) && Array.isArray(c2.globals.seriesGoals[a2][s2]) && (d2 = c2.globals.seriesGoals[a2][s2].map(function(z2) {
              return { attrs: z2, val: k2.yLbFormatter(z2.value, { seriesIndex: a2, dataPointIndex: s2, w: c2 }) };
            }));
          }
        }
        s2 === null && (t2 = k2.yLbFormatter(c2.globals.series[a2], X2(X2({}, c2), {}, { seriesIndex: a2, dataPointIndex: a2 }))), i.DOMHandling({ i: a2, t: S2, j: s2, ttItems: n2, values: { val: t2, goalVals: d2, xVal: p2, xAxisTTVal: b2, zVal: f2 }, seriesName: m2, shared: o2, pColor: w2 });
      }, l2 = 0, u2 = c2.globals.series.length - 1; l2 < c2.globals.series.length; l2++, u2--)
        A2(l2, u2);
    } }, { key: "getFormatters", value: function(e2) {
      var t2, i = this.w, a2 = i.globals.yLabelFormatters[e2];
      return i.globals.ttVal !== void 0 ? Array.isArray(i.globals.ttVal) ? (a2 = i.globals.ttVal[e2] && i.globals.ttVal[e2].formatter, t2 = i.globals.ttVal[e2] && i.globals.ttVal[e2].title && i.globals.ttVal[e2].title.formatter) : (a2 = i.globals.ttVal.formatter, typeof i.globals.ttVal.title.formatter == "function" && (t2 = i.globals.ttVal.title.formatter)) : t2 = i.config.tooltip.y.title.formatter, typeof a2 != "function" && (a2 = i.globals.yLabelFormatters[0] ? i.globals.yLabelFormatters[0] : function(s2) {
        return s2;
      }), typeof t2 != "function" && (t2 = function(s2) {
        return s2;
      }), { yLbFormatter: a2, yLbTitleFormatter: t2 };
    } }, { key: "getSeriesName", value: function(e2) {
      var t2 = e2.fn, i = e2.index, a2 = e2.seriesIndex, s2 = e2.j, r = this.w;
      return t2(String(r.globals.seriesNames[i]), { series: r.globals.series, seriesIndex: a2, dataPointIndex: s2, w: r });
    } }, { key: "DOMHandling", value: function(e2) {
      e2.i;
      var t2 = e2.t, i = e2.j, a2 = e2.ttItems, s2 = e2.values, r = e2.seriesName, n2 = e2.shared, o2 = e2.pColor, h2 = this.w, c2 = this.ttCtx, d2 = s2.val, g2 = s2.goalVals, p2 = s2.xVal, f2 = s2.xAxisTTVal, b2 = s2.zVal, m2 = null;
      m2 = a2[t2].children, h2.config.tooltip.fillSeriesColor && (a2[t2].style.backgroundColor = o2, m2[0].style.display = "none"), c2.showTooltipTitle && (c2.tooltipTitle === null && (c2.tooltipTitle = h2.globals.dom.baseEl.querySelector(".apexcharts-tooltip-title")), c2.tooltipTitle.innerHTML = p2), c2.isXAxisTooltipEnabled && (c2.xaxisTooltipText.innerHTML = f2 !== "" ? f2 : p2);
      var w2 = a2[t2].querySelector(".apexcharts-tooltip-text-y-label");
      w2 && (w2.innerHTML = r || "");
      var A2 = a2[t2].querySelector(".apexcharts-tooltip-text-y-value");
      A2 && (A2.innerHTML = d2 !== void 0 ? d2 : ""), m2[0] && m2[0].classList.contains("apexcharts-tooltip-marker") && (h2.config.tooltip.marker.fillColors && Array.isArray(h2.config.tooltip.marker.fillColors) && (o2 = h2.config.tooltip.marker.fillColors[t2]), m2[0].style.backgroundColor = o2), h2.config.tooltip.marker.show || (m2[0].style.display = "none");
      var l2 = a2[t2].querySelector(".apexcharts-tooltip-text-goals-label"), u2 = a2[t2].querySelector(".apexcharts-tooltip-text-goals-value");
      if (g2.length && h2.globals.seriesGoals[t2]) {
        var x2 = function() {
          var S2 = "<div >", C2 = "<div>";
          g2.forEach(function(L2, I2) {
            S2 += ' <div style="display: flex"><span class="apexcharts-tooltip-marker" style="background-color: '.concat(L2.attrs.strokeColor, '; height: 3px; border-radius: 0; top: 5px;"></span> ').concat(L2.attrs.name, "</div>"), C2 += "<div>".concat(L2.val, "</div>");
          }), l2.innerHTML = S2 + "</div>", u2.innerHTML = C2 + "</div>";
        };
        n2 ? h2.globals.seriesGoals[t2][i] && Array.isArray(h2.globals.seriesGoals[t2][i]) ? x2() : (l2.innerHTML = "", u2.innerHTML = "") : x2();
      } else
        l2.innerHTML = "", u2.innerHTML = "";
      if (b2 !== null && (a2[t2].querySelector(".apexcharts-tooltip-text-z-label").innerHTML = h2.config.tooltip.z.title, a2[t2].querySelector(".apexcharts-tooltip-text-z-value").innerHTML = b2 !== void 0 ? b2 : ""), n2 && m2[0]) {
        if (h2.config.tooltip.hideEmptySeries) {
          var v2 = a2[t2].querySelector(".apexcharts-tooltip-marker"), k2 = a2[t2].querySelector(".apexcharts-tooltip-text");
          parseFloat(d2) == 0 ? (v2.style.display = "none", k2.style.display = "none") : (v2.style.display = "block", k2.style.display = "block");
        }
        d2 == null || h2.globals.ancillaryCollapsedSeriesIndices.indexOf(t2) > -1 || h2.globals.collapsedSeriesIndices.indexOf(t2) > -1 ? m2[0].parentNode.style.display = "none" : m2[0].parentNode.style.display = h2.config.tooltip.items.display;
      }
    } }, { key: "toggleActiveInactiveSeries", value: function(e2) {
      var t2 = this.w;
      if (e2)
        this.tooltipUtil.toggleAllTooltipSeriesGroups("enable");
      else {
        this.tooltipUtil.toggleAllTooltipSeriesGroups("disable");
        var i = t2.globals.dom.baseEl.querySelector(".apexcharts-tooltip-series-group");
        i && (i.classList.add("apexcharts-active"), i.style.display = t2.config.tooltip.items.display);
      }
    } }, { key: "getValuesToPrint", value: function(e2) {
      var t2 = e2.i, i = e2.j, a2 = this.w, s2 = this.ctx.series.filteredSeriesX(), r = "", n2 = "", o2 = null, h2 = null, c2 = { series: a2.globals.series, seriesIndex: t2, dataPointIndex: i, w: a2 }, d2 = a2.globals.ttZFormatter;
      i === null ? h2 = a2.globals.series[t2] : a2.globals.isXNumeric && a2.config.chart.type !== "treemap" ? (r = s2[t2][i], s2[t2].length === 0 && (r = s2[this.tooltipUtil.getFirstActiveXArray(s2)][i])) : r = a2.globals.labels[i] !== void 0 ? a2.globals.labels[i] : "";
      var g2 = r;
      return a2.globals.isXNumeric && a2.config.xaxis.type === "datetime" ? r = new re2(this.ctx).xLabelFormat(a2.globals.ttKeyFormatter, g2, g2, { i: void 0, dateFormatter: new B3(this.ctx).formatDate, w: this.w }) : r = a2.globals.isBarHorizontal ? a2.globals.yLabelFormatters[0](g2, c2) : a2.globals.xLabelFormatter(g2, c2), a2.config.tooltip.x.formatter !== void 0 && (r = a2.globals.ttKeyFormatter(g2, c2)), a2.globals.seriesZ.length > 0 && a2.globals.seriesZ[t2].length > 0 && (o2 = d2(a2.globals.seriesZ[t2][i], a2)), n2 = typeof a2.config.xaxis.tooltip.formatter == "function" ? a2.globals.xaxisTooltipFormatter(g2, c2) : r, { val: Array.isArray(h2) ? h2.join(" ") : h2, xVal: Array.isArray(r) ? r.join(" ") : r, xAxisTTVal: Array.isArray(n2) ? n2.join(" ") : n2, zVal: o2 };
    } }, { key: "handleCustomTooltip", value: function(e2) {
      var t2 = e2.i, i = e2.j, a2 = e2.y1, s2 = e2.y2, r = e2.w, n2 = this.ttCtx.getElTooltip(), o2 = r.config.tooltip.custom;
      Array.isArray(o2) && o2[t2] && (o2 = o2[t2]), n2.innerHTML = o2({ ctx: this.ctx, series: r.globals.series, seriesIndex: t2, dataPointIndex: i, y1: a2, y2: s2, w: r });
    } }]), y2;
  }(), it2 = function() {
    function y2(e2) {
      F2(this, y2), this.ttCtx = e2, this.ctx = e2.ctx, this.w = e2.w;
    }
    return Y2(y2, [{ key: "moveXCrosshairs", value: function(e2) {
      var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, i = this.ttCtx, a2 = this.w, s2 = i.getElXCrosshairs(), r = e2 - i.xcrosshairsWidth / 2, n2 = a2.globals.labels.slice().length;
      if (t2 !== null && (r = a2.globals.gridWidth / n2 * t2), s2 === null || a2.globals.isBarHorizontal || (s2.setAttribute("x", r), s2.setAttribute("x1", r), s2.setAttribute("x2", r), s2.setAttribute("y2", a2.globals.gridHeight), s2.classList.add("apexcharts-active")), r < 0 && (r = 0), r > a2.globals.gridWidth && (r = a2.globals.gridWidth), i.isXAxisTooltipEnabled) {
        var o2 = r;
        a2.config.xaxis.crosshairs.width !== "tickWidth" && a2.config.xaxis.crosshairs.width !== "barWidth" || (o2 = r + i.xcrosshairsWidth / 2), this.moveXAxisTooltip(o2);
      }
    } }, { key: "moveYCrosshairs", value: function(e2) {
      var t2 = this.ttCtx;
      t2.ycrosshairs !== null && M2.setAttrs(t2.ycrosshairs, { y1: e2, y2: e2 }), t2.ycrosshairsHidden !== null && M2.setAttrs(t2.ycrosshairsHidden, { y1: e2, y2: e2 });
    } }, { key: "moveXAxisTooltip", value: function(e2) {
      var t2 = this.w, i = this.ttCtx;
      if (i.xaxisTooltip !== null && i.xcrosshairsWidth !== 0) {
        i.xaxisTooltip.classList.add("apexcharts-active");
        var a2 = i.xaxisOffY + t2.config.xaxis.tooltip.offsetY + t2.globals.translateY + 1 + t2.config.xaxis.offsetY;
        if (e2 -= i.xaxisTooltip.getBoundingClientRect().width / 2, !isNaN(e2)) {
          e2 += t2.globals.translateX;
          var s2;
          s2 = new M2(this.ctx).getTextRects(i.xaxisTooltipText.innerHTML), i.xaxisTooltipText.style.minWidth = s2.width + "px", i.xaxisTooltip.style.left = e2 + "px", i.xaxisTooltip.style.top = a2 + "px";
        }
      }
    } }, { key: "moveYAxisTooltip", value: function(e2) {
      var t2 = this.w, i = this.ttCtx;
      i.yaxisTTEls === null && (i.yaxisTTEls = t2.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
      var a2 = parseInt(i.ycrosshairsHidden.getAttribute("y1"), 10), s2 = t2.globals.translateY + a2, r = i.yaxisTTEls[e2].getBoundingClientRect().height, n2 = t2.globals.translateYAxisX[e2] - 2;
      t2.config.yaxis[e2].opposite && (n2 -= 26), s2 -= r / 2, t2.globals.ignoreYAxisIndexes.indexOf(e2) === -1 ? (i.yaxisTTEls[e2].classList.add("apexcharts-active"), i.yaxisTTEls[e2].style.top = s2 + "px", i.yaxisTTEls[e2].style.left = n2 + t2.config.yaxis[e2].tooltip.offsetX + "px") : i.yaxisTTEls[e2].classList.remove("apexcharts-active");
    } }, { key: "moveTooltip", value: function(e2, t2) {
      var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, a2 = this.w, s2 = this.ttCtx, r = s2.getElTooltip(), n2 = s2.tooltipRect, o2 = i !== null ? parseFloat(i) : 1, h2 = parseFloat(e2) + o2 + 5, c2 = parseFloat(t2) + o2 / 2;
      if (h2 > a2.globals.gridWidth / 2 && (h2 = h2 - n2.ttWidth - o2 - 10), h2 > a2.globals.gridWidth - n2.ttWidth - 10 && (h2 = a2.globals.gridWidth - n2.ttWidth), h2 < -20 && (h2 = -20), a2.config.tooltip.followCursor) {
        var d2 = s2.getElGrid().getBoundingClientRect();
        (h2 = s2.e.clientX - d2.left) > a2.globals.gridWidth / 2 && (h2 -= s2.tooltipRect.ttWidth), (c2 = s2.e.clientY + a2.globals.translateY - d2.top) > a2.globals.gridHeight / 2 && (c2 -= s2.tooltipRect.ttHeight);
      } else
        a2.globals.isBarHorizontal || n2.ttHeight / 2 + c2 > a2.globals.gridHeight && (c2 = a2.globals.gridHeight - n2.ttHeight + a2.globals.translateY);
      isNaN(h2) || (h2 += a2.globals.translateX, r.style.left = h2 + "px", r.style.top = c2 + "px");
    } }, { key: "moveMarkers", value: function(e2, t2) {
      var i = this.w, a2 = this.ttCtx;
      if (i.globals.markers.size[e2] > 0)
        for (var s2 = i.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(e2, "'] .apexcharts-marker")), r = 0; r < s2.length; r++)
          parseInt(s2[r].getAttribute("rel"), 10) === t2 && (a2.marker.resetPointsSize(), a2.marker.enlargeCurrentPoint(t2, s2[r]));
      else
        a2.marker.resetPointsSize(), this.moveDynamicPointOnHover(t2, e2);
    } }, { key: "moveDynamicPointOnHover", value: function(e2, t2) {
      var i, a2, s2 = this.w, r = this.ttCtx, n2 = s2.globals.pointsArray, o2 = r.tooltipUtil.getHoverMarkerSize(t2), h2 = s2.config.series[t2].type;
      if (!h2 || h2 !== "column" && h2 !== "candlestick" && h2 !== "boxPlot") {
        i = n2[t2][e2][0], a2 = n2[t2][e2][1] ? n2[t2][e2][1] : 0;
        var c2 = s2.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(t2, "'] .apexcharts-series-markers circle"));
        c2 && a2 < s2.globals.gridHeight && a2 > 0 && (c2.setAttribute("r", o2), c2.setAttribute("cx", i), c2.setAttribute("cy", a2)), this.moveXCrosshairs(i), r.fixedTooltip || this.moveTooltip(i, a2, o2);
      }
    } }, { key: "moveDynamicPointsOnHover", value: function(e2) {
      var t2, i = this.ttCtx, a2 = i.w, s2 = 0, r = 0, n2 = a2.globals.pointsArray;
      t2 = new te2(this.ctx).getActiveConfigSeriesIndex("asc", ["line", "area", "scatter", "bubble"]);
      var o2 = i.tooltipUtil.getHoverMarkerSize(t2);
      n2[t2] && (s2 = n2[t2][e2][0], r = n2[t2][e2][1]);
      var h2 = i.tooltipUtil.getAllMarkers();
      if (h2 !== null)
        for (var c2 = 0; c2 < a2.globals.series.length; c2++) {
          var d2 = n2[c2];
          if (a2.globals.comboCharts && d2 === void 0 && h2.splice(c2, 0, null), d2 && d2.length) {
            var g2 = n2[c2][e2][1], p2 = void 0;
            if (h2[c2].setAttribute("cx", s2), a2.config.chart.type === "rangeArea" && !a2.globals.comboCharts) {
              var f2 = e2 + a2.globals.series[c2].length;
              p2 = n2[c2][f2][1], g2 -= Math.abs(g2 - p2) / 2;
            }
            g2 !== null && !isNaN(g2) && g2 < a2.globals.gridHeight + o2 && g2 + o2 > 0 ? (h2[c2] && h2[c2].setAttribute("r", o2), h2[c2] && h2[c2].setAttribute("cy", g2)) : h2[c2] && h2[c2].setAttribute("r", 0);
          }
        }
      this.moveXCrosshairs(s2), i.fixedTooltip || this.moveTooltip(s2, r || a2.globals.gridHeight, o2);
    } }, { key: "moveStickyTooltipOverBars", value: function(e2, t2) {
      var i = this.w, a2 = this.ttCtx, s2 = i.globals.columnSeries ? i.globals.columnSeries.length : i.globals.series.length, r = s2 >= 2 && s2 % 2 == 0 ? Math.floor(s2 / 2) : Math.floor(s2 / 2) + 1;
      i.globals.isBarHorizontal && (r = new te2(this.ctx).getActiveConfigSeriesIndex("desc") + 1);
      var n2 = i.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='".concat(r, "'] path[j='").concat(e2, "'], .apexcharts-candlestick-series .apexcharts-series[rel='").concat(r, "'] path[j='").concat(e2, "'], .apexcharts-boxPlot-series .apexcharts-series[rel='").concat(r, "'] path[j='").concat(e2, "'], .apexcharts-rangebar-series .apexcharts-series[rel='").concat(r, "'] path[j='").concat(e2, "']"));
      n2 || typeof t2 != "number" || (n2 = i.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[data\\:realIndex='".concat(t2, "'] path[j='").concat(e2, `'],
        .apexcharts-candlestick-series .apexcharts-series[data\\:realIndex='`).concat(t2, "'] path[j='").concat(e2, `'],
        .apexcharts-boxPlot-series .apexcharts-series[data\\:realIndex='`).concat(t2, "'] path[j='").concat(e2, `'],
        .apexcharts-rangebar-series .apexcharts-series[data\\:realIndex='`).concat(t2, "'] path[j='").concat(e2, "']")));
      var o2 = n2 ? parseFloat(n2.getAttribute("cx")) : 0, h2 = n2 ? parseFloat(n2.getAttribute("cy")) : 0, c2 = n2 ? parseFloat(n2.getAttribute("barWidth")) : 0, d2 = a2.getElGrid().getBoundingClientRect(), g2 = n2 && (n2.classList.contains("apexcharts-candlestick-area") || n2.classList.contains("apexcharts-boxPlot-area"));
      i.globals.isXNumeric ? (n2 && !g2 && (o2 -= s2 % 2 != 0 ? c2 / 2 : 0), n2 && g2 && i.globals.comboCharts && (o2 -= c2 / 2)) : i.globals.isBarHorizontal || (o2 = a2.xAxisTicksPositions[e2 - 1] + a2.dataPointsDividedWidth / 2, isNaN(o2) && (o2 = a2.xAxisTicksPositions[e2] - a2.dataPointsDividedWidth / 2)), i.globals.isBarHorizontal ? h2 -= a2.tooltipRect.ttHeight : i.config.tooltip.followCursor ? h2 = a2.e.clientY - d2.top - a2.tooltipRect.ttHeight / 2 : h2 + a2.tooltipRect.ttHeight + 15 > i.globals.gridHeight && (h2 = i.globals.gridHeight), i.globals.isBarHorizontal || this.moveXCrosshairs(o2), a2.fixedTooltip || this.moveTooltip(o2, h2 || i.globals.gridHeight);
    } }]), y2;
  }(), Tt2 = function() {
    function y2(e2) {
      F2(this, y2), this.w = e2.w, this.ttCtx = e2, this.ctx = e2.ctx, this.tooltipPosition = new it2(e2);
    }
    return Y2(y2, [{ key: "drawDynamicPoints", value: function() {
      var e2 = this.w, t2 = new M2(this.ctx), i = new Pe(this.ctx), a2 = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
      a2 = J2(a2), e2.config.chart.stacked && a2.sort(function(d2, g2) {
        return parseFloat(d2.getAttribute("data:realIndex")) - parseFloat(g2.getAttribute("data:realIndex"));
      });
      for (var s2 = 0; s2 < a2.length; s2++) {
        var r = a2[s2].querySelector(".apexcharts-series-markers-wrap");
        if (r !== null) {
          var n2 = void 0, o2 = "apexcharts-marker w".concat((Math.random() + 1).toString(36).substring(4));
          e2.config.chart.type !== "line" && e2.config.chart.type !== "area" || e2.globals.comboCharts || e2.config.tooltip.intersect || (o2 += " no-pointer-events");
          var h2 = i.getMarkerConfig({ cssClass: o2, seriesIndex: Number(r.getAttribute("data:realIndex")) });
          (n2 = t2.drawMarker(0, 0, h2)).node.setAttribute("default-marker-size", 0);
          var c2 = document.createElementNS(e2.globals.SVGNS, "g");
          c2.classList.add("apexcharts-series-markers"), c2.appendChild(n2.node), r.appendChild(c2);
        }
      }
    } }, { key: "enlargeCurrentPoint", value: function(e2, t2) {
      var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, a2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, s2 = this.w;
      s2.config.chart.type !== "bubble" && this.newPointSize(e2, t2);
      var r = t2.getAttribute("cx"), n2 = t2.getAttribute("cy");
      if (i !== null && a2 !== null && (r = i, n2 = a2), this.tooltipPosition.moveXCrosshairs(r), !this.fixedTooltip) {
        if (s2.config.chart.type === "radar") {
          var o2 = this.ttCtx.getElGrid().getBoundingClientRect();
          r = this.ttCtx.e.clientX - o2.left;
        }
        this.tooltipPosition.moveTooltip(r, n2, s2.config.markers.hover.size);
      }
    } }, { key: "enlargePoints", value: function(e2) {
      for (var t2 = this.w, i = this, a2 = this.ttCtx, s2 = e2, r = t2.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), n2 = t2.config.markers.hover.size, o2 = 0; o2 < r.length; o2++) {
        var h2 = r[o2].getAttribute("rel"), c2 = r[o2].getAttribute("index");
        if (n2 === void 0 && (n2 = t2.globals.markers.size[c2] + t2.config.markers.hover.sizeOffset), s2 === parseInt(h2, 10)) {
          i.newPointSize(s2, r[o2]);
          var d2 = r[o2].getAttribute("cx"), g2 = r[o2].getAttribute("cy");
          i.tooltipPosition.moveXCrosshairs(d2), a2.fixedTooltip || i.tooltipPosition.moveTooltip(d2, g2, n2);
        } else
          i.oldPointSize(r[o2]);
      }
    } }, { key: "newPointSize", value: function(e2, t2) {
      var i = this.w, a2 = i.config.markers.hover.size, s2 = e2 === 0 ? t2.parentNode.firstChild : t2.parentNode.lastChild;
      if (s2.getAttribute("default-marker-size") !== "0") {
        var r = parseInt(s2.getAttribute("index"), 10);
        a2 === void 0 && (a2 = i.globals.markers.size[r] + i.config.markers.hover.sizeOffset), a2 < 0 && (a2 = 0), s2.setAttribute("r", a2);
      }
    } }, { key: "oldPointSize", value: function(e2) {
      var t2 = parseFloat(e2.getAttribute("default-marker-size"));
      e2.setAttribute("r", t2);
    } }, { key: "resetPointsSize", value: function() {
      for (var e2 = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), t2 = 0; t2 < e2.length; t2++) {
        var i = parseFloat(e2[t2].getAttribute("default-marker-size"));
        P2.isNumber(i) && i >= 0 ? e2[t2].setAttribute("r", i) : e2[t2].setAttribute("r", 0);
      }
    } }]), y2;
  }(), zt2 = function() {
    function y2(e2) {
      F2(this, y2), this.w = e2.w;
      var t2 = this.w;
      this.ttCtx = e2, this.isVerticalGroupedRangeBar = !t2.globals.isBarHorizontal && t2.config.chart.type === "rangeBar" && t2.config.plotOptions.bar.rangeBarGroupRows;
    }
    return Y2(y2, [{ key: "getAttr", value: function(e2, t2) {
      return parseFloat(e2.target.getAttribute(t2));
    } }, { key: "handleHeatTreeTooltip", value: function(e2) {
      var t2 = e2.e, i = e2.opt, a2 = e2.x, s2 = e2.y, r = e2.type, n2 = this.ttCtx, o2 = this.w;
      if (t2.target.classList.contains("apexcharts-".concat(r, "-rect"))) {
        var h2 = this.getAttr(t2, "i"), c2 = this.getAttr(t2, "j"), d2 = this.getAttr(t2, "cx"), g2 = this.getAttr(t2, "cy"), p2 = this.getAttr(t2, "width"), f2 = this.getAttr(t2, "height");
        if (n2.tooltipLabels.drawSeriesTexts({ ttItems: i.ttItems, i: h2, j: c2, shared: false, e: t2 }), o2.globals.capturedSeriesIndex = h2, o2.globals.capturedDataPointIndex = c2, a2 = d2 + n2.tooltipRect.ttWidth / 2 + p2, s2 = g2 + n2.tooltipRect.ttHeight / 2 - f2 / 2, n2.tooltipPosition.moveXCrosshairs(d2 + p2 / 2), a2 > o2.globals.gridWidth / 2 && (a2 = d2 - n2.tooltipRect.ttWidth / 2 + p2), n2.w.config.tooltip.followCursor) {
          var b2 = o2.globals.dom.elWrap.getBoundingClientRect();
          a2 = o2.globals.clientX - b2.left - (a2 > o2.globals.gridWidth / 2 ? n2.tooltipRect.ttWidth : 0), s2 = o2.globals.clientY - b2.top - (s2 > o2.globals.gridHeight / 2 ? n2.tooltipRect.ttHeight : 0);
        }
      }
      return { x: a2, y: s2 };
    } }, { key: "handleMarkerTooltip", value: function(e2) {
      var t2, i, a2 = e2.e, s2 = e2.opt, r = e2.x, n2 = e2.y, o2 = this.w, h2 = this.ttCtx;
      if (a2.target.classList.contains("apexcharts-marker")) {
        var c2 = parseInt(s2.paths.getAttribute("cx"), 10), d2 = parseInt(s2.paths.getAttribute("cy"), 10), g2 = parseFloat(s2.paths.getAttribute("val"));
        if (i = parseInt(s2.paths.getAttribute("rel"), 10), t2 = parseInt(s2.paths.parentNode.parentNode.parentNode.getAttribute("rel"), 10) - 1, h2.intersect) {
          var p2 = P2.findAncestor(s2.paths, "apexcharts-series");
          p2 && (t2 = parseInt(p2.getAttribute("data:realIndex"), 10));
        }
        if (h2.tooltipLabels.drawSeriesTexts({ ttItems: s2.ttItems, i: t2, j: i, shared: !h2.showOnIntersect && o2.config.tooltip.shared, e: a2 }), a2.type === "mouseup" && h2.markerClick(a2, t2, i), o2.globals.capturedSeriesIndex = t2, o2.globals.capturedDataPointIndex = i, r = c2, n2 = d2 + o2.globals.translateY - 1.4 * h2.tooltipRect.ttHeight, h2.w.config.tooltip.followCursor) {
          var f2 = h2.getElGrid().getBoundingClientRect();
          n2 = h2.e.clientY + o2.globals.translateY - f2.top;
        }
        g2 < 0 && (n2 = d2), h2.marker.enlargeCurrentPoint(i, s2.paths, r, n2);
      }
      return { x: r, y: n2 };
    } }, { key: "handleBarTooltip", value: function(e2) {
      var t2, i, a2 = e2.e, s2 = e2.opt, r = this.w, n2 = this.ttCtx, o2 = n2.getElTooltip(), h2 = 0, c2 = 0, d2 = 0, g2 = this.getBarTooltipXY({ e: a2, opt: s2 });
      t2 = g2.i;
      var p2 = g2.barHeight, f2 = g2.j;
      r.globals.capturedSeriesIndex = t2, r.globals.capturedDataPointIndex = f2, r.globals.isBarHorizontal && n2.tooltipUtil.hasBars() || !r.config.tooltip.shared ? (c2 = g2.x, d2 = g2.y, i = Array.isArray(r.config.stroke.width) ? r.config.stroke.width[t2] : r.config.stroke.width, h2 = c2) : r.globals.comboCharts || r.config.tooltip.shared || (h2 /= 2), isNaN(d2) && (d2 = r.globals.svgHeight - n2.tooltipRect.ttHeight);
      var b2 = parseInt(s2.paths.parentNode.getAttribute("data:realIndex"), 10), m2 = r.globals.isMultipleYAxis ? r.config.yaxis[b2] && r.config.yaxis[b2].reversed : r.config.yaxis[0].reversed;
      if (c2 + n2.tooltipRect.ttWidth > r.globals.gridWidth && !m2 ? c2 -= n2.tooltipRect.ttWidth : c2 < 0 && (c2 = 0), n2.w.config.tooltip.followCursor) {
        var w2 = n2.getElGrid().getBoundingClientRect();
        d2 = n2.e.clientY - w2.top;
      }
      n2.tooltip === null && (n2.tooltip = r.globals.dom.baseEl.querySelector(".apexcharts-tooltip")), r.config.tooltip.shared || (r.globals.comboBarCount > 0 ? n2.tooltipPosition.moveXCrosshairs(h2 + i / 2) : n2.tooltipPosition.moveXCrosshairs(h2)), !n2.fixedTooltip && (!r.config.tooltip.shared || r.globals.isBarHorizontal && n2.tooltipUtil.hasBars()) && (m2 && (c2 -= n2.tooltipRect.ttWidth) < 0 && (c2 = 0), !m2 || r.globals.isBarHorizontal && n2.tooltipUtil.hasBars() || (d2 = d2 + p2 - 2 * (r.globals.series[t2][f2] < 0 ? p2 : 0)), d2 = d2 + r.globals.translateY - n2.tooltipRect.ttHeight / 2, o2.style.left = c2 + r.globals.translateX + "px", o2.style.top = d2 + "px");
    } }, { key: "getBarTooltipXY", value: function(e2) {
      var t2 = this, i = e2.e, a2 = e2.opt, s2 = this.w, r = null, n2 = this.ttCtx, o2 = 0, h2 = 0, c2 = 0, d2 = 0, g2 = 0, p2 = i.target.classList;
      if (p2.contains("apexcharts-bar-area") || p2.contains("apexcharts-candlestick-area") || p2.contains("apexcharts-boxPlot-area") || p2.contains("apexcharts-rangebar-area")) {
        var f2 = i.target, b2 = f2.getBoundingClientRect(), m2 = a2.elGrid.getBoundingClientRect(), w2 = b2.height;
        g2 = b2.height;
        var A2 = b2.width, l2 = parseInt(f2.getAttribute("cx"), 10), u2 = parseInt(f2.getAttribute("cy"), 10);
        d2 = parseFloat(f2.getAttribute("barWidth"));
        var x2 = i.type === "touchmove" ? i.touches[0].clientX : i.clientX;
        r = parseInt(f2.getAttribute("j"), 10), o2 = parseInt(f2.parentNode.getAttribute("rel"), 10) - 1;
        var v2 = f2.getAttribute("data-range-y1"), k2 = f2.getAttribute("data-range-y2");
        s2.globals.comboCharts && (o2 = parseInt(f2.parentNode.getAttribute("data:realIndex"), 10));
        var S2 = function(L2) {
          return s2.globals.isXNumeric ? l2 - A2 / 2 : t2.isVerticalGroupedRangeBar ? l2 + A2 / 2 : l2 - n2.dataPointsDividedWidth + A2 / 2;
        }, C2 = function() {
          return u2 - n2.dataPointsDividedHeight + w2 / 2 - n2.tooltipRect.ttHeight / 2;
        };
        n2.tooltipLabels.drawSeriesTexts({ ttItems: a2.ttItems, i: o2, j: r, y1: v2 ? parseInt(v2, 10) : null, y2: k2 ? parseInt(k2, 10) : null, shared: !n2.showOnIntersect && s2.config.tooltip.shared, e: i }), s2.config.tooltip.followCursor ? s2.globals.isBarHorizontal ? (h2 = x2 - m2.left + 15, c2 = C2()) : (h2 = S2(), c2 = i.clientY - m2.top - n2.tooltipRect.ttHeight / 2 - 15) : s2.globals.isBarHorizontal ? ((h2 = l2) < n2.xyRatios.baseLineInvertedY && (h2 = l2 - n2.tooltipRect.ttWidth), c2 = C2()) : (h2 = S2(), c2 = u2);
      }
      return { x: h2, y: c2, barHeight: g2, barWidth: d2, i: o2, j: r };
    } }]), y2;
  }(), Mt2 = function() {
    function y2(e2) {
      F2(this, y2), this.w = e2.w, this.ttCtx = e2;
    }
    return Y2(y2, [{ key: "drawXaxisTooltip", value: function() {
      var e2 = this.w, t2 = this.ttCtx, i = e2.config.xaxis.position === "bottom";
      t2.xaxisOffY = i ? e2.globals.gridHeight + 1 : -e2.globals.xAxisHeight - e2.config.xaxis.axisTicks.height + 3;
      var a2 = i ? "apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom" : "apexcharts-xaxistooltip apexcharts-xaxistooltip-top", s2 = e2.globals.dom.elWrap;
      t2.isXAxisTooltipEnabled && e2.globals.dom.baseEl.querySelector(".apexcharts-xaxistooltip") === null && (t2.xaxisTooltip = document.createElement("div"), t2.xaxisTooltip.setAttribute("class", a2 + " apexcharts-theme-" + e2.config.tooltip.theme), s2.appendChild(t2.xaxisTooltip), t2.xaxisTooltipText = document.createElement("div"), t2.xaxisTooltipText.classList.add("apexcharts-xaxistooltip-text"), t2.xaxisTooltipText.style.fontFamily = e2.config.xaxis.tooltip.style.fontFamily || e2.config.chart.fontFamily, t2.xaxisTooltipText.style.fontSize = e2.config.xaxis.tooltip.style.fontSize, t2.xaxisTooltip.appendChild(t2.xaxisTooltipText));
    } }, { key: "drawYaxisTooltip", value: function() {
      for (var e2 = this.w, t2 = this.ttCtx, i = function(s2) {
        var r = e2.config.yaxis[s2].opposite || e2.config.yaxis[s2].crosshairs.opposite;
        t2.yaxisOffX = r ? e2.globals.gridWidth + 1 : 1;
        var n2 = "apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(s2, r ? " apexcharts-yaxistooltip-right" : " apexcharts-yaxistooltip-left");
        e2.globals.yAxisSameScaleIndices.map(function(h2, c2) {
          h2.map(function(d2, g2) {
            g2 === s2 && (n2 += e2.config.yaxis[g2].show ? " " : " apexcharts-yaxistooltip-hidden");
          });
        });
        var o2 = e2.globals.dom.elWrap;
        e2.globals.dom.baseEl.querySelector(".apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(s2)) === null && (t2.yaxisTooltip = document.createElement("div"), t2.yaxisTooltip.setAttribute("class", n2 + " apexcharts-theme-" + e2.config.tooltip.theme), o2.appendChild(t2.yaxisTooltip), s2 === 0 && (t2.yaxisTooltipText = []), t2.yaxisTooltipText[s2] = document.createElement("div"), t2.yaxisTooltipText[s2].classList.add("apexcharts-yaxistooltip-text"), t2.yaxisTooltip.appendChild(t2.yaxisTooltipText[s2]));
      }, a2 = 0; a2 < e2.config.yaxis.length; a2++)
        i(a2);
    } }, { key: "setXCrosshairWidth", value: function() {
      var e2 = this.w, t2 = this.ttCtx, i = t2.getElXCrosshairs();
      if (t2.xcrosshairsWidth = parseInt(e2.config.xaxis.crosshairs.width, 10), e2.globals.comboCharts) {
        var a2 = e2.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
        if (a2 !== null && e2.config.xaxis.crosshairs.width === "barWidth") {
          var s2 = parseFloat(a2.getAttribute("barWidth"));
          t2.xcrosshairsWidth = s2;
        } else if (e2.config.xaxis.crosshairs.width === "tickWidth") {
          var r = e2.globals.labels.length;
          t2.xcrosshairsWidth = e2.globals.gridWidth / r;
        }
      } else if (e2.config.xaxis.crosshairs.width === "tickWidth") {
        var n2 = e2.globals.labels.length;
        t2.xcrosshairsWidth = e2.globals.gridWidth / n2;
      } else if (e2.config.xaxis.crosshairs.width === "barWidth") {
        var o2 = e2.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
        if (o2 !== null) {
          var h2 = parseFloat(o2.getAttribute("barWidth"));
          t2.xcrosshairsWidth = h2;
        } else
          t2.xcrosshairsWidth = 1;
      }
      e2.globals.isBarHorizontal && (t2.xcrosshairsWidth = 0), i !== null && t2.xcrosshairsWidth > 0 && i.setAttribute("width", t2.xcrosshairsWidth);
    } }, { key: "handleYCrosshair", value: function() {
      var e2 = this.w, t2 = this.ttCtx;
      t2.ycrosshairs = e2.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs"), t2.ycrosshairsHidden = e2.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs-hidden");
    } }, { key: "drawYaxisTooltipText", value: function(e2, t2, i) {
      var a2 = this.ttCtx, s2 = this.w, r = s2.globals.yLabelFormatters[e2];
      if (a2.yaxisTooltips[e2]) {
        var n2 = a2.getElGrid().getBoundingClientRect(), o2 = (t2 - n2.top) * i.yRatio[e2], h2 = s2.globals.maxYArr[e2] - s2.globals.minYArr[e2], c2 = s2.globals.minYArr[e2] + (h2 - o2);
        a2.tooltipPosition.moveYCrosshairs(t2 - n2.top), a2.yaxisTooltipText[e2].innerHTML = r(c2), a2.tooltipPosition.moveYAxisTooltip(e2);
      }
    } }]), y2;
  }(), at2 = function() {
    function y2(e2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w;
      var t2 = this.w;
      this.tConfig = t2.config.tooltip, this.tooltipUtil = new tt2(this), this.tooltipLabels = new It2(this), this.tooltipPosition = new it2(this), this.marker = new Tt2(this), this.intersect = new zt2(this), this.axesTooltip = new Mt2(this), this.showOnIntersect = this.tConfig.intersect, this.showTooltipTitle = this.tConfig.x.show, this.fixedTooltip = this.tConfig.fixed.enabled, this.xaxisTooltip = null, this.yaxisTTEls = null, this.isBarShared = !t2.globals.isBarHorizontal && this.tConfig.shared, this.lastHoverTime = Date.now();
    }
    return Y2(y2, [{ key: "getElTooltip", value: function(e2) {
      return e2 || (e2 = this), e2.w.globals.dom.baseEl ? e2.w.globals.dom.baseEl.querySelector(".apexcharts-tooltip") : null;
    } }, { key: "getElXCrosshairs", value: function() {
      return this.w.globals.dom.baseEl.querySelector(".apexcharts-xcrosshairs");
    } }, { key: "getElGrid", value: function() {
      return this.w.globals.dom.baseEl.querySelector(".apexcharts-grid");
    } }, { key: "drawTooltip", value: function(e2) {
      var t2 = this.w;
      this.xyRatios = e2, this.isXAxisTooltipEnabled = t2.config.xaxis.tooltip.enabled && t2.globals.axisCharts, this.yaxisTooltips = t2.config.yaxis.map(function(r, n2) {
        return !!(r.show && r.tooltip.enabled && t2.globals.axisCharts);
      }), this.allTooltipSeriesGroups = [], t2.globals.axisCharts || (this.showTooltipTitle = false);
      var i = document.createElement("div");
      if (i.classList.add("apexcharts-tooltip"), t2.config.tooltip.cssClass && i.classList.add(t2.config.tooltip.cssClass), i.classList.add("apexcharts-theme-".concat(this.tConfig.theme)), t2.globals.dom.elWrap.appendChild(i), t2.globals.axisCharts) {
        this.axesTooltip.drawXaxisTooltip(), this.axesTooltip.drawYaxisTooltip(), this.axesTooltip.setXCrosshairWidth(), this.axesTooltip.handleYCrosshair();
        var a2 = new Ie(this.ctx);
        this.xAxisTicksPositions = a2.getXAxisTicksPositions();
      }
      if (!t2.globals.comboCharts && !this.tConfig.intersect && t2.config.chart.type !== "rangeBar" || this.tConfig.shared || (this.showOnIntersect = true), t2.config.markers.size !== 0 && t2.globals.markers.largestSize !== 0 || this.marker.drawDynamicPoints(this), t2.globals.collapsedSeries.length !== t2.globals.series.length) {
        this.dataPointsDividedHeight = t2.globals.gridHeight / t2.globals.dataPoints, this.dataPointsDividedWidth = t2.globals.gridWidth / t2.globals.dataPoints, this.showTooltipTitle && (this.tooltipTitle = document.createElement("div"), this.tooltipTitle.classList.add("apexcharts-tooltip-title"), this.tooltipTitle.style.fontFamily = this.tConfig.style.fontFamily || t2.config.chart.fontFamily, this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize, i.appendChild(this.tooltipTitle));
        var s2 = t2.globals.series.length;
        (t2.globals.xyCharts || t2.globals.comboCharts) && this.tConfig.shared && (s2 = this.showOnIntersect ? 1 : t2.globals.series.length), this.legendLabels = t2.globals.dom.baseEl.querySelectorAll(".apexcharts-legend-text"), this.ttItems = this.createTTElements(s2), this.addSVGEvents();
      }
    } }, { key: "createTTElements", value: function(e2) {
      for (var t2 = this, i = this.w, a2 = [], s2 = this.getElTooltip(), r = function(o2) {
        var h2 = document.createElement("div");
        h2.classList.add("apexcharts-tooltip-series-group"), h2.style.order = i.config.tooltip.inverseOrder ? e2 - o2 : o2 + 1, t2.tConfig.shared && t2.tConfig.enabledOnSeries && Array.isArray(t2.tConfig.enabledOnSeries) && t2.tConfig.enabledOnSeries.indexOf(o2) < 0 && h2.classList.add("apexcharts-tooltip-series-group-hidden");
        var c2 = document.createElement("span");
        c2.classList.add("apexcharts-tooltip-marker"), c2.style.backgroundColor = i.globals.colors[o2], h2.appendChild(c2);
        var d2 = document.createElement("div");
        d2.classList.add("apexcharts-tooltip-text"), d2.style.fontFamily = t2.tConfig.style.fontFamily || i.config.chart.fontFamily, d2.style.fontSize = t2.tConfig.style.fontSize, ["y", "goals", "z"].forEach(function(g2) {
          var p2 = document.createElement("div");
          p2.classList.add("apexcharts-tooltip-".concat(g2, "-group"));
          var f2 = document.createElement("span");
          f2.classList.add("apexcharts-tooltip-text-".concat(g2, "-label")), p2.appendChild(f2);
          var b2 = document.createElement("span");
          b2.classList.add("apexcharts-tooltip-text-".concat(g2, "-value")), p2.appendChild(b2), d2.appendChild(p2);
        }), h2.appendChild(d2), s2.appendChild(h2), a2.push(h2);
      }, n2 = 0; n2 < e2; n2++)
        r(n2);
      return a2;
    } }, { key: "addSVGEvents", value: function() {
      var e2 = this.w, t2 = e2.config.chart.type, i = this.getElTooltip(), a2 = !(t2 !== "bar" && t2 !== "candlestick" && t2 !== "boxPlot" && t2 !== "rangeBar"), s2 = t2 === "area" || t2 === "line" || t2 === "scatter" || t2 === "bubble" || t2 === "radar", r = e2.globals.dom.Paper.node, n2 = this.getElGrid();
      n2 && (this.seriesBound = n2.getBoundingClientRect());
      var o2, h2 = [], c2 = [], d2 = { hoverArea: r, elGrid: n2, tooltipEl: i, tooltipY: h2, tooltipX: c2, ttItems: this.ttItems };
      if (e2.globals.axisCharts && (s2 ? o2 = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker") : a2 ? o2 = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-boxPlot-area, .apexcharts-series .apexcharts-rangebar-area") : t2 !== "heatmap" && t2 !== "treemap" || (o2 = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-heatmap, .apexcharts-series .apexcharts-treemap")), o2 && o2.length))
        for (var g2 = 0; g2 < o2.length; g2++)
          h2.push(o2[g2].getAttribute("cy")), c2.push(o2[g2].getAttribute("cx"));
      if (e2.globals.xyCharts && !this.showOnIntersect || e2.globals.comboCharts && !this.showOnIntersect || a2 && this.tooltipUtil.hasBars() && this.tConfig.shared)
        this.addPathsEventListeners([r], d2);
      else if (a2 && !e2.globals.comboCharts || s2 && this.showOnIntersect)
        this.addDatapointEventsListeners(d2);
      else if (!e2.globals.axisCharts || t2 === "heatmap" || t2 === "treemap") {
        var p2 = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
        this.addPathsEventListeners(p2, d2);
      }
      if (this.showOnIntersect) {
        var f2 = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker");
        f2.length > 0 && this.addPathsEventListeners(f2, d2), this.tooltipUtil.hasBars() && !this.tConfig.shared && this.addDatapointEventsListeners(d2);
      }
    } }, { key: "drawFixedTooltipRect", value: function() {
      var e2 = this.w, t2 = this.getElTooltip(), i = t2.getBoundingClientRect(), a2 = i.width + 10, s2 = i.height + 10, r = this.tConfig.fixed.offsetX, n2 = this.tConfig.fixed.offsetY, o2 = this.tConfig.fixed.position.toLowerCase();
      return o2.indexOf("right") > -1 && (r = r + e2.globals.svgWidth - a2 + 10), o2.indexOf("bottom") > -1 && (n2 = n2 + e2.globals.svgHeight - s2 - 10), t2.style.left = r + "px", t2.style.top = n2 + "px", { x: r, y: n2, ttWidth: a2, ttHeight: s2 };
    } }, { key: "addDatapointEventsListeners", value: function(e2) {
      var t2 = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-boxPlot-area, .apexcharts-rangebar-area");
      this.addPathsEventListeners(t2, e2);
    } }, { key: "addPathsEventListeners", value: function(e2, t2) {
      for (var i = this, a2 = function(r) {
        var n2 = { paths: e2[r], tooltipEl: t2.tooltipEl, tooltipY: t2.tooltipY, tooltipX: t2.tooltipX, elGrid: t2.elGrid, hoverArea: t2.hoverArea, ttItems: t2.ttItems };
        ["mousemove", "mouseup", "touchmove", "mouseout", "touchend"].map(function(o2) {
          return e2[r].addEventListener(o2, i.onSeriesHover.bind(i, n2), { capture: false, passive: true });
        });
      }, s2 = 0; s2 < e2.length; s2++)
        a2(s2);
    } }, { key: "onSeriesHover", value: function(e2, t2) {
      var i = this, a2 = Date.now() - this.lastHoverTime;
      a2 >= 100 ? this.seriesHover(e2, t2) : (clearTimeout(this.seriesHoverTimeout), this.seriesHoverTimeout = setTimeout(function() {
        i.seriesHover(e2, t2);
      }, 100 - a2));
    } }, { key: "seriesHover", value: function(e2, t2) {
      var i = this;
      this.lastHoverTime = Date.now();
      var a2 = [], s2 = this.w;
      s2.config.chart.group && (a2 = this.ctx.getGroupedCharts()), s2.globals.axisCharts && (s2.globals.minX === -1 / 0 && s2.globals.maxX === 1 / 0 || s2.globals.dataPoints === 0) || (a2.length ? a2.forEach(function(r) {
        var n2 = i.getElTooltip(r), o2 = { paths: e2.paths, tooltipEl: n2, tooltipY: e2.tooltipY, tooltipX: e2.tooltipX, elGrid: e2.elGrid, hoverArea: e2.hoverArea, ttItems: r.w.globals.tooltip.ttItems };
        r.w.globals.minX === i.w.globals.minX && r.w.globals.maxX === i.w.globals.maxX && r.w.globals.tooltip.seriesHoverByContext({ chartCtx: r, ttCtx: r.w.globals.tooltip, opt: o2, e: t2 });
      }) : this.seriesHoverByContext({ chartCtx: this.ctx, ttCtx: this.w.globals.tooltip, opt: e2, e: t2 }));
    } }, { key: "seriesHoverByContext", value: function(e2) {
      var t2 = e2.chartCtx, i = e2.ttCtx, a2 = e2.opt, s2 = e2.e, r = t2.w, n2 = this.getElTooltip();
      n2 && (i.tooltipRect = { x: 0, y: 0, ttWidth: n2.getBoundingClientRect().width, ttHeight: n2.getBoundingClientRect().height }, i.e = s2, i.tooltipUtil.hasBars() && !r.globals.comboCharts && !i.isBarShared && this.tConfig.onDatasetHover.highlightDataSeries && new te2(t2).toggleSeriesOnHover(s2, s2.target.parentNode), i.fixedTooltip && i.drawFixedTooltipRect(), r.globals.axisCharts ? i.axisChartsTooltips({ e: s2, opt: a2, tooltipRect: i.tooltipRect }) : i.nonAxisChartsTooltips({ e: s2, opt: a2, tooltipRect: i.tooltipRect }));
    } }, { key: "axisChartsTooltips", value: function(e2) {
      var t2, i, a2 = e2.e, s2 = e2.opt, r = this.w, n2 = s2.elGrid.getBoundingClientRect(), o2 = a2.type === "touchmove" ? a2.touches[0].clientX : a2.clientX, h2 = a2.type === "touchmove" ? a2.touches[0].clientY : a2.clientY;
      if (this.clientY = h2, this.clientX = o2, r.globals.capturedSeriesIndex = -1, r.globals.capturedDataPointIndex = -1, h2 < n2.top || h2 > n2.top + n2.height)
        this.handleMouseOut(s2);
      else {
        if (Array.isArray(this.tConfig.enabledOnSeries) && !r.config.tooltip.shared) {
          var c2 = parseInt(s2.paths.getAttribute("index"), 10);
          if (this.tConfig.enabledOnSeries.indexOf(c2) < 0)
            return void this.handleMouseOut(s2);
        }
        var d2 = this.getElTooltip(), g2 = this.getElXCrosshairs(), p2 = r.globals.xyCharts || r.config.chart.type === "bar" && !r.globals.isBarHorizontal && this.tooltipUtil.hasBars() && this.tConfig.shared || r.globals.comboCharts && this.tooltipUtil.hasBars();
        if (a2.type === "mousemove" || a2.type === "touchmove" || a2.type === "mouseup") {
          if (r.globals.collapsedSeries.length + r.globals.ancillaryCollapsedSeries.length === r.globals.series.length)
            return;
          g2 !== null && g2.classList.add("apexcharts-active");
          var f2 = this.yaxisTooltips.filter(function(w2) {
            return w2 === true;
          });
          if (this.ycrosshairs !== null && f2.length && this.ycrosshairs.classList.add("apexcharts-active"), p2 && !this.showOnIntersect)
            this.handleStickyTooltip(a2, o2, h2, s2);
          else if (r.config.chart.type === "heatmap" || r.config.chart.type === "treemap") {
            var b2 = this.intersect.handleHeatTreeTooltip({ e: a2, opt: s2, x: t2, y: i, type: r.config.chart.type });
            t2 = b2.x, i = b2.y, d2.style.left = t2 + "px", d2.style.top = i + "px";
          } else
            this.tooltipUtil.hasBars() && this.intersect.handleBarTooltip({ e: a2, opt: s2 }), this.tooltipUtil.hasMarkers() && this.intersect.handleMarkerTooltip({ e: a2, opt: s2, x: t2, y: i });
          if (this.yaxisTooltips.length)
            for (var m2 = 0; m2 < r.config.yaxis.length; m2++)
              this.axesTooltip.drawYaxisTooltipText(m2, h2, this.xyRatios);
          s2.tooltipEl.classList.add("apexcharts-active");
        } else
          a2.type !== "mouseout" && a2.type !== "touchend" || this.handleMouseOut(s2);
      }
    } }, { key: "nonAxisChartsTooltips", value: function(e2) {
      var t2 = e2.e, i = e2.opt, a2 = e2.tooltipRect, s2 = this.w, r = i.paths.getAttribute("rel"), n2 = this.getElTooltip(), o2 = s2.globals.dom.elWrap.getBoundingClientRect();
      if (t2.type === "mousemove" || t2.type === "touchmove") {
        n2.classList.add("apexcharts-active"), this.tooltipLabels.drawSeriesTexts({ ttItems: i.ttItems, i: parseInt(r, 10) - 1, shared: false });
        var h2 = s2.globals.clientX - o2.left - a2.ttWidth / 2, c2 = s2.globals.clientY - o2.top - a2.ttHeight - 10;
        if (n2.style.left = h2 + "px", n2.style.top = c2 + "px", s2.config.legend.tooltipHoverFormatter) {
          var d2 = r - 1, g2 = (0, s2.config.legend.tooltipHoverFormatter)(this.legendLabels[d2].getAttribute("data:default-text"), { seriesIndex: d2, dataPointIndex: d2, w: s2 });
          this.legendLabels[d2].innerHTML = g2;
        }
      } else
        t2.type !== "mouseout" && t2.type !== "touchend" || (n2.classList.remove("apexcharts-active"), s2.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(p2) {
          var f2 = p2.getAttribute("data:default-text");
          p2.innerHTML = decodeURIComponent(f2);
        }));
    } }, { key: "handleStickyTooltip", value: function(e2, t2, i, a2) {
      var s2 = this.w, r = this.tooltipUtil.getNearestValues({ context: this, hoverArea: a2.hoverArea, elGrid: a2.elGrid, clientX: t2, clientY: i }), n2 = r.j, o2 = r.capturedSeries;
      s2.globals.collapsedSeriesIndices.includes(o2) && (o2 = null);
      var h2 = a2.elGrid.getBoundingClientRect();
      if (r.hoverX < 0 || r.hoverX > h2.width)
        this.handleMouseOut(a2);
      else if (o2 !== null)
        this.handleStickyCapturedSeries(e2, o2, a2, n2);
      else if (this.tooltipUtil.isXoverlap(n2) || s2.globals.isBarHorizontal) {
        var c2 = s2.globals.series.findIndex(function(d2, g2) {
          return !s2.globals.collapsedSeriesIndices.includes(g2);
        });
        this.create(e2, this, c2, n2, a2.ttItems);
      }
    } }, { key: "handleStickyCapturedSeries", value: function(e2, t2, i, a2) {
      var s2 = this.w;
      if (!this.tConfig.shared && s2.globals.series[t2][a2] === null)
        return void this.handleMouseOut(i);
      if (s2.globals.series[t2][a2] !== void 0)
        this.tConfig.shared && this.tooltipUtil.isXoverlap(a2) && this.tooltipUtil.isInitialSeriesSameLen() ? this.create(e2, this, t2, a2, i.ttItems) : this.create(e2, this, t2, a2, i.ttItems, false);
      else if (this.tooltipUtil.isXoverlap(a2)) {
        var r = s2.globals.series.findIndex(function(n2, o2) {
          return !s2.globals.collapsedSeriesIndices.includes(o2);
        });
        this.create(e2, this, r, a2, i.ttItems);
      }
    } }, { key: "deactivateHoverFilter", value: function() {
      for (var e2 = this.w, t2 = new M2(this.ctx), i = e2.globals.dom.Paper.select(".apexcharts-bar-area"), a2 = 0; a2 < i.length; a2++)
        t2.pathMouseLeave(i[a2]);
    } }, { key: "handleMouseOut", value: function(e2) {
      var t2 = this.w, i = this.getElXCrosshairs();
      if (e2.tooltipEl.classList.remove("apexcharts-active"), this.deactivateHoverFilter(), t2.config.chart.type !== "bubble" && this.marker.resetPointsSize(), i !== null && i.classList.remove("apexcharts-active"), this.ycrosshairs !== null && this.ycrosshairs.classList.remove("apexcharts-active"), this.isXAxisTooltipEnabled && this.xaxisTooltip.classList.remove("apexcharts-active"), this.yaxisTooltips.length) {
        this.yaxisTTEls === null && (this.yaxisTTEls = t2.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
        for (var a2 = 0; a2 < this.yaxisTTEls.length; a2++)
          this.yaxisTTEls[a2].classList.remove("apexcharts-active");
      }
      t2.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(s2) {
        var r = s2.getAttribute("data:default-text");
        s2.innerHTML = decodeURIComponent(r);
      });
    } }, { key: "markerClick", value: function(e2, t2, i) {
      var a2 = this.w;
      typeof a2.config.chart.events.markerClick == "function" && a2.config.chart.events.markerClick(e2, this.ctx, { seriesIndex: t2, dataPointIndex: i, w: a2 }), this.ctx.events.fireEvent("markerClick", [e2, this.ctx, { seriesIndex: t2, dataPointIndex: i, w: a2 }]);
    } }, { key: "create", value: function(e2, t2, i, a2, s2) {
      var r, n2, o2, h2, c2, d2, g2, p2, f2, b2, m2, w2, A2, l2, u2, x2, v2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null, k2 = this.w, S2 = t2;
      e2.type === "mouseup" && this.markerClick(e2, i, a2), v2 === null && (v2 = this.tConfig.shared);
      var C2 = this.tooltipUtil.hasMarkers(i), L2 = this.tooltipUtil.getElBars();
      if (k2.config.legend.tooltipHoverFormatter) {
        var I2 = k2.config.legend.tooltipHoverFormatter, z2 = Array.from(this.legendLabels);
        z2.forEach(function(se2) {
          var K2 = se2.getAttribute("data:default-text");
          se2.innerHTML = decodeURIComponent(K2);
        });
        for (var T2 = 0; T2 < z2.length; T2++) {
          var E2 = z2[T2], R2 = parseInt(E2.getAttribute("i"), 10), O2 = decodeURIComponent(E2.getAttribute("data:default-text")), D2 = I2(O2, { seriesIndex: v2 ? R2 : i, dataPointIndex: a2, w: k2 });
          if (v2)
            E2.innerHTML = k2.globals.collapsedSeriesIndices.indexOf(R2) < 0 ? D2 : O2;
          else if (E2.innerHTML = R2 === i ? D2 : O2, i === R2)
            break;
        }
      }
      var W2 = X2(X2({ ttItems: s2, i, j: a2 }, ((r = k2.globals.seriesRange) === null || r === void 0 || (n2 = r[i]) === null || n2 === void 0 || (o2 = n2[a2]) === null || o2 === void 0 || (h2 = o2.y[0]) === null || h2 === void 0 ? void 0 : h2.y1) !== void 0 && { y1: (c2 = k2.globals.seriesRange) === null || c2 === void 0 || (d2 = c2[i]) === null || d2 === void 0 || (g2 = d2[a2]) === null || g2 === void 0 || (p2 = g2.y[0]) === null || p2 === void 0 ? void 0 : p2.y1 }), ((f2 = k2.globals.seriesRange) === null || f2 === void 0 || (b2 = f2[i]) === null || b2 === void 0 || (m2 = b2[a2]) === null || m2 === void 0 || (w2 = m2.y[0]) === null || w2 === void 0 ? void 0 : w2.y2) !== void 0 && { y2: (A2 = k2.globals.seriesRange) === null || A2 === void 0 || (l2 = A2[i]) === null || l2 === void 0 || (u2 = l2[a2]) === null || u2 === void 0 || (x2 = u2.y[0]) === null || x2 === void 0 ? void 0 : x2.y2 });
      if (v2) {
        if (S2.tooltipLabels.drawSeriesTexts(X2(X2({}, W2), {}, { shared: !this.showOnIntersect && this.tConfig.shared })), C2)
          k2.globals.markers.largestSize > 0 ? S2.marker.enlargePoints(a2) : S2.tooltipPosition.moveDynamicPointsOnHover(a2);
        else if (this.tooltipUtil.hasBars() && (this.barSeriesHeight = this.tooltipUtil.getBarsHeight(L2), this.barSeriesHeight > 0)) {
          var N2 = new M2(this.ctx), V2 = k2.globals.dom.Paper.select(".apexcharts-bar-area[j='".concat(a2, "']"));
          this.deactivateHoverFilter(), this.tooltipPosition.moveStickyTooltipOverBars(a2, i);
          for (var j2 = 0; j2 < V2.length; j2++)
            N2.pathMouseEnter(V2[j2]);
        }
      } else
        S2.tooltipLabels.drawSeriesTexts(X2({ shared: false }, W2)), this.tooltipUtil.hasBars() && S2.tooltipPosition.moveStickyTooltipOverBars(a2, i), C2 && S2.tooltipPosition.moveMarkers(i, a2);
    } }]), y2;
  }(), Xt2 = function() {
    function y2(e2) {
      F2(this, y2), this.w = e2.w, this.barCtx = e2, this.totalFormatter = this.w.config.plotOptions.bar.dataLabels.total.formatter, this.totalFormatter || (this.totalFormatter = this.w.config.dataLabels.formatter);
    }
    return Y2(y2, [{ key: "handleBarDataLabels", value: function(e2) {
      var t2 = e2.x, i = e2.y, a2 = e2.y1, s2 = e2.y2, r = e2.i, n2 = e2.j, o2 = e2.realIndex, h2 = e2.groupIndex, c2 = e2.series, d2 = e2.barHeight, g2 = e2.barWidth, p2 = e2.barXPosition, f2 = e2.barYPosition, b2 = e2.visibleSeries, m2 = e2.renderedPath, w2 = this.w, A2 = new M2(this.barCtx.ctx), l2 = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[o2] : this.barCtx.strokeWidth, u2 = t2 + parseFloat(g2 * b2), x2 = i + parseFloat(d2 * b2);
      w2.globals.isXNumeric && !w2.globals.isBarHorizontal && (u2 = t2 + parseFloat(g2 * (b2 + 1)), x2 = i + parseFloat(d2 * (b2 + 1)) - l2);
      var v2, k2 = null, S2 = t2, C2 = i, L2 = {}, I2 = w2.config.dataLabels, z2 = this.barCtx.barOptions.dataLabels, T2 = this.barCtx.barOptions.dataLabels.total;
      f2 !== void 0 && this.barCtx.isRangeBar && (x2 = f2, C2 = f2), p2 !== void 0 && this.barCtx.isVerticalGroupedRangeBar && (u2 = p2, S2 = p2);
      var E2 = I2.offsetX, R2 = I2.offsetY, O2 = { width: 0, height: 0 };
      if (w2.config.dataLabels.enabled) {
        var D2 = this.barCtx.series[r][n2];
        O2 = A2.getTextRects(w2.globals.yLabelFormatters[0](D2), parseFloat(I2.style.fontSize));
      }
      var W2 = { x: t2, y: i, i: r, j: n2, realIndex: o2, groupIndex: h2 || -1, renderedPath: m2, bcx: u2, bcy: x2, barHeight: d2, barWidth: g2, textRects: O2, strokeWidth: l2, dataLabelsX: S2, dataLabelsY: C2, dataLabelsConfig: I2, barDataLabelsConfig: z2, barTotalDataLabelsConfig: T2, offX: E2, offY: R2 };
      return L2 = this.barCtx.isHorizontal ? this.calculateBarsDataLabelsPosition(W2) : this.calculateColumnsDataLabelsPosition(W2), m2.attr({ cy: L2.bcy, cx: L2.bcx, j: n2, val: c2[r][n2], barHeight: d2, barWidth: g2 }), v2 = this.drawCalculatedDataLabels({ x: L2.dataLabelsX, y: L2.dataLabelsY, val: this.barCtx.isRangeBar ? [a2, s2] : c2[r][n2], i: o2, j: n2, barWidth: g2, barHeight: d2, textRects: O2, dataLabelsConfig: I2 }), w2.config.chart.stacked && T2.enabled && (k2 = this.drawTotalDataLabels({ x: L2.totalDataLabelsX, y: L2.totalDataLabelsY, barWidth: g2, barHeight: d2, realIndex: o2, textAnchor: L2.totalDataLabelsAnchor, val: this.getStackedTotalDataLabel({ realIndex: o2, j: n2 }), dataLabelsConfig: I2, barTotalDataLabelsConfig: T2 })), { dataLabels: v2, totalDataLabels: k2 };
    } }, { key: "getStackedTotalDataLabel", value: function(e2) {
      var t2 = e2.realIndex, i = e2.j, a2 = this.w, s2 = this.barCtx.stackedSeriesTotals[i];
      return this.totalFormatter && (s2 = this.totalFormatter(s2, X2(X2({}, a2), {}, { seriesIndex: t2, dataPointIndex: i, w: a2 }))), s2;
    } }, { key: "calculateColumnsDataLabelsPosition", value: function(e2) {
      var t2, i, a2 = this.w, s2 = e2.i, r = e2.j, n2 = e2.realIndex, o2 = e2.groupIndex, h2 = e2.y, c2 = e2.bcx, d2 = e2.barWidth, g2 = e2.barHeight, p2 = e2.textRects, f2 = e2.dataLabelsX, b2 = e2.dataLabelsY, m2 = e2.dataLabelsConfig, w2 = e2.barDataLabelsConfig, A2 = e2.barTotalDataLabelsConfig, l2 = e2.strokeWidth, u2 = e2.offX, x2 = e2.offY;
      g2 = Math.abs(g2);
      var v2 = a2.config.plotOptions.bar.dataLabels.orientation === "vertical", k2 = this.barCtx.barHelpers.getZeroValueEncounters({ i: s2, j: r }).zeroEncounters;
      c2 = c2 - l2 / 2 + (o2 !== -1 ? o2 * d2 : 0);
      var S2 = a2.globals.gridWidth / a2.globals.dataPoints;
      this.barCtx.isVerticalGroupedRangeBar ? f2 += d2 / 2 : (f2 = a2.globals.isXNumeric ? c2 - d2 / 2 + u2 : c2 - S2 + d2 / 2 + u2, k2 > 0 && a2.config.plotOptions.bar.hideZeroBarsWhenGrouped && (f2 -= d2 * k2)), v2 && (f2 = f2 + p2.height / 2 - l2 / 2 - 2);
      var C2 = this.barCtx.series[s2][r] < 0, L2 = h2;
      switch (this.barCtx.isReversed && (L2 = h2 - g2 + (C2 ? 2 * g2 : 0), h2 -= g2), w2.position) {
        case "center":
          b2 = v2 ? C2 ? L2 - g2 / 2 + x2 : L2 + g2 / 2 - x2 : C2 ? L2 - g2 / 2 + p2.height / 2 + x2 : L2 + g2 / 2 + p2.height / 2 - x2;
          break;
        case "bottom":
          b2 = v2 ? C2 ? L2 - g2 + x2 : L2 + g2 - x2 : C2 ? L2 - g2 + p2.height + l2 + x2 : L2 + g2 - p2.height / 2 + l2 - x2;
          break;
        case "top":
          b2 = v2 ? C2 ? L2 + x2 : L2 - x2 : C2 ? L2 - p2.height / 2 - x2 : L2 + p2.height + x2;
      }
      if (this.barCtx.lastActiveBarSerieIndex === n2 && A2.enabled) {
        var I2 = new M2(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({ realIndex: n2, j: r }), m2.fontSize);
        t2 = C2 ? L2 - I2.height / 2 - x2 - A2.offsetY + 18 : L2 + I2.height + x2 + A2.offsetY - 18, i = f2 + A2.offsetX;
      }
      return a2.config.chart.stacked || (b2 < 0 ? b2 = 0 + l2 : b2 + p2.height / 3 > a2.globals.gridHeight && (b2 = a2.globals.gridHeight - l2)), { bcx: c2, bcy: h2, dataLabelsX: f2, dataLabelsY: b2, totalDataLabelsX: i, totalDataLabelsY: t2, totalDataLabelsAnchor: "middle" };
    } }, { key: "calculateBarsDataLabelsPosition", value: function(e2) {
      var t2 = this.w, i = e2.x, a2 = e2.i, s2 = e2.j, r = e2.realIndex, n2 = e2.groupIndex, o2 = e2.bcy, h2 = e2.barHeight, c2 = e2.barWidth, d2 = e2.textRects, g2 = e2.dataLabelsX, p2 = e2.strokeWidth, f2 = e2.dataLabelsConfig, b2 = e2.barDataLabelsConfig, m2 = e2.barTotalDataLabelsConfig, w2 = e2.offX, A2 = e2.offY, l2 = t2.globals.gridHeight / t2.globals.dataPoints;
      c2 = Math.abs(c2);
      var u2, x2, v2 = (o2 += n2 !== -1 ? n2 * h2 : 0) - (this.barCtx.isRangeBar ? 0 : l2) + h2 / 2 + d2.height / 2 + A2 - 3, k2 = "start", S2 = this.barCtx.series[a2][s2] < 0, C2 = i;
      switch (this.barCtx.isReversed && (C2 = i + c2 - (S2 ? 2 * c2 : 0), i = t2.globals.gridWidth - c2), b2.position) {
        case "center":
          g2 = S2 ? C2 + c2 / 2 - w2 : Math.max(d2.width / 2, C2 - c2 / 2) + w2;
          break;
        case "bottom":
          g2 = S2 ? C2 + c2 - p2 - Math.round(d2.width / 2) - w2 : C2 - c2 + p2 + Math.round(d2.width / 2) + w2;
          break;
        case "top":
          g2 = S2 ? C2 - p2 + Math.round(d2.width / 2) - w2 : C2 - p2 - Math.round(d2.width / 2) + w2;
      }
      if (this.barCtx.lastActiveBarSerieIndex === r && m2.enabled) {
        var L2 = new M2(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({ realIndex: r, j: s2 }), f2.fontSize);
        S2 ? (u2 = C2 - p2 + Math.round(L2.width / 2) - w2 - m2.offsetX - 15, k2 = "end") : u2 = C2 - p2 - Math.round(L2.width / 2) + w2 + m2.offsetX + 15, x2 = v2 + m2.offsetY;
      }
      return t2.config.chart.stacked || (g2 < 0 ? g2 = g2 + d2.width + p2 : g2 + d2.width / 2 > t2.globals.gridWidth && (g2 = t2.globals.gridWidth - d2.width - p2)), { bcx: i, bcy: o2, dataLabelsX: g2, dataLabelsY: v2, totalDataLabelsX: u2, totalDataLabelsY: x2, totalDataLabelsAnchor: k2 };
    } }, { key: "drawCalculatedDataLabels", value: function(e2) {
      var t2 = e2.x, i = e2.y, a2 = e2.val, s2 = e2.i, r = e2.j, n2 = e2.textRects, o2 = e2.barHeight, h2 = e2.barWidth, c2 = e2.dataLabelsConfig, d2 = this.w, g2 = "rotate(0)";
      d2.config.plotOptions.bar.dataLabels.orientation === "vertical" && (g2 = "rotate(-90, ".concat(t2, ", ").concat(i, ")"));
      var p2 = new ye2(this.barCtx.ctx), f2 = new M2(this.barCtx.ctx), b2 = c2.formatter, m2 = null, w2 = d2.globals.collapsedSeriesIndices.indexOf(s2) > -1;
      if (c2.enabled && !w2) {
        m2 = f2.group({ class: "apexcharts-data-labels", transform: g2 });
        var A2 = "";
        a2 !== void 0 && (A2 = b2(a2, X2(X2({}, d2), {}, { seriesIndex: s2, dataPointIndex: r, w: d2 }))), !a2 && d2.config.plotOptions.bar.hideZeroBarsWhenGrouped && (A2 = "");
        var l2 = d2.globals.series[s2][r] < 0, u2 = d2.config.plotOptions.bar.dataLabels.position;
        d2.config.plotOptions.bar.dataLabels.orientation === "vertical" && (u2 === "top" && (c2.textAnchor = l2 ? "end" : "start"), u2 === "center" && (c2.textAnchor = "middle"), u2 === "bottom" && (c2.textAnchor = l2 ? "end" : "start")), this.barCtx.isRangeBar && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && h2 < f2.getTextRects(A2, parseFloat(c2.style.fontSize)).width && (A2 = ""), d2.config.chart.stacked && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && (this.barCtx.isHorizontal ? n2.width / 1.6 > Math.abs(h2) && (A2 = "") : n2.height / 1.6 > Math.abs(o2) && (A2 = ""));
        var x2 = X2({}, c2);
        this.barCtx.isHorizontal && a2 < 0 && (c2.textAnchor === "start" ? x2.textAnchor = "end" : c2.textAnchor === "end" && (x2.textAnchor = "start")), p2.plotDataLabelsText({ x: t2, y: i, text: A2, i: s2, j: r, parent: m2, dataLabelsConfig: x2, alwaysDrawDataLabel: true, offsetCorrection: true });
      }
      return m2;
    } }, { key: "drawTotalDataLabels", value: function(e2) {
      var t2, i = e2.x, a2 = e2.y, s2 = e2.val, r = e2.barWidth, n2 = e2.barHeight, o2 = e2.realIndex, h2 = e2.textAnchor, c2 = e2.barTotalDataLabelsConfig, d2 = this.w, g2 = new M2(this.barCtx.ctx);
      return c2.enabled && i !== void 0 && a2 !== void 0 && this.barCtx.lastActiveBarSerieIndex === o2 && (t2 = g2.drawText({ x: i - (!d2.globals.isBarHorizontal && d2.globals.seriesGroups.length ? r / d2.globals.seriesGroups.length : 0), y: a2 - (d2.globals.isBarHorizontal && d2.globals.seriesGroups.length ? n2 / d2.globals.seriesGroups.length : 0), foreColor: c2.style.color, text: s2, textAnchor: h2, fontFamily: c2.style.fontFamily, fontSize: c2.style.fontSize, fontWeight: c2.style.fontWeight })), t2;
    } }]), y2;
  }(), Et2 = function() {
    function y2(e2) {
      F2(this, y2), this.w = e2.w, this.barCtx = e2;
    }
    return Y2(y2, [{ key: "initVariables", value: function(e2) {
      var t2 = this.w;
      this.barCtx.series = e2, this.barCtx.totalItems = 0, this.barCtx.seriesLen = 0, this.barCtx.visibleI = -1, this.barCtx.visibleItems = 1;
      for (var i = 0; i < e2.length; i++)
        if (e2[i].length > 0 && (this.barCtx.seriesLen = this.barCtx.seriesLen + 1, this.barCtx.totalItems += e2[i].length), t2.globals.isXNumeric)
          for (var a2 = 0; a2 < e2[i].length; a2++)
            t2.globals.seriesX[i][a2] > t2.globals.minX && t2.globals.seriesX[i][a2] < t2.globals.maxX && this.barCtx.visibleItems++;
        else
          this.barCtx.visibleItems = t2.globals.dataPoints;
      this.barCtx.seriesLen === 0 && (this.barCtx.seriesLen = 1), this.barCtx.zeroSerieses = [], t2.globals.comboCharts || this.checkZeroSeries({ series: e2 });
    } }, { key: "initialPositions", value: function() {
      var e2, t2, i, a2, s2, r, n2, o2, h2 = this.w, c2 = h2.globals.dataPoints;
      this.barCtx.isRangeBar && (c2 = h2.globals.labels.length);
      var d2 = this.barCtx.seriesLen;
      if (h2.config.plotOptions.bar.rangeBarGroupRows && (d2 = 1), this.barCtx.isHorizontal)
        s2 = (i = h2.globals.gridHeight / c2) / d2, h2.globals.isXNumeric && (s2 = (i = h2.globals.gridHeight / this.barCtx.totalItems) / this.barCtx.seriesLen), s2 = s2 * parseInt(this.barCtx.barOptions.barHeight, 10) / 100, String(this.barCtx.barOptions.barHeight).indexOf("%") === -1 && (s2 = parseInt(this.barCtx.barOptions.barHeight, 10)), o2 = this.barCtx.baseLineInvertedY + h2.globals.padHorizontal + (this.barCtx.isReversed ? h2.globals.gridWidth : 0) - (this.barCtx.isReversed ? 2 * this.barCtx.baseLineInvertedY : 0), this.barCtx.isFunnel && (o2 = h2.globals.gridWidth / 2), t2 = (i - s2 * this.barCtx.seriesLen) / 2;
      else {
        if (a2 = h2.globals.gridWidth / this.barCtx.visibleItems, h2.config.xaxis.convertedCatToNumeric && (a2 = h2.globals.gridWidth / h2.globals.dataPoints), r = a2 / d2 * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100, h2.globals.isXNumeric) {
          var g2 = this.barCtx.xRatio;
          h2.globals.minXDiff && h2.globals.minXDiff !== 0.5 && h2.globals.minXDiff / g2 > 0 && (a2 = h2.globals.minXDiff / g2), (r = a2 / d2 * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100) < 1 && (r = 1);
        }
        String(this.barCtx.barOptions.columnWidth).indexOf("%") === -1 && (r = parseInt(this.barCtx.barOptions.columnWidth, 10)), n2 = h2.globals.gridHeight - this.barCtx.baseLineY[this.barCtx.yaxisIndex] - (this.barCtx.isReversed ? h2.globals.gridHeight : 0) + (this.barCtx.isReversed ? 2 * this.barCtx.baseLineY[this.barCtx.yaxisIndex] : 0), e2 = h2.globals.padHorizontal + (a2 - r * this.barCtx.seriesLen) / 2;
      }
      return h2.globals.barHeight = s2, h2.globals.barWidth = r, { x: e2, y: t2, yDivision: i, xDivision: a2, barHeight: s2, barWidth: r, zeroH: n2, zeroW: o2 };
    } }, { key: "initializeStackedPrevVars", value: function(e2) {
      var t2 = e2.w;
      t2.globals.hasSeriesGroups ? t2.globals.seriesGroups.forEach(function(i) {
        e2[i] || (e2[i] = {}), e2[i].prevY = [], e2[i].prevX = [], e2[i].prevYF = [], e2[i].prevXF = [], e2[i].prevYVal = [], e2[i].prevXVal = [];
      }) : (e2.prevY = [], e2.prevX = [], e2.prevYF = [], e2.prevXF = [], e2.prevYVal = [], e2.prevXVal = []);
    } }, { key: "initializeStackedXYVars", value: function(e2) {
      var t2 = e2.w;
      t2.globals.hasSeriesGroups ? t2.globals.seriesGroups.forEach(function(i) {
        e2[i] || (e2[i] = {}), e2[i].xArrj = [], e2[i].xArrjF = [], e2[i].xArrjVal = [], e2[i].yArrj = [], e2[i].yArrjF = [], e2[i].yArrjVal = [];
      }) : (e2.xArrj = [], e2.xArrjF = [], e2.xArrjVal = [], e2.yArrj = [], e2.yArrjF = [], e2.yArrjVal = []);
    } }, { key: "getPathFillColor", value: function(e2, t2, i, a2) {
      var s2, r, n2, o2, h2 = this.w, c2 = new ae2(this.barCtx.ctx), d2 = null, g2 = this.barCtx.barOptions.distributed ? i : t2;
      return this.barCtx.barOptions.colors.ranges.length > 0 && this.barCtx.barOptions.colors.ranges.map(function(p2) {
        e2[t2][i] >= p2.from && e2[t2][i] <= p2.to && (d2 = p2.color);
      }), h2.config.series[t2].data[i] && h2.config.series[t2].data[i].fillColor && (d2 = h2.config.series[t2].data[i].fillColor), c2.fillPath({ seriesNumber: this.barCtx.barOptions.distributed ? g2 : a2, dataPointIndex: i, color: d2, value: e2[t2][i], fillConfig: (s2 = h2.config.series[t2].data[i]) === null || s2 === void 0 ? void 0 : s2.fill, fillType: (r = h2.config.series[t2].data[i]) !== null && r !== void 0 && (n2 = r.fill) !== null && n2 !== void 0 && n2.type ? (o2 = h2.config.series[t2].data[i]) === null || o2 === void 0 ? void 0 : o2.fill.type : Array.isArray(h2.config.fill.type) ? h2.config.fill.type[t2] : h2.config.fill.type });
    } }, { key: "getStrokeWidth", value: function(e2, t2, i) {
      var a2 = 0, s2 = this.w;
      return this.barCtx.series[e2][t2] === void 0 || this.barCtx.series[e2][t2] === null ? this.barCtx.isNullValue = true : this.barCtx.isNullValue = false, s2.config.stroke.show && (this.barCtx.isNullValue || (a2 = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[i] : this.barCtx.strokeWidth)), a2;
    } }, { key: "shouldApplyRadius", value: function(e2) {
      var t2 = this.w, i = false;
      return t2.config.plotOptions.bar.borderRadius > 0 && (t2.config.chart.stacked && t2.config.plotOptions.bar.borderRadiusWhenStacked === "last" ? this.barCtx.lastActiveBarSerieIndex === e2 && (i = true) : i = true), i;
    } }, { key: "barBackground", value: function(e2) {
      var t2 = e2.j, i = e2.i, a2 = e2.x1, s2 = e2.x2, r = e2.y1, n2 = e2.y2, o2 = e2.elSeries, h2 = this.w, c2 = new M2(this.barCtx.ctx), d2 = new te2(this.barCtx.ctx).getActiveConfigSeriesIndex();
      if (this.barCtx.barOptions.colors.backgroundBarColors.length > 0 && d2 === i) {
        t2 >= this.barCtx.barOptions.colors.backgroundBarColors.length && (t2 %= this.barCtx.barOptions.colors.backgroundBarColors.length);
        var g2 = this.barCtx.barOptions.colors.backgroundBarColors[t2], p2 = c2.drawRect(a2 !== void 0 ? a2 : 0, r !== void 0 ? r : 0, s2 !== void 0 ? s2 : h2.globals.gridWidth, n2 !== void 0 ? n2 : h2.globals.gridHeight, this.barCtx.barOptions.colors.backgroundBarRadius, g2, this.barCtx.barOptions.colors.backgroundBarOpacity);
        o2.add(p2), p2.node.classList.add("apexcharts-backgroundBar");
      }
    } }, { key: "getColumnPaths", value: function(e2) {
      var t2, i = e2.barWidth, a2 = e2.barXPosition, s2 = e2.y1, r = e2.y2, n2 = e2.strokeWidth, o2 = e2.seriesGroup, h2 = e2.realIndex, c2 = e2.i, d2 = e2.j, g2 = e2.w, p2 = new M2(this.barCtx.ctx);
      (n2 = Array.isArray(n2) ? n2[h2] : n2) || (n2 = 0);
      var f2 = i, b2 = a2;
      (t2 = g2.config.series[h2].data[d2]) !== null && t2 !== void 0 && t2.columnWidthOffset && (b2 = a2 - g2.config.series[h2].data[d2].columnWidthOffset / 2, f2 = i + g2.config.series[h2].data[d2].columnWidthOffset);
      var m2 = b2, w2 = b2 + f2;
      s2 += 1e-3, r += 1e-3;
      var A2 = p2.move(m2, s2), l2 = p2.move(m2, s2), u2 = p2.line(w2 - n2, s2);
      if (g2.globals.previousPaths.length > 0 && (l2 = this.barCtx.getPreviousPath(h2, d2, false)), A2 = A2 + p2.line(m2, r) + p2.line(w2 - n2, r) + p2.line(w2 - n2, s2) + (g2.config.plotOptions.bar.borderRadiusApplication === "around" ? " Z" : " z"), l2 = l2 + p2.line(m2, s2) + u2 + u2 + u2 + u2 + u2 + p2.line(m2, s2) + (g2.config.plotOptions.bar.borderRadiusApplication === "around" ? " Z" : " z"), this.shouldApplyRadius(h2) && (A2 = p2.roundPathCorners(A2, g2.config.plotOptions.bar.borderRadius)), g2.config.chart.stacked) {
        var x2 = this.barCtx;
        g2.globals.hasSeriesGroups && o2 && (x2 = this.barCtx[o2]), x2.yArrj.push(r), x2.yArrjF.push(Math.abs(s2 - r)), x2.yArrjVal.push(this.barCtx.series[c2][d2]);
      }
      return { pathTo: A2, pathFrom: l2 };
    } }, { key: "getBarpaths", value: function(e2) {
      var t2, i = e2.barYPosition, a2 = e2.barHeight, s2 = e2.x1, r = e2.x2, n2 = e2.strokeWidth, o2 = e2.seriesGroup, h2 = e2.realIndex, c2 = e2.i, d2 = e2.j, g2 = e2.w, p2 = new M2(this.barCtx.ctx);
      (n2 = Array.isArray(n2) ? n2[h2] : n2) || (n2 = 0);
      var f2 = i, b2 = a2;
      (t2 = g2.config.series[h2].data[d2]) !== null && t2 !== void 0 && t2.barHeightOffset && (f2 = i - g2.config.series[h2].data[d2].barHeightOffset / 2, b2 = a2 + g2.config.series[h2].data[d2].barHeightOffset);
      var m2 = f2, w2 = f2 + b2;
      s2 += 1e-3, r += 1e-3;
      var A2 = p2.move(s2, m2), l2 = p2.move(s2, m2);
      g2.globals.previousPaths.length > 0 && (l2 = this.barCtx.getPreviousPath(h2, d2, false));
      var u2 = p2.line(s2, w2 - n2);
      if (A2 = A2 + p2.line(r, m2) + p2.line(r, w2 - n2) + u2 + (g2.config.plotOptions.bar.borderRadiusApplication === "around" ? " Z" : " z"), l2 = l2 + p2.line(s2, m2) + u2 + u2 + u2 + u2 + u2 + p2.line(s2, m2) + (g2.config.plotOptions.bar.borderRadiusApplication === "around" ? " Z" : " z"), this.shouldApplyRadius(h2) && (A2 = p2.roundPathCorners(A2, g2.config.plotOptions.bar.borderRadius)), g2.config.chart.stacked) {
        var x2 = this.barCtx;
        g2.globals.hasSeriesGroups && o2 && (x2 = this.barCtx[o2]), x2.xArrj.push(r), x2.xArrjF.push(Math.abs(s2 - r)), x2.xArrjVal.push(this.barCtx.series[c2][d2]);
      }
      return { pathTo: A2, pathFrom: l2 };
    } }, { key: "checkZeroSeries", value: function(e2) {
      for (var t2 = e2.series, i = this.w, a2 = 0; a2 < t2.length; a2++) {
        for (var s2 = 0, r = 0; r < t2[i.globals.maxValsInArrayIndex].length; r++)
          s2 += t2[a2][r];
        s2 === 0 && this.barCtx.zeroSerieses.push(a2);
      }
    } }, { key: "getXForValue", value: function(e2, t2) {
      var i = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2] ? t2 : null;
      return e2 != null && (i = t2 + e2 / this.barCtx.invertedYRatio - 2 * (this.barCtx.isReversed ? e2 / this.barCtx.invertedYRatio : 0)), i;
    } }, { key: "getYForValue", value: function(e2, t2) {
      var i = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2] ? t2 : null;
      return e2 != null && (i = t2 - e2 / this.barCtx.yRatio[this.barCtx.yaxisIndex] + 2 * (this.barCtx.isReversed ? e2 / this.barCtx.yRatio[this.barCtx.yaxisIndex] : 0)), i;
    } }, { key: "getGoalValues", value: function(e2, t2, i, a2, s2) {
      var r = this, n2 = this.w, o2 = [], h2 = function(g2, p2) {
        var f2;
        o2.push((ee2(f2 = {}, e2, e2 === "x" ? r.getXForValue(g2, t2, false) : r.getYForValue(g2, i, false)), ee2(f2, "attrs", p2), f2));
      };
      if (n2.globals.seriesGoals[a2] && n2.globals.seriesGoals[a2][s2] && Array.isArray(n2.globals.seriesGoals[a2][s2]) && n2.globals.seriesGoals[a2][s2].forEach(function(g2) {
        h2(g2.value, g2);
      }), this.barCtx.barOptions.isDumbbell && n2.globals.seriesRange.length) {
        var c2 = this.barCtx.barOptions.dumbbellColors ? this.barCtx.barOptions.dumbbellColors : n2.globals.colors, d2 = { strokeHeight: e2 === "x" ? 0 : n2.globals.markers.size[a2], strokeWidth: e2 === "x" ? n2.globals.markers.size[a2] : 0, strokeDashArray: 0, strokeLineCap: "round", strokeColor: Array.isArray(c2[a2]) ? c2[a2][0] : c2[a2] };
        h2(n2.globals.seriesRangeStart[a2][s2], d2), h2(n2.globals.seriesRangeEnd[a2][s2], X2(X2({}, d2), {}, { strokeColor: Array.isArray(c2[a2]) ? c2[a2][1] : c2[a2] }));
      }
      return o2;
    } }, { key: "drawGoalLine", value: function(e2) {
      var t2 = e2.barXPosition, i = e2.barYPosition, a2 = e2.goalX, s2 = e2.goalY, r = e2.barWidth, n2 = e2.barHeight, o2 = new M2(this.barCtx.ctx), h2 = o2.group({ className: "apexcharts-bar-goals-groups" });
      h2.node.classList.add("apexcharts-element-hidden"), this.barCtx.w.globals.delayedElements.push({ el: h2.node }), h2.attr("clip-path", "url(#gridRectMarkerMask".concat(this.barCtx.w.globals.cuid, ")"));
      var c2 = null;
      return this.barCtx.isHorizontal ? Array.isArray(a2) && a2.forEach(function(d2) {
        var g2 = d2.attrs.strokeHeight !== void 0 ? d2.attrs.strokeHeight : n2 / 2, p2 = i + g2 + n2 / 2;
        c2 = o2.drawLine(d2.x, p2 - 2 * g2, d2.x, p2, d2.attrs.strokeColor ? d2.attrs.strokeColor : void 0, d2.attrs.strokeDashArray, d2.attrs.strokeWidth ? d2.attrs.strokeWidth : 2, d2.attrs.strokeLineCap), h2.add(c2);
      }) : Array.isArray(s2) && s2.forEach(function(d2) {
        var g2 = d2.attrs.strokeWidth !== void 0 ? d2.attrs.strokeWidth : r / 2, p2 = t2 + g2 + r / 2;
        c2 = o2.drawLine(p2 - 2 * g2, d2.y, p2, d2.y, d2.attrs.strokeColor ? d2.attrs.strokeColor : void 0, d2.attrs.strokeDashArray, d2.attrs.strokeHeight ? d2.attrs.strokeHeight : 2, d2.attrs.strokeLineCap), h2.add(c2);
      }), h2;
    } }, { key: "drawBarShadow", value: function(e2) {
      var t2 = e2.prevPaths, i = e2.currPaths, a2 = e2.color, s2 = this.w, r = t2.x, n2 = t2.x1, o2 = t2.barYPosition, h2 = i.x, c2 = i.x1, d2 = i.barYPosition, g2 = o2 + i.barHeight, p2 = new M2(this.barCtx.ctx), f2 = new P2(), b2 = p2.move(n2, g2) + p2.line(r, g2) + p2.line(h2, d2) + p2.line(c2, d2) + p2.line(n2, g2) + (s2.config.plotOptions.bar.borderRadiusApplication === "around" ? " Z" : " z");
      return p2.drawPath({ d: b2, fill: f2.shadeColor(0.5, P2.rgb2hex(a2)), stroke: "none", strokeWidth: 0, fillOpacity: 1, classes: "apexcharts-bar-shadows" });
    } }, { key: "getZeroValueEncounters", value: function(e2) {
      var t2 = e2.i, i = e2.j, a2 = this.w, s2 = 0, r = 0;
      return a2.globals.seriesPercent.forEach(function(n2, o2) {
        n2[i] && s2++, o2 < t2 && n2[i] === 0 && r++;
      }), { nonZeroColumns: s2, zeroEncounters: r };
    } }]), y2;
  }(), ke = function() {
    function y2(e2, t2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w;
      var i = this.w;
      this.barOptions = i.config.plotOptions.bar, this.isHorizontal = this.barOptions.horizontal, this.strokeWidth = i.config.stroke.width, this.isNullValue = false, this.isRangeBar = i.globals.seriesRange.length && this.isHorizontal, this.isVerticalGroupedRangeBar = !i.globals.isBarHorizontal && i.globals.seriesRange.length && i.config.plotOptions.bar.rangeBarGroupRows, this.isFunnel = this.barOptions.isFunnel, this.xyRatios = t2, this.xyRatios !== null && (this.xRatio = t2.xRatio, this.yRatio = t2.yRatio, this.invertedXRatio = t2.invertedXRatio, this.invertedYRatio = t2.invertedYRatio, this.baseLineY = t2.baseLineY, this.baseLineInvertedY = t2.baseLineInvertedY), this.yaxisIndex = 0, this.seriesLen = 0, this.pathArr = [];
      var a2 = new te2(this.ctx);
      this.lastActiveBarSerieIndex = a2.getActiveConfigSeriesIndex("desc", ["bar", "column"]);
      var s2 = a2.getBarSeriesIndices(), r = new q2(this.ctx);
      this.stackedSeriesTotals = r.getStackedSeriesTotals(this.w.config.series.map(function(n2, o2) {
        return s2.indexOf(o2) === -1 ? o2 : -1;
      }).filter(function(n2) {
        return n2 !== -1;
      })), this.barHelpers = new Et2(this);
    }
    return Y2(y2, [{ key: "draw", value: function(e2, t2) {
      var i = this.w, a2 = new M2(this.ctx), s2 = new q2(this.ctx, i);
      e2 = s2.getLogSeries(e2), this.series = e2, this.yRatio = s2.getLogYRatios(this.yRatio), this.barHelpers.initVariables(e2);
      var r = a2.group({ class: "apexcharts-bar-series apexcharts-plot-series" });
      i.config.dataLabels.enabled && this.totalItems > this.barOptions.dataLabels.maxItems && console.warn("WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering - ApexCharts");
      for (var n2 = 0, o2 = 0; n2 < e2.length; n2++, o2++) {
        var h2, c2, d2, g2, p2 = void 0, f2 = void 0, b2 = [], m2 = [], w2 = i.globals.comboCharts ? t2[n2] : n2, A2 = a2.group({ class: "apexcharts-series", rel: n2 + 1, seriesName: P2.escapeString(i.globals.seriesNames[w2]), "data:realIndex": w2 });
        this.ctx.series.addCollapsedClassToSeries(A2, w2), e2[n2].length > 0 && (this.visibleI = this.visibleI + 1);
        var l2 = 0, u2 = 0;
        this.yRatio.length > 1 && (this.yaxisIndex = w2), this.isReversed = i.config.yaxis[this.yaxisIndex] && i.config.yaxis[this.yaxisIndex].reversed;
        var x2 = this.barHelpers.initialPositions();
        f2 = x2.y, l2 = x2.barHeight, c2 = x2.yDivision, g2 = x2.zeroW, p2 = x2.x, u2 = x2.barWidth, h2 = x2.xDivision, d2 = x2.zeroH, this.horizontal || m2.push(p2 + u2 / 2);
        var v2 = a2.group({ class: "apexcharts-datalabels", "data:realIndex": w2 });
        i.globals.delayedElements.push({ el: v2.node }), v2.node.classList.add("apexcharts-element-hidden");
        var k2 = a2.group({ class: "apexcharts-bar-goals-markers" }), S2 = a2.group({ class: "apexcharts-bar-shadows" });
        i.globals.delayedElements.push({ el: S2.node }), S2.node.classList.add("apexcharts-element-hidden");
        for (var C2 = 0; C2 < i.globals.dataPoints; C2++) {
          var L2 = this.barHelpers.getStrokeWidth(n2, C2, w2), I2 = null, z2 = { indexes: { i: n2, j: C2, realIndex: w2, bc: o2 }, x: p2, y: f2, strokeWidth: L2, elSeries: A2 };
          this.isHorizontal ? (I2 = this.drawBarPaths(X2(X2({}, z2), {}, { barHeight: l2, zeroW: g2, yDivision: c2 })), u2 = this.series[n2][C2] / this.invertedYRatio) : (I2 = this.drawColumnPaths(X2(X2({}, z2), {}, { xDivision: h2, barWidth: u2, zeroH: d2 })), l2 = this.series[n2][C2] / this.yRatio[this.yaxisIndex]);
          var T2 = this.barHelpers.getPathFillColor(e2, n2, C2, w2);
          if (this.isFunnel && this.barOptions.isFunnel3d && this.pathArr.length && C2 > 0) {
            var E2 = this.barHelpers.drawBarShadow({ color: typeof T2 == "string" && (T2 == null ? void 0 : T2.indexOf("url")) === -1 ? T2 : P2.hexToRgba(i.globals.colors[n2]), prevPaths: this.pathArr[this.pathArr.length - 1], currPaths: I2 });
            E2 && S2.add(E2);
          }
          this.pathArr.push(I2);
          var R2 = this.barHelpers.drawGoalLine({ barXPosition: I2.barXPosition, barYPosition: I2.barYPosition, goalX: I2.goalX, goalY: I2.goalY, barHeight: l2, barWidth: u2 });
          R2 && k2.add(R2), f2 = I2.y, p2 = I2.x, C2 > 0 && m2.push(p2 + u2 / 2), b2.push(f2), this.renderSeries({ realIndex: w2, pathFill: T2, j: C2, i: n2, pathFrom: I2.pathFrom, pathTo: I2.pathTo, strokeWidth: L2, elSeries: A2, x: p2, y: f2, series: e2, barHeight: I2.barHeight ? I2.barHeight : l2, barWidth: I2.barWidth ? I2.barWidth : u2, elDataLabelsWrap: v2, elGoalsMarkers: k2, elBarShadows: S2, visibleSeries: this.visibleI, type: "bar" });
        }
        i.globals.seriesXvalues[w2] = m2, i.globals.seriesYvalues[w2] = b2, r.add(A2);
      }
      return r;
    } }, { key: "renderSeries", value: function(e2) {
      var t2 = e2.realIndex, i = e2.pathFill, a2 = e2.lineFill, s2 = e2.j, r = e2.i, n2 = e2.groupIndex, o2 = e2.pathFrom, h2 = e2.pathTo, c2 = e2.strokeWidth, d2 = e2.elSeries, g2 = e2.x, p2 = e2.y, f2 = e2.y1, b2 = e2.y2, m2 = e2.series, w2 = e2.barHeight, A2 = e2.barWidth, l2 = e2.barXPosition, u2 = e2.barYPosition, x2 = e2.elDataLabelsWrap, v2 = e2.elGoalsMarkers, k2 = e2.elBarShadows, S2 = e2.visibleSeries, C2 = e2.type, L2 = this.w, I2 = new M2(this.ctx);
      a2 || (a2 = this.barOptions.distributed ? L2.globals.stroke.colors[s2] : L2.globals.stroke.colors[t2]), L2.config.series[r].data[s2] && L2.config.series[r].data[s2].strokeColor && (a2 = L2.config.series[r].data[s2].strokeColor), this.isNullValue && (i = "none");
      var z2 = s2 / L2.config.chart.animations.animateGradually.delay * (L2.config.chart.animations.speed / L2.globals.dataPoints) / 2.4, T2 = I2.renderPaths({ i: r, j: s2, realIndex: t2, pathFrom: o2, pathTo: h2, stroke: a2, strokeWidth: c2, strokeLineCap: L2.config.stroke.lineCap, fill: i, animationDelay: z2, initialSpeed: L2.config.chart.animations.speed, dataChangeSpeed: L2.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-".concat(C2, "-area") });
      T2.attr("clip-path", "url(#gridRectMask".concat(L2.globals.cuid, ")"));
      var E2 = L2.config.forecastDataPoints;
      E2.count > 0 && s2 >= L2.globals.dataPoints - E2.count && (T2.node.setAttribute("stroke-dasharray", E2.dashArray), T2.node.setAttribute("stroke-width", E2.strokeWidth), T2.node.setAttribute("fill-opacity", E2.fillOpacity)), f2 !== void 0 && b2 !== void 0 && (T2.attr("data-range-y1", f2), T2.attr("data-range-y2", b2)), new Z2(this.ctx).setSelectionFilter(T2, t2, s2), d2.add(T2);
      var R2 = new Xt2(this).handleBarDataLabels({ x: g2, y: p2, y1: f2, y2: b2, i: r, j: s2, series: m2, realIndex: t2, groupIndex: n2, barHeight: w2, barWidth: A2, barXPosition: l2, barYPosition: u2, renderedPath: T2, visibleSeries: S2 });
      return R2.dataLabels !== null && x2.add(R2.dataLabels), R2.totalDataLabels && x2.add(R2.totalDataLabels), d2.add(x2), v2 && d2.add(v2), k2 && d2.add(k2), d2;
    } }, { key: "drawBarPaths", value: function(e2) {
      var t2, i = e2.indexes, a2 = e2.barHeight, s2 = e2.strokeWidth, r = e2.zeroW, n2 = e2.x, o2 = e2.y, h2 = e2.yDivision, c2 = e2.elSeries, d2 = this.w, g2 = i.i, p2 = i.j;
      if (d2.globals.isXNumeric)
        t2 = (o2 = (d2.globals.seriesX[g2][p2] - d2.globals.minX) / this.invertedXRatio - a2) + a2 * this.visibleI;
      else if (d2.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
        var f2 = 0, b2 = 0;
        d2.globals.seriesPercent.forEach(function(w2, A2) {
          w2[p2] && f2++, A2 < g2 && w2[p2] === 0 && b2++;
        }), f2 > 0 && (a2 = this.seriesLen * a2 / f2), t2 = o2 + a2 * this.visibleI, t2 -= a2 * b2;
      } else
        t2 = o2 + a2 * this.visibleI;
      this.isFunnel && (r -= (this.barHelpers.getXForValue(this.series[g2][p2], r) - r) / 2), n2 = this.barHelpers.getXForValue(this.series[g2][p2], r);
      var m2 = this.barHelpers.getBarpaths({ barYPosition: t2, barHeight: a2, x1: r, x2: n2, strokeWidth: s2, series: this.series, realIndex: i.realIndex, i: g2, j: p2, w: d2 });
      return d2.globals.isXNumeric || (o2 += h2), this.barHelpers.barBackground({ j: p2, i: g2, y1: t2 - a2 * this.visibleI, y2: a2 * this.seriesLen, elSeries: c2 }), { pathTo: m2.pathTo, pathFrom: m2.pathFrom, x1: r, x: n2, y: o2, goalX: this.barHelpers.getGoalValues("x", r, null, g2, p2), barYPosition: t2, barHeight: a2 };
    } }, { key: "drawColumnPaths", value: function(e2) {
      var t2, i = e2.indexes, a2 = e2.x, s2 = e2.y, r = e2.xDivision, n2 = e2.barWidth, o2 = e2.zeroH, h2 = e2.strokeWidth, c2 = e2.elSeries, d2 = this.w, g2 = i.realIndex, p2 = i.i, f2 = i.j, b2 = i.bc;
      if (d2.globals.isXNumeric) {
        var m2 = this.getBarXForNumericXAxis({ x: a2, j: f2, realIndex: g2, barWidth: n2 });
        a2 = m2.x, t2 = m2.barXPosition;
      } else if (d2.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
        var w2 = this.barHelpers.getZeroValueEncounters({ i: p2, j: f2 }), A2 = w2.nonZeroColumns, l2 = w2.zeroEncounters;
        A2 > 0 && (n2 = this.seriesLen * n2 / A2), t2 = a2 + n2 * this.visibleI, t2 -= n2 * l2;
      } else
        t2 = a2 + n2 * this.visibleI;
      s2 = this.barHelpers.getYForValue(this.series[p2][f2], o2);
      var u2 = this.barHelpers.getColumnPaths({ barXPosition: t2, barWidth: n2, y1: o2, y2: s2, strokeWidth: h2, series: this.series, realIndex: i.realIndex, i: p2, j: f2, w: d2 });
      return d2.globals.isXNumeric || (a2 += r), this.barHelpers.barBackground({ bc: b2, j: f2, i: p2, x1: t2 - h2 / 2 - n2 * this.visibleI, x2: n2 * this.seriesLen + h2 / 2, elSeries: c2 }), { pathTo: u2.pathTo, pathFrom: u2.pathFrom, x: a2, y: s2, goalY: this.barHelpers.getGoalValues("y", null, o2, p2, f2), barXPosition: t2, barWidth: n2 };
    } }, { key: "getBarXForNumericXAxis", value: function(e2) {
      var t2 = e2.x, i = e2.barWidth, a2 = e2.realIndex, s2 = e2.j, r = this.w, n2 = a2;
      return r.globals.seriesX[a2].length || (n2 = r.globals.maxValsInArrayIndex), r.globals.seriesX[n2][s2] && (t2 = (r.globals.seriesX[n2][s2] - r.globals.minX) / this.xRatio - i * this.seriesLen / 2), { barXPosition: t2 + i * this.visibleI, x: t2 };
    } }, { key: "getPreviousPath", value: function(e2, t2) {
      for (var i, a2 = this.w, s2 = 0; s2 < a2.globals.previousPaths.length; s2++) {
        var r = a2.globals.previousPaths[s2];
        r.paths && r.paths.length > 0 && parseInt(r.realIndex, 10) === parseInt(e2, 10) && a2.globals.previousPaths[s2].paths[t2] !== void 0 && (i = a2.globals.previousPaths[s2].paths[t2].d);
      }
      return i;
    } }]), y2;
  }(), st2 = function(y2) {
    ge2(t2, ke);
    var e2 = ue2(t2);
    function t2() {
      return F2(this, t2), e2.apply(this, arguments);
    }
    return Y2(t2, [{ key: "draw", value: function(i, a2) {
      var s2 = this, r = this.w;
      this.graphics = new M2(this.ctx), this.bar = new ke(this.ctx, this.xyRatios);
      var n2 = new q2(this.ctx, r);
      i = n2.getLogSeries(i), this.yRatio = n2.getLogYRatios(this.yRatio), this.barHelpers.initVariables(i), r.config.chart.stackType === "100%" && (i = r.globals.seriesPercent.slice()), this.series = i, this.barHelpers.initializeStackedPrevVars(this);
      for (var o2 = this.graphics.group({ class: "apexcharts-bar-series apexcharts-plot-series" }), h2 = 0, c2 = 0, d2 = function(f2, b2) {
        var m2 = void 0, w2 = void 0, A2 = void 0, l2 = void 0, u2 = -1;
        s2.groupCtx = s2, r.globals.seriesGroups.forEach(function(V2, j2) {
          V2.indexOf(r.config.series[f2].name) > -1 && (u2 = j2);
        }), u2 !== -1 && (s2.groupCtx = s2[r.globals.seriesGroups[u2]]);
        var x2 = [], v2 = [], k2 = r.globals.comboCharts ? a2[f2] : f2;
        s2.yRatio.length > 1 && (s2.yaxisIndex = k2), s2.isReversed = r.config.yaxis[s2.yaxisIndex] && r.config.yaxis[s2.yaxisIndex].reversed;
        var S2 = s2.graphics.group({ class: "apexcharts-series", seriesName: P2.escapeString(r.globals.seriesNames[k2]), rel: f2 + 1, "data:realIndex": k2 });
        s2.ctx.series.addCollapsedClassToSeries(S2, k2);
        var C2 = s2.graphics.group({ class: "apexcharts-datalabels", "data:realIndex": k2 }), L2 = s2.graphics.group({ class: "apexcharts-bar-goals-markers" }), I2 = 0, z2 = 0, T2 = s2.initialPositions(h2, c2, m2, w2, A2, l2);
        c2 = T2.y, I2 = T2.barHeight, w2 = T2.yDivision, l2 = T2.zeroW, h2 = T2.x, z2 = T2.barWidth, m2 = T2.xDivision, A2 = T2.zeroH, r.globals.barHeight = I2, r.globals.barWidth = z2, s2.barHelpers.initializeStackedXYVars(s2), s2.groupCtx.prevY.length === 1 && s2.groupCtx.prevY[0].every(function(V2) {
          return isNaN(V2);
        }) && (s2.groupCtx.prevY[0] = s2.groupCtx.prevY[0].map(function(V2) {
          return A2;
        }), s2.groupCtx.prevYF[0] = s2.groupCtx.prevYF[0].map(function(V2) {
          return 0;
        }));
        for (var E2 = 0; E2 < r.globals.dataPoints; E2++) {
          var R2 = s2.barHelpers.getStrokeWidth(f2, E2, k2), O2 = { indexes: { i: f2, j: E2, realIndex: k2, bc: b2 }, strokeWidth: R2, x: h2, y: c2, elSeries: S2, groupIndex: u2, seriesGroup: r.globals.seriesGroups[u2] }, D2 = null;
          s2.isHorizontal ? (D2 = s2.drawStackedBarPaths(X2(X2({}, O2), {}, { zeroW: l2, barHeight: I2, yDivision: w2 })), z2 = s2.series[f2][E2] / s2.invertedYRatio) : (D2 = s2.drawStackedColumnPaths(X2(X2({}, O2), {}, { xDivision: m2, barWidth: z2, zeroH: A2 })), I2 = s2.series[f2][E2] / s2.yRatio[s2.yaxisIndex]);
          var W2 = s2.barHelpers.drawGoalLine({ barXPosition: D2.barXPosition, barYPosition: D2.barYPosition, goalX: D2.goalX, goalY: D2.goalY, barHeight: I2, barWidth: z2 });
          W2 && L2.add(W2), c2 = D2.y, h2 = D2.x, x2.push(h2), v2.push(c2);
          var N2 = s2.barHelpers.getPathFillColor(i, f2, E2, k2);
          S2 = s2.renderSeries({ realIndex: k2, pathFill: N2, j: E2, i: f2, groupIndex: u2, pathFrom: D2.pathFrom, pathTo: D2.pathTo, strokeWidth: R2, elSeries: S2, x: h2, y: c2, series: i, barHeight: I2, barWidth: z2, elDataLabelsWrap: C2, elGoalsMarkers: L2, type: "bar", visibleSeries: 0 });
        }
        r.globals.seriesXvalues[k2] = x2, r.globals.seriesYvalues[k2] = v2, s2.groupCtx.prevY.push(s2.groupCtx.yArrj), s2.groupCtx.prevYF.push(s2.groupCtx.yArrjF), s2.groupCtx.prevYVal.push(s2.groupCtx.yArrjVal), s2.groupCtx.prevX.push(s2.groupCtx.xArrj), s2.groupCtx.prevXF.push(s2.groupCtx.xArrjF), s2.groupCtx.prevXVal.push(s2.groupCtx.xArrjVal), o2.add(S2);
      }, g2 = 0, p2 = 0; g2 < i.length; g2++, p2++)
        d2(g2, p2);
      return o2;
    } }, { key: "initialPositions", value: function(i, a2, s2, r, n2, o2) {
      var h2, c2, d2, g2, p2 = this.w;
      return this.isHorizontal ? (d2 = (d2 = r = p2.globals.gridHeight / p2.globals.dataPoints) * parseInt(p2.config.plotOptions.bar.barHeight, 10) / 100, String(p2.config.plotOptions.bar.barHeight).indexOf("%") === -1 && (d2 = parseInt(p2.config.plotOptions.bar.barHeight, 10)), o2 = this.baseLineInvertedY + p2.globals.padHorizontal + (this.isReversed ? p2.globals.gridWidth : 0) - (this.isReversed ? 2 * this.baseLineInvertedY : 0), a2 = (r - d2) / 2) : (g2 = s2 = p2.globals.gridWidth / p2.globals.dataPoints, g2 = p2.globals.isXNumeric && p2.globals.dataPoints > 1 ? (s2 = p2.globals.minXDiff / this.xRatio) * parseInt(this.barOptions.columnWidth, 10) / 100 : g2 * parseInt(p2.config.plotOptions.bar.columnWidth, 10) / 100, String(p2.config.plotOptions.bar.columnWidth).indexOf("%") === -1 && (g2 = parseInt(p2.config.plotOptions.bar.columnWidth, 10)), n2 = p2.globals.gridHeight - this.baseLineY[this.yaxisIndex] - (this.isReversed ? p2.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0), i = p2.globals.padHorizontal + (s2 - g2) / 2), { x: i, y: a2, yDivision: r, xDivision: s2, barHeight: (h2 = p2.globals.seriesGroups) !== null && h2 !== void 0 && h2.length ? d2 / p2.globals.seriesGroups.length : d2, barWidth: (c2 = p2.globals.seriesGroups) !== null && c2 !== void 0 && c2.length ? g2 / p2.globals.seriesGroups.length : g2, zeroH: n2, zeroW: o2 };
    } }, { key: "drawStackedBarPaths", value: function(i) {
      for (var a2, s2 = i.indexes, r = i.barHeight, n2 = i.strokeWidth, o2 = i.zeroW, h2 = i.x, c2 = i.y, d2 = i.groupIndex, g2 = i.seriesGroup, p2 = i.yDivision, f2 = i.elSeries, b2 = this.w, m2 = c2 + (d2 !== -1 ? d2 * r : 0), w2 = s2.i, A2 = s2.j, l2 = 0, u2 = 0; u2 < this.groupCtx.prevXF.length; u2++)
        l2 += this.groupCtx.prevXF[u2][A2];
      var x2 = w2;
      if (g2 && (x2 = g2.indexOf(b2.config.series[w2].name)), x2 > 0) {
        var v2 = o2;
        this.groupCtx.prevXVal[x2 - 1][A2] < 0 ? v2 = this.series[w2][A2] >= 0 ? this.groupCtx.prevX[x2 - 1][A2] + l2 - 2 * (this.isReversed ? l2 : 0) : this.groupCtx.prevX[x2 - 1][A2] : this.groupCtx.prevXVal[x2 - 1][A2] >= 0 && (v2 = this.series[w2][A2] >= 0 ? this.groupCtx.prevX[x2 - 1][A2] : this.groupCtx.prevX[x2 - 1][A2] - l2 + 2 * (this.isReversed ? l2 : 0)), a2 = v2;
      } else
        a2 = o2;
      h2 = this.series[w2][A2] === null ? a2 : a2 + this.series[w2][A2] / this.invertedYRatio - 2 * (this.isReversed ? this.series[w2][A2] / this.invertedYRatio : 0);
      var k2 = this.barHelpers.getBarpaths({ barYPosition: m2, barHeight: r, x1: a2, x2: h2, strokeWidth: n2, series: this.series, realIndex: s2.realIndex, seriesGroup: g2, i: w2, j: A2, w: b2 });
      return this.barHelpers.barBackground({ j: A2, i: w2, y1: m2, y2: r, elSeries: f2 }), c2 += p2, { pathTo: k2.pathTo, pathFrom: k2.pathFrom, goalX: this.barHelpers.getGoalValues("x", o2, null, w2, A2), barYPosition: m2, x: h2, y: c2 };
    } }, { key: "drawStackedColumnPaths", value: function(i) {
      var a2 = i.indexes, s2 = i.x, r = i.y, n2 = i.xDivision, o2 = i.barWidth, h2 = i.zeroH, c2 = i.groupIndex, d2 = i.seriesGroup, g2 = i.elSeries, p2 = this.w, f2 = a2.i, b2 = a2.j, m2 = a2.bc;
      if (p2.globals.isXNumeric) {
        var w2 = p2.globals.seriesX[f2][b2];
        w2 || (w2 = 0), s2 = (w2 - p2.globals.minX) / this.xRatio - o2 / 2, p2.globals.seriesGroups.length && (s2 = (w2 - p2.globals.minX) / this.xRatio - o2 / 2 * p2.globals.seriesGroups.length);
      }
      for (var A2, l2 = s2 + (c2 !== -1 ? c2 * o2 : 0), u2 = 0, x2 = 0; x2 < this.groupCtx.prevYF.length; x2++)
        u2 += isNaN(this.groupCtx.prevYF[x2][b2]) ? 0 : this.groupCtx.prevYF[x2][b2];
      var v2 = f2;
      if (d2 && (v2 = d2.indexOf(p2.config.series[f2].name)), v2 > 0 && !p2.globals.isXNumeric || v2 > 0 && p2.globals.isXNumeric && p2.globals.seriesX[f2 - 1][b2] === p2.globals.seriesX[f2][b2]) {
        var k2, S2, C2, L2 = Math.min(this.yRatio.length + 1, f2 + 1);
        if (this.groupCtx.prevY[v2 - 1] !== void 0 && this.groupCtx.prevY[v2 - 1].length)
          for (var I2 = 1; I2 < L2; I2++) {
            var z2;
            if (!isNaN((z2 = this.groupCtx.prevY[v2 - I2]) === null || z2 === void 0 ? void 0 : z2[b2])) {
              C2 = this.groupCtx.prevY[v2 - I2][b2];
              break;
            }
          }
        for (var T2 = 1; T2 < L2; T2++) {
          var E2, R2;
          if (((E2 = this.groupCtx.prevYVal[v2 - T2]) === null || E2 === void 0 ? void 0 : E2[b2]) < 0) {
            S2 = this.series[f2][b2] >= 0 ? C2 - u2 + 2 * (this.isReversed ? u2 : 0) : C2;
            break;
          }
          if (((R2 = this.groupCtx.prevYVal[v2 - T2]) === null || R2 === void 0 ? void 0 : R2[b2]) >= 0) {
            S2 = this.series[f2][b2] >= 0 ? C2 : C2 + u2 - 2 * (this.isReversed ? u2 : 0);
            break;
          }
        }
        S2 === void 0 && (S2 = p2.globals.gridHeight), A2 = (k2 = this.groupCtx.prevYF[0]) !== null && k2 !== void 0 && k2.every(function(D2) {
          return D2 === 0;
        }) && this.groupCtx.prevYF.slice(1, v2).every(function(D2) {
          return D2.every(function(W2) {
            return isNaN(W2);
          });
        }) ? h2 : S2;
      } else
        A2 = h2;
      r = this.series[f2][b2] ? A2 - this.series[f2][b2] / this.yRatio[this.yaxisIndex] + 2 * (this.isReversed ? this.series[f2][b2] / this.yRatio[this.yaxisIndex] : 0) : A2;
      var O2 = this.barHelpers.getColumnPaths({ barXPosition: l2, barWidth: o2, y1: A2, y2: r, yRatio: this.yRatio[this.yaxisIndex], strokeWidth: this.strokeWidth, series: this.series, seriesGroup: d2, realIndex: a2.realIndex, i: f2, j: b2, w: p2 });
      return this.barHelpers.barBackground({ bc: m2, j: b2, i: f2, x1: l2, x2: o2, elSeries: g2 }), s2 += n2, { pathTo: O2.pathTo, pathFrom: O2.pathFrom, goalY: this.barHelpers.getGoalValues("y", null, h2, f2, b2), barXPosition: l2, x: p2.globals.isXNumeric ? s2 - n2 : s2, y: r };
    } }]), t2;
  }(), Be = function(y2) {
    ge2(t2, ke);
    var e2 = ue2(t2);
    function t2() {
      return F2(this, t2), e2.apply(this, arguments);
    }
    return Y2(t2, [{ key: "draw", value: function(i, a2, s2) {
      var r = this, n2 = this.w, o2 = new M2(this.ctx), h2 = n2.globals.comboCharts ? a2 : n2.config.chart.type, c2 = new ae2(this.ctx);
      this.candlestickOptions = this.w.config.plotOptions.candlestick, this.boxOptions = this.w.config.plotOptions.boxPlot, this.isHorizontal = n2.config.plotOptions.bar.horizontal;
      var d2 = new q2(this.ctx, n2);
      i = d2.getLogSeries(i), this.series = i, this.yRatio = d2.getLogYRatios(this.yRatio), this.barHelpers.initVariables(i);
      for (var g2 = o2.group({ class: "apexcharts-".concat(h2, "-series apexcharts-plot-series") }), p2 = function(b2) {
        r.isBoxPlot = n2.config.chart.type === "boxPlot" || n2.config.series[b2].type === "boxPlot";
        var m2, w2, A2, l2, u2 = void 0, x2 = void 0, v2 = [], k2 = [], S2 = n2.globals.comboCharts ? s2[b2] : b2, C2 = o2.group({ class: "apexcharts-series", seriesName: P2.escapeString(n2.globals.seriesNames[S2]), rel: b2 + 1, "data:realIndex": S2 });
        r.ctx.series.addCollapsedClassToSeries(C2, S2), i[b2].length > 0 && (r.visibleI = r.visibleI + 1);
        var L2, I2;
        r.yRatio.length > 1 && (r.yaxisIndex = S2);
        var z2 = r.barHelpers.initialPositions();
        x2 = z2.y, L2 = z2.barHeight, w2 = z2.yDivision, l2 = z2.zeroW, u2 = z2.x, I2 = z2.barWidth, m2 = z2.xDivision, A2 = z2.zeroH, k2.push(u2 + I2 / 2);
        for (var T2 = o2.group({ class: "apexcharts-datalabels", "data:realIndex": S2 }), E2 = function(O2) {
          var D2 = r.barHelpers.getStrokeWidth(b2, O2, S2), W2 = null, N2 = { indexes: { i: b2, j: O2, realIndex: S2 }, x: u2, y: x2, strokeWidth: D2, elSeries: C2 };
          W2 = r.isHorizontal ? r.drawHorizontalBoxPaths(X2(X2({}, N2), {}, { yDivision: w2, barHeight: L2, zeroW: l2 })) : r.drawVerticalBoxPaths(X2(X2({}, N2), {}, { xDivision: m2, barWidth: I2, zeroH: A2 })), x2 = W2.y, u2 = W2.x, O2 > 0 && k2.push(u2 + I2 / 2), v2.push(x2), W2.pathTo.forEach(function(V2, j2) {
            var se2 = !r.isBoxPlot && r.candlestickOptions.wick.useFillColor ? W2.color[j2] : n2.globals.stroke.colors[b2], K2 = c2.fillPath({ seriesNumber: S2, dataPointIndex: O2, color: W2.color[j2], value: i[b2][O2] });
            r.renderSeries({ realIndex: S2, pathFill: K2, lineFill: se2, j: O2, i: b2, pathFrom: W2.pathFrom, pathTo: V2, strokeWidth: D2, elSeries: C2, x: u2, y: x2, series: i, barHeight: L2, barWidth: I2, elDataLabelsWrap: T2, visibleSeries: r.visibleI, type: n2.config.chart.type });
          });
        }, R2 = 0; R2 < n2.globals.dataPoints; R2++)
          E2(R2);
        n2.globals.seriesXvalues[S2] = k2, n2.globals.seriesYvalues[S2] = v2, g2.add(C2);
      }, f2 = 0; f2 < i.length; f2++)
        p2(f2);
      return g2;
    } }, { key: "drawVerticalBoxPaths", value: function(i) {
      var a2 = i.indexes, s2 = i.x;
      i.y;
      var r = i.xDivision, n2 = i.barWidth, o2 = i.zeroH, h2 = i.strokeWidth, c2 = this.w, d2 = new M2(this.ctx), g2 = a2.i, p2 = a2.j, f2 = true, b2 = c2.config.plotOptions.candlestick.colors.upward, m2 = c2.config.plotOptions.candlestick.colors.downward, w2 = "";
      this.isBoxPlot && (w2 = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
      var A2 = this.yRatio[this.yaxisIndex], l2 = a2.realIndex, u2 = this.getOHLCValue(l2, p2), x2 = o2, v2 = o2;
      u2.o > u2.c && (f2 = false);
      var k2 = Math.min(u2.o, u2.c), S2 = Math.max(u2.o, u2.c), C2 = u2.m;
      c2.globals.isXNumeric && (s2 = (c2.globals.seriesX[l2][p2] - c2.globals.minX) / this.xRatio - n2 / 2);
      var L2 = s2 + n2 * this.visibleI;
      this.series[g2][p2] === void 0 || this.series[g2][p2] === null ? (k2 = o2, S2 = o2) : (k2 = o2 - k2 / A2, S2 = o2 - S2 / A2, x2 = o2 - u2.h / A2, v2 = o2 - u2.l / A2, C2 = o2 - u2.m / A2);
      var I2 = d2.move(L2, o2), z2 = d2.move(L2 + n2 / 2, k2);
      return c2.globals.previousPaths.length > 0 && (z2 = this.getPreviousPath(l2, p2, true)), I2 = this.isBoxPlot ? [d2.move(L2, k2) + d2.line(L2 + n2 / 2, k2) + d2.line(L2 + n2 / 2, x2) + d2.line(L2 + n2 / 4, x2) + d2.line(L2 + n2 - n2 / 4, x2) + d2.line(L2 + n2 / 2, x2) + d2.line(L2 + n2 / 2, k2) + d2.line(L2 + n2, k2) + d2.line(L2 + n2, C2) + d2.line(L2, C2) + d2.line(L2, k2 + h2 / 2), d2.move(L2, C2) + d2.line(L2 + n2, C2) + d2.line(L2 + n2, S2) + d2.line(L2 + n2 / 2, S2) + d2.line(L2 + n2 / 2, v2) + d2.line(L2 + n2 - n2 / 4, v2) + d2.line(L2 + n2 / 4, v2) + d2.line(L2 + n2 / 2, v2) + d2.line(L2 + n2 / 2, S2) + d2.line(L2, S2) + d2.line(L2, C2) + "z"] : [d2.move(L2, S2) + d2.line(L2 + n2 / 2, S2) + d2.line(L2 + n2 / 2, x2) + d2.line(L2 + n2 / 2, S2) + d2.line(L2 + n2, S2) + d2.line(L2 + n2, k2) + d2.line(L2 + n2 / 2, k2) + d2.line(L2 + n2 / 2, v2) + d2.line(L2 + n2 / 2, k2) + d2.line(L2, k2) + d2.line(L2, S2 - h2 / 2)], z2 += d2.move(L2, k2), c2.globals.isXNumeric || (s2 += r), { pathTo: I2, pathFrom: z2, x: s2, y: S2, barXPosition: L2, color: this.isBoxPlot ? w2 : f2 ? [b2] : [m2] };
    } }, { key: "drawHorizontalBoxPaths", value: function(i) {
      var a2 = i.indexes;
      i.x;
      var s2 = i.y, r = i.yDivision, n2 = i.barHeight, o2 = i.zeroW, h2 = i.strokeWidth, c2 = this.w, d2 = new M2(this.ctx), g2 = a2.i, p2 = a2.j, f2 = this.boxOptions.colors.lower;
      this.isBoxPlot && (f2 = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
      var b2 = this.invertedYRatio, m2 = a2.realIndex, w2 = this.getOHLCValue(m2, p2), A2 = o2, l2 = o2, u2 = Math.min(w2.o, w2.c), x2 = Math.max(w2.o, w2.c), v2 = w2.m;
      c2.globals.isXNumeric && (s2 = (c2.globals.seriesX[m2][p2] - c2.globals.minX) / this.invertedXRatio - n2 / 2);
      var k2 = s2 + n2 * this.visibleI;
      this.series[g2][p2] === void 0 || this.series[g2][p2] === null ? (u2 = o2, x2 = o2) : (u2 = o2 + u2 / b2, x2 = o2 + x2 / b2, A2 = o2 + w2.h / b2, l2 = o2 + w2.l / b2, v2 = o2 + w2.m / b2);
      var S2 = d2.move(o2, k2), C2 = d2.move(u2, k2 + n2 / 2);
      return c2.globals.previousPaths.length > 0 && (C2 = this.getPreviousPath(m2, p2, true)), S2 = [d2.move(u2, k2) + d2.line(u2, k2 + n2 / 2) + d2.line(A2, k2 + n2 / 2) + d2.line(A2, k2 + n2 / 2 - n2 / 4) + d2.line(A2, k2 + n2 / 2 + n2 / 4) + d2.line(A2, k2 + n2 / 2) + d2.line(u2, k2 + n2 / 2) + d2.line(u2, k2 + n2) + d2.line(v2, k2 + n2) + d2.line(v2, k2) + d2.line(u2 + h2 / 2, k2), d2.move(v2, k2) + d2.line(v2, k2 + n2) + d2.line(x2, k2 + n2) + d2.line(x2, k2 + n2 / 2) + d2.line(l2, k2 + n2 / 2) + d2.line(l2, k2 + n2 - n2 / 4) + d2.line(l2, k2 + n2 / 4) + d2.line(l2, k2 + n2 / 2) + d2.line(x2, k2 + n2 / 2) + d2.line(x2, k2) + d2.line(v2, k2) + "z"], C2 += d2.move(u2, k2), c2.globals.isXNumeric || (s2 += r), { pathTo: S2, pathFrom: C2, x: x2, y: s2, barYPosition: k2, color: f2 };
    } }, { key: "getOHLCValue", value: function(i, a2) {
      var s2 = this.w;
      return { o: this.isBoxPlot ? s2.globals.seriesCandleH[i][a2] : s2.globals.seriesCandleO[i][a2], h: this.isBoxPlot ? s2.globals.seriesCandleO[i][a2] : s2.globals.seriesCandleH[i][a2], m: s2.globals.seriesCandleM[i][a2], l: this.isBoxPlot ? s2.globals.seriesCandleC[i][a2] : s2.globals.seriesCandleL[i][a2], c: this.isBoxPlot ? s2.globals.seriesCandleL[i][a2] : s2.globals.seriesCandleC[i][a2] };
    } }]), t2;
  }(), rt2 = function() {
    function y2(e2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w;
    }
    return Y2(y2, [{ key: "checkColorRange", value: function() {
      var e2 = this.w, t2 = false, i = e2.config.plotOptions[e2.config.chart.type];
      return i.colorScale.ranges.length > 0 && i.colorScale.ranges.map(function(a2, s2) {
        a2.from <= 0 && (t2 = true);
      }), t2;
    } }, { key: "getShadeColor", value: function(e2, t2, i, a2) {
      var s2 = this.w, r = 1, n2 = s2.config.plotOptions[e2].shadeIntensity, o2 = this.determineColor(e2, t2, i);
      s2.globals.hasNegs || a2 ? r = s2.config.plotOptions[e2].reverseNegativeShade ? o2.percent < 0 ? o2.percent / 100 * (1.25 * n2) : (1 - o2.percent / 100) * (1.25 * n2) : o2.percent <= 0 ? 1 - (1 + o2.percent / 100) * n2 : (1 - o2.percent / 100) * n2 : (r = 1 - o2.percent / 100, e2 === "treemap" && (r = (1 - o2.percent / 100) * (1.25 * n2)));
      var h2 = o2.color, c2 = new P2();
      return s2.config.plotOptions[e2].enableShades && (h2 = this.w.config.theme.mode === "dark" ? P2.hexToRgba(c2.shadeColor(-1 * r, o2.color), s2.config.fill.opacity) : P2.hexToRgba(c2.shadeColor(r, o2.color), s2.config.fill.opacity)), { color: h2, colorProps: o2 };
    } }, { key: "determineColor", value: function(e2, t2, i) {
      var a2 = this.w, s2 = a2.globals.series[t2][i], r = a2.config.plotOptions[e2], n2 = r.colorScale.inverse ? i : t2;
      r.distributed && a2.config.chart.type === "treemap" && (n2 = i);
      var o2 = a2.globals.colors[n2], h2 = null, c2 = Math.min.apply(Math, J2(a2.globals.series[t2])), d2 = Math.max.apply(Math, J2(a2.globals.series[t2]));
      r.distributed || e2 !== "heatmap" || (c2 = a2.globals.minY, d2 = a2.globals.maxY), r.colorScale.min !== void 0 && (c2 = r.colorScale.min < a2.globals.minY ? r.colorScale.min : a2.globals.minY, d2 = r.colorScale.max > a2.globals.maxY ? r.colorScale.max : a2.globals.maxY);
      var g2 = Math.abs(d2) + Math.abs(c2), p2 = 100 * s2 / (g2 === 0 ? g2 - 1e-6 : g2);
      return r.colorScale.ranges.length > 0 && r.colorScale.ranges.map(function(f2, b2) {
        if (s2 >= f2.from && s2 <= f2.to) {
          o2 = f2.color, h2 = f2.foreColor ? f2.foreColor : null, c2 = f2.from, d2 = f2.to;
          var m2 = Math.abs(d2) + Math.abs(c2);
          p2 = 100 * s2 / (m2 === 0 ? m2 - 1e-6 : m2);
        }
      }), { color: o2, foreColor: h2, percent: p2 };
    } }, { key: "calculateDataLabels", value: function(e2) {
      var t2 = e2.text, i = e2.x, a2 = e2.y, s2 = e2.i, r = e2.j, n2 = e2.colorProps, o2 = e2.fontSize, h2 = this.w.config.dataLabels, c2 = new M2(this.ctx), d2 = new ye2(this.ctx), g2 = null;
      if (h2.enabled) {
        g2 = c2.group({ class: "apexcharts-data-labels" });
        var p2 = h2.offsetX, f2 = h2.offsetY, b2 = i + p2, m2 = a2 + parseFloat(h2.style.fontSize) / 3 + f2;
        d2.plotDataLabelsText({ x: b2, y: m2, text: t2, i: s2, j: r, color: n2.foreColor, parent: g2, fontSize: o2, dataLabelsConfig: h2 });
      }
      return g2;
    } }, { key: "addListeners", value: function(e2) {
      var t2 = new M2(this.ctx);
      e2.node.addEventListener("mouseenter", t2.pathMouseEnter.bind(this, e2)), e2.node.addEventListener("mouseleave", t2.pathMouseLeave.bind(this, e2)), e2.node.addEventListener("mousedown", t2.pathMouseDown.bind(this, e2));
    } }]), y2;
  }(), Yt2 = function() {
    function y2(e2, t2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w, this.xRatio = t2.xRatio, this.yRatio = t2.yRatio, this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.helpers = new rt2(e2), this.rectRadius = this.w.config.plotOptions.heatmap.radius, this.strokeWidth = this.w.config.stroke.show ? this.w.config.stroke.width : 0;
    }
    return Y2(y2, [{ key: "draw", value: function(e2) {
      var t2 = this.w, i = new M2(this.ctx), a2 = i.group({ class: "apexcharts-heatmap" });
      a2.attr("clip-path", "url(#gridRectMask".concat(t2.globals.cuid, ")"));
      var s2 = t2.globals.gridWidth / t2.globals.dataPoints, r = t2.globals.gridHeight / t2.globals.series.length, n2 = 0, o2 = false;
      this.negRange = this.helpers.checkColorRange();
      var h2 = e2.slice();
      t2.config.yaxis[0].reversed && (o2 = true, h2.reverse());
      for (var c2 = o2 ? 0 : h2.length - 1; o2 ? c2 < h2.length : c2 >= 0; o2 ? c2++ : c2--) {
        var d2 = i.group({ class: "apexcharts-series apexcharts-heatmap-series", seriesName: P2.escapeString(t2.globals.seriesNames[c2]), rel: c2 + 1, "data:realIndex": c2 });
        if (this.ctx.series.addCollapsedClassToSeries(d2, c2), t2.config.chart.dropShadow.enabled) {
          var g2 = t2.config.chart.dropShadow;
          new Z2(this.ctx).dropShadow(d2, g2, c2);
        }
        for (var p2 = 0, f2 = t2.config.plotOptions.heatmap.shadeIntensity, b2 = 0; b2 < h2[c2].length; b2++) {
          var m2 = this.helpers.getShadeColor(t2.config.chart.type, c2, b2, this.negRange), w2 = m2.color, A2 = m2.colorProps;
          t2.config.fill.type === "image" && (w2 = new ae2(this.ctx).fillPath({ seriesNumber: c2, dataPointIndex: b2, opacity: t2.globals.hasNegs ? A2.percent < 0 ? 1 - (1 + A2.percent / 100) : f2 + A2.percent / 100 : A2.percent / 100, patternID: P2.randomId(), width: t2.config.fill.image.width ? t2.config.fill.image.width : s2, height: t2.config.fill.image.height ? t2.config.fill.image.height : r }));
          var l2 = this.rectRadius, u2 = i.drawRect(p2, n2, s2, r, l2);
          if (u2.attr({ cx: p2, cy: n2 }), u2.node.classList.add("apexcharts-heatmap-rect"), d2.add(u2), u2.attr({ fill: w2, i: c2, index: c2, j: b2, val: e2[c2][b2], "stroke-width": this.strokeWidth, stroke: t2.config.plotOptions.heatmap.useFillColorAsStroke ? w2 : t2.globals.stroke.colors[0], color: w2 }), this.helpers.addListeners(u2), t2.config.chart.animations.enabled && !t2.globals.dataChanged) {
            var x2 = 1;
            t2.globals.resized || (x2 = t2.config.chart.animations.speed), this.animateHeatMap(u2, p2, n2, s2, r, x2);
          }
          if (t2.globals.dataChanged) {
            var v2 = 1;
            if (this.dynamicAnim.enabled && t2.globals.shouldAnimate) {
              v2 = this.dynamicAnim.speed;
              var k2 = t2.globals.previousPaths[c2] && t2.globals.previousPaths[c2][b2] && t2.globals.previousPaths[c2][b2].color;
              k2 || (k2 = "rgba(255, 255, 255, 0)"), this.animateHeatColor(u2, P2.isColorHex(k2) ? k2 : P2.rgb2hex(k2), P2.isColorHex(w2) ? w2 : P2.rgb2hex(w2), v2);
            }
          }
          var S2 = (0, t2.config.dataLabels.formatter)(t2.globals.series[c2][b2], { value: t2.globals.series[c2][b2], seriesIndex: c2, dataPointIndex: b2, w: t2 }), C2 = this.helpers.calculateDataLabels({ text: S2, x: p2 + s2 / 2, y: n2 + r / 2, i: c2, j: b2, colorProps: A2, series: h2 });
          C2 !== null && d2.add(C2), p2 += s2;
        }
        n2 += r, a2.add(d2);
      }
      var L2 = t2.globals.yAxisScale[0].result.slice();
      return t2.config.yaxis[0].reversed ? L2.unshift("") : L2.push(""), t2.globals.yAxisScale[0].result = L2, a2;
    } }, { key: "animateHeatMap", value: function(e2, t2, i, a2, s2, r) {
      var n2 = new de2(this.ctx);
      n2.animateRect(e2, { x: t2 + a2 / 2, y: i + s2 / 2, width: 0, height: 0 }, { x: t2, y: i, width: a2, height: s2 }, r, function() {
        n2.animationCompleted(e2);
      });
    } }, { key: "animateHeatColor", value: function(e2, t2, i, a2) {
      e2.attr({ fill: t2 }).animate(a2).attr({ fill: i });
    } }]), y2;
  }(), nt2 = function() {
    function y2(e2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w;
    }
    return Y2(y2, [{ key: "drawYAxisTexts", value: function(e2, t2, i, a2) {
      var s2 = this.w, r = s2.config.yaxis[0], n2 = s2.globals.yLabelFormatters[0];
      return new M2(this.ctx).drawText({ x: e2 + r.labels.offsetX, y: t2 + r.labels.offsetY, text: n2(a2, i), textAnchor: "middle", fontSize: r.labels.style.fontSize, fontFamily: r.labels.style.fontFamily, foreColor: Array.isArray(r.labels.style.colors) ? r.labels.style.colors[i] : r.labels.style.colors });
    } }]), y2;
  }(), ot2 = function() {
    function y2(e2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w;
      var t2 = this.w;
      this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animBeginArr = [0], this.animDur = 0, this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels, this.lineColorArr = t2.globals.stroke.colors !== void 0 ? t2.globals.stroke.colors : t2.globals.colors, this.defaultSize = Math.min(t2.globals.gridWidth, t2.globals.gridHeight), this.centerY = this.defaultSize / 2, this.centerX = t2.globals.gridWidth / 2, t2.config.chart.type === "radialBar" ? this.fullAngle = 360 : this.fullAngle = Math.abs(t2.config.plotOptions.pie.endAngle - t2.config.plotOptions.pie.startAngle), this.initialAngle = t2.config.plotOptions.pie.startAngle % this.fullAngle, t2.globals.radialSize = this.defaultSize / 2.05 - t2.config.stroke.width - (t2.config.chart.sparkline.enabled ? 0 : t2.config.chart.dropShadow.blur), this.donutSize = t2.globals.radialSize * parseInt(t2.config.plotOptions.pie.donut.size, 10) / 100, this.maxY = 0, this.sliceLabels = [], this.sliceSizes = [], this.prevSectorAngleArr = [];
    }
    return Y2(y2, [{ key: "draw", value: function(e2) {
      var t2 = this, i = this.w, a2 = new M2(this.ctx);
      if (this.ret = a2.group({ class: "apexcharts-pie" }), i.globals.noData)
        return this.ret;
      for (var s2 = 0, r = 0; r < e2.length; r++)
        s2 += P2.negToZero(e2[r]);
      var n2 = [], o2 = a2.group();
      s2 === 0 && (s2 = 1e-5), e2.forEach(function(k2) {
        t2.maxY = Math.max(t2.maxY, k2);
      }), i.config.yaxis[0].max && (this.maxY = i.config.yaxis[0].max), i.config.grid.position === "back" && this.chartType === "polarArea" && this.drawPolarElements(this.ret);
      for (var h2 = 0; h2 < e2.length; h2++) {
        var c2 = this.fullAngle * P2.negToZero(e2[h2]) / s2;
        n2.push(c2), this.chartType === "polarArea" ? (n2[h2] = this.fullAngle / e2.length, this.sliceSizes.push(i.globals.radialSize * e2[h2] / this.maxY)) : this.sliceSizes.push(i.globals.radialSize);
      }
      if (i.globals.dataChanged) {
        for (var d2, g2 = 0, p2 = 0; p2 < i.globals.previousPaths.length; p2++)
          g2 += P2.negToZero(i.globals.previousPaths[p2]);
        for (var f2 = 0; f2 < i.globals.previousPaths.length; f2++)
          d2 = this.fullAngle * P2.negToZero(i.globals.previousPaths[f2]) / g2, this.prevSectorAngleArr.push(d2);
      }
      this.donutSize < 0 && (this.donutSize = 0);
      var b2 = i.config.plotOptions.pie.customScale, m2 = i.globals.gridWidth / 2, w2 = i.globals.gridHeight / 2, A2 = m2 - i.globals.gridWidth / 2 * b2, l2 = w2 - i.globals.gridHeight / 2 * b2;
      if (this.chartType === "donut") {
        var u2 = a2.drawCircle(this.donutSize);
        u2.attr({ cx: this.centerX, cy: this.centerY, fill: i.config.plotOptions.pie.donut.background ? i.config.plotOptions.pie.donut.background : "transparent" }), o2.add(u2);
      }
      var x2 = this.drawArcs(n2, e2);
      if (this.sliceLabels.forEach(function(k2) {
        x2.add(k2);
      }), o2.attr({ transform: "translate(".concat(A2, ", ").concat(l2, ") scale(").concat(b2, ")") }), o2.add(x2), this.ret.add(o2), this.donutDataLabels.show) {
        var v2 = this.renderInnerDataLabels(this.donutDataLabels, { hollowSize: this.donutSize, centerX: this.centerX, centerY: this.centerY, opacity: this.donutDataLabels.show, translateX: A2, translateY: l2 });
        this.ret.add(v2);
      }
      return i.config.grid.position === "front" && this.chartType === "polarArea" && this.drawPolarElements(this.ret), this.ret;
    } }, { key: "drawArcs", value: function(e2, t2) {
      var i = this.w, a2 = new Z2(this.ctx), s2 = new M2(this.ctx), r = new ae2(this.ctx), n2 = s2.group({ class: "apexcharts-slices" }), o2 = this.initialAngle, h2 = this.initialAngle, c2 = this.initialAngle, d2 = this.initialAngle;
      this.strokeWidth = i.config.stroke.show ? i.config.stroke.width : 0;
      for (var g2 = 0; g2 < e2.length; g2++) {
        var p2 = s2.group({ class: "apexcharts-series apexcharts-pie-series", seriesName: P2.escapeString(i.globals.seriesNames[g2]), rel: g2 + 1, "data:realIndex": g2 });
        n2.add(p2), h2 = d2, c2 = (o2 = c2) + e2[g2], d2 = h2 + this.prevSectorAngleArr[g2];
        var f2 = c2 < o2 ? this.fullAngle + c2 - o2 : c2 - o2, b2 = r.fillPath({ seriesNumber: g2, size: this.sliceSizes[g2], value: t2[g2] }), m2 = this.getChangedPath(h2, d2), w2 = s2.drawPath({ d: m2, stroke: Array.isArray(this.lineColorArr) ? this.lineColorArr[g2] : this.lineColorArr, strokeWidth: 0, fill: b2, fillOpacity: i.config.fill.opacity, classes: "apexcharts-pie-area apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(g2) });
        if (w2.attr({ index: 0, j: g2 }), a2.setSelectionFilter(w2, 0, g2), i.config.chart.dropShadow.enabled) {
          var A2 = i.config.chart.dropShadow;
          a2.dropShadow(w2, A2, g2);
        }
        this.addListeners(w2, this.donutDataLabels), M2.setAttrs(w2.node, { "data:angle": f2, "data:startAngle": o2, "data:strokeWidth": this.strokeWidth, "data:value": t2[g2] });
        var l2 = { x: 0, y: 0 };
        this.chartType === "pie" || this.chartType === "polarArea" ? l2 = P2.polarToCartesian(this.centerX, this.centerY, i.globals.radialSize / 1.25 + i.config.plotOptions.pie.dataLabels.offset, (o2 + f2 / 2) % this.fullAngle) : this.chartType === "donut" && (l2 = P2.polarToCartesian(this.centerX, this.centerY, (i.globals.radialSize + this.donutSize) / 2 + i.config.plotOptions.pie.dataLabels.offset, (o2 + f2 / 2) % this.fullAngle)), p2.add(w2);
        var u2 = 0;
        if (!this.initialAnim || i.globals.resized || i.globals.dataChanged ? this.animBeginArr.push(0) : ((u2 = f2 / this.fullAngle * i.config.chart.animations.speed) === 0 && (u2 = 1), this.animDur = u2 + this.animDur, this.animBeginArr.push(this.animDur)), this.dynamicAnim && i.globals.dataChanged ? this.animatePaths(w2, { size: this.sliceSizes[g2], endAngle: c2, startAngle: o2, prevStartAngle: h2, prevEndAngle: d2, animateStartingPos: true, i: g2, animBeginArr: this.animBeginArr, shouldSetPrevPaths: true, dur: i.config.chart.animations.dynamicAnimation.speed }) : this.animatePaths(w2, { size: this.sliceSizes[g2], endAngle: c2, startAngle: o2, i: g2, totalItems: e2.length - 1, animBeginArr: this.animBeginArr, dur: u2 }), i.config.plotOptions.pie.expandOnClick && this.chartType !== "polarArea" && w2.click(this.pieClicked.bind(this, g2)), i.globals.selectedDataPoints[0] !== void 0 && i.globals.selectedDataPoints[0].indexOf(g2) > -1 && this.pieClicked(g2), i.config.dataLabels.enabled) {
          var x2 = l2.x, v2 = l2.y, k2 = 100 * f2 / this.fullAngle + "%";
          if (f2 !== 0 && i.config.plotOptions.pie.dataLabels.minAngleToShowLabel < e2[g2]) {
            var S2 = i.config.dataLabels.formatter;
            S2 !== void 0 && (k2 = S2(i.globals.seriesPercent[g2][0], { seriesIndex: g2, w: i }));
            var C2 = i.globals.dataLabels.style.colors[g2], L2 = s2.group({ class: "apexcharts-datalabels" }), I2 = s2.drawText({ x: x2, y: v2, text: k2, textAnchor: "middle", fontSize: i.config.dataLabels.style.fontSize, fontFamily: i.config.dataLabels.style.fontFamily, fontWeight: i.config.dataLabels.style.fontWeight, foreColor: C2 });
            if (L2.add(I2), i.config.dataLabels.dropShadow.enabled) {
              var z2 = i.config.dataLabels.dropShadow;
              a2.dropShadow(I2, z2);
            }
            I2.node.classList.add("apexcharts-pie-label"), i.config.chart.animations.animate && i.globals.resized === false && (I2.node.classList.add("apexcharts-pie-label-delay"), I2.node.style.animationDelay = i.config.chart.animations.speed / 940 + "s"), this.sliceLabels.push(L2);
          }
        }
      }
      return n2;
    } }, { key: "addListeners", value: function(e2, t2) {
      var i = new M2(this.ctx);
      e2.node.addEventListener("mouseenter", i.pathMouseEnter.bind(this, e2)), e2.node.addEventListener("mouseleave", i.pathMouseLeave.bind(this, e2)), e2.node.addEventListener("mouseleave", this.revertDataLabelsInner.bind(this, e2.node, t2)), e2.node.addEventListener("mousedown", i.pathMouseDown.bind(this, e2)), this.donutDataLabels.total.showAlways || (e2.node.addEventListener("mouseenter", this.printDataLabelsInner.bind(this, e2.node, t2)), e2.node.addEventListener("mousedown", this.printDataLabelsInner.bind(this, e2.node, t2)));
    } }, { key: "animatePaths", value: function(e2, t2) {
      var i = this.w, a2 = t2.endAngle < t2.startAngle ? this.fullAngle + t2.endAngle - t2.startAngle : t2.endAngle - t2.startAngle, s2 = a2, r = t2.startAngle, n2 = t2.startAngle;
      t2.prevStartAngle !== void 0 && t2.prevEndAngle !== void 0 && (r = t2.prevEndAngle, s2 = t2.prevEndAngle < t2.prevStartAngle ? this.fullAngle + t2.prevEndAngle - t2.prevStartAngle : t2.prevEndAngle - t2.prevStartAngle), t2.i === i.config.series.length - 1 && (a2 + n2 > this.fullAngle ? t2.endAngle = t2.endAngle - (a2 + n2) : a2 + n2 < this.fullAngle && (t2.endAngle = t2.endAngle + (this.fullAngle - (a2 + n2)))), a2 === this.fullAngle && (a2 = this.fullAngle - 0.01), this.animateArc(e2, r, n2, a2, s2, t2);
    } }, { key: "animateArc", value: function(e2, t2, i, a2, s2, r) {
      var n2, o2 = this, h2 = this.w, c2 = new de2(this.ctx), d2 = r.size;
      (isNaN(t2) || isNaN(s2)) && (t2 = i, s2 = a2, r.dur = 0);
      var g2 = a2, p2 = i, f2 = t2 < i ? this.fullAngle + t2 - i : t2 - i;
      h2.globals.dataChanged && r.shouldSetPrevPaths && r.prevEndAngle && (n2 = o2.getPiePath({ me: o2, startAngle: r.prevStartAngle, angle: r.prevEndAngle < r.prevStartAngle ? this.fullAngle + r.prevEndAngle - r.prevStartAngle : r.prevEndAngle - r.prevStartAngle, size: d2 }), e2.attr({ d: n2 })), r.dur !== 0 ? e2.animate(r.dur, h2.globals.easing, r.animBeginArr[r.i]).afterAll(function() {
        o2.chartType !== "pie" && o2.chartType !== "donut" && o2.chartType !== "polarArea" || this.animate(h2.config.chart.animations.dynamicAnimation.speed).attr({ "stroke-width": o2.strokeWidth }), r.i === h2.config.series.length - 1 && c2.animationCompleted(e2);
      }).during(function(b2) {
        g2 = f2 + (a2 - f2) * b2, r.animateStartingPos && (g2 = s2 + (a2 - s2) * b2, p2 = t2 - s2 + (i - (t2 - s2)) * b2), n2 = o2.getPiePath({ me: o2, startAngle: p2, angle: g2, size: d2 }), e2.node.setAttribute("data:pathOrig", n2), e2.attr({ d: n2 });
      }) : (n2 = o2.getPiePath({ me: o2, startAngle: p2, angle: a2, size: d2 }), r.isTrack || (h2.globals.animationEnded = true), e2.node.setAttribute("data:pathOrig", n2), e2.attr({ d: n2, "stroke-width": o2.strokeWidth }));
    } }, { key: "pieClicked", value: function(e2) {
      var t2, i = this.w, a2 = this, s2 = a2.sliceSizes[e2] + (i.config.plotOptions.pie.expandOnClick ? 4 : 0), r = i.globals.dom.Paper.select(".apexcharts-".concat(a2.chartType.toLowerCase(), "-slice-").concat(e2)).members[0];
      if (r.attr("data:pieClicked") !== "true") {
        var n2 = i.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area");
        Array.prototype.forEach.call(n2, function(d2) {
          d2.setAttribute("data:pieClicked", "false");
          var g2 = d2.getAttribute("data:pathOrig");
          g2 && d2.setAttribute("d", g2);
        }), r.attr("data:pieClicked", "true");
        var o2 = parseInt(r.attr("data:startAngle"), 10), h2 = parseInt(r.attr("data:angle"), 10);
        t2 = a2.getPiePath({ me: a2, startAngle: o2, angle: h2, size: s2 }), h2 !== 360 && r.plot(t2);
      } else {
        r.attr({ "data:pieClicked": "false" }), this.revertDataLabelsInner(r.node, this.donutDataLabels);
        var c2 = r.attr("data:pathOrig");
        r.attr({ d: c2 });
      }
    } }, { key: "getChangedPath", value: function(e2, t2) {
      var i = "";
      return this.dynamicAnim && this.w.globals.dataChanged && (i = this.getPiePath({ me: this, startAngle: e2, angle: t2 - e2, size: this.size })), i;
    } }, { key: "getPiePath", value: function(e2) {
      var t2, i = e2.me, a2 = e2.startAngle, s2 = e2.angle, r = e2.size, n2 = new M2(this.ctx), o2 = a2, h2 = Math.PI * (o2 - 90) / 180, c2 = s2 + a2;
      Math.ceil(c2) >= this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle && (c2 = this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle - 0.01), Math.ceil(c2) > this.fullAngle && (c2 -= this.fullAngle);
      var d2 = Math.PI * (c2 - 90) / 180, g2 = i.centerX + r * Math.cos(h2), p2 = i.centerY + r * Math.sin(h2), f2 = i.centerX + r * Math.cos(d2), b2 = i.centerY + r * Math.sin(d2), m2 = P2.polarToCartesian(i.centerX, i.centerY, i.donutSize, c2), w2 = P2.polarToCartesian(i.centerX, i.centerY, i.donutSize, o2), A2 = s2 > 180 ? 1 : 0, l2 = ["M", g2, p2, "A", r, r, 0, A2, 1, f2, b2];
      return t2 = i.chartType === "donut" ? [].concat(l2, ["L", m2.x, m2.y, "A", i.donutSize, i.donutSize, 0, A2, 0, w2.x, w2.y, "L", g2, p2, "z"]).join(" ") : i.chartType === "pie" || i.chartType === "polarArea" ? [].concat(l2, ["L", i.centerX, i.centerY, "L", g2, p2]).join(" ") : [].concat(l2).join(" "), n2.roundPathCorners(t2, 2 * this.strokeWidth);
    } }, { key: "drawPolarElements", value: function(e2) {
      var t2 = this.w, i = new we2(this.ctx), a2 = new M2(this.ctx), s2 = new nt2(this.ctx), r = a2.group(), n2 = a2.group(), o2 = i.niceScale(0, Math.ceil(this.maxY), t2.config.yaxis[0].tickAmount, 0, true), h2 = o2.result.reverse(), c2 = o2.result.length;
      this.maxY = o2.niceMax;
      for (var d2 = t2.globals.radialSize, g2 = d2 / (c2 - 1), p2 = 0; p2 < c2 - 1; p2++) {
        var f2 = a2.drawCircle(d2);
        if (f2.attr({ cx: this.centerX, cy: this.centerY, fill: "none", "stroke-width": t2.config.plotOptions.polarArea.rings.strokeWidth, stroke: t2.config.plotOptions.polarArea.rings.strokeColor }), t2.config.yaxis[0].show) {
          var b2 = s2.drawYAxisTexts(this.centerX, this.centerY - d2 + parseInt(t2.config.yaxis[0].labels.style.fontSize, 10) / 2, p2, h2[p2]);
          n2.add(b2);
        }
        r.add(f2), d2 -= g2;
      }
      this.drawSpokes(e2), e2.add(r), e2.add(n2);
    } }, { key: "renderInnerDataLabels", value: function(e2, t2) {
      var i = this.w, a2 = new M2(this.ctx), s2 = a2.group({ class: "apexcharts-datalabels-group", transform: "translate(".concat(t2.translateX ? t2.translateX : 0, ", ").concat(t2.translateY ? t2.translateY : 0, ") scale(").concat(i.config.plotOptions.pie.customScale, ")") }), r = e2.total.show;
      s2.node.style.opacity = t2.opacity;
      var n2, o2, h2 = t2.centerX, c2 = t2.centerY;
      n2 = e2.name.color === void 0 ? i.globals.colors[0] : e2.name.color;
      var d2 = e2.name.fontSize, g2 = e2.name.fontFamily, p2 = e2.name.fontWeight;
      o2 = e2.value.color === void 0 ? i.config.chart.foreColor : e2.value.color;
      var f2 = e2.value.formatter, b2 = "", m2 = "";
      if (r ? (n2 = e2.total.color, d2 = e2.total.fontSize, g2 = e2.total.fontFamily, p2 = e2.total.fontWeight, m2 = e2.total.label, b2 = e2.total.formatter(i)) : i.globals.series.length === 1 && (b2 = f2(i.globals.series[0], i), m2 = i.globals.seriesNames[0]), m2 && (m2 = e2.name.formatter(m2, e2.total.show, i)), e2.name.show) {
        var w2 = a2.drawText({ x: h2, y: c2 + parseFloat(e2.name.offsetY), text: m2, textAnchor: "middle", foreColor: n2, fontSize: d2, fontWeight: p2, fontFamily: g2 });
        w2.node.classList.add("apexcharts-datalabel-label"), s2.add(w2);
      }
      if (e2.value.show) {
        var A2 = e2.name.show ? parseFloat(e2.value.offsetY) + 16 : e2.value.offsetY, l2 = a2.drawText({ x: h2, y: c2 + A2, text: b2, textAnchor: "middle", foreColor: o2, fontWeight: e2.value.fontWeight, fontSize: e2.value.fontSize, fontFamily: e2.value.fontFamily });
        l2.node.classList.add("apexcharts-datalabel-value"), s2.add(l2);
      }
      return s2;
    } }, { key: "printInnerLabels", value: function(e2, t2, i, a2) {
      var s2, r = this.w;
      a2 ? s2 = e2.name.color === void 0 ? r.globals.colors[parseInt(a2.parentNode.getAttribute("rel"), 10) - 1] : e2.name.color : r.globals.series.length > 1 && e2.total.show && (s2 = e2.total.color);
      var n2 = r.globals.dom.baseEl.querySelector(".apexcharts-datalabel-label"), o2 = r.globals.dom.baseEl.querySelector(".apexcharts-datalabel-value");
      i = (0, e2.value.formatter)(i, r), a2 || typeof e2.total.formatter != "function" || (i = e2.total.formatter(r));
      var h2 = t2 === e2.total.label;
      t2 = e2.name.formatter(t2, h2, r), n2 !== null && (n2.textContent = t2), o2 !== null && (o2.textContent = i), n2 !== null && (n2.style.fill = s2);
    } }, { key: "printDataLabelsInner", value: function(e2, t2) {
      var i = this.w, a2 = e2.getAttribute("data:value"), s2 = i.globals.seriesNames[parseInt(e2.parentNode.getAttribute("rel"), 10) - 1];
      i.globals.series.length > 1 && this.printInnerLabels(t2, s2, a2, e2);
      var r = i.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group");
      r !== null && (r.style.opacity = 1);
    } }, { key: "drawSpokes", value: function(e2) {
      var t2 = this, i = this.w, a2 = new M2(this.ctx), s2 = i.config.plotOptions.polarArea.spokes;
      if (s2.strokeWidth !== 0) {
        for (var r = [], n2 = 360 / i.globals.series.length, o2 = 0; o2 < i.globals.series.length; o2++)
          r.push(P2.polarToCartesian(this.centerX, this.centerY, i.globals.radialSize, i.config.plotOptions.pie.startAngle + n2 * o2));
        r.forEach(function(h2, c2) {
          var d2 = a2.drawLine(h2.x, h2.y, t2.centerX, t2.centerY, Array.isArray(s2.connectorColors) ? s2.connectorColors[c2] : s2.connectorColors);
          e2.add(d2);
        });
      }
    } }, { key: "revertDataLabelsInner", value: function(e2, t2, i) {
      var a2 = this, s2 = this.w, r = s2.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group"), n2 = false, o2 = s2.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area"), h2 = function(g2) {
        var p2 = g2.makeSliceOut, f2 = g2.printLabel;
        Array.prototype.forEach.call(o2, function(b2) {
          b2.getAttribute("data:pieClicked") === "true" && (p2 && (n2 = true), f2 && a2.printDataLabelsInner(b2, t2));
        });
      };
      if (h2({ makeSliceOut: true, printLabel: false }), t2.total.show && s2.globals.series.length > 1)
        n2 && !t2.total.showAlways ? h2({ makeSliceOut: false, printLabel: true }) : this.printInnerLabels(t2, t2.total.label, t2.total.formatter(s2));
      else if (h2({ makeSliceOut: false, printLabel: true }), !n2)
        if (s2.globals.selectedDataPoints.length && s2.globals.series.length > 1)
          if (s2.globals.selectedDataPoints[0].length > 0) {
            var c2 = s2.globals.selectedDataPoints[0], d2 = s2.globals.dom.baseEl.querySelector(".apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(c2));
            this.printDataLabelsInner(d2, t2);
          } else
            r && s2.globals.selectedDataPoints.length && s2.globals.selectedDataPoints[0].length === 0 && (r.style.opacity = 0);
        else
          r && s2.globals.series.length > 1 && (r.style.opacity = 0);
    } }]), y2;
  }(), Ft2 = function() {
    function y2(e2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w, this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animDur = 0;
      var t2 = this.w;
      this.graphics = new M2(this.ctx), this.lineColorArr = t2.globals.stroke.colors !== void 0 ? t2.globals.stroke.colors : t2.globals.colors, this.defaultSize = t2.globals.svgHeight < t2.globals.svgWidth ? t2.globals.gridHeight + 1.5 * t2.globals.goldenPadding : t2.globals.gridWidth, this.isLog = t2.config.yaxis[0].logarithmic, this.coreUtils = new q2(this.ctx), this.maxValue = this.isLog ? this.coreUtils.getLogVal(t2.globals.maxY, 0) : t2.globals.maxY, this.minValue = this.isLog ? this.coreUtils.getLogVal(this.w.globals.minY, 0) : t2.globals.minY, this.polygons = t2.config.plotOptions.radar.polygons, this.strokeWidth = t2.config.stroke.show ? t2.config.stroke.width : 0, this.size = this.defaultSize / 2.1 - this.strokeWidth - t2.config.chart.dropShadow.blur, t2.config.xaxis.labels.show && (this.size = this.size - t2.globals.xAxisLabelsWidth / 1.75), t2.config.plotOptions.radar.size !== void 0 && (this.size = t2.config.plotOptions.radar.size), this.dataRadiusOfPercent = [], this.dataRadius = [], this.angleArr = [], this.yaxisLabelsTextsPos = [];
    }
    return Y2(y2, [{ key: "draw", value: function(e2) {
      var t2 = this, i = this.w, a2 = new ae2(this.ctx), s2 = [], r = new ye2(this.ctx);
      e2.length && (this.dataPointsLen = e2[i.globals.maxValsInArrayIndex].length), this.disAngle = 2 * Math.PI / this.dataPointsLen;
      var n2 = i.globals.gridWidth / 2, o2 = i.globals.gridHeight / 2, h2 = n2 + i.config.plotOptions.radar.offsetX, c2 = o2 + i.config.plotOptions.radar.offsetY, d2 = this.graphics.group({ class: "apexcharts-radar-series apexcharts-plot-series", transform: "translate(".concat(h2 || 0, ", ").concat(c2 || 0, ")") }), g2 = [], p2 = null, f2 = null;
      if (this.yaxisLabels = this.graphics.group({ class: "apexcharts-yaxis" }), e2.forEach(function(m2, w2) {
        var A2 = m2.length === i.globals.dataPoints, l2 = t2.graphics.group().attr({ class: "apexcharts-series", "data:longestSeries": A2, seriesName: P2.escapeString(i.globals.seriesNames[w2]), rel: w2 + 1, "data:realIndex": w2 });
        t2.dataRadiusOfPercent[w2] = [], t2.dataRadius[w2] = [], t2.angleArr[w2] = [], m2.forEach(function(T2, E2) {
          var R2 = Math.abs(t2.maxValue - t2.minValue);
          T2 += Math.abs(t2.minValue), t2.isLog && (T2 = t2.coreUtils.getLogVal(T2, 0)), t2.dataRadiusOfPercent[w2][E2] = T2 / R2, t2.dataRadius[w2][E2] = t2.dataRadiusOfPercent[w2][E2] * t2.size, t2.angleArr[w2][E2] = E2 * t2.disAngle;
        }), g2 = t2.getDataPointsPos(t2.dataRadius[w2], t2.angleArr[w2]);
        var u2 = t2.createPaths(g2, { x: 0, y: 0 });
        p2 = t2.graphics.group({ class: "apexcharts-series-markers-wrap apexcharts-element-hidden" }), f2 = t2.graphics.group({ class: "apexcharts-datalabels", "data:realIndex": w2 }), i.globals.delayedElements.push({ el: p2.node, index: w2 });
        var x2 = { i: w2, realIndex: w2, animationDelay: w2, initialSpeed: i.config.chart.animations.speed, dataChangeSpeed: i.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-radar", shouldClipToGrid: false, bindEventsOnPaths: false, stroke: i.globals.stroke.colors[w2], strokeLineCap: i.config.stroke.lineCap }, v2 = null;
        i.globals.previousPaths.length > 0 && (v2 = t2.getPreviousPath(w2));
        for (var k2 = 0; k2 < u2.linePathsTo.length; k2++) {
          var S2 = t2.graphics.renderPaths(X2(X2({}, x2), {}, { pathFrom: v2 === null ? u2.linePathsFrom[k2] : v2, pathTo: u2.linePathsTo[k2], strokeWidth: Array.isArray(t2.strokeWidth) ? t2.strokeWidth[w2] : t2.strokeWidth, fill: "none", drawShadow: false }));
          l2.add(S2);
          var C2 = a2.fillPath({ seriesNumber: w2 }), L2 = t2.graphics.renderPaths(X2(X2({}, x2), {}, { pathFrom: v2 === null ? u2.areaPathsFrom[k2] : v2, pathTo: u2.areaPathsTo[k2], strokeWidth: 0, fill: C2, drawShadow: false }));
          if (i.config.chart.dropShadow.enabled) {
            var I2 = new Z2(t2.ctx), z2 = i.config.chart.dropShadow;
            I2.dropShadow(L2, Object.assign({}, z2, { noUserSpaceOnUse: true }), w2);
          }
          l2.add(L2);
        }
        m2.forEach(function(T2, E2) {
          var R2 = new Pe(t2.ctx).getMarkerConfig({ cssClass: "apexcharts-marker", seriesIndex: w2, dataPointIndex: E2 }), O2 = t2.graphics.drawMarker(g2[E2].x, g2[E2].y, R2);
          O2.attr("rel", E2), O2.attr("j", E2), O2.attr("index", w2), O2.node.setAttribute("default-marker-size", R2.pSize);
          var D2 = t2.graphics.group({ class: "apexcharts-series-markers" });
          D2 && D2.add(O2), p2.add(D2), l2.add(p2);
          var W2 = i.config.dataLabels;
          if (W2.enabled) {
            var N2 = W2.formatter(i.globals.series[w2][E2], { seriesIndex: w2, dataPointIndex: E2, w: i });
            r.plotDataLabelsText({ x: g2[E2].x, y: g2[E2].y, text: N2, textAnchor: "middle", i: w2, j: w2, parent: f2, offsetCorrection: false, dataLabelsConfig: X2({}, W2) });
          }
          l2.add(f2);
        }), s2.push(l2);
      }), this.drawPolygons({ parent: d2 }), i.config.xaxis.labels.show) {
        var b2 = this.drawXAxisTexts();
        d2.add(b2);
      }
      return s2.forEach(function(m2) {
        d2.add(m2);
      }), d2.add(this.yaxisLabels), d2;
    } }, { key: "drawPolygons", value: function(e2) {
      for (var t2 = this, i = this.w, a2 = e2.parent, s2 = new nt2(this.ctx), r = i.globals.yAxisScale[0].result.reverse(), n2 = r.length, o2 = [], h2 = this.size / (n2 - 1), c2 = 0; c2 < n2; c2++)
        o2[c2] = h2 * c2;
      o2.reverse();
      var d2 = [], g2 = [];
      o2.forEach(function(p2, f2) {
        var b2 = P2.getPolygonPos(p2, t2.dataPointsLen), m2 = "";
        b2.forEach(function(w2, A2) {
          if (f2 === 0) {
            var l2 = t2.graphics.drawLine(w2.x, w2.y, 0, 0, Array.isArray(t2.polygons.connectorColors) ? t2.polygons.connectorColors[A2] : t2.polygons.connectorColors);
            g2.push(l2);
          }
          A2 === 0 && t2.yaxisLabelsTextsPos.push({ x: w2.x, y: w2.y }), m2 += w2.x + "," + w2.y + " ";
        }), d2.push(m2);
      }), d2.forEach(function(p2, f2) {
        var b2 = t2.polygons.strokeColors, m2 = t2.polygons.strokeWidth, w2 = t2.graphics.drawPolygon(p2, Array.isArray(b2) ? b2[f2] : b2, Array.isArray(m2) ? m2[f2] : m2, i.globals.radarPolygons.fill.colors[f2]);
        a2.add(w2);
      }), g2.forEach(function(p2) {
        a2.add(p2);
      }), i.config.yaxis[0].show && this.yaxisLabelsTextsPos.forEach(function(p2, f2) {
        var b2 = s2.drawYAxisTexts(p2.x, p2.y, f2, r[f2]);
        t2.yaxisLabels.add(b2);
      });
    } }, { key: "drawXAxisTexts", value: function() {
      var e2 = this, t2 = this.w, i = t2.config.xaxis.labels, a2 = this.graphics.group({ class: "apexcharts-xaxis" }), s2 = P2.getPolygonPos(this.size, this.dataPointsLen);
      return t2.globals.labels.forEach(function(r, n2) {
        var o2 = t2.config.xaxis.labels.formatter, h2 = new ye2(e2.ctx);
        if (s2[n2]) {
          var c2 = e2.getTextPos(s2[n2], e2.size), d2 = o2(r, { seriesIndex: -1, dataPointIndex: n2, w: t2 });
          h2.plotDataLabelsText({ x: c2.newX, y: c2.newY, text: d2, textAnchor: c2.textAnchor, i: n2, j: n2, parent: a2, color: Array.isArray(i.style.colors) && i.style.colors[n2] ? i.style.colors[n2] : "#a8a8a8", dataLabelsConfig: X2({ textAnchor: c2.textAnchor, dropShadow: { enabled: false } }, i), offsetCorrection: false });
        }
      }), a2;
    } }, { key: "createPaths", value: function(e2, t2) {
      var i = this, a2 = [], s2 = [], r = [], n2 = [];
      if (e2.length) {
        s2 = [this.graphics.move(t2.x, t2.y)], n2 = [this.graphics.move(t2.x, t2.y)];
        var o2 = this.graphics.move(e2[0].x, e2[0].y), h2 = this.graphics.move(e2[0].x, e2[0].y);
        e2.forEach(function(c2, d2) {
          o2 += i.graphics.line(c2.x, c2.y), h2 += i.graphics.line(c2.x, c2.y), d2 === e2.length - 1 && (o2 += "Z", h2 += "Z");
        }), a2.push(o2), r.push(h2);
      }
      return { linePathsFrom: s2, linePathsTo: a2, areaPathsFrom: n2, areaPathsTo: r };
    } }, { key: "getTextPos", value: function(e2, t2) {
      var i = "middle", a2 = e2.x, s2 = e2.y;
      return Math.abs(e2.x) >= 10 ? e2.x > 0 ? (i = "start", a2 += 10) : e2.x < 0 && (i = "end", a2 -= 10) : i = "middle", Math.abs(e2.y) >= t2 - 10 && (e2.y < 0 ? s2 -= 10 : e2.y > 0 && (s2 += 10)), { textAnchor: i, newX: a2, newY: s2 };
    } }, { key: "getPreviousPath", value: function(e2) {
      for (var t2 = this.w, i = null, a2 = 0; a2 < t2.globals.previousPaths.length; a2++) {
        var s2 = t2.globals.previousPaths[a2];
        s2.paths.length > 0 && parseInt(s2.realIndex, 10) === parseInt(e2, 10) && t2.globals.previousPaths[a2].paths[0] !== void 0 && (i = t2.globals.previousPaths[a2].paths[0].d);
      }
      return i;
    } }, { key: "getDataPointsPos", value: function(e2, t2) {
      var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.dataPointsLen;
      e2 = e2 || [], t2 = t2 || [];
      for (var a2 = [], s2 = 0; s2 < i; s2++) {
        var r = {};
        r.x = e2[s2] * Math.sin(t2[s2]), r.y = -e2[s2] * Math.cos(t2[s2]), a2.push(r);
      }
      return a2;
    } }]), y2;
  }(), Rt2 = function(y2) {
    ge2(t2, ot2);
    var e2 = ue2(t2);
    function t2(i) {
      var a2;
      F2(this, t2), (a2 = e2.call(this, i)).ctx = i, a2.w = i.w, a2.animBeginArr = [0], a2.animDur = 0;
      var s2 = a2.w;
      return a2.startAngle = s2.config.plotOptions.radialBar.startAngle, a2.endAngle = s2.config.plotOptions.radialBar.endAngle, a2.totalAngle = Math.abs(s2.config.plotOptions.radialBar.endAngle - s2.config.plotOptions.radialBar.startAngle), a2.trackStartAngle = s2.config.plotOptions.radialBar.track.startAngle, a2.trackEndAngle = s2.config.plotOptions.radialBar.track.endAngle, a2.barLabels = a2.w.config.plotOptions.radialBar.barLabels, a2.donutDataLabels = a2.w.config.plotOptions.radialBar.dataLabels, a2.radialDataLabels = a2.donutDataLabels, a2.trackStartAngle || (a2.trackStartAngle = a2.startAngle), a2.trackEndAngle || (a2.trackEndAngle = a2.endAngle), a2.endAngle === 360 && (a2.endAngle = 359.99), a2.margin = parseInt(s2.config.plotOptions.radialBar.track.margin, 10), a2.onBarLabelClick = a2.onBarLabelClick.bind(ze(a2)), a2;
    }
    return Y2(t2, [{ key: "draw", value: function(i) {
      var a2 = this.w, s2 = new M2(this.ctx), r = s2.group({ class: "apexcharts-radialbar" });
      if (a2.globals.noData)
        return r;
      var n2 = s2.group(), o2 = this.defaultSize / 2, h2 = a2.globals.gridWidth / 2, c2 = this.defaultSize / 2.05;
      a2.config.chart.sparkline.enabled || (c2 = c2 - a2.config.stroke.width - a2.config.chart.dropShadow.blur);
      var d2 = a2.globals.fill.colors;
      if (a2.config.plotOptions.radialBar.track.show) {
        var g2 = this.drawTracks({ size: c2, centerX: h2, centerY: o2, colorArr: d2, series: i });
        n2.add(g2);
      }
      var p2 = this.drawArcs({ size: c2, centerX: h2, centerY: o2, colorArr: d2, series: i }), f2 = 360;
      a2.config.plotOptions.radialBar.startAngle < 0 && (f2 = this.totalAngle);
      var b2 = (360 - f2) / 360;
      if (a2.globals.radialSize = c2 - c2 * b2, this.radialDataLabels.value.show) {
        var m2 = Math.max(this.radialDataLabels.value.offsetY, this.radialDataLabels.name.offsetY);
        a2.globals.radialSize += m2 * b2;
      }
      return n2.add(p2.g), a2.config.plotOptions.radialBar.hollow.position === "front" && (p2.g.add(p2.elHollow), p2.dataLabels && p2.g.add(p2.dataLabels)), r.add(n2), r;
    } }, { key: "drawTracks", value: function(i) {
      var a2 = this.w, s2 = new M2(this.ctx), r = s2.group({ class: "apexcharts-tracks" }), n2 = new Z2(this.ctx), o2 = new ae2(this.ctx), h2 = this.getStrokeWidth(i);
      i.size = i.size - h2 / 2;
      for (var c2 = 0; c2 < i.series.length; c2++) {
        var d2 = s2.group({ class: "apexcharts-radialbar-track apexcharts-track" });
        r.add(d2), d2.attr({ rel: c2 + 1 }), i.size = i.size - h2 - this.margin;
        var g2 = a2.config.plotOptions.radialBar.track, p2 = o2.fillPath({ seriesNumber: 0, size: i.size, fillColors: Array.isArray(g2.background) ? g2.background[c2] : g2.background, solid: true }), f2 = this.trackStartAngle, b2 = this.trackEndAngle;
        Math.abs(b2) + Math.abs(f2) >= 360 && (b2 = 360 - Math.abs(this.startAngle) - 0.1);
        var m2 = s2.drawPath({ d: "", stroke: p2, strokeWidth: h2 * parseInt(g2.strokeWidth, 10) / 100, fill: "none", strokeOpacity: g2.opacity, classes: "apexcharts-radialbar-area" });
        if (g2.dropShadow.enabled) {
          var w2 = g2.dropShadow;
          n2.dropShadow(m2, w2);
        }
        d2.add(m2), m2.attr("id", "apexcharts-radialbarTrack-" + c2), this.animatePaths(m2, { centerX: i.centerX, centerY: i.centerY, endAngle: b2, startAngle: f2, size: i.size, i: c2, totalItems: 2, animBeginArr: 0, dur: 0, isTrack: true, easing: a2.globals.easing });
      }
      return r;
    } }, { key: "drawArcs", value: function(i) {
      var a2 = this.w, s2 = new M2(this.ctx), r = new ae2(this.ctx), n2 = new Z2(this.ctx), o2 = s2.group(), h2 = this.getStrokeWidth(i);
      i.size = i.size - h2 / 2;
      var c2 = a2.config.plotOptions.radialBar.hollow.background, d2 = i.size - h2 * i.series.length - this.margin * i.series.length - h2 * parseInt(a2.config.plotOptions.radialBar.track.strokeWidth, 10) / 100 / 2, g2 = d2 - a2.config.plotOptions.radialBar.hollow.margin;
      a2.config.plotOptions.radialBar.hollow.image !== void 0 && (c2 = this.drawHollowImage(i, o2, d2, c2));
      var p2 = this.drawHollow({ size: g2, centerX: i.centerX, centerY: i.centerY, fill: c2 || "transparent" });
      if (a2.config.plotOptions.radialBar.hollow.dropShadow.enabled) {
        var f2 = a2.config.plotOptions.radialBar.hollow.dropShadow;
        n2.dropShadow(p2, f2);
      }
      var b2 = 1;
      !this.radialDataLabels.total.show && a2.globals.series.length > 1 && (b2 = 0);
      var m2 = null;
      this.radialDataLabels.show && (m2 = this.renderInnerDataLabels(this.radialDataLabels, { hollowSize: d2, centerX: i.centerX, centerY: i.centerY, opacity: b2 })), a2.config.plotOptions.radialBar.hollow.position === "back" && (o2.add(p2), m2 && o2.add(m2));
      var w2 = false;
      a2.config.plotOptions.radialBar.inverseOrder && (w2 = true);
      for (var A2 = w2 ? i.series.length - 1 : 0; w2 ? A2 >= 0 : A2 < i.series.length; w2 ? A2-- : A2++) {
        var l2 = s2.group({ class: "apexcharts-series apexcharts-radial-series", seriesName: P2.escapeString(a2.globals.seriesNames[A2]) });
        o2.add(l2), l2.attr({ rel: A2 + 1, "data:realIndex": A2 }), this.ctx.series.addCollapsedClassToSeries(l2, A2), i.size = i.size - h2 - this.margin;
        var u2 = r.fillPath({ seriesNumber: A2, size: i.size, value: i.series[A2] }), x2 = this.startAngle, v2 = void 0, k2 = P2.negToZero(i.series[A2] > 100 ? 100 : i.series[A2]) / 100, S2 = Math.round(this.totalAngle * k2) + this.startAngle, C2 = void 0;
        a2.globals.dataChanged && (v2 = this.startAngle, C2 = Math.round(this.totalAngle * P2.negToZero(a2.globals.previousPaths[A2]) / 100) + v2), Math.abs(S2) + Math.abs(x2) >= 360 && (S2 -= 0.01), Math.abs(C2) + Math.abs(v2) >= 360 && (C2 -= 0.01);
        var L2 = S2 - x2, I2 = Array.isArray(a2.config.stroke.dashArray) ? a2.config.stroke.dashArray[A2] : a2.config.stroke.dashArray, z2 = s2.drawPath({ d: "", stroke: u2, strokeWidth: h2, fill: "none", fillOpacity: a2.config.fill.opacity, classes: "apexcharts-radialbar-area apexcharts-radialbar-slice-" + A2, strokeDashArray: I2 });
        if (M2.setAttrs(z2.node, { "data:angle": L2, "data:value": i.series[A2] }), a2.config.chart.dropShadow.enabled) {
          var T2 = a2.config.chart.dropShadow;
          n2.dropShadow(z2, T2, A2);
        }
        if (n2.setSelectionFilter(z2, 0, A2), this.addListeners(z2, this.radialDataLabels), l2.add(z2), z2.attr({ index: 0, j: A2 }), this.barLabels.enabled) {
          var E2 = P2.polarToCartesian(i.centerX, i.centerY, i.size, x2), R2 = this.barLabels.formatter(a2.globals.seriesNames[A2], { seriesIndex: A2, w: a2 }), O2 = ["apexcharts-radialbar-label"];
          this.barLabels.onClick || O2.push("apexcharts-no-click");
          var D2 = this.barLabels.useSeriesColors ? a2.globals.colors[A2] : a2.config.chart.foreColor;
          D2 || (D2 = a2.config.chart.foreColor);
          var W2 = E2.x - this.barLabels.margin, N2 = E2.y, V2 = s2.drawText({ x: W2, y: N2, text: R2, textAnchor: "end", dominantBaseline: "middle", fontFamily: this.barLabels.fontFamily, fontWeight: this.barLabels.fontWeight, fontSize: this.barLabels.fontSize, foreColor: D2, cssClass: O2.join(" ") });
          V2.on("click", this.onBarLabelClick), V2.attr({ rel: A2 + 1 }), x2 !== 0 && V2.attr({ "transform-origin": "".concat(W2, " ").concat(N2), transform: "rotate(".concat(x2, " 0 0)") }), l2.add(V2);
        }
        var j2 = 0;
        !this.initialAnim || a2.globals.resized || a2.globals.dataChanged || (j2 = a2.config.chart.animations.speed), a2.globals.dataChanged && (j2 = a2.config.chart.animations.dynamicAnimation.speed), this.animDur = j2 / (1.2 * i.series.length) + this.animDur, this.animBeginArr.push(this.animDur), this.animatePaths(z2, { centerX: i.centerX, centerY: i.centerY, endAngle: S2, startAngle: x2, prevEndAngle: C2, prevStartAngle: v2, size: i.size, i: A2, totalItems: 2, animBeginArr: this.animBeginArr, dur: j2, shouldSetPrevPaths: true, easing: a2.globals.easing });
      }
      return { g: o2, elHollow: p2, dataLabels: m2 };
    } }, { key: "drawHollow", value: function(i) {
      var a2 = new M2(this.ctx).drawCircle(2 * i.size);
      return a2.attr({ class: "apexcharts-radialbar-hollow", cx: i.centerX, cy: i.centerY, r: i.size, fill: i.fill }), a2;
    } }, { key: "drawHollowImage", value: function(i, a2, s2, r) {
      var n2 = this.w, o2 = new ae2(this.ctx), h2 = P2.randomId(), c2 = n2.config.plotOptions.radialBar.hollow.image;
      if (n2.config.plotOptions.radialBar.hollow.imageClipped)
        o2.clippedImgArea({ width: s2, height: s2, image: c2, patternID: "pattern".concat(n2.globals.cuid).concat(h2) }), r = "url(#pattern".concat(n2.globals.cuid).concat(h2, ")");
      else {
        var d2 = n2.config.plotOptions.radialBar.hollow.imageWidth, g2 = n2.config.plotOptions.radialBar.hollow.imageHeight;
        if (d2 === void 0 && g2 === void 0) {
          var p2 = n2.globals.dom.Paper.image(c2).loaded(function(b2) {
            this.move(i.centerX - b2.width / 2 + n2.config.plotOptions.radialBar.hollow.imageOffsetX, i.centerY - b2.height / 2 + n2.config.plotOptions.radialBar.hollow.imageOffsetY);
          });
          a2.add(p2);
        } else {
          var f2 = n2.globals.dom.Paper.image(c2).loaded(function(b2) {
            this.move(i.centerX - d2 / 2 + n2.config.plotOptions.radialBar.hollow.imageOffsetX, i.centerY - g2 / 2 + n2.config.plotOptions.radialBar.hollow.imageOffsetY), this.size(d2, g2);
          });
          a2.add(f2);
        }
      }
      return r;
    } }, { key: "getStrokeWidth", value: function(i) {
      var a2 = this.w;
      return i.size * (100 - parseInt(a2.config.plotOptions.radialBar.hollow.size, 10)) / 100 / (i.series.length + 1) - this.margin;
    } }, { key: "onBarLabelClick", value: function(i) {
      var a2 = parseInt(i.target.getAttribute("rel"), 10) - 1, s2 = this.barLabels.onClick, r = this.w;
      s2 && s2(r.globals.seriesNames[a2], { w: r, seriesIndex: a2 });
    } }]), t2;
  }(), Ot2 = function(y2) {
    ge2(t2, ke);
    var e2 = ue2(t2);
    function t2() {
      return F2(this, t2), e2.apply(this, arguments);
    }
    return Y2(t2, [{ key: "draw", value: function(i, a2) {
      var s2 = this.w, r = new M2(this.ctx);
      this.rangeBarOptions = this.w.config.plotOptions.rangeBar, this.series = i, this.seriesRangeStart = s2.globals.seriesRangeStart, this.seriesRangeEnd = s2.globals.seriesRangeEnd, this.barHelpers.initVariables(i);
      for (var n2 = r.group({ class: "apexcharts-rangebar-series apexcharts-plot-series" }), o2 = 0; o2 < i.length; o2++) {
        var h2, c2, d2, g2, p2 = void 0, f2 = void 0, b2 = s2.globals.comboCharts ? a2[o2] : o2, m2 = r.group({ class: "apexcharts-series", seriesName: P2.escapeString(s2.globals.seriesNames[b2]), rel: o2 + 1, "data:realIndex": b2 });
        this.ctx.series.addCollapsedClassToSeries(m2, b2), i[o2].length > 0 && (this.visibleI = this.visibleI + 1);
        var w2 = 0, A2 = 0;
        this.yRatio.length > 1 && (this.yaxisIndex = b2);
        var l2 = this.barHelpers.initialPositions();
        f2 = l2.y, g2 = l2.zeroW, p2 = l2.x, A2 = l2.barWidth, w2 = l2.barHeight, h2 = l2.xDivision, c2 = l2.yDivision, d2 = l2.zeroH;
        for (var u2 = r.group({ class: "apexcharts-datalabels", "data:realIndex": b2 }), x2 = r.group({ class: "apexcharts-rangebar-goals-markers" }), v2 = 0; v2 < s2.globals.dataPoints; v2++) {
          var k2, S2 = this.barHelpers.getStrokeWidth(o2, v2, b2), C2 = this.seriesRangeStart[o2][v2], L2 = this.seriesRangeEnd[o2][v2], I2 = null, z2 = null, T2 = null, E2 = { x: p2, y: f2, strokeWidth: S2, elSeries: m2 }, R2 = this.seriesLen;
          if (s2.config.plotOptions.bar.rangeBarGroupRows && (R2 = 1), s2.config.series[o2].data[v2] === void 0)
            break;
          if (this.isHorizontal) {
            T2 = f2 + w2 * this.visibleI;
            var O2 = (c2 - w2 * R2) / 2;
            if (s2.config.series[o2].data[v2].x) {
              var D2 = this.detectOverlappingBars({ i: o2, j: v2, barYPosition: T2, srty: O2, barHeight: w2, yDivision: c2, initPositions: l2 });
              w2 = D2.barHeight, T2 = D2.barYPosition;
            }
            A2 = (I2 = this.drawRangeBarPaths(X2({ indexes: { i: o2, j: v2, realIndex: b2 }, barHeight: w2, barYPosition: T2, zeroW: g2, yDivision: c2, y1: C2, y2: L2 }, E2))).barWidth;
          } else {
            s2.globals.isXNumeric && (p2 = (s2.globals.seriesX[o2][v2] - s2.globals.minX) / this.xRatio - A2 / 2), z2 = p2 + A2 * this.visibleI;
            var W2 = (h2 - A2 * R2) / 2;
            if (s2.config.series[o2].data[v2].x) {
              var N2 = this.detectOverlappingBars({ i: o2, j: v2, barXPosition: z2, srtx: W2, barWidth: A2, xDivision: h2, initPositions: l2 });
              A2 = N2.barWidth, z2 = N2.barXPosition;
            }
            w2 = (I2 = this.drawRangeColumnPaths(X2({ indexes: { i: o2, j: v2, realIndex: b2 }, barWidth: A2, barXPosition: z2, zeroH: d2, xDivision: h2 }, E2))).barHeight;
          }
          var V2 = this.barHelpers.drawGoalLine({ barXPosition: I2.barXPosition, barYPosition: T2, goalX: I2.goalX, goalY: I2.goalY, barHeight: w2, barWidth: A2 });
          V2 && x2.add(V2), f2 = I2.y, p2 = I2.x;
          var j2 = this.barHelpers.getPathFillColor(i, o2, v2, b2), se2 = s2.globals.stroke.colors[b2];
          this.renderSeries((ee2(k2 = { realIndex: b2, pathFill: j2, lineFill: se2, j: v2, i: o2, x: p2, y: f2, y1: C2, y2: L2, pathFrom: I2.pathFrom, pathTo: I2.pathTo, strokeWidth: S2, elSeries: m2, series: i, barHeight: w2, barWidth: A2, barXPosition: z2, barYPosition: T2 }, "barWidth", A2), ee2(k2, "elDataLabelsWrap", u2), ee2(k2, "elGoalsMarkers", x2), ee2(k2, "visibleSeries", this.visibleI), ee2(k2, "type", "rangebar"), k2));
        }
        n2.add(m2);
      }
      return n2;
    } }, { key: "detectOverlappingBars", value: function(i) {
      var a2 = i.i, s2 = i.j, r = i.barYPosition, n2 = i.barXPosition, o2 = i.srty, h2 = i.srtx, c2 = i.barHeight, d2 = i.barWidth, g2 = i.yDivision, p2 = i.xDivision, f2 = i.initPositions, b2 = this.w, m2 = [], w2 = b2.config.series[a2].data[s2].rangeName, A2 = b2.config.series[a2].data[s2].x, l2 = Array.isArray(A2) ? A2.join(" ") : A2, u2 = b2.globals.labels.map(function(v2) {
        return Array.isArray(v2) ? v2.join(" ") : v2;
      }).indexOf(l2), x2 = b2.globals.seriesRange[a2].findIndex(function(v2) {
        return v2.x === l2 && v2.overlaps.length > 0;
      });
      return this.isHorizontal ? (r = b2.config.plotOptions.bar.rangeBarGroupRows ? o2 + g2 * u2 : o2 + c2 * this.visibleI + g2 * u2, x2 > -1 && !b2.config.plotOptions.bar.rangeBarOverlap && (m2 = b2.globals.seriesRange[a2][x2].overlaps).indexOf(w2) > -1 && (r = (c2 = f2.barHeight / m2.length) * this.visibleI + g2 * (100 - parseInt(this.barOptions.barHeight, 10)) / 100 / 2 + c2 * (this.visibleI + m2.indexOf(w2)) + g2 * u2)) : (u2 > -1 && (n2 = b2.config.plotOptions.bar.rangeBarGroupRows ? h2 + p2 * u2 : h2 + d2 * this.visibleI + p2 * u2), x2 > -1 && !b2.config.plotOptions.bar.rangeBarOverlap && (m2 = b2.globals.seriesRange[a2][x2].overlaps).indexOf(w2) > -1 && (n2 = (d2 = f2.barWidth / m2.length) * this.visibleI + p2 * (100 - parseInt(this.barOptions.barWidth, 10)) / 100 / 2 + d2 * (this.visibleI + m2.indexOf(w2)) + p2 * u2)), { barYPosition: r, barXPosition: n2, barHeight: c2, barWidth: d2 };
    } }, { key: "drawRangeColumnPaths", value: function(i) {
      var a2 = i.indexes, s2 = i.x, r = i.xDivision, n2 = i.barWidth, o2 = i.barXPosition, h2 = i.zeroH, c2 = this.w, d2 = a2.i, g2 = a2.j, p2 = this.yRatio[this.yaxisIndex], f2 = a2.realIndex, b2 = this.getRangeValue(f2, g2), m2 = Math.min(b2.start, b2.end), w2 = Math.max(b2.start, b2.end);
      this.series[d2][g2] === void 0 || this.series[d2][g2] === null ? m2 = h2 : (m2 = h2 - m2 / p2, w2 = h2 - w2 / p2);
      var A2 = Math.abs(w2 - m2), l2 = this.barHelpers.getColumnPaths({ barXPosition: o2, barWidth: n2, y1: m2, y2: w2, strokeWidth: this.strokeWidth, series: this.seriesRangeEnd, realIndex: a2.realIndex, i: f2, j: g2, w: c2 });
      if (c2.globals.isXNumeric) {
        var u2 = this.getBarXForNumericXAxis({ x: s2, j: g2, realIndex: f2, barWidth: n2 });
        s2 = u2.x, o2 = u2.barXPosition;
      } else
        s2 += r;
      return { pathTo: l2.pathTo, pathFrom: l2.pathFrom, barHeight: A2, x: s2, y: w2, goalY: this.barHelpers.getGoalValues("y", null, h2, d2, g2), barXPosition: o2 };
    } }, { key: "drawRangeBarPaths", value: function(i) {
      var a2 = i.indexes, s2 = i.y, r = i.y1, n2 = i.y2, o2 = i.yDivision, h2 = i.barHeight, c2 = i.barYPosition, d2 = i.zeroW, g2 = this.w, p2 = d2 + r / this.invertedYRatio, f2 = d2 + n2 / this.invertedYRatio, b2 = Math.abs(f2 - p2), m2 = this.barHelpers.getBarpaths({ barYPosition: c2, barHeight: h2, x1: p2, x2: f2, strokeWidth: this.strokeWidth, series: this.seriesRangeEnd, i: a2.realIndex, realIndex: a2.realIndex, j: a2.j, w: g2 });
      return g2.globals.isXNumeric || (s2 += o2), { pathTo: m2.pathTo, pathFrom: m2.pathFrom, barWidth: b2, x: f2, goalX: this.barHelpers.getGoalValues("x", d2, null, a2.realIndex, a2.j), y: s2 };
    } }, { key: "getRangeValue", value: function(i, a2) {
      var s2 = this.w;
      return { start: s2.globals.seriesRangeStart[i][a2], end: s2.globals.seriesRangeEnd[i][a2] };
    } }]), t2;
  }(), Ht2 = function() {
    function y2(e2) {
      F2(this, y2), this.w = e2.w, this.lineCtx = e2;
    }
    return Y2(y2, [{ key: "sameValueSeriesFix", value: function(e2, t2) {
      var i = this.w;
      if ((i.config.fill.type === "gradient" || i.config.fill.type[e2] === "gradient") && new q2(this.lineCtx.ctx, i).seriesHaveSameValues(e2)) {
        var a2 = t2[e2].slice();
        a2[a2.length - 1] = a2[a2.length - 1] + 1e-6, t2[e2] = a2;
      }
      return t2;
    } }, { key: "calculatePoints", value: function(e2) {
      var t2 = e2.series, i = e2.realIndex, a2 = e2.x, s2 = e2.y, r = e2.i, n2 = e2.j, o2 = e2.prevY, h2 = this.w, c2 = [], d2 = [];
      if (n2 === 0) {
        var g2 = this.lineCtx.categoryAxisCorrection + h2.config.markers.offsetX;
        h2.globals.isXNumeric && (g2 = (h2.globals.seriesX[i][0] - h2.globals.minX) / this.lineCtx.xRatio + h2.config.markers.offsetX), c2.push(g2), d2.push(P2.isNumber(t2[r][0]) ? o2 + h2.config.markers.offsetY : null), c2.push(a2 + h2.config.markers.offsetX), d2.push(P2.isNumber(t2[r][n2 + 1]) ? s2 + h2.config.markers.offsetY : null);
      } else
        c2.push(a2 + h2.config.markers.offsetX), d2.push(P2.isNumber(t2[r][n2 + 1]) ? s2 + h2.config.markers.offsetY : null);
      return { x: c2, y: d2 };
    } }, { key: "checkPreviousPaths", value: function(e2) {
      for (var t2 = e2.pathFromLine, i = e2.pathFromArea, a2 = e2.realIndex, s2 = this.w, r = 0; r < s2.globals.previousPaths.length; r++) {
        var n2 = s2.globals.previousPaths[r];
        (n2.type === "line" || n2.type === "area") && n2.paths.length > 0 && parseInt(n2.realIndex, 10) === parseInt(a2, 10) && (n2.type === "line" ? (this.lineCtx.appendPathFrom = false, t2 = s2.globals.previousPaths[r].paths[0].d) : n2.type === "area" && (this.lineCtx.appendPathFrom = false, i = s2.globals.previousPaths[r].paths[0].d, s2.config.stroke.show && s2.globals.previousPaths[r].paths[1] && (t2 = s2.globals.previousPaths[r].paths[1].d)));
      }
      return { pathFromLine: t2, pathFromArea: i };
    } }, { key: "determineFirstPrevY", value: function(e2) {
      var t2, i, a2 = e2.i, s2 = e2.series, r = e2.prevY, n2 = e2.lineYPosition, o2 = this.w, h2 = o2.config.chart.stacked && !o2.globals.comboCharts || o2.config.chart.stacked && o2.globals.comboCharts && (!this.w.config.chart.stackOnlyBar || ((t2 = this.w.config.series[a2]) === null || t2 === void 0 ? void 0 : t2.type) === "bar");
      if (((i = s2[a2]) === null || i === void 0 ? void 0 : i[0]) !== void 0)
        r = (n2 = h2 && a2 > 0 ? this.lineCtx.prevSeriesY[a2 - 1][0] : this.lineCtx.zeroY) - s2[a2][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] + 2 * (this.lineCtx.isReversed ? s2[a2][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] : 0);
      else if (h2 && a2 > 0 && s2[a2][0] === void 0) {
        for (var c2 = a2 - 1; c2 >= 0; c2--)
          if (s2[c2][0] !== null && s2[c2][0] !== void 0) {
            r = n2 = this.lineCtx.prevSeriesY[c2][0];
            break;
          }
      }
      return { prevY: r, lineYPosition: n2 };
    } }]), y2;
  }(), Dt2 = function(y2) {
    for (var e2, t2, i, a2, s2 = function(c2) {
      for (var d2 = [], g2 = c2[0], p2 = c2[1], f2 = d2[0] = Ve(g2, p2), b2 = 1, m2 = c2.length - 1; b2 < m2; b2++)
        g2 = p2, p2 = c2[b2 + 1], d2[b2] = 0.5 * (f2 + (f2 = Ve(g2, p2)));
      return d2[b2] = f2, d2;
    }(y2), r = y2.length - 1, n2 = [], o2 = 0; o2 < r; o2++)
      i = Ve(y2[o2], y2[o2 + 1]), Math.abs(i) < 1e-6 ? s2[o2] = s2[o2 + 1] = 0 : (a2 = (e2 = s2[o2] / i) * e2 + (t2 = s2[o2 + 1] / i) * t2) > 9 && (a2 = 3 * i / Math.sqrt(a2), s2[o2] = a2 * e2, s2[o2 + 1] = a2 * t2);
    for (var h2 = 0; h2 <= r; h2++)
      a2 = (y2[Math.min(r, h2 + 1)][0] - y2[Math.max(0, h2 - 1)][0]) / (6 * (1 + s2[h2] * s2[h2])), n2.push([a2 || 0, s2[h2] * a2 || 0]);
    return n2;
  }, Ge = function(y2) {
    for (var e2 = "", t2 = 0; t2 < y2.length; t2++) {
      var i = y2[t2], a2 = i.length;
      a2 > 4 ? (e2 += "C".concat(i[0], ", ").concat(i[1]), e2 += ", ".concat(i[2], ", ").concat(i[3]), e2 += ", ".concat(i[4], ", ").concat(i[5])) : a2 > 2 && (e2 += "S".concat(i[0], ", ").concat(i[1]), e2 += ", ".concat(i[2], ", ").concat(i[3]));
    }
    return e2;
  }, lt2 = function(y2) {
    var e2 = Dt2(y2), t2 = y2[1], i = y2[0], a2 = [], s2 = e2[1], r = e2[0];
    a2.push(i, [i[0] + r[0], i[1] + r[1], t2[0] - s2[0], t2[1] - s2[1], t2[0], t2[1]]);
    for (var n2 = 2, o2 = e2.length; n2 < o2; n2++) {
      var h2 = y2[n2], c2 = e2[n2];
      a2.push([h2[0] - c2[0], h2[1] - c2[1], h2[0], h2[1]]);
    }
    return a2;
  };
  function Ve(y2, e2) {
    return (e2[1] - y2[1]) / (e2[0] - y2[0]);
  }
  var je = function() {
    function y2(e2, t2, i) {
      F2(this, y2), this.ctx = e2, this.w = e2.w, this.xyRatios = t2, this.pointsChart = !(this.w.config.chart.type !== "bubble" && this.w.config.chart.type !== "scatter") || i, this.scatter = new $e(this.ctx), this.noNegatives = this.w.globals.minX === Number.MAX_VALUE, this.lineHelpers = new Ht2(this), this.markers = new Pe(this.ctx), this.prevSeriesY = [], this.categoryAxisCorrection = 0, this.yaxisIndex = 0;
    }
    return Y2(y2, [{ key: "draw", value: function(e2, t2, i, a2) {
      var s2, r = this.w, n2 = new M2(this.ctx), o2 = r.globals.comboCharts ? t2 : r.config.chart.type, h2 = n2.group({ class: "apexcharts-".concat(o2, "-series apexcharts-plot-series") }), c2 = new q2(this.ctx, r);
      this.yRatio = this.xyRatios.yRatio, this.zRatio = this.xyRatios.zRatio, this.xRatio = this.xyRatios.xRatio, this.baseLineY = this.xyRatios.baseLineY, e2 = c2.getLogSeries(e2), this.yRatio = c2.getLogYRatios(this.yRatio);
      for (var d2 = [], g2 = 0; g2 < e2.length; g2++) {
        e2 = this.lineHelpers.sameValueSeriesFix(g2, e2);
        var p2 = r.globals.comboCharts ? i[g2] : g2;
        this._initSerieVariables(e2, g2, p2);
        var f2 = [], b2 = [], m2 = [], w2 = r.globals.padHorizontal + this.categoryAxisCorrection;
        this.ctx.series.addCollapsedClassToSeries(this.elSeries, p2), r.globals.isXNumeric && r.globals.seriesX.length > 0 && (w2 = (r.globals.seriesX[p2][0] - r.globals.minX) / this.xRatio), m2.push(w2);
        var A2, l2 = w2, u2 = void 0, x2 = l2, v2 = this.zeroY, k2 = this.zeroY;
        v2 = this.lineHelpers.determineFirstPrevY({ i: g2, series: e2, prevY: v2, lineYPosition: 0 }).prevY, r.config.stroke.curve === "monotonCubic" && e2[g2][0] === null ? f2.push(null) : f2.push(v2), A2 = v2, o2 === "rangeArea" && (u2 = k2 = this.lineHelpers.determineFirstPrevY({ i: g2, series: a2, prevY: k2, lineYPosition: 0 }).prevY, b2.push(k2));
        var S2 = { type: o2, series: e2, realIndex: p2, i: g2, x: w2, y: 1, pX: l2, pY: A2, pathsFrom: this._calculatePathsFrom({ type: o2, series: e2, i: g2, realIndex: p2, prevX: x2, prevY: v2, prevY2: k2 }), linePaths: [], areaPaths: [], seriesIndex: i, lineYPosition: 0, xArrj: m2, yArrj: f2, y2Arrj: b2, seriesRangeEnd: a2 }, C2 = this._iterateOverDataPoints(X2(X2({}, S2), {}, { iterations: o2 === "rangeArea" ? e2[g2].length - 1 : void 0, isRangeStart: true }));
        if (o2 === "rangeArea") {
          var L2 = this._calculatePathsFrom({ series: a2, i: g2, realIndex: p2, prevX: x2, prevY: k2 }), I2 = this._iterateOverDataPoints(X2(X2({}, S2), {}, { series: a2, pY: u2, pathsFrom: L2, iterations: a2[g2].length - 1, isRangeStart: false }));
          C2.linePaths[0] = I2.linePath + C2.linePath, C2.pathFromLine = I2.pathFromLine + C2.pathFromLine;
        }
        this._handlePaths({ type: o2, realIndex: p2, i: g2, paths: C2 }), this.elSeries.add(this.elPointsMain), this.elSeries.add(this.elDataLabelsWrap), d2.push(this.elSeries);
      }
      if (((s2 = r.config.series[0]) === null || s2 === void 0 ? void 0 : s2.zIndex) !== void 0 && d2.sort(function(E2, R2) {
        return Number(E2.node.getAttribute("zIndex")) - Number(R2.node.getAttribute("zIndex"));
      }), r.config.chart.stacked)
        for (var z2 = d2.length; z2 > 0; z2--)
          h2.add(d2[z2 - 1]);
      else
        for (var T2 = 0; T2 < d2.length; T2++)
          h2.add(d2[T2]);
      return h2;
    } }, { key: "_initSerieVariables", value: function(e2, t2, i) {
      var a2 = this.w, s2 = new M2(this.ctx);
      this.xDivision = a2.globals.gridWidth / (a2.globals.dataPoints - (a2.config.xaxis.tickPlacement === "on" ? 1 : 0)), this.strokeWidth = Array.isArray(a2.config.stroke.width) ? a2.config.stroke.width[i] : a2.config.stroke.width, this.yRatio.length > 1 && (this.yaxisIndex = i), this.isReversed = a2.config.yaxis[this.yaxisIndex] && a2.config.yaxis[this.yaxisIndex].reversed, this.zeroY = a2.globals.gridHeight - this.baseLineY[this.yaxisIndex] - (this.isReversed ? a2.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0), this.areaBottomY = this.zeroY, (this.zeroY > a2.globals.gridHeight || a2.config.plotOptions.area.fillTo === "end") && (this.areaBottomY = a2.globals.gridHeight), this.categoryAxisCorrection = this.xDivision / 2, this.elSeries = s2.group({ class: "apexcharts-series", zIndex: a2.config.series[i].zIndex !== void 0 ? a2.config.series[i].zIndex : i, seriesName: P2.escapeString(a2.globals.seriesNames[i]) }), this.elPointsMain = s2.group({ class: "apexcharts-series-markers-wrap", "data:realIndex": i }), this.elDataLabelsWrap = s2.group({ class: "apexcharts-datalabels", "data:realIndex": i });
      var r = e2[t2].length === a2.globals.dataPoints;
      this.elSeries.attr({ "data:longestSeries": r, rel: t2 + 1, "data:realIndex": i }), this.appendPathFrom = true;
    } }, { key: "_calculatePathsFrom", value: function(e2) {
      var t2, i, a2, s2, r = e2.type, n2 = e2.series, o2 = e2.i, h2 = e2.realIndex, c2 = e2.prevX, d2 = e2.prevY, g2 = e2.prevY2, p2 = this.w, f2 = new M2(this.ctx);
      if (n2[o2][0] === null) {
        for (var b2 = 0; b2 < n2[o2].length; b2++)
          if (n2[o2][b2] !== null) {
            c2 = this.xDivision * b2, d2 = this.zeroY - n2[o2][b2] / this.yRatio[this.yaxisIndex], t2 = f2.move(c2, d2), i = f2.move(c2, this.areaBottomY);
            break;
          }
      } else
        t2 = f2.move(c2, d2), r === "rangeArea" && (t2 = f2.move(c2, g2) + f2.line(c2, d2)), i = f2.move(c2, this.areaBottomY) + f2.line(c2, d2);
      if (a2 = f2.move(-1, this.zeroY) + f2.line(-1, this.zeroY), s2 = f2.move(-1, this.zeroY) + f2.line(-1, this.zeroY), p2.globals.previousPaths.length > 0) {
        var m2 = this.lineHelpers.checkPreviousPaths({ pathFromLine: a2, pathFromArea: s2, realIndex: h2 });
        a2 = m2.pathFromLine, s2 = m2.pathFromArea;
      }
      return { prevX: c2, prevY: d2, linePath: t2, areaPath: i, pathFromLine: a2, pathFromArea: s2 };
    } }, { key: "_handlePaths", value: function(e2) {
      var t2 = e2.type, i = e2.realIndex, a2 = e2.i, s2 = e2.paths, r = this.w, n2 = new M2(this.ctx), o2 = new ae2(this.ctx);
      this.prevSeriesY.push(s2.yArrj), r.globals.seriesXvalues[i] = s2.xArrj, r.globals.seriesYvalues[i] = s2.yArrj;
      var h2 = r.config.forecastDataPoints;
      if (h2.count > 0 && t2 !== "rangeArea") {
        var c2 = r.globals.seriesXvalues[i][r.globals.seriesXvalues[i].length - h2.count - 1], d2 = n2.drawRect(c2, 0, r.globals.gridWidth, r.globals.gridHeight, 0);
        r.globals.dom.elForecastMask.appendChild(d2.node);
        var g2 = n2.drawRect(0, 0, c2, r.globals.gridHeight, 0);
        r.globals.dom.elNonForecastMask.appendChild(g2.node);
      }
      this.pointsChart || r.globals.delayedElements.push({ el: this.elPointsMain.node, index: i });
      var p2 = { i: a2, realIndex: i, animationDelay: a2, initialSpeed: r.config.chart.animations.speed, dataChangeSpeed: r.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-".concat(t2) };
      if (t2 === "area")
        for (var f2 = o2.fillPath({ seriesNumber: i }), b2 = 0; b2 < s2.areaPaths.length; b2++) {
          var m2 = n2.renderPaths(X2(X2({}, p2), {}, { pathFrom: s2.pathFromArea, pathTo: s2.areaPaths[b2], stroke: "none", strokeWidth: 0, strokeLineCap: null, fill: f2 }));
          this.elSeries.add(m2);
        }
      if (r.config.stroke.show && !this.pointsChart) {
        var w2 = null;
        if (t2 === "line")
          w2 = o2.fillPath({ seriesNumber: i, i: a2 });
        else if (r.config.stroke.fill.type === "solid")
          w2 = r.globals.stroke.colors[i];
        else {
          var A2 = r.config.fill;
          r.config.fill = r.config.stroke.fill, w2 = o2.fillPath({ seriesNumber: i, i: a2 }), r.config.fill = A2;
        }
        for (var l2 = 0; l2 < s2.linePaths.length; l2++) {
          var u2 = w2;
          t2 === "rangeArea" && (u2 = o2.fillPath({ seriesNumber: i }));
          var x2 = X2(X2({}, p2), {}, { pathFrom: s2.pathFromLine, pathTo: s2.linePaths[l2], stroke: w2, strokeWidth: this.strokeWidth, strokeLineCap: r.config.stroke.lineCap, fill: t2 === "rangeArea" ? u2 : "none" }), v2 = n2.renderPaths(x2);
          if (this.elSeries.add(v2), v2.attr("fill-rule", "evenodd"), h2.count > 0 && t2 !== "rangeArea") {
            var k2 = n2.renderPaths(x2);
            k2.node.setAttribute("stroke-dasharray", h2.dashArray), h2.strokeWidth && k2.node.setAttribute("stroke-width", h2.strokeWidth), this.elSeries.add(k2), k2.attr("clip-path", "url(#forecastMask".concat(r.globals.cuid, ")")), v2.attr("clip-path", "url(#nonForecastMask".concat(r.globals.cuid, ")"));
          }
        }
      }
    } }, { key: "_iterateOverDataPoints", value: function(e2) {
      var t2, i = this, a2 = e2.type, s2 = e2.series, r = e2.iterations, n2 = e2.realIndex, o2 = e2.i, h2 = e2.x, c2 = e2.y, d2 = e2.pX, g2 = e2.pY, p2 = e2.pathsFrom, f2 = e2.linePaths, b2 = e2.areaPaths, m2 = e2.seriesIndex, w2 = e2.lineYPosition, A2 = e2.xArrj, l2 = e2.yArrj, u2 = e2.y2Arrj, x2 = e2.isRangeStart, v2 = e2.seriesRangeEnd, k2 = this.w, S2 = new M2(this.ctx), C2 = this.yRatio, L2 = p2.prevY, I2 = p2.linePath, z2 = p2.areaPath, T2 = p2.pathFromLine, E2 = p2.pathFromArea, R2 = P2.isNumber(k2.globals.minYArr[n2]) ? k2.globals.minYArr[n2] : k2.globals.minY;
      r || (r = k2.globals.dataPoints > 1 ? k2.globals.dataPoints - 1 : k2.globals.dataPoints);
      for (var O2 = function(le2, he2) {
        return he2 - le2 / C2[i.yaxisIndex] + 2 * (i.isReversed ? le2 / C2[i.yaxisIndex] : 0);
      }, D2 = c2, W2 = k2.config.chart.stacked && !k2.globals.comboCharts || k2.config.chart.stacked && k2.globals.comboCharts && (!this.w.config.chart.stackOnlyBar || ((t2 = this.w.config.series[n2]) === null || t2 === void 0 ? void 0 : t2.type) === "bar"), N2 = 0; N2 < r; N2++) {
        var V2 = s2[o2][N2 + 1] === void 0 || s2[o2][N2 + 1] === null;
        if (k2.globals.isXNumeric) {
          var j2 = k2.globals.seriesX[n2][N2 + 1];
          k2.globals.seriesX[n2][N2 + 1] === void 0 && (j2 = k2.globals.seriesX[n2][r - 1]), h2 = (j2 - k2.globals.minX) / this.xRatio;
        } else
          h2 += this.xDivision;
        W2 ? o2 > 0 && k2.globals.collapsedSeries.length < k2.config.series.length - 1 ? w2 = this.prevSeriesY[function(le2) {
          for (var he2 = le2, $2 = 0; $2 < k2.globals.series.length; $2++)
            if (k2.globals.collapsedSeriesIndices.indexOf(le2) > -1) {
              he2--;
              break;
            }
          return he2 >= 0 ? he2 : 0;
        }(o2 - 1)][N2 + 1] : w2 = this.zeroY : w2 = this.zeroY, V2 ? c2 = O2(R2, w2) : (c2 = O2(s2[o2][N2 + 1], w2), a2 === "rangeArea" && (D2 = O2(v2[o2][N2 + 1], w2))), A2.push(h2), V2 && k2.config.stroke.curve === "smooth" ? l2.push(null) : l2.push(c2), u2.push(D2);
        var se2 = this.lineHelpers.calculatePoints({ series: s2, x: h2, y: c2, realIndex: n2, i: o2, j: N2, prevY: L2 }), K2 = this._createPaths({ type: a2, series: s2, i: o2, realIndex: n2, j: N2, x: h2, y: c2, y2: D2, xArrj: A2, yArrj: l2, y2Arrj: u2, pX: d2, pY: g2, linePath: I2, areaPath: z2, linePaths: f2, areaPaths: b2, seriesIndex: m2, isRangeStart: x2 });
        b2 = K2.areaPaths, f2 = K2.linePaths, d2 = K2.pX, g2 = K2.pY, z2 = K2.areaPath, I2 = K2.linePath, !this.appendPathFrom || k2.config.stroke.curve === "monotoneCubic" && a2 === "rangeArea" || (T2 += S2.line(h2, this.zeroY), E2 += S2.line(h2, this.zeroY)), this.handleNullDataPoints(s2, se2, o2, N2, n2), this._handleMarkersAndLabels({ type: a2, pointsPos: se2, i: o2, j: N2, realIndex: n2, isRangeStart: x2 });
      }
      return { yArrj: l2, xArrj: A2, pathFromArea: E2, areaPaths: b2, pathFromLine: T2, linePaths: f2, linePath: I2, areaPath: z2 };
    } }, { key: "_handleMarkersAndLabels", value: function(e2) {
      var t2 = e2.type, i = e2.pointsPos, a2 = e2.isRangeStart, s2 = e2.i, r = e2.j, n2 = e2.realIndex, o2 = this.w, h2 = new ye2(this.ctx);
      if (this.pointsChart)
        this.scatter.draw(this.elSeries, r, { realIndex: n2, pointsPos: i, zRatio: this.zRatio, elParent: this.elPointsMain });
      else {
        o2.globals.series[s2].length > 1 && this.elPointsMain.node.classList.add("apexcharts-element-hidden");
        var c2 = this.markers.plotChartMarkers(i, n2, r + 1);
        c2 !== null && this.elPointsMain.add(c2);
      }
      var d2 = h2.drawDataLabel({ type: t2, isRangeStart: a2, pos: i, i: n2, j: r + 1 });
      d2 !== null && this.elDataLabelsWrap.add(d2);
    } }, { key: "_createPaths", value: function(e2) {
      var t2 = e2.type, i = e2.series, a2 = e2.i, s2 = e2.realIndex, r = e2.j, n2 = e2.x, o2 = e2.y, h2 = e2.xArrj, c2 = e2.yArrj, d2 = e2.y2, g2 = e2.y2Arrj, p2 = e2.pX, f2 = e2.pY, b2 = e2.linePath, m2 = e2.areaPath, w2 = e2.linePaths, A2 = e2.areaPaths, l2 = e2.seriesIndex, u2 = e2.isRangeStart, x2 = this.w, v2 = new M2(this.ctx), k2 = x2.config.stroke.curve, S2 = this.areaBottomY;
      if (Array.isArray(x2.config.stroke.curve) && (k2 = Array.isArray(l2) ? x2.config.stroke.curve[l2[a2]] : x2.config.stroke.curve[a2]), t2 === "rangeArea" && (x2.globals.hasNullValues || x2.config.forecastDataPoints.count > 0) && k2 === "monotoneCubic" && (k2 = "straight"), k2 === "monotoneCubic") {
        var C2 = t2 === "rangeArea" ? h2.length === x2.globals.dataPoints : r === i[a2].length - 2, L2 = h2.map(function(W2, N2) {
          return [h2[N2], c2[N2]];
        }).filter(function(W2) {
          return W2[1] !== null;
        });
        if (C2 && L2.length > 1) {
          var I2 = lt2(L2);
          if (b2 += Ge(I2), i[a2][0] === null ? m2 = b2 : m2 += Ge(I2), t2 === "rangeArea" && u2) {
            b2 += v2.line(h2[h2.length - 1], g2[g2.length - 1]);
            var z2 = h2.slice().reverse(), T2 = g2.slice().reverse(), E2 = z2.map(function(W2, N2) {
              return [z2[N2], T2[N2]];
            }), R2 = lt2(E2);
            m2 = b2 += Ge(R2);
          } else
            m2 += v2.line(L2[L2.length - 1][0], S2) + v2.line(L2[0][0], S2) + v2.move(L2[0][0], L2[0][1]) + "z";
          w2.push(b2), A2.push(m2);
        }
      } else if (k2 === "smooth") {
        var O2 = 0.35 * (n2 - p2);
        x2.globals.hasNullValues ? (i[a2][r] !== null && (i[a2][r + 1] !== null ? (b2 = v2.move(p2, f2) + v2.curve(p2 + O2, f2, n2 - O2, o2, n2 + 1, o2), m2 = v2.move(p2 + 1, f2) + v2.curve(p2 + O2, f2, n2 - O2, o2, n2 + 1, o2) + v2.line(n2, S2) + v2.line(p2, S2) + "z") : (b2 = v2.move(p2, f2), m2 = v2.move(p2, f2) + "z")), w2.push(b2), A2.push(m2)) : (b2 += v2.curve(p2 + O2, f2, n2 - O2, o2, n2, o2), m2 += v2.curve(p2 + O2, f2, n2 - O2, o2, n2, o2)), p2 = n2, f2 = o2, r === i[a2].length - 2 && (m2 = m2 + v2.curve(p2, f2, n2, o2, n2, S2) + v2.move(n2, o2) + "z", t2 === "rangeArea" && u2 ? b2 = b2 + v2.curve(p2, f2, n2, o2, n2, d2) + v2.move(n2, d2) + "z" : x2.globals.hasNullValues || (w2.push(b2), A2.push(m2)));
      } else {
        if (i[a2][r + 1] === null) {
          b2 += v2.move(n2, o2);
          var D2 = x2.globals.isXNumeric ? (x2.globals.seriesX[s2][r] - x2.globals.minX) / this.xRatio : n2 - this.xDivision;
          m2 = m2 + v2.line(D2, S2) + v2.move(n2, o2) + "z";
        }
        i[a2][r] === null && (b2 += v2.move(n2, o2), m2 += v2.move(n2, S2)), k2 === "stepline" ? (b2 = b2 + v2.line(n2, null, "H") + v2.line(null, o2, "V"), m2 = m2 + v2.line(n2, null, "H") + v2.line(null, o2, "V")) : k2 === "straight" && (b2 += v2.line(n2, o2), m2 += v2.line(n2, o2)), r === i[a2].length - 2 && (m2 = m2 + v2.line(n2, S2) + v2.move(n2, o2) + "z", t2 === "rangeArea" && u2 ? b2 = b2 + v2.line(n2, d2) + v2.move(n2, d2) + "z" : (w2.push(b2), A2.push(m2)));
      }
      return { linePaths: w2, areaPaths: A2, pX: p2, pY: f2, linePath: b2, areaPath: m2 };
    } }, { key: "handleNullDataPoints", value: function(e2, t2, i, a2, s2) {
      var r = this.w;
      if (e2[i][a2] === null && r.config.markers.showNullDataPoints || e2[i].length === 1) {
        var n2 = this.markers.plotChartMarkers(t2, s2, a2 + 1, this.strokeWidth - r.config.markers.strokeWidth / 2, true);
        n2 !== null && this.elPointsMain.add(n2);
      }
    } }]), y2;
  }();
  window.TreemapSquared = {}, window.TreemapSquared.generate = /* @__PURE__ */ function() {
    function y2(n2, o2, h2, c2) {
      this.xoffset = n2, this.yoffset = o2, this.height = c2, this.width = h2, this.shortestEdge = function() {
        return Math.min(this.height, this.width);
      }, this.getCoordinates = function(d2) {
        var g2, p2 = [], f2 = this.xoffset, b2 = this.yoffset, m2 = s2(d2) / this.height, w2 = s2(d2) / this.width;
        if (this.width >= this.height)
          for (g2 = 0; g2 < d2.length; g2++)
            p2.push([f2, b2, f2 + m2, b2 + d2[g2] / m2]), b2 += d2[g2] / m2;
        else
          for (g2 = 0; g2 < d2.length; g2++)
            p2.push([f2, b2, f2 + d2[g2] / w2, b2 + w2]), f2 += d2[g2] / w2;
        return p2;
      }, this.cutArea = function(d2) {
        var g2;
        if (this.width >= this.height) {
          var p2 = d2 / this.height, f2 = this.width - p2;
          g2 = new y2(this.xoffset + p2, this.yoffset, f2, this.height);
        } else {
          var b2 = d2 / this.width, m2 = this.height - b2;
          g2 = new y2(this.xoffset, this.yoffset + b2, this.width, m2);
        }
        return g2;
      };
    }
    function e2(n2, o2, h2, c2, d2) {
      c2 = c2 === void 0 ? 0 : c2, d2 = d2 === void 0 ? 0 : d2;
      var g2 = t2(function(p2, f2) {
        var b2, m2 = [], w2 = f2 / s2(p2);
        for (b2 = 0; b2 < p2.length; b2++)
          m2[b2] = p2[b2] * w2;
        return m2;
      }(n2, o2 * h2), [], new y2(c2, d2, o2, h2), []);
      return function(p2) {
        var f2, b2, m2 = [];
        for (f2 = 0; f2 < p2.length; f2++)
          for (b2 = 0; b2 < p2[f2].length; b2++)
            m2.push(p2[f2][b2]);
        return m2;
      }(g2);
    }
    function t2(n2, o2, h2, c2) {
      var d2, g2, p2;
      if (n2.length !== 0)
        return d2 = h2.shortestEdge(), function(f2, b2, m2) {
          var w2;
          if (f2.length === 0)
            return true;
          (w2 = f2.slice()).push(b2);
          var A2 = i(f2, m2), l2 = i(w2, m2);
          return A2 >= l2;
        }(o2, g2 = n2[0], d2) ? (o2.push(g2), t2(n2.slice(1), o2, h2, c2)) : (p2 = h2.cutArea(s2(o2), c2), c2.push(h2.getCoordinates(o2)), t2(n2, [], p2, c2)), c2;
      c2.push(h2.getCoordinates(o2));
    }
    function i(n2, o2) {
      var h2 = Math.min.apply(Math, n2), c2 = Math.max.apply(Math, n2), d2 = s2(n2);
      return Math.max(Math.pow(o2, 2) * c2 / Math.pow(d2, 2), Math.pow(d2, 2) / (Math.pow(o2, 2) * h2));
    }
    function a2(n2) {
      return n2 && n2.constructor === Array;
    }
    function s2(n2) {
      var o2, h2 = 0;
      for (o2 = 0; o2 < n2.length; o2++)
        h2 += n2[o2];
      return h2;
    }
    function r(n2) {
      var o2, h2 = 0;
      if (a2(n2[0]))
        for (o2 = 0; o2 < n2.length; o2++)
          h2 += r(n2[o2]);
      else
        h2 = s2(n2);
      return h2;
    }
    return function n2(o2, h2, c2, d2, g2) {
      d2 = d2 === void 0 ? 0 : d2, g2 = g2 === void 0 ? 0 : g2;
      var p2, f2, b2 = [], m2 = [];
      if (a2(o2[0])) {
        for (f2 = 0; f2 < o2.length; f2++)
          b2[f2] = r(o2[f2]);
        for (p2 = e2(b2, h2, c2, d2, g2), f2 = 0; f2 < o2.length; f2++)
          m2.push(n2(o2[f2], p2[f2][2] - p2[f2][0], p2[f2][3] - p2[f2][1], p2[f2][0], p2[f2][1]));
      } else
        m2 = e2(o2, h2, c2, d2, g2);
      return m2;
    };
  }();
  var be2, Fe, Nt2 = function() {
    function y2(e2, t2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w, this.strokeWidth = this.w.config.stroke.width, this.helpers = new rt2(e2), this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.labels = [];
    }
    return Y2(y2, [{ key: "draw", value: function(e2) {
      var t2 = this, i = this.w, a2 = new M2(this.ctx), s2 = new ae2(this.ctx), r = a2.group({ class: "apexcharts-treemap" });
      if (i.globals.noData)
        return r;
      var n2 = [];
      return e2.forEach(function(o2) {
        var h2 = o2.map(function(c2) {
          return Math.abs(c2);
        });
        n2.push(h2);
      }), this.negRange = this.helpers.checkColorRange(), i.config.series.forEach(function(o2, h2) {
        o2.data.forEach(function(c2) {
          Array.isArray(t2.labels[h2]) || (t2.labels[h2] = []), t2.labels[h2].push(c2.x);
        });
      }), window.TreemapSquared.generate(n2, i.globals.gridWidth, i.globals.gridHeight).forEach(function(o2, h2) {
        var c2 = a2.group({ class: "apexcharts-series apexcharts-treemap-series", seriesName: P2.escapeString(i.globals.seriesNames[h2]), rel: h2 + 1, "data:realIndex": h2 });
        if (i.config.chart.dropShadow.enabled) {
          var d2 = i.config.chart.dropShadow;
          new Z2(t2.ctx).dropShadow(r, d2, h2);
        }
        var g2 = a2.group({ class: "apexcharts-data-labels" });
        o2.forEach(function(p2, f2) {
          var b2 = p2[0], m2 = p2[1], w2 = p2[2], A2 = p2[3], l2 = a2.drawRect(b2, m2, w2 - b2, A2 - m2, i.config.plotOptions.treemap.borderRadius, "#fff", 1, t2.strokeWidth, i.config.plotOptions.treemap.useFillColorAsStroke ? x2 : i.globals.stroke.colors[h2]);
          l2.attr({ cx: b2, cy: m2, index: h2, i: h2, j: f2, width: w2 - b2, height: A2 - m2 });
          var u2 = t2.helpers.getShadeColor(i.config.chart.type, h2, f2, t2.negRange), x2 = u2.color;
          i.config.series[h2].data[f2] !== void 0 && i.config.series[h2].data[f2].fillColor && (x2 = i.config.series[h2].data[f2].fillColor);
          var v2 = s2.fillPath({ color: x2, seriesNumber: h2, dataPointIndex: f2 });
          l2.node.classList.add("apexcharts-treemap-rect"), l2.attr({ fill: v2 }), t2.helpers.addListeners(l2);
          var k2 = { x: b2 + (w2 - b2) / 2, y: m2 + (A2 - m2) / 2, width: 0, height: 0 }, S2 = { x: b2, y: m2, width: w2 - b2, height: A2 - m2 };
          if (i.config.chart.animations.enabled && !i.globals.dataChanged) {
            var C2 = 1;
            i.globals.resized || (C2 = i.config.chart.animations.speed), t2.animateTreemap(l2, k2, S2, C2);
          }
          if (i.globals.dataChanged) {
            var L2 = 1;
            t2.dynamicAnim.enabled && i.globals.shouldAnimate && (L2 = t2.dynamicAnim.speed, i.globals.previousPaths[h2] && i.globals.previousPaths[h2][f2] && i.globals.previousPaths[h2][f2].rect && (k2 = i.globals.previousPaths[h2][f2].rect), t2.animateTreemap(l2, k2, S2, L2));
          }
          var I2 = t2.getFontSize(p2), z2 = i.config.dataLabels.formatter(t2.labels[h2][f2], { value: i.globals.series[h2][f2], seriesIndex: h2, dataPointIndex: f2, w: i });
          i.config.plotOptions.treemap.dataLabels.format === "truncate" && (I2 = parseInt(i.config.dataLabels.style.fontSize, 10), z2 = t2.truncateLabels(z2, I2, b2, m2, w2, A2));
          var T2 = t2.helpers.calculateDataLabels({ text: z2, x: (b2 + w2) / 2, y: (m2 + A2) / 2 + t2.strokeWidth / 2 + I2 / 3, i: h2, j: f2, colorProps: u2, fontSize: I2, series: e2 });
          i.config.dataLabels.enabled && T2 && t2.rotateToFitLabel(T2, I2, z2, b2, m2, w2, A2), c2.add(l2), T2 !== null && c2.add(T2);
        }), c2.add(g2), r.add(c2);
      }), r;
    } }, { key: "getFontSize", value: function(e2) {
      var t2 = this.w, i, a2, s2, r, n2 = function o2(h2) {
        var c2, d2 = 0;
        if (Array.isArray(h2[0]))
          for (c2 = 0; c2 < h2.length; c2++)
            d2 += o2(h2[c2]);
        else
          for (c2 = 0; c2 < h2.length; c2++)
            d2 += h2[c2].length;
        return d2;
      }(this.labels) / function o2(h2) {
        var c2, d2 = 0;
        if (Array.isArray(h2[0]))
          for (c2 = 0; c2 < h2.length; c2++)
            d2 += o2(h2[c2]);
        else
          for (c2 = 0; c2 < h2.length; c2++)
            d2 += 1;
        return d2;
      }(this.labels);
      return i = e2[2] - e2[0], a2 = e2[3] - e2[1], s2 = i * a2, r = Math.pow(s2, 0.5), Math.min(r / n2, parseInt(t2.config.dataLabels.style.fontSize, 10));
    } }, { key: "rotateToFitLabel", value: function(e2, t2, i, a2, s2, r, n2) {
      var o2 = new M2(this.ctx), h2 = o2.getTextRects(i, t2);
      if (h2.width + this.w.config.stroke.width + 5 > r - a2 && h2.width <= n2 - s2) {
        var c2 = o2.rotateAroundCenter(e2.node);
        e2.node.setAttribute("transform", "rotate(-90 ".concat(c2.x, " ").concat(c2.y, ") translate(").concat(h2.height / 3, ")"));
      }
    } }, { key: "truncateLabels", value: function(e2, t2, i, a2, s2, r) {
      var n2 = new M2(this.ctx), o2 = n2.getTextRects(e2, t2).width + this.w.config.stroke.width + 5 > s2 - i && r - a2 > s2 - i ? r - a2 : s2 - i, h2 = n2.getTextBasedOnMaxWidth({ text: e2, maxWidth: o2, fontSize: t2 });
      return e2.length !== h2.length && o2 / t2 < 5 ? "" : h2;
    } }, { key: "animateTreemap", value: function(e2, t2, i, a2) {
      var s2 = new de2(this.ctx);
      s2.animateRect(e2, { x: t2.x, y: t2.y, width: t2.width, height: t2.height }, { x: i.x, y: i.y, width: i.width, height: i.height }, a2, function() {
        s2.animationCompleted(e2);
      });
    } }]), y2;
  }(), Wt2 = 86400, Bt2 = function() {
    function y2(e2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w, this.timeScaleArray = [], this.utc = this.w.config.xaxis.labels.datetimeUTC;
    }
    return Y2(y2, [{ key: "calculateTimeScaleTicks", value: function(e2, t2) {
      var i = this, a2 = this.w;
      if (a2.globals.allSeriesCollapsed)
        return a2.globals.labels = [], a2.globals.timescaleLabels = [], [];
      var s2 = new B3(this.ctx), r = (t2 - e2) / 864e5;
      this.determineInterval(r), a2.globals.disableZoomIn = false, a2.globals.disableZoomOut = false, r < 11574074074074075e-20 ? a2.globals.disableZoomIn = true : r > 5e4 && (a2.globals.disableZoomOut = true);
      var n2 = s2.getTimeUnitsfromTimestamp(e2, t2, this.utc), o2 = a2.globals.gridWidth / r, h2 = o2 / 24, c2 = h2 / 60, d2 = c2 / 60, g2 = Math.floor(24 * r), p2 = Math.floor(1440 * r), f2 = Math.floor(r * Wt2), b2 = Math.floor(r), m2 = Math.floor(r / 30), w2 = Math.floor(r / 365), A2 = { minMillisecond: n2.minMillisecond, minSecond: n2.minSecond, minMinute: n2.minMinute, minHour: n2.minHour, minDate: n2.minDate, minMonth: n2.minMonth, minYear: n2.minYear }, l2 = { firstVal: A2, currentMillisecond: A2.minMillisecond, currentSecond: A2.minSecond, currentMinute: A2.minMinute, currentHour: A2.minHour, currentMonthDate: A2.minDate, currentDate: A2.minDate, currentMonth: A2.minMonth, currentYear: A2.minYear, daysWidthOnXAxis: o2, hoursWidthOnXAxis: h2, minutesWidthOnXAxis: c2, secondsWidthOnXAxis: d2, numberOfSeconds: f2, numberOfMinutes: p2, numberOfHours: g2, numberOfDays: b2, numberOfMonths: m2, numberOfYears: w2 };
      switch (this.tickInterval) {
        case "years":
          this.generateYearScale(l2);
          break;
        case "months":
        case "half_year":
          this.generateMonthScale(l2);
          break;
        case "months_days":
        case "months_fortnight":
        case "days":
        case "week_days":
          this.generateDayScale(l2);
          break;
        case "hours":
          this.generateHourScale(l2);
          break;
        case "minutes_fives":
        case "minutes":
          this.generateMinuteScale(l2);
          break;
        case "seconds_tens":
        case "seconds_fives":
        case "seconds":
          this.generateSecondScale(l2);
      }
      var u2 = this.timeScaleArray.map(function(x2) {
        var v2 = { position: x2.position, unit: x2.unit, year: x2.year, day: x2.day ? x2.day : 1, hour: x2.hour ? x2.hour : 0, month: x2.month + 1 };
        return x2.unit === "month" ? X2(X2({}, v2), {}, { day: 1, value: x2.value + 1 }) : x2.unit === "day" || x2.unit === "hour" ? X2(X2({}, v2), {}, { value: x2.value }) : x2.unit === "minute" ? X2(X2({}, v2), {}, { value: x2.value, minute: x2.value }) : x2.unit === "second" ? X2(X2({}, v2), {}, { value: x2.value, minute: x2.minute, second: x2.second }) : x2;
      });
      return u2.filter(function(x2) {
        var v2 = 1, k2 = Math.ceil(a2.globals.gridWidth / 120), S2 = x2.value;
        a2.config.xaxis.tickAmount !== void 0 && (k2 = a2.config.xaxis.tickAmount), u2.length > k2 && (v2 = Math.floor(u2.length / k2));
        var C2 = false, L2 = false;
        switch (i.tickInterval) {
          case "years":
            x2.unit === "year" && (C2 = true);
            break;
          case "half_year":
            v2 = 7, x2.unit === "year" && (C2 = true);
            break;
          case "months":
            v2 = 1, x2.unit === "year" && (C2 = true);
            break;
          case "months_fortnight":
            v2 = 15, x2.unit !== "year" && x2.unit !== "month" || (C2 = true), S2 === 30 && (L2 = true);
            break;
          case "months_days":
            v2 = 10, x2.unit === "month" && (C2 = true), S2 === 30 && (L2 = true);
            break;
          case "week_days":
            v2 = 8, x2.unit === "month" && (C2 = true);
            break;
          case "days":
            v2 = 1, x2.unit === "month" && (C2 = true);
            break;
          case "hours":
            x2.unit === "day" && (C2 = true);
            break;
          case "minutes_fives":
          case "seconds_fives":
            S2 % 5 != 0 && (L2 = true);
            break;
          case "seconds_tens":
            S2 % 10 != 0 && (L2 = true);
        }
        if (i.tickInterval === "hours" || i.tickInterval === "minutes_fives" || i.tickInterval === "seconds_tens" || i.tickInterval === "seconds_fives") {
          if (!L2)
            return true;
        } else if ((S2 % v2 == 0 || C2) && !L2)
          return true;
      });
    } }, { key: "recalcDimensionsBasedOnFormat", value: function(e2, t2) {
      var i = this.w, a2 = this.formatDates(e2), s2 = this.removeOverlappingTS(a2);
      i.globals.timescaleLabels = s2.slice(), new Ye(this.ctx).plotCoords();
    } }, { key: "determineInterval", value: function(e2) {
      var t2 = 24 * e2, i = 60 * t2;
      switch (true) {
        case e2 / 365 > 5:
          this.tickInterval = "years";
          break;
        case e2 > 800:
          this.tickInterval = "half_year";
          break;
        case e2 > 180:
          this.tickInterval = "months";
          break;
        case e2 > 90:
          this.tickInterval = "months_fortnight";
          break;
        case e2 > 60:
          this.tickInterval = "months_days";
          break;
        case e2 > 30:
          this.tickInterval = "week_days";
          break;
        case e2 > 2:
          this.tickInterval = "days";
          break;
        case t2 > 2.4:
          this.tickInterval = "hours";
          break;
        case i > 15:
          this.tickInterval = "minutes_fives";
          break;
        case i > 5:
          this.tickInterval = "minutes";
          break;
        case i > 1:
          this.tickInterval = "seconds_tens";
          break;
        case 60 * i > 20:
          this.tickInterval = "seconds_fives";
          break;
        default:
          this.tickInterval = "seconds";
      }
    } }, { key: "generateYearScale", value: function(e2) {
      var t2 = e2.firstVal, i = e2.currentMonth, a2 = e2.currentYear, s2 = e2.daysWidthOnXAxis, r = e2.numberOfYears, n2 = t2.minYear, o2 = 0, h2 = new B3(this.ctx), c2 = "year";
      if (t2.minDate > 1 || t2.minMonth > 0) {
        var d2 = h2.determineRemainingDaysOfYear(t2.minYear, t2.minMonth, t2.minDate);
        o2 = (h2.determineDaysOfYear(t2.minYear) - d2 + 1) * s2, n2 = t2.minYear + 1, this.timeScaleArray.push({ position: o2, value: n2, unit: c2, year: n2, month: P2.monthMod(i + 1) });
      } else
        t2.minDate === 1 && t2.minMonth === 0 && this.timeScaleArray.push({ position: o2, value: n2, unit: c2, year: a2, month: P2.monthMod(i + 1) });
      for (var g2 = n2, p2 = o2, f2 = 0; f2 < r; f2++)
        g2++, p2 = h2.determineDaysOfYear(g2 - 1) * s2 + p2, this.timeScaleArray.push({ position: p2, value: g2, unit: c2, year: g2, month: 1 });
    } }, { key: "generateMonthScale", value: function(e2) {
      var t2 = e2.firstVal, i = e2.currentMonthDate, a2 = e2.currentMonth, s2 = e2.currentYear, r = e2.daysWidthOnXAxis, n2 = e2.numberOfMonths, o2 = a2, h2 = 0, c2 = new B3(this.ctx), d2 = "month", g2 = 0;
      if (t2.minDate > 1) {
        h2 = (c2.determineDaysOfMonths(a2 + 1, t2.minYear) - i + 1) * r, o2 = P2.monthMod(a2 + 1);
        var p2 = s2 + g2, f2 = P2.monthMod(o2), b2 = o2;
        o2 === 0 && (d2 = "year", b2 = p2, f2 = 1, p2 += g2 += 1), this.timeScaleArray.push({ position: h2, value: b2, unit: d2, year: p2, month: f2 });
      } else
        this.timeScaleArray.push({ position: h2, value: o2, unit: d2, year: s2, month: P2.monthMod(a2) });
      for (var m2 = o2 + 1, w2 = h2, A2 = 0, l2 = 1; A2 < n2; A2++, l2++) {
        (m2 = P2.monthMod(m2)) === 0 ? (d2 = "year", g2 += 1) : d2 = "month";
        var u2 = this._getYear(s2, m2, g2);
        w2 = c2.determineDaysOfMonths(m2, u2) * r + w2;
        var x2 = m2 === 0 ? u2 : m2;
        this.timeScaleArray.push({ position: w2, value: x2, unit: d2, year: u2, month: m2 === 0 ? 1 : m2 }), m2++;
      }
    } }, { key: "generateDayScale", value: function(e2) {
      var t2 = e2.firstVal, i = e2.currentMonth, a2 = e2.currentYear, s2 = e2.hoursWidthOnXAxis, r = e2.numberOfDays, n2 = new B3(this.ctx), o2 = "day", h2 = t2.minDate + 1, c2 = h2, d2 = function(l2, u2, x2) {
        return l2 > n2.determineDaysOfMonths(u2 + 1, x2) && (c2 = 1, o2 = "month", p2 = u2 += 1), u2;
      }, g2 = (24 - t2.minHour) * s2, p2 = h2, f2 = d2(c2, i, a2);
      t2.minHour === 0 && t2.minDate === 1 ? (g2 = 0, p2 = P2.monthMod(t2.minMonth), o2 = "month", c2 = t2.minDate) : t2.minDate !== 1 && t2.minHour === 0 && t2.minMinute === 0 && (g2 = 0, h2 = t2.minDate, p2 = h2, f2 = d2(c2 = h2, i, a2)), this.timeScaleArray.push({ position: g2, value: p2, unit: o2, year: this._getYear(a2, f2, 0), month: P2.monthMod(f2), day: c2 });
      for (var b2 = g2, m2 = 0; m2 < r; m2++) {
        o2 = "day", f2 = d2(c2 += 1, f2, this._getYear(a2, f2, 0));
        var w2 = this._getYear(a2, f2, 0);
        b2 = 24 * s2 + b2;
        var A2 = c2 === 1 ? P2.monthMod(f2) : c2;
        this.timeScaleArray.push({ position: b2, value: A2, unit: o2, year: w2, month: P2.monthMod(f2), day: A2 });
      }
    } }, { key: "generateHourScale", value: function(e2) {
      var t2 = e2.firstVal, i = e2.currentDate, a2 = e2.currentMonth, s2 = e2.currentYear, r = e2.minutesWidthOnXAxis, n2 = e2.numberOfHours, o2 = new B3(this.ctx), h2 = "hour", c2 = function(v2, k2) {
        return v2 > o2.determineDaysOfMonths(k2 + 1, s2) && (m2 = 1, k2 += 1), { month: k2, date: m2 };
      }, d2 = function(v2, k2) {
        return v2 > o2.determineDaysOfMonths(k2 + 1, s2) ? k2 += 1 : k2;
      }, g2 = 60 - (t2.minMinute + t2.minSecond / 60), p2 = g2 * r, f2 = t2.minHour + 1, b2 = f2;
      g2 === 60 && (p2 = 0, b2 = f2 = t2.minHour);
      var m2 = i;
      b2 >= 24 && (b2 = 0, m2 += 1, h2 = "day");
      var w2 = c2(m2, a2).month;
      w2 = d2(m2, w2), this.timeScaleArray.push({ position: p2, value: f2, unit: h2, day: m2, hour: b2, year: s2, month: P2.monthMod(w2) }), b2++;
      for (var A2 = p2, l2 = 0; l2 < n2; l2++) {
        h2 = "hour", b2 >= 24 && (b2 = 0, h2 = "day", w2 = c2(m2 += 1, w2).month, w2 = d2(m2, w2));
        var u2 = this._getYear(s2, w2, 0);
        A2 = 60 * r + A2;
        var x2 = b2 === 0 ? m2 : b2;
        this.timeScaleArray.push({ position: A2, value: x2, unit: h2, hour: b2, day: m2, year: u2, month: P2.monthMod(w2) }), b2++;
      }
    } }, { key: "generateMinuteScale", value: function(e2) {
      for (var t2 = e2.currentMillisecond, i = e2.currentSecond, a2 = e2.currentMinute, s2 = e2.currentHour, r = e2.currentDate, n2 = e2.currentMonth, o2 = e2.currentYear, h2 = e2.minutesWidthOnXAxis, c2 = e2.secondsWidthOnXAxis, d2 = e2.numberOfMinutes, g2 = a2 + 1, p2 = r, f2 = n2, b2 = o2, m2 = s2, w2 = (60 - i - t2 / 1e3) * c2, A2 = 0; A2 < d2; A2++)
        g2 >= 60 && (g2 = 0, (m2 += 1) === 24 && (m2 = 0)), this.timeScaleArray.push({ position: w2, value: g2, unit: "minute", hour: m2, minute: g2, day: p2, year: this._getYear(b2, f2, 0), month: P2.monthMod(f2) }), w2 += h2, g2++;
    } }, { key: "generateSecondScale", value: function(e2) {
      for (var t2 = e2.currentMillisecond, i = e2.currentSecond, a2 = e2.currentMinute, s2 = e2.currentHour, r = e2.currentDate, n2 = e2.currentMonth, o2 = e2.currentYear, h2 = e2.secondsWidthOnXAxis, c2 = e2.numberOfSeconds, d2 = i + 1, g2 = a2, p2 = r, f2 = n2, b2 = o2, m2 = s2, w2 = (1e3 - t2) / 1e3 * h2, A2 = 0; A2 < c2; A2++)
        d2 >= 60 && (d2 = 0, ++g2 >= 60 && (g2 = 0, ++m2 === 24 && (m2 = 0))), this.timeScaleArray.push({ position: w2, value: d2, unit: "second", hour: m2, minute: g2, second: d2, day: p2, year: this._getYear(b2, f2, 0), month: P2.monthMod(f2) }), w2 += h2, d2++;
    } }, { key: "createRawDateString", value: function(e2, t2) {
      var i = e2.year;
      return e2.month === 0 && (e2.month = 1), i += "-" + ("0" + e2.month.toString()).slice(-2), e2.unit === "day" ? i += e2.unit === "day" ? "-" + ("0" + t2).slice(-2) : "-01" : i += "-" + ("0" + (e2.day ? e2.day : "1")).slice(-2), e2.unit === "hour" ? i += e2.unit === "hour" ? "T" + ("0" + t2).slice(-2) : "T00" : i += "T" + ("0" + (e2.hour ? e2.hour : "0")).slice(-2), e2.unit === "minute" ? i += ":" + ("0" + t2).slice(-2) : i += ":" + (e2.minute ? ("0" + e2.minute).slice(-2) : "00"), e2.unit === "second" ? i += ":" + ("0" + t2).slice(-2) : i += ":00", this.utc && (i += ".000Z"), i;
    } }, { key: "formatDates", value: function(e2) {
      var t2 = this, i = this.w;
      return e2.map(function(a2) {
        var s2 = a2.value.toString(), r = new B3(t2.ctx), n2 = t2.createRawDateString(a2, s2), o2 = r.getDate(r.parseDate(n2));
        if (t2.utc || (o2 = r.getDate(r.parseDateWithTimezone(n2))), i.config.xaxis.labels.format === void 0) {
          var h2 = "dd MMM", c2 = i.config.xaxis.labels.datetimeFormatter;
          a2.unit === "year" && (h2 = c2.year), a2.unit === "month" && (h2 = c2.month), a2.unit === "day" && (h2 = c2.day), a2.unit === "hour" && (h2 = c2.hour), a2.unit === "minute" && (h2 = c2.minute), a2.unit === "second" && (h2 = c2.second), s2 = r.formatDate(o2, h2);
        } else
          s2 = r.formatDate(o2, i.config.xaxis.labels.format);
        return { dateString: n2, position: a2.position, value: s2, unit: a2.unit, year: a2.year, month: a2.month };
      });
    } }, { key: "removeOverlappingTS", value: function(e2) {
      var t2, i = this, a2 = new M2(this.ctx), s2 = false;
      e2.length > 0 && e2[0].value && e2.every(function(o2) {
        return o2.value.length === e2[0].value.length;
      }) && (s2 = true, t2 = a2.getTextRects(e2[0].value).width);
      var r = 0, n2 = e2.map(function(o2, h2) {
        if (h2 > 0 && i.w.config.xaxis.labels.hideOverlappingLabels) {
          var c2 = s2 ? t2 : a2.getTextRects(e2[r].value).width, d2 = e2[r].position;
          return o2.position > d2 + c2 + 10 ? (r = h2, o2) : null;
        }
        return o2;
      });
      return n2 = n2.filter(function(o2) {
        return o2 !== null;
      });
    } }, { key: "_getYear", value: function(e2, t2, i) {
      return e2 + Math.floor(t2 / 12) + i;
    } }]), y2;
  }(), Gt2 = function() {
    function y2(e2, t2) {
      F2(this, y2), this.ctx = t2, this.w = t2.w, this.el = e2;
    }
    return Y2(y2, [{ key: "setupElements", value: function() {
      var e2 = this.w.globals, t2 = this.w.config, i = t2.chart.type;
      e2.axisCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble", "radar", "heatmap", "treemap"].indexOf(i) > -1, e2.xyCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble"].indexOf(i) > -1, e2.isBarHorizontal = (t2.chart.type === "bar" || t2.chart.type === "rangeBar" || t2.chart.type === "boxPlot") && t2.plotOptions.bar.horizontal, e2.chartClass = ".apexcharts" + e2.chartID, e2.dom.baseEl = this.el, e2.dom.elWrap = document.createElement("div"), M2.setAttrs(e2.dom.elWrap, { id: e2.chartClass.substring(1), class: "apexcharts-canvas " + e2.chartClass.substring(1) }), this.el.appendChild(e2.dom.elWrap), e2.dom.Paper = new window.SVG.Doc(e2.dom.elWrap), e2.dom.Paper.attr({ class: "apexcharts-svg", "xmlns:data": "ApexChartsNS", transform: "translate(".concat(t2.chart.offsetX, ", ").concat(t2.chart.offsetY, ")") }), e2.dom.Paper.node.style.background = t2.theme.mode !== "dark" || t2.chart.background ? t2.chart.background : "rgba(0, 0, 0, 0.8)", this.setSVGDimensions(), e2.dom.elLegendForeign = document.createElementNS(e2.SVGNS, "foreignObject"), M2.setAttrs(e2.dom.elLegendForeign, { x: 0, y: 0, width: e2.svgWidth, height: e2.svgHeight }), e2.dom.elLegendWrap = document.createElement("div"), e2.dom.elLegendWrap.classList.add("apexcharts-legend"), e2.dom.elLegendWrap.setAttribute("xmlns", "http://www.w3.org/1999/xhtml"), e2.dom.elLegendForeign.appendChild(e2.dom.elLegendWrap), e2.dom.Paper.node.appendChild(e2.dom.elLegendForeign), e2.dom.elGraphical = e2.dom.Paper.group().attr({ class: "apexcharts-inner apexcharts-graphical" }), e2.dom.elDefs = e2.dom.Paper.defs(), e2.dom.Paper.add(e2.dom.elGraphical), e2.dom.elGraphical.add(e2.dom.elDefs);
    } }, { key: "plotChartType", value: function(e2, t2) {
      var i = this.w, a2 = i.config, s2 = i.globals, r = { series: [], i: [] }, n2 = { series: [], i: [] }, o2 = { series: [], i: [] }, h2 = { series: [], i: [] }, c2 = { series: [], i: [] }, d2 = { series: [], i: [] }, g2 = { series: [], i: [] }, p2 = { series: [], i: [] }, f2 = { series: [], seriesRangeEnd: [], i: [] };
      s2.series.map(function(k2, S2) {
        var C2 = 0;
        e2[S2].type !== void 0 ? (e2[S2].type === "column" || e2[S2].type === "bar" ? (s2.series.length > 1 && a2.plotOptions.bar.horizontal && console.warn("Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`"), c2.series.push(k2), c2.i.push(S2), C2++, i.globals.columnSeries = c2.series) : e2[S2].type === "area" ? (n2.series.push(k2), n2.i.push(S2), C2++) : e2[S2].type === "line" ? (r.series.push(k2), r.i.push(S2), C2++) : e2[S2].type === "scatter" ? (o2.series.push(k2), o2.i.push(S2)) : e2[S2].type === "bubble" ? (h2.series.push(k2), h2.i.push(S2), C2++) : e2[S2].type === "candlestick" ? (d2.series.push(k2), d2.i.push(S2), C2++) : e2[S2].type === "boxPlot" ? (g2.series.push(k2), g2.i.push(S2), C2++) : e2[S2].type === "rangeBar" ? (p2.series.push(k2), p2.i.push(S2), C2++) : e2[S2].type === "rangeArea" ? (f2.series.push(s2.seriesRangeStart[S2]), f2.seriesRangeEnd.push(s2.seriesRangeEnd[S2]), f2.i.push(S2), C2++) : console.warn("You have specified an unrecognized chart type. Available types for this property are line/area/column/bar/scatter/bubble/candlestick/boxPlot/rangeBar/rangeArea"), C2 > 1 && (s2.comboCharts = true)) : (r.series.push(k2), r.i.push(S2));
      });
      var b2 = new je(this.ctx, t2), m2 = new Be(this.ctx, t2);
      this.ctx.pie = new ot2(this.ctx);
      var w2 = new Rt2(this.ctx);
      this.ctx.rangeBar = new Ot2(this.ctx, t2);
      var A2 = new Ft2(this.ctx), l2 = [];
      if (s2.comboCharts) {
        if (n2.series.length > 0 && l2.push(b2.draw(n2.series, "area", n2.i)), c2.series.length > 0)
          if (i.config.chart.stacked) {
            var u2 = new st2(this.ctx, t2);
            l2.push(u2.draw(c2.series, c2.i));
          } else
            this.ctx.bar = new ke(this.ctx, t2), l2.push(this.ctx.bar.draw(c2.series, c2.i));
        if (f2.series.length > 0 && l2.push(b2.draw(f2.series, "rangeArea", f2.i, f2.seriesRangeEnd)), r.series.length > 0 && l2.push(b2.draw(r.series, "line", r.i)), d2.series.length > 0 && l2.push(m2.draw(d2.series, "candlestick", d2.i)), g2.series.length > 0 && l2.push(m2.draw(g2.series, "boxPlot", g2.i)), p2.series.length > 0 && l2.push(this.ctx.rangeBar.draw(p2.series, p2.i)), o2.series.length > 0) {
          var x2 = new je(this.ctx, t2, true);
          l2.push(x2.draw(o2.series, "scatter", o2.i));
        }
        if (h2.series.length > 0) {
          var v2 = new je(this.ctx, t2, true);
          l2.push(v2.draw(h2.series, "bubble", h2.i));
        }
      } else
        switch (a2.chart.type) {
          case "line":
            l2 = b2.draw(s2.series, "line");
            break;
          case "area":
            l2 = b2.draw(s2.series, "area");
            break;
          case "bar":
            a2.chart.stacked ? l2 = new st2(this.ctx, t2).draw(s2.series) : (this.ctx.bar = new ke(this.ctx, t2), l2 = this.ctx.bar.draw(s2.series));
            break;
          case "candlestick":
            l2 = new Be(this.ctx, t2).draw(s2.series, "candlestick");
            break;
          case "boxPlot":
            l2 = new Be(this.ctx, t2).draw(s2.series, a2.chart.type);
            break;
          case "rangeBar":
            l2 = this.ctx.rangeBar.draw(s2.series);
            break;
          case "rangeArea":
            l2 = b2.draw(s2.seriesRangeStart, "rangeArea", void 0, s2.seriesRangeEnd);
            break;
          case "heatmap":
            l2 = new Yt2(this.ctx, t2).draw(s2.series);
            break;
          case "treemap":
            l2 = new Nt2(this.ctx, t2).draw(s2.series);
            break;
          case "pie":
          case "donut":
          case "polarArea":
            l2 = this.ctx.pie.draw(s2.series);
            break;
          case "radialBar":
            l2 = w2.draw(s2.series);
            break;
          case "radar":
            l2 = A2.draw(s2.series);
            break;
          default:
            l2 = b2.draw(s2.series);
        }
      return l2;
    } }, { key: "setSVGDimensions", value: function() {
      var e2 = this.w.globals, t2 = this.w.config;
      e2.svgWidth = t2.chart.width, e2.svgHeight = t2.chart.height;
      var i = P2.getDimensions(this.el), a2 = t2.chart.width.toString().split(/[0-9]+/g).pop();
      a2 === "%" ? P2.isNumber(i[0]) && (i[0].width === 0 && (i = P2.getDimensions(this.el.parentNode)), e2.svgWidth = i[0] * parseInt(t2.chart.width, 10) / 100) : a2 !== "px" && a2 !== "" || (e2.svgWidth = parseInt(t2.chart.width, 10));
      var s2 = t2.chart.height.toString().split(/[0-9]+/g).pop();
      if (e2.svgHeight !== "auto" && e2.svgHeight !== "")
        if (s2 === "%") {
          var r = P2.getDimensions(this.el.parentNode);
          e2.svgHeight = r[1] * parseInt(t2.chart.height, 10) / 100;
        } else
          e2.svgHeight = parseInt(t2.chart.height, 10);
      else
        e2.axisCharts ? e2.svgHeight = e2.svgWidth / 1.61 : e2.svgHeight = e2.svgWidth / 1.2;
      if (e2.svgWidth < 0 && (e2.svgWidth = 0), e2.svgHeight < 0 && (e2.svgHeight = 0), M2.setAttrs(e2.dom.Paper.node, { width: e2.svgWidth, height: e2.svgHeight }), s2 !== "%") {
        var n2 = t2.chart.sparkline.enabled ? 0 : e2.axisCharts ? t2.chart.parentHeightOffset : 0;
        e2.dom.Paper.node.parentNode.parentNode.style.minHeight = e2.svgHeight + n2 + "px";
      }
      e2.dom.elWrap.style.width = e2.svgWidth + "px", e2.dom.elWrap.style.height = e2.svgHeight + "px";
    } }, { key: "shiftGraphPosition", value: function() {
      var e2 = this.w.globals, t2 = e2.translateY, i = { transform: "translate(" + e2.translateX + ", " + t2 + ")" };
      M2.setAttrs(e2.dom.elGraphical.node, i);
    } }, { key: "resizeNonAxisCharts", value: function() {
      var e2 = this.w, t2 = e2.globals, i = 0, a2 = e2.config.chart.sparkline.enabled ? 1 : 15;
      a2 += e2.config.grid.padding.bottom, e2.config.legend.position !== "top" && e2.config.legend.position !== "bottom" || !e2.config.legend.show || e2.config.legend.floating || (i = new Ke(this.ctx).legendHelpers.getLegendBBox().clwh + 10);
      var s2 = e2.globals.dom.baseEl.querySelector(".apexcharts-radialbar, .apexcharts-pie"), r = 2.05 * e2.globals.radialSize;
      if (s2 && !e2.config.chart.sparkline.enabled && e2.config.plotOptions.radialBar.startAngle !== 0) {
        var n2 = P2.getBoundingClientRect(s2);
        r = n2.bottom;
        var o2 = n2.bottom - n2.top;
        r = Math.max(2.05 * e2.globals.radialSize, o2);
      }
      var h2 = r + t2.translateY + i + a2;
      t2.dom.elLegendForeign && t2.dom.elLegendForeign.setAttribute("height", h2), e2.config.chart.height && String(e2.config.chart.height).indexOf("%") > 0 || (t2.dom.elWrap.style.height = h2 + "px", M2.setAttrs(t2.dom.Paper.node, { height: h2 }), t2.dom.Paper.node.parentNode.parentNode.style.minHeight = h2 + "px");
    } }, { key: "coreCalculations", value: function() {
      new De(this.ctx).init();
    } }, { key: "resetGlobals", value: function() {
      var e2 = this, t2 = function() {
        return e2.w.config.series.map(function(s2) {
          return [];
        });
      }, i = new Ze(), a2 = this.w.globals;
      i.initGlobalVars(a2), a2.seriesXvalues = t2(), a2.seriesYvalues = t2();
    } }, { key: "isMultipleY", value: function() {
      if (this.w.config.yaxis.constructor === Array && this.w.config.yaxis.length > 1)
        return this.w.globals.isMultipleYAxis = true, true;
    } }, { key: "xySettings", value: function() {
      var e2 = null, t2 = this.w;
      if (t2.globals.axisCharts) {
        if (t2.config.xaxis.crosshairs.position === "back" && new We(this.ctx).drawXCrosshairs(), t2.config.yaxis[0].crosshairs.position === "back" && new We(this.ctx).drawYCrosshairs(), t2.config.xaxis.type === "datetime" && t2.config.xaxis.labels.formatter === void 0) {
          this.ctx.timeScale = new Bt2(this.ctx);
          var i = [];
          isFinite(t2.globals.minX) && isFinite(t2.globals.maxX) && !t2.globals.isBarHorizontal ? i = this.ctx.timeScale.calculateTimeScaleTicks(t2.globals.minX, t2.globals.maxX) : t2.globals.isBarHorizontal && (i = this.ctx.timeScale.calculateTimeScaleTicks(t2.globals.minY, t2.globals.maxY)), this.ctx.timeScale.recalcDimensionsBasedOnFormat(i);
        }
        e2 = new q2(this.ctx).getCalculatedRatios();
      }
      return e2;
    } }, { key: "updateSourceChart", value: function(e2) {
      this.ctx.w.globals.selection = void 0, this.ctx.updateHelpers._updateOptions({ chart: { selection: { xaxis: { min: e2.w.globals.minX, max: e2.w.globals.maxX } } } }, false, false);
    } }, { key: "setupBrushHandler", value: function() {
      var e2 = this, t2 = this.w;
      if (t2.config.chart.brush.enabled && typeof t2.config.chart.events.selection != "function") {
        var i = Array.isArray(t2.config.chart.brush.targets) ? t2.config.chart.brush.targets : [t2.config.chart.brush.target];
        i.forEach(function(a2) {
          var s2 = ApexCharts.getChartByID(a2);
          s2.w.globals.brushSource = e2.ctx, typeof s2.w.config.chart.events.zoomed != "function" && (s2.w.config.chart.events.zoomed = function() {
            e2.updateSourceChart(s2);
          }), typeof s2.w.config.chart.events.scrolled != "function" && (s2.w.config.chart.events.scrolled = function() {
            e2.updateSourceChart(s2);
          });
        }), t2.config.chart.events.selection = function(a2, s2) {
          i.forEach(function(r) {
            var n2 = ApexCharts.getChartByID(r), o2 = P2.clone(t2.config.yaxis);
            if (t2.config.chart.brush.autoScaleYaxis && n2.w.globals.series.length === 1) {
              var h2 = new we2(n2);
              o2 = h2.autoScaleY(n2, o2, s2);
            }
            var c2 = n2.w.config.yaxis.reduce(function(d2, g2, p2) {
              return [].concat(J2(d2), [X2(X2({}, n2.w.config.yaxis[p2]), {}, { min: o2[0].min, max: o2[0].max })]);
            }, []);
            n2.ctx.updateHelpers._updateOptions({ xaxis: { min: s2.xaxis.min, max: s2.xaxis.max }, yaxis: c2 }, false, false, false, false);
          });
        };
      }
    } }]), y2;
  }(), Vt2 = function() {
    function y2(e2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w;
    }
    return Y2(y2, [{ key: "_updateOptions", value: function(e2) {
      var t2 = this, i = arguments.length > 1 && arguments[1] !== void 0 && arguments[1], a2 = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2], s2 = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3], r = arguments.length > 4 && arguments[4] !== void 0 && arguments[4];
      return new Promise(function(n2) {
        var o2 = [t2.ctx];
        s2 && (o2 = t2.ctx.getSyncedCharts()), t2.ctx.w.globals.isExecCalled && (o2 = [t2.ctx], t2.ctx.w.globals.isExecCalled = false), o2.forEach(function(h2, c2) {
          var d2 = h2.w;
          if (d2.globals.shouldAnimate = a2, i || (d2.globals.resized = true, d2.globals.dataChanged = true, a2 && h2.series.getPreviousPaths()), e2 && U2(e2) === "object" && (h2.config = new Le2(e2), e2 = q2.extendArrayProps(h2.config, e2, d2), h2.w.globals.chartID !== t2.ctx.w.globals.chartID && delete e2.series, d2.config = P2.extend(d2.config, e2), r && (d2.globals.lastXAxis = e2.xaxis ? P2.clone(e2.xaxis) : [], d2.globals.lastYAxis = e2.yaxis ? P2.clone(e2.yaxis) : [], d2.globals.initialConfig = P2.extend({}, d2.config), d2.globals.initialSeries = P2.clone(d2.config.series), e2.series))) {
            for (var g2 = 0; g2 < d2.globals.collapsedSeriesIndices.length; g2++) {
              var p2 = d2.config.series[d2.globals.collapsedSeriesIndices[g2]];
              d2.globals.collapsedSeries[g2].data = d2.globals.axisCharts ? p2.data.slice() : p2;
            }
            for (var f2 = 0; f2 < d2.globals.ancillaryCollapsedSeriesIndices.length; f2++) {
              var b2 = d2.config.series[d2.globals.ancillaryCollapsedSeriesIndices[f2]];
              d2.globals.ancillaryCollapsedSeries[f2].data = d2.globals.axisCharts ? b2.data.slice() : b2;
            }
            h2.series.emptyCollapsedSeries(d2.config.series);
          }
          return h2.update(e2).then(function() {
            c2 === o2.length - 1 && n2(h2);
          });
        });
      });
    } }, { key: "_updateSeries", value: function(e2, t2) {
      var i = this, a2 = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
      return new Promise(function(s2) {
        var r, n2 = i.w;
        return n2.globals.shouldAnimate = t2, n2.globals.dataChanged = true, t2 && i.ctx.series.getPreviousPaths(), n2.globals.axisCharts ? ((r = e2.map(function(o2, h2) {
          return i._extendSeries(o2, h2);
        })).length === 0 && (r = [{ data: [] }]), n2.config.series = r) : n2.config.series = e2.slice(), a2 && (n2.globals.initialConfig.series = P2.clone(n2.config.series), n2.globals.initialSeries = P2.clone(n2.config.series)), i.ctx.update().then(function() {
          s2(i.ctx);
        });
      });
    } }, { key: "_extendSeries", value: function(e2, t2) {
      var i = this.w, a2 = i.config.series[t2];
      return X2(X2({}, i.config.series[t2]), {}, { name: e2.name ? e2.name : a2 == null ? void 0 : a2.name, color: e2.color ? e2.color : a2 == null ? void 0 : a2.color, type: e2.type ? e2.type : a2 == null ? void 0 : a2.type, group: e2.group ? e2.group : a2 == null ? void 0 : a2.group, data: e2.data ? e2.data : a2 == null ? void 0 : a2.data, zIndex: e2.zIndex !== void 0 ? e2.zIndex : t2 });
    } }, { key: "toggleDataPointSelection", value: function(e2, t2) {
      var i = this.w, a2 = null, s2 = ".apexcharts-series[data\\:realIndex='".concat(e2, "']");
      return i.globals.axisCharts ? a2 = i.globals.dom.Paper.select("".concat(s2, " path[j='").concat(t2, "'], ").concat(s2, " circle[j='").concat(t2, "'], ").concat(s2, " rect[j='").concat(t2, "']")).members[0] : t2 === void 0 && (a2 = i.globals.dom.Paper.select("".concat(s2, " path[j='").concat(e2, "']")).members[0], i.config.chart.type !== "pie" && i.config.chart.type !== "polarArea" && i.config.chart.type !== "donut" || this.ctx.pie.pieClicked(e2)), a2 ? (new M2(this.ctx).pathMouseDown(a2, null), a2.node ? a2.node : null) : (console.warn("toggleDataPointSelection: Element not found"), null);
    } }, { key: "forceXAxisUpdate", value: function(e2) {
      var t2 = this.w;
      if (["min", "max"].forEach(function(a2) {
        e2.xaxis[a2] !== void 0 && (t2.config.xaxis[a2] = e2.xaxis[a2], t2.globals.lastXAxis[a2] = e2.xaxis[a2]);
      }), e2.xaxis.categories && e2.xaxis.categories.length && (t2.config.xaxis.categories = e2.xaxis.categories), t2.config.xaxis.convertedCatToNumeric) {
        var i = new oe2(e2);
        e2 = i.convertCatToNumericXaxis(e2, this.ctx);
      }
      return e2;
    } }, { key: "forceYAxisUpdate", value: function(e2) {
      return e2.chart && e2.chart.stacked && e2.chart.stackType === "100%" && (Array.isArray(e2.yaxis) ? e2.yaxis.forEach(function(t2, i) {
        e2.yaxis[i].min = 0, e2.yaxis[i].max = 100;
      }) : (e2.yaxis.min = 0, e2.yaxis.max = 100)), e2;
    } }, { key: "revertDefaultAxisMinMax", value: function(e2) {
      var t2 = this, i = this.w, a2 = i.globals.lastXAxis, s2 = i.globals.lastYAxis;
      e2 && e2.xaxis && (a2 = e2.xaxis), e2 && e2.yaxis && (s2 = e2.yaxis), i.config.xaxis.min = a2.min, i.config.xaxis.max = a2.max;
      var r = function(n2) {
        s2[n2] !== void 0 && (i.config.yaxis[n2].min = s2[n2].min, i.config.yaxis[n2].max = s2[n2].max);
      };
      i.config.yaxis.map(function(n2, o2) {
        i.globals.zoomed || s2[o2] !== void 0 ? r(o2) : t2.ctx.opts.yaxis[o2] !== void 0 && (n2.min = t2.ctx.opts.yaxis[o2].min, n2.max = t2.ctx.opts.yaxis[o2].max);
      });
    } }]), y2;
  }();
  be2 = typeof window < "u" ? window : void 0, Fe = function(y2, e2) {
    var t2 = (this !== void 0 ? this : y2).SVG = function(l2) {
      if (t2.supported)
        return l2 = new t2.Doc(l2), t2.parser.draw || t2.prepare(), l2;
    };
    if (t2.ns = "http://www.w3.org/2000/svg", t2.xmlns = "http://www.w3.org/2000/xmlns/", t2.xlink = "http://www.w3.org/1999/xlink", t2.svgjs = "http://svgjs.dev", t2.supported = true, !t2.supported)
      return false;
    t2.did = 1e3, t2.eid = function(l2) {
      return "Svgjs" + c2(l2) + t2.did++;
    }, t2.create = function(l2) {
      var u2 = e2.createElementNS(this.ns, l2);
      return u2.setAttribute("id", this.eid(l2)), u2;
    }, t2.extend = function() {
      var l2, u2;
      u2 = (l2 = [].slice.call(arguments)).pop();
      for (var x2 = l2.length - 1; x2 >= 0; x2--)
        if (l2[x2])
          for (var v2 in u2)
            l2[x2].prototype[v2] = u2[v2];
      t2.Set && t2.Set.inherit && t2.Set.inherit();
    }, t2.invent = function(l2) {
      var u2 = typeof l2.create == "function" ? l2.create : function() {
        this.constructor.call(this, t2.create(l2.create));
      };
      return l2.inherit && (u2.prototype = new l2.inherit()), l2.extend && t2.extend(u2, l2.extend), l2.construct && t2.extend(l2.parent || t2.Container, l2.construct), u2;
    }, t2.adopt = function(l2) {
      return l2 ? l2.instance ? l2.instance : ((u2 = l2.nodeName == "svg" ? l2.parentNode instanceof y2.SVGElement ? new t2.Nested() : new t2.Doc() : l2.nodeName == "linearGradient" ? new t2.Gradient("linear") : l2.nodeName == "radialGradient" ? new t2.Gradient("radial") : t2[c2(l2.nodeName)] ? new t2[c2(l2.nodeName)]() : new t2.Element(l2)).type = l2.nodeName, u2.node = l2, l2.instance = u2, u2 instanceof t2.Doc && u2.namespace().defs(), u2.setData(JSON.parse(l2.getAttribute("svgjs:data")) || {}), u2) : null;
      var u2;
    }, t2.prepare = function() {
      var l2 = e2.getElementsByTagName("body")[0], u2 = (l2 ? new t2.Doc(l2) : t2.adopt(e2.documentElement).nested()).size(2, 0);
      t2.parser = { body: l2 || e2.documentElement, draw: u2.style("opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden").node, poly: u2.polyline().node, path: u2.path().node, native: t2.create("svg") };
    }, t2.parser = { native: t2.create("svg") }, e2.addEventListener("DOMContentLoaded", function() {
      t2.parser.draw || t2.prepare();
    }, false), t2.regex = { numberAndUnit: /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i, hex: /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i, rgb: /rgb\((\d+),(\d+),(\d+)\)/, reference: /#([a-z0-9\-_]+)/i, transforms: /\)\s*,?\s*/, whitespace: /\s/g, isHex: /^#[a-f0-9]{3,6}$/i, isRgb: /^rgb\(/, isCss: /[^:]+:[^;]+;?/, isBlank: /^(\s+)?$/, isNumber: /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, isPercent: /^-?[\d\.]+%$/, isImage: /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i, delimiter: /[\s,]+/, hyphen: /([^e])\-/gi, pathLetters: /[MLHVCSQTAZ]/gi, isPathLetter: /[MLHVCSQTAZ]/i, numbersWithDots: /((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi, dots: /\./g }, t2.utils = { map: function(l2, u2) {
      for (var x2 = l2.length, v2 = [], k2 = 0; k2 < x2; k2++)
        v2.push(u2(l2[k2]));
      return v2;
    }, filter: function(l2, u2) {
      for (var x2 = l2.length, v2 = [], k2 = 0; k2 < x2; k2++)
        u2(l2[k2]) && v2.push(l2[k2]);
      return v2;
    }, filterSVGElements: function(l2) {
      return this.filter(l2, function(u2) {
        return u2 instanceof y2.SVGElement;
      });
    } }, t2.defaults = { attrs: { "fill-opacity": 1, "stroke-opacity": 1, "stroke-width": 0, "stroke-linejoin": "miter", "stroke-linecap": "butt", fill: "#000000", stroke: "#000000", opacity: 1, x: 0, y: 0, cx: 0, cy: 0, width: 0, height: 0, r: 0, rx: 0, ry: 0, offset: 0, "stop-opacity": 1, "stop-color": "#000000", "font-size": 16, "font-family": "Helvetica, Arial, sans-serif", "text-anchor": "start" } }, t2.Color = function(l2) {
      var u2, x2;
      this.r = 0, this.g = 0, this.b = 0, l2 && (typeof l2 == "string" ? t2.regex.isRgb.test(l2) ? (u2 = t2.regex.rgb.exec(l2.replace(t2.regex.whitespace, "")), this.r = parseInt(u2[1]), this.g = parseInt(u2[2]), this.b = parseInt(u2[3])) : t2.regex.isHex.test(l2) && (u2 = t2.regex.hex.exec((x2 = l2).length == 4 ? ["#", x2.substring(1, 2), x2.substring(1, 2), x2.substring(2, 3), x2.substring(2, 3), x2.substring(3, 4), x2.substring(3, 4)].join("") : x2), this.r = parseInt(u2[1], 16), this.g = parseInt(u2[2], 16), this.b = parseInt(u2[3], 16)) : U2(l2) === "object" && (this.r = l2.r, this.g = l2.g, this.b = l2.b));
    }, t2.extend(t2.Color, { toString: function() {
      return this.toHex();
    }, toHex: function() {
      return "#" + d2(this.r) + d2(this.g) + d2(this.b);
    }, toRgb: function() {
      return "rgb(" + [this.r, this.g, this.b].join() + ")";
    }, brightness: function() {
      return this.r / 255 * 0.3 + this.g / 255 * 0.59 + this.b / 255 * 0.11;
    }, morph: function(l2) {
      return this.destination = new t2.Color(l2), this;
    }, at: function(l2) {
      return this.destination ? (l2 = l2 < 0 ? 0 : l2 > 1 ? 1 : l2, new t2.Color({ r: ~~(this.r + (this.destination.r - this.r) * l2), g: ~~(this.g + (this.destination.g - this.g) * l2), b: ~~(this.b + (this.destination.b - this.b) * l2) })) : this;
    } }), t2.Color.test = function(l2) {
      return l2 += "", t2.regex.isHex.test(l2) || t2.regex.isRgb.test(l2);
    }, t2.Color.isRgb = function(l2) {
      return l2 && typeof l2.r == "number" && typeof l2.g == "number" && typeof l2.b == "number";
    }, t2.Color.isColor = function(l2) {
      return t2.Color.isRgb(l2) || t2.Color.test(l2);
    }, t2.Array = function(l2, u2) {
      (l2 = (l2 || []).valueOf()).length == 0 && u2 && (l2 = u2.valueOf()), this.value = this.parse(l2);
    }, t2.extend(t2.Array, { toString: function() {
      return this.value.join(" ");
    }, valueOf: function() {
      return this.value;
    }, parse: function(l2) {
      return l2 = l2.valueOf(), Array.isArray(l2) ? l2 : this.split(l2);
    } }), t2.PointArray = function(l2, u2) {
      t2.Array.call(this, l2, u2 || [[0, 0]]);
    }, t2.PointArray.prototype = new t2.Array(), t2.PointArray.prototype.constructor = t2.PointArray;
    for (var i = { M: function(l2, u2, x2) {
      return u2.x = x2.x = l2[0], u2.y = x2.y = l2[1], ["M", u2.x, u2.y];
    }, L: function(l2, u2) {
      return u2.x = l2[0], u2.y = l2[1], ["L", l2[0], l2[1]];
    }, H: function(l2, u2) {
      return u2.x = l2[0], ["H", l2[0]];
    }, V: function(l2, u2) {
      return u2.y = l2[0], ["V", l2[0]];
    }, C: function(l2, u2) {
      return u2.x = l2[4], u2.y = l2[5], ["C", l2[0], l2[1], l2[2], l2[3], l2[4], l2[5]];
    }, Q: function(l2, u2) {
      return u2.x = l2[2], u2.y = l2[3], ["Q", l2[0], l2[1], l2[2], l2[3]];
    }, S: function(l2, u2) {
      return u2.x = l2[2], u2.y = l2[3], ["S", l2[0], l2[1], l2[2], l2[3]];
    }, Z: function(l2, u2, x2) {
      return u2.x = x2.x, u2.y = x2.y, ["Z"];
    } }, a2 = "mlhvqtcsaz".split(""), s2 = 0, r = a2.length; s2 < r; ++s2)
      i[a2[s2]] = /* @__PURE__ */ function(l2) {
        return function(u2, x2, v2) {
          if (l2 == "H")
            u2[0] = u2[0] + x2.x;
          else if (l2 == "V")
            u2[0] = u2[0] + x2.y;
          else if (l2 == "A")
            u2[5] = u2[5] + x2.x, u2[6] = u2[6] + x2.y;
          else
            for (var k2 = 0, S2 = u2.length; k2 < S2; ++k2)
              u2[k2] = u2[k2] + (k2 % 2 ? x2.y : x2.x);
          if (i && typeof i[l2] == "function")
            return i[l2](u2, x2, v2);
        };
      }(a2[s2].toUpperCase());
    t2.PathArray = function(l2, u2) {
      t2.Array.call(this, l2, u2 || [["M", 0, 0]]);
    }, t2.PathArray.prototype = new t2.Array(), t2.PathArray.prototype.constructor = t2.PathArray, t2.extend(t2.PathArray, { toString: function() {
      return function(l2) {
        for (var u2 = 0, x2 = l2.length, v2 = ""; u2 < x2; u2++)
          v2 += l2[u2][0], l2[u2][1] != null && (v2 += l2[u2][1], l2[u2][2] != null && (v2 += " ", v2 += l2[u2][2], l2[u2][3] != null && (v2 += " ", v2 += l2[u2][3], v2 += " ", v2 += l2[u2][4], l2[u2][5] != null && (v2 += " ", v2 += l2[u2][5], v2 += " ", v2 += l2[u2][6], l2[u2][7] != null && (v2 += " ", v2 += l2[u2][7])))));
        return v2 + " ";
      }(this.value);
    }, move: function(l2, u2) {
      var x2 = this.bbox();
      return x2.x, x2.y, this;
    }, at: function(l2) {
      if (!this.destination)
        return this;
      for (var u2 = this.value, x2 = this.destination.value, v2 = [], k2 = new t2.PathArray(), S2 = 0, C2 = u2.length; S2 < C2; S2++) {
        v2[S2] = [u2[S2][0]];
        for (var L2 = 1, I2 = u2[S2].length; L2 < I2; L2++)
          v2[S2][L2] = u2[S2][L2] + (x2[S2][L2] - u2[S2][L2]) * l2;
        v2[S2][0] === "A" && (v2[S2][4] = +(v2[S2][4] != 0), v2[S2][5] = +(v2[S2][5] != 0));
      }
      return k2.value = v2, k2;
    }, parse: function(l2) {
      if (l2 instanceof t2.PathArray)
        return l2.valueOf();
      var u2, x2 = { M: 2, L: 2, H: 1, V: 1, C: 6, S: 4, Q: 4, T: 2, A: 7, Z: 0 };
      l2 = typeof l2 == "string" ? l2.replace(t2.regex.numbersWithDots, o2).replace(t2.regex.pathLetters, " $& ").replace(t2.regex.hyphen, "$1 -").trim().split(t2.regex.delimiter) : l2.reduce(function(I2, z2) {
        return [].concat.call(I2, z2);
      }, []);
      var v2 = [], k2 = new t2.Point(), S2 = new t2.Point(), C2 = 0, L2 = l2.length;
      do
        t2.regex.isPathLetter.test(l2[C2]) ? (u2 = l2[C2], ++C2) : u2 == "M" ? u2 = "L" : u2 == "m" && (u2 = "l"), v2.push(i[u2].call(null, l2.slice(C2, C2 += x2[u2.toUpperCase()]).map(parseFloat), k2, S2));
      while (L2 > C2);
      return v2;
    }, bbox: function() {
      return t2.parser.draw || t2.prepare(), t2.parser.path.setAttribute("d", this.toString()), t2.parser.path.getBBox();
    } }), t2.Number = t2.invent({ create: function(l2, u2) {
      this.value = 0, this.unit = u2 || "", typeof l2 == "number" ? this.value = isNaN(l2) ? 0 : isFinite(l2) ? l2 : l2 < 0 ? -34e37 : 34e37 : typeof l2 == "string" ? (u2 = l2.match(t2.regex.numberAndUnit)) && (this.value = parseFloat(u2[1]), u2[5] == "%" ? this.value /= 100 : u2[5] == "s" && (this.value *= 1e3), this.unit = u2[5]) : l2 instanceof t2.Number && (this.value = l2.valueOf(), this.unit = l2.unit);
    }, extend: { toString: function() {
      return (this.unit == "%" ? ~~(1e8 * this.value) / 1e6 : this.unit == "s" ? this.value / 1e3 : this.value) + this.unit;
    }, toJSON: function() {
      return this.toString();
    }, valueOf: function() {
      return this.value;
    }, plus: function(l2) {
      return l2 = new t2.Number(l2), new t2.Number(this + l2, this.unit || l2.unit);
    }, minus: function(l2) {
      return l2 = new t2.Number(l2), new t2.Number(this - l2, this.unit || l2.unit);
    }, times: function(l2) {
      return l2 = new t2.Number(l2), new t2.Number(this * l2, this.unit || l2.unit);
    }, divide: function(l2) {
      return l2 = new t2.Number(l2), new t2.Number(this / l2, this.unit || l2.unit);
    }, to: function(l2) {
      var u2 = new t2.Number(this);
      return typeof l2 == "string" && (u2.unit = l2), u2;
    }, morph: function(l2) {
      return this.destination = new t2.Number(l2), l2.relative && (this.destination.value += this.value), this;
    }, at: function(l2) {
      return this.destination ? new t2.Number(this.destination).minus(this).times(l2).plus(this) : this;
    } } }), t2.Element = t2.invent({ create: function(l2) {
      this._stroke = t2.defaults.attrs.stroke, this._event = null, this.dom = {}, (this.node = l2) && (this.type = l2.nodeName, this.node.instance = this, this._stroke = l2.getAttribute("stroke") || this._stroke);
    }, extend: { x: function(l2) {
      return this.attr("x", l2);
    }, y: function(l2) {
      return this.attr("y", l2);
    }, cx: function(l2) {
      return l2 == null ? this.x() + this.width() / 2 : this.x(l2 - this.width() / 2);
    }, cy: function(l2) {
      return l2 == null ? this.y() + this.height() / 2 : this.y(l2 - this.height() / 2);
    }, move: function(l2, u2) {
      return this.x(l2).y(u2);
    }, center: function(l2, u2) {
      return this.cx(l2).cy(u2);
    }, width: function(l2) {
      return this.attr("width", l2);
    }, height: function(l2) {
      return this.attr("height", l2);
    }, size: function(l2, u2) {
      var x2 = g2(this, l2, u2);
      return this.width(new t2.Number(x2.width)).height(new t2.Number(x2.height));
    }, clone: function(l2) {
      this.writeDataToDom();
      var u2 = b2(this.node.cloneNode(true));
      return l2 ? l2.add(u2) : this.after(u2), u2;
    }, remove: function() {
      return this.parent() && this.parent().removeElement(this), this;
    }, replace: function(l2) {
      return this.after(l2).remove(), l2;
    }, addTo: function(l2) {
      return l2.put(this);
    }, putIn: function(l2) {
      return l2.add(this);
    }, id: function(l2) {
      return this.attr("id", l2);
    }, show: function() {
      return this.style("display", "");
    }, hide: function() {
      return this.style("display", "none");
    }, visible: function() {
      return this.style("display") != "none";
    }, toString: function() {
      return this.attr("id");
    }, classes: function() {
      var l2 = this.attr("class");
      return l2 == null ? [] : l2.trim().split(t2.regex.delimiter);
    }, hasClass: function(l2) {
      return this.classes().indexOf(l2) != -1;
    }, addClass: function(l2) {
      if (!this.hasClass(l2)) {
        var u2 = this.classes();
        u2.push(l2), this.attr("class", u2.join(" "));
      }
      return this;
    }, removeClass: function(l2) {
      return this.hasClass(l2) && this.attr("class", this.classes().filter(function(u2) {
        return u2 != l2;
      }).join(" ")), this;
    }, toggleClass: function(l2) {
      return this.hasClass(l2) ? this.removeClass(l2) : this.addClass(l2);
    }, reference: function(l2) {
      return t2.get(this.attr(l2));
    }, parent: function(l2) {
      var u2 = this;
      if (!u2.node.parentNode)
        return null;
      if (u2 = t2.adopt(u2.node.parentNode), !l2)
        return u2;
      for (; u2 && u2.node instanceof y2.SVGElement; ) {
        if (typeof l2 == "string" ? u2.matches(l2) : u2 instanceof l2)
          return u2;
        if (!u2.node.parentNode || u2.node.parentNode.nodeName == "#document")
          return null;
        u2 = t2.adopt(u2.node.parentNode);
      }
    }, doc: function() {
      return this instanceof t2.Doc ? this : this.parent(t2.Doc);
    }, parents: function(l2) {
      var u2 = [], x2 = this;
      do {
        if (!(x2 = x2.parent(l2)) || !x2.node)
          break;
        u2.push(x2);
      } while (x2.parent);
      return u2;
    }, matches: function(l2) {
      return function(u2, x2) {
        return (u2.matches || u2.matchesSelector || u2.msMatchesSelector || u2.mozMatchesSelector || u2.webkitMatchesSelector || u2.oMatchesSelector).call(u2, x2);
      }(this.node, l2);
    }, native: function() {
      return this.node;
    }, svg: function(l2) {
      var u2 = e2.createElement("svg");
      if (!(l2 && this instanceof t2.Parent))
        return u2.appendChild(l2 = e2.createElement("svg")), this.writeDataToDom(), l2.appendChild(this.node.cloneNode(true)), u2.innerHTML.replace(/^<svg>/, "").replace(/<\/svg>$/, "");
      u2.innerHTML = "<svg>" + l2.replace(/\n/, "").replace(/<([\w:-]+)([^<]+?)\/>/g, "<$1$2></$1>") + "</svg>";
      for (var x2 = 0, v2 = u2.firstChild.childNodes.length; x2 < v2; x2++)
        this.node.appendChild(u2.firstChild.firstChild);
      return this;
    }, writeDataToDom: function() {
      return (this.each || this.lines) && (this.each ? this : this.lines()).each(function() {
        this.writeDataToDom();
      }), this.node.removeAttribute("svgjs:data"), Object.keys(this.dom).length && this.node.setAttribute("svgjs:data", JSON.stringify(this.dom)), this;
    }, setData: function(l2) {
      return this.dom = l2, this;
    }, is: function(l2) {
      return function(u2, x2) {
        return u2 instanceof x2;
      }(this, l2);
    } } }), t2.easing = { "-": function(l2) {
      return l2;
    }, "<>": function(l2) {
      return -Math.cos(l2 * Math.PI) / 2 + 0.5;
    }, ">": function(l2) {
      return Math.sin(l2 * Math.PI / 2);
    }, "<": function(l2) {
      return 1 - Math.cos(l2 * Math.PI / 2);
    } }, t2.morph = function(l2) {
      return function(u2, x2) {
        return new t2.MorphObj(u2, x2).at(l2);
      };
    }, t2.Situation = t2.invent({ create: function(l2) {
      this.init = false, this.reversed = false, this.reversing = false, this.duration = new t2.Number(l2.duration).valueOf(), this.delay = new t2.Number(l2.delay).valueOf(), this.start = +/* @__PURE__ */ new Date() + this.delay, this.finish = this.start + this.duration, this.ease = l2.ease, this.loop = 0, this.loops = false, this.animations = {}, this.attrs = {}, this.styles = {}, this.transforms = [], this.once = {};
    } }), t2.FX = t2.invent({ create: function(l2) {
      this._target = l2, this.situations = [], this.active = false, this.situation = null, this.paused = false, this.lastPos = 0, this.pos = 0, this.absPos = 0, this._speed = 1;
    }, extend: { animate: function(l2, u2, x2) {
      U2(l2) === "object" && (u2 = l2.ease, x2 = l2.delay, l2 = l2.duration);
      var v2 = new t2.Situation({ duration: l2 || 1e3, delay: x2 || 0, ease: t2.easing[u2 || "-"] || u2 });
      return this.queue(v2), this;
    }, target: function(l2) {
      return l2 && l2 instanceof t2.Element ? (this._target = l2, this) : this._target;
    }, timeToAbsPos: function(l2) {
      return (l2 - this.situation.start) / (this.situation.duration / this._speed);
    }, absPosToTime: function(l2) {
      return this.situation.duration / this._speed * l2 + this.situation.start;
    }, startAnimFrame: function() {
      this.stopAnimFrame(), this.animationFrame = y2.requestAnimationFrame((function() {
        this.step();
      }).bind(this));
    }, stopAnimFrame: function() {
      y2.cancelAnimationFrame(this.animationFrame);
    }, start: function() {
      return !this.active && this.situation && (this.active = true, this.startCurrent()), this;
    }, startCurrent: function() {
      return this.situation.start = +/* @__PURE__ */ new Date() + this.situation.delay / this._speed, this.situation.finish = this.situation.start + this.situation.duration / this._speed, this.initAnimations().step();
    }, queue: function(l2) {
      return (typeof l2 == "function" || l2 instanceof t2.Situation) && this.situations.push(l2), this.situation || (this.situation = this.situations.shift()), this;
    }, dequeue: function() {
      return this.stop(), this.situation = this.situations.shift(), this.situation && (this.situation instanceof t2.Situation ? this.start() : this.situation.call(this)), this;
    }, initAnimations: function() {
      var l2, u2 = this.situation;
      if (u2.init)
        return this;
      for (var x2 in u2.animations) {
        l2 = this.target()[x2](), Array.isArray(l2) || (l2 = [l2]), Array.isArray(u2.animations[x2]) || (u2.animations[x2] = [u2.animations[x2]]);
        for (var v2 = l2.length; v2--; )
          u2.animations[x2][v2] instanceof t2.Number && (l2[v2] = new t2.Number(l2[v2])), u2.animations[x2][v2] = l2[v2].morph(u2.animations[x2][v2]);
      }
      for (var x2 in u2.attrs)
        u2.attrs[x2] = new t2.MorphObj(this.target().attr(x2), u2.attrs[x2]);
      for (var x2 in u2.styles)
        u2.styles[x2] = new t2.MorphObj(this.target().style(x2), u2.styles[x2]);
      return u2.initialTransformation = this.target().matrixify(), u2.init = true, this;
    }, clearQueue: function() {
      return this.situations = [], this;
    }, clearCurrent: function() {
      return this.situation = null, this;
    }, stop: function(l2, u2) {
      var x2 = this.active;
      return this.active = false, u2 && this.clearQueue(), l2 && this.situation && (!x2 && this.startCurrent(), this.atEnd()), this.stopAnimFrame(), this.clearCurrent();
    }, after: function(l2) {
      var u2 = this.last();
      return this.target().on("finished.fx", function x2(v2) {
        v2.detail.situation == u2 && (l2.call(this, u2), this.off("finished.fx", x2));
      }), this._callStart();
    }, during: function(l2) {
      var u2 = this.last(), x2 = function(v2) {
        v2.detail.situation == u2 && l2.call(this, v2.detail.pos, t2.morph(v2.detail.pos), v2.detail.eased, u2);
      };
      return this.target().off("during.fx", x2).on("during.fx", x2), this.after(function() {
        this.off("during.fx", x2);
      }), this._callStart();
    }, afterAll: function(l2) {
      var u2 = function x2(v2) {
        l2.call(this), this.off("allfinished.fx", x2);
      };
      return this.target().off("allfinished.fx", u2).on("allfinished.fx", u2), this._callStart();
    }, last: function() {
      return this.situations.length ? this.situations[this.situations.length - 1] : this.situation;
    }, add: function(l2, u2, x2) {
      return this.last()[x2 || "animations"][l2] = u2, this._callStart();
    }, step: function(l2) {
      var u2, x2, v2;
      l2 || (this.absPos = this.timeToAbsPos(+/* @__PURE__ */ new Date())), this.situation.loops !== false ? (u2 = Math.max(this.absPos, 0), x2 = Math.floor(u2), this.situation.loops === true || x2 < this.situation.loops ? (this.pos = u2 - x2, v2 = this.situation.loop, this.situation.loop = x2) : (this.absPos = this.situation.loops, this.pos = 1, v2 = this.situation.loop - 1, this.situation.loop = this.situation.loops), this.situation.reversing && (this.situation.reversed = this.situation.reversed != !!((this.situation.loop - v2) % 2))) : (this.absPos = Math.min(this.absPos, 1), this.pos = this.absPos), this.pos < 0 && (this.pos = 0), this.situation.reversed && (this.pos = 1 - this.pos);
      var k2 = this.situation.ease(this.pos);
      for (var S2 in this.situation.once)
        S2 > this.lastPos && S2 <= k2 && (this.situation.once[S2].call(this.target(), this.pos, k2), delete this.situation.once[S2]);
      return this.active && this.target().fire("during", { pos: this.pos, eased: k2, fx: this, situation: this.situation }), this.situation ? (this.eachAt(), this.pos == 1 && !this.situation.reversed || this.situation.reversed && this.pos == 0 ? (this.stopAnimFrame(), this.target().fire("finished", { fx: this, situation: this.situation }), this.situations.length || (this.target().fire("allfinished"), this.situations.length || (this.target().off(".fx"), this.active = false)), this.active ? this.dequeue() : this.clearCurrent()) : !this.paused && this.active && this.startAnimFrame(), this.lastPos = k2, this) : this;
    }, eachAt: function() {
      var l2, u2 = this, x2 = this.target(), v2 = this.situation;
      for (var k2 in v2.animations)
        l2 = [].concat(v2.animations[k2]).map(function(L2) {
          return typeof L2 != "string" && L2.at ? L2.at(v2.ease(u2.pos), u2.pos) : L2;
        }), x2[k2].apply(x2, l2);
      for (var k2 in v2.attrs)
        l2 = [k2].concat(v2.attrs[k2]).map(function(I2) {
          return typeof I2 != "string" && I2.at ? I2.at(v2.ease(u2.pos), u2.pos) : I2;
        }), x2.attr.apply(x2, l2);
      for (var k2 in v2.styles)
        l2 = [k2].concat(v2.styles[k2]).map(function(I2) {
          return typeof I2 != "string" && I2.at ? I2.at(v2.ease(u2.pos), u2.pos) : I2;
        }), x2.style.apply(x2, l2);
      if (v2.transforms.length) {
        l2 = v2.initialTransformation, k2 = 0;
        for (var S2 = v2.transforms.length; k2 < S2; k2++) {
          var C2 = v2.transforms[k2];
          C2 instanceof t2.Matrix ? l2 = C2.relative ? l2.multiply(new t2.Matrix().morph(C2).at(v2.ease(this.pos))) : l2.morph(C2).at(v2.ease(this.pos)) : (C2.relative || C2.undo(l2.extract()), l2 = l2.multiply(C2.at(v2.ease(this.pos))));
        }
        x2.matrix(l2);
      }
      return this;
    }, once: function(l2, u2, x2) {
      var v2 = this.last();
      return x2 || (l2 = v2.ease(l2)), v2.once[l2] = u2, this;
    }, _callStart: function() {
      return setTimeout((function() {
        this.start();
      }).bind(this), 0), this;
    } }, parent: t2.Element, construct: { animate: function(l2, u2, x2) {
      return (this.fx || (this.fx = new t2.FX(this))).animate(l2, u2, x2);
    }, delay: function(l2) {
      return (this.fx || (this.fx = new t2.FX(this))).delay(l2);
    }, stop: function(l2, u2) {
      return this.fx && this.fx.stop(l2, u2), this;
    }, finish: function() {
      return this.fx && this.fx.finish(), this;
    } } }), t2.MorphObj = t2.invent({ create: function(l2, u2) {
      return t2.Color.isColor(u2) ? new t2.Color(l2).morph(u2) : t2.regex.delimiter.test(l2) ? t2.regex.pathLetters.test(l2) ? new t2.PathArray(l2).morph(u2) : new t2.Array(l2).morph(u2) : t2.regex.numberAndUnit.test(u2) ? new t2.Number(l2).morph(u2) : (this.value = l2, void (this.destination = u2));
    }, extend: { at: function(l2, u2) {
      return u2 < 1 ? this.value : this.destination;
    }, valueOf: function() {
      return this.value;
    } } }), t2.extend(t2.FX, { attr: function(l2, u2, x2) {
      if (U2(l2) === "object")
        for (var v2 in l2)
          this.attr(v2, l2[v2]);
      else
        this.add(l2, u2, "attrs");
      return this;
    }, plot: function(l2, u2, x2, v2) {
      return arguments.length == 4 ? this.plot([l2, u2, x2, v2]) : this.add("plot", new (this.target()).morphArray(l2));
    } }), t2.Box = t2.invent({ create: function(l2, u2, x2, v2) {
      if (!(U2(l2) !== "object" || l2 instanceof t2.Element))
        return t2.Box.call(this, l2.left != null ? l2.left : l2.x, l2.top != null ? l2.top : l2.y, l2.width, l2.height);
      var k2;
      arguments.length == 4 && (this.x = l2, this.y = u2, this.width = x2, this.height = v2), (k2 = this).x == null && (k2.x = 0, k2.y = 0, k2.width = 0, k2.height = 0), k2.w = k2.width, k2.h = k2.height, k2.x2 = k2.x + k2.width, k2.y2 = k2.y + k2.height, k2.cx = k2.x + k2.width / 2, k2.cy = k2.y + k2.height / 2;
    } }), t2.BBox = t2.invent({ create: function(l2) {
      if (t2.Box.apply(this, [].slice.call(arguments)), l2 instanceof t2.Element) {
        var u2;
        try {
          if (!e2.documentElement.contains) {
            for (var x2 = l2.node; x2.parentNode; )
              x2 = x2.parentNode;
            if (x2 != e2)
              throw new Error("Element not in the dom");
          }
          u2 = l2.node.getBBox();
        } catch {
          if (l2 instanceof t2.Shape) {
            t2.parser.draw || t2.prepare();
            var v2 = l2.clone(t2.parser.draw.instance).show();
            v2 && v2.node && typeof v2.node.getBBox == "function" && (u2 = v2.node.getBBox()), v2 && typeof v2.remove == "function" && v2.remove();
          } else
            u2 = { x: l2.node.clientLeft, y: l2.node.clientTop, width: l2.node.clientWidth, height: l2.node.clientHeight };
        }
        t2.Box.call(this, u2);
      }
    }, inherit: t2.Box, parent: t2.Element, construct: { bbox: function() {
      return new t2.BBox(this);
    } } }), t2.BBox.prototype.constructor = t2.BBox, t2.Matrix = t2.invent({ create: function(l2) {
      var u2 = f2([1, 0, 0, 1, 0, 0]);
      l2 = l2 === null ? u2 : l2 instanceof t2.Element ? l2.matrixify() : typeof l2 == "string" ? f2(l2.split(t2.regex.delimiter).map(parseFloat)) : arguments.length == 6 ? f2([].slice.call(arguments)) : Array.isArray(l2) ? f2(l2) : l2 && U2(l2) === "object" ? l2 : u2;
      for (var x2 = w2.length - 1; x2 >= 0; --x2)
        this[w2[x2]] = l2[w2[x2]] != null ? l2[w2[x2]] : u2[w2[x2]];
    }, extend: { extract: function() {
      var l2 = p2(this, 0, 1);
      p2(this, 1, 0);
      var u2 = 180 / Math.PI * Math.atan2(l2.y, l2.x) - 90;
      return { x: this.e, y: this.f, transformedX: (this.e * Math.cos(u2 * Math.PI / 180) + this.f * Math.sin(u2 * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b), transformedY: (this.f * Math.cos(u2 * Math.PI / 180) + this.e * Math.sin(-u2 * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d), rotation: u2, a: this.a, b: this.b, c: this.c, d: this.d, e: this.e, f: this.f, matrix: new t2.Matrix(this) };
    }, clone: function() {
      return new t2.Matrix(this);
    }, morph: function(l2) {
      return this.destination = new t2.Matrix(l2), this;
    }, multiply: function(l2) {
      return new t2.Matrix(this.native().multiply(function(u2) {
        return u2 instanceof t2.Matrix || (u2 = new t2.Matrix(u2)), u2;
      }(l2).native()));
    }, inverse: function() {
      return new t2.Matrix(this.native().inverse());
    }, translate: function(l2, u2) {
      return new t2.Matrix(this.native().translate(l2 || 0, u2 || 0));
    }, native: function() {
      for (var l2 = t2.parser.native.createSVGMatrix(), u2 = w2.length - 1; u2 >= 0; u2--)
        l2[w2[u2]] = this[w2[u2]];
      return l2;
    }, toString: function() {
      return "matrix(" + m2(this.a) + "," + m2(this.b) + "," + m2(this.c) + "," + m2(this.d) + "," + m2(this.e) + "," + m2(this.f) + ")";
    } }, parent: t2.Element, construct: { ctm: function() {
      return new t2.Matrix(this.node.getCTM());
    }, screenCTM: function() {
      if (this instanceof t2.Nested) {
        var l2 = this.rect(1, 1), u2 = l2.node.getScreenCTM();
        return l2.remove(), new t2.Matrix(u2);
      }
      return new t2.Matrix(this.node.getScreenCTM());
    } } }), t2.Point = t2.invent({ create: function(l2, u2) {
      var x2;
      x2 = Array.isArray(l2) ? { x: l2[0], y: l2[1] } : U2(l2) === "object" ? { x: l2.x, y: l2.y } : l2 != null ? { x: l2, y: u2 ?? l2 } : { x: 0, y: 0 }, this.x = x2.x, this.y = x2.y;
    }, extend: { clone: function() {
      return new t2.Point(this);
    }, morph: function(l2, u2) {
      return this.destination = new t2.Point(l2, u2), this;
    } } }), t2.extend(t2.Element, { point: function(l2, u2) {
      return new t2.Point(l2, u2).transform(this.screenCTM().inverse());
    } }), t2.extend(t2.Element, { attr: function(l2, u2, x2) {
      if (l2 == null) {
        for (l2 = {}, x2 = (u2 = this.node.attributes).length - 1; x2 >= 0; x2--)
          l2[u2[x2].nodeName] = t2.regex.isNumber.test(u2[x2].nodeValue) ? parseFloat(u2[x2].nodeValue) : u2[x2].nodeValue;
        return l2;
      }
      if (U2(l2) === "object")
        for (var v2 in l2)
          this.attr(v2, l2[v2]);
      else if (u2 === null)
        this.node.removeAttribute(l2);
      else {
        if (u2 == null)
          return (u2 = this.node.getAttribute(l2)) == null ? t2.defaults.attrs[l2] : t2.regex.isNumber.test(u2) ? parseFloat(u2) : u2;
        l2 == "stroke-width" ? this.attr("stroke", parseFloat(u2) > 0 ? this._stroke : null) : l2 == "stroke" && (this._stroke = u2), l2 != "fill" && l2 != "stroke" || (t2.regex.isImage.test(u2) && (u2 = this.doc().defs().image(u2, 0, 0)), u2 instanceof t2.Image && (u2 = this.doc().defs().pattern(0, 0, function() {
          this.add(u2);
        }))), typeof u2 == "number" ? u2 = new t2.Number(u2) : t2.Color.isColor(u2) ? u2 = new t2.Color(u2) : Array.isArray(u2) && (u2 = new t2.Array(u2)), l2 == "leading" ? this.leading && this.leading(u2) : typeof x2 == "string" ? this.node.setAttributeNS(x2, l2, u2.toString()) : this.node.setAttribute(l2, u2.toString()), !this.rebuild || l2 != "font-size" && l2 != "x" || this.rebuild(l2, u2);
      }
      return this;
    } }), t2.extend(t2.Element, { transform: function(l2, u2) {
      var x2;
      return U2(l2) !== "object" ? (x2 = new t2.Matrix(this).extract(), typeof l2 == "string" ? x2[l2] : x2) : (x2 = new t2.Matrix(this), u2 = !!u2 || !!l2.relative, l2.a != null && (x2 = u2 ? x2.multiply(new t2.Matrix(l2)) : new t2.Matrix(l2)), this.attr("transform", x2));
    } }), t2.extend(t2.Element, { untransform: function() {
      return this.attr("transform", null);
    }, matrixify: function() {
      return (this.attr("transform") || "").split(t2.regex.transforms).slice(0, -1).map(function(l2) {
        var u2 = l2.trim().split("(");
        return [u2[0], u2[1].split(t2.regex.delimiter).map(function(x2) {
          return parseFloat(x2);
        })];
      }).reduce(function(l2, u2) {
        return u2[0] == "matrix" ? l2.multiply(f2(u2[1])) : l2[u2[0]].apply(l2, u2[1]);
      }, new t2.Matrix());
    }, toParent: function(l2) {
      if (this == l2)
        return this;
      var u2 = this.screenCTM(), x2 = l2.screenCTM().inverse();
      return this.addTo(l2).untransform().transform(x2.multiply(u2)), this;
    }, toDoc: function() {
      return this.toParent(this.doc());
    } }), t2.Transformation = t2.invent({ create: function(l2, u2) {
      if (arguments.length > 1 && typeof u2 != "boolean")
        return this.constructor.call(this, [].slice.call(arguments));
      if (Array.isArray(l2))
        for (var x2 = 0, v2 = this.arguments.length; x2 < v2; ++x2)
          this[this.arguments[x2]] = l2[x2];
      else if (l2 && U2(l2) === "object")
        for (x2 = 0, v2 = this.arguments.length; x2 < v2; ++x2)
          this[this.arguments[x2]] = l2[this.arguments[x2]];
      this.inversed = false, u2 === true && (this.inversed = true);
    } }), t2.Translate = t2.invent({ parent: t2.Matrix, inherit: t2.Transformation, create: function(l2, u2) {
      this.constructor.apply(this, [].slice.call(arguments));
    }, extend: { arguments: ["transformedX", "transformedY"], method: "translate" } }), t2.extend(t2.Element, { style: function(l2, u2) {
      if (arguments.length == 0)
        return this.node.style.cssText || "";
      if (arguments.length < 2)
        if (U2(l2) === "object")
          for (var x2 in l2)
            this.style(x2, l2[x2]);
        else {
          if (!t2.regex.isCss.test(l2))
            return this.node.style[h2(l2)];
          for (l2 = l2.split(/\s*;\s*/).filter(function(v2) {
            return !!v2;
          }).map(function(v2) {
            return v2.split(/\s*:\s*/);
          }); u2 = l2.pop(); )
            this.style(u2[0], u2[1]);
        }
      else
        this.node.style[h2(l2)] = u2 === null || t2.regex.isBlank.test(u2) ? "" : u2;
      return this;
    } }), t2.Parent = t2.invent({ create: function(l2) {
      this.constructor.call(this, l2);
    }, inherit: t2.Element, extend: { children: function() {
      return t2.utils.map(t2.utils.filterSVGElements(this.node.childNodes), function(l2) {
        return t2.adopt(l2);
      });
    }, add: function(l2, u2) {
      return u2 == null ? this.node.appendChild(l2.node) : l2.node != this.node.childNodes[u2] && this.node.insertBefore(l2.node, this.node.childNodes[u2]), this;
    }, put: function(l2, u2) {
      return this.add(l2, u2), l2;
    }, has: function(l2) {
      return this.index(l2) >= 0;
    }, index: function(l2) {
      return [].slice.call(this.node.childNodes).indexOf(l2.node);
    }, get: function(l2) {
      return t2.adopt(this.node.childNodes[l2]);
    }, first: function() {
      return this.get(0);
    }, last: function() {
      return this.get(this.node.childNodes.length - 1);
    }, each: function(l2, u2) {
      for (var x2 = this.children(), v2 = 0, k2 = x2.length; v2 < k2; v2++)
        x2[v2] instanceof t2.Element && l2.apply(x2[v2], [v2, x2]), u2 && x2[v2] instanceof t2.Container && x2[v2].each(l2, u2);
      return this;
    }, removeElement: function(l2) {
      return this.node.removeChild(l2.node), this;
    }, clear: function() {
      for (; this.node.hasChildNodes(); )
        this.node.removeChild(this.node.lastChild);
      return delete this._defs, this;
    }, defs: function() {
      return this.doc().defs();
    } } }), t2.extend(t2.Parent, { ungroup: function(l2, u2) {
      return u2 === 0 || this instanceof t2.Defs || this.node == t2.parser.draw || (l2 = l2 || (this instanceof t2.Doc ? this : this.parent(t2.Parent)), u2 = u2 || 1 / 0, this.each(function() {
        return this instanceof t2.Defs ? this : this instanceof t2.Parent ? this.ungroup(l2, u2 - 1) : this.toParent(l2);
      }), this.node.firstChild || this.remove()), this;
    }, flatten: function(l2, u2) {
      return this.ungroup(l2, u2);
    } }), t2.Container = t2.invent({ create: function(l2) {
      this.constructor.call(this, l2);
    }, inherit: t2.Parent }), t2.ViewBox = t2.invent({ parent: t2.Container, construct: {} }), ["click", "dblclick", "mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "touchstart", "touchmove", "touchleave", "touchend", "touchcancel"].forEach(function(l2) {
      t2.Element.prototype[l2] = function(u2) {
        return t2.on(this.node, l2, u2), this;
      };
    }), t2.listeners = [], t2.handlerMap = [], t2.listenerId = 0, t2.on = function(l2, u2, x2, v2, k2) {
      var S2 = x2.bind(v2 || l2.instance || l2), C2 = (t2.handlerMap.indexOf(l2) + 1 || t2.handlerMap.push(l2)) - 1, L2 = u2.split(".")[0], I2 = u2.split(".")[1] || "*";
      t2.listeners[C2] = t2.listeners[C2] || {}, t2.listeners[C2][L2] = t2.listeners[C2][L2] || {}, t2.listeners[C2][L2][I2] = t2.listeners[C2][L2][I2] || {}, x2._svgjsListenerId || (x2._svgjsListenerId = ++t2.listenerId), t2.listeners[C2][L2][I2][x2._svgjsListenerId] = S2, l2.addEventListener(L2, S2, k2 || { passive: true });
    }, t2.off = function(l2, u2, x2) {
      var v2 = t2.handlerMap.indexOf(l2), k2 = u2 && u2.split(".")[0], S2 = u2 && u2.split(".")[1], C2 = "";
      if (v2 != -1)
        if (x2) {
          if (typeof x2 == "function" && (x2 = x2._svgjsListenerId), !x2)
            return;
          t2.listeners[v2][k2] && t2.listeners[v2][k2][S2 || "*"] && (l2.removeEventListener(k2, t2.listeners[v2][k2][S2 || "*"][x2], false), delete t2.listeners[v2][k2][S2 || "*"][x2]);
        } else if (S2 && k2) {
          if (t2.listeners[v2][k2] && t2.listeners[v2][k2][S2]) {
            for (var L2 in t2.listeners[v2][k2][S2])
              t2.off(l2, [k2, S2].join("."), L2);
            delete t2.listeners[v2][k2][S2];
          }
        } else if (S2)
          for (var I2 in t2.listeners[v2])
            for (var C2 in t2.listeners[v2][I2])
              S2 === C2 && t2.off(l2, [I2, S2].join("."));
        else if (k2) {
          if (t2.listeners[v2][k2]) {
            for (var C2 in t2.listeners[v2][k2])
              t2.off(l2, [k2, C2].join("."));
            delete t2.listeners[v2][k2];
          }
        } else {
          for (var I2 in t2.listeners[v2])
            t2.off(l2, I2);
          delete t2.listeners[v2], delete t2.handlerMap[v2];
        }
    }, t2.extend(t2.Element, { on: function(l2, u2, x2, v2) {
      return t2.on(this.node, l2, u2, x2, v2), this;
    }, off: function(l2, u2) {
      return t2.off(this.node, l2, u2), this;
    }, fire: function(l2, u2) {
      return l2 instanceof y2.Event ? this.node.dispatchEvent(l2) : this.node.dispatchEvent(l2 = new t2.CustomEvent(l2, { detail: u2, cancelable: true })), this._event = l2, this;
    }, event: function() {
      return this._event;
    } }), t2.Defs = t2.invent({ create: "defs", inherit: t2.Container }), t2.G = t2.invent({ create: "g", inherit: t2.Container, extend: { x: function(l2) {
      return l2 == null ? this.transform("x") : this.transform({ x: l2 - this.x() }, true);
    } }, construct: { group: function() {
      return this.put(new t2.G());
    } } }), t2.Doc = t2.invent({ create: function(l2) {
      l2 && ((l2 = typeof l2 == "string" ? e2.getElementById(l2) : l2).nodeName == "svg" ? this.constructor.call(this, l2) : (this.constructor.call(this, t2.create("svg")), l2.appendChild(this.node), this.size("100%", "100%")), this.namespace().defs());
    }, inherit: t2.Container, extend: { namespace: function() {
      return this.attr({ xmlns: t2.ns, version: "1.1" }).attr("xmlns:xlink", t2.xlink, t2.xmlns).attr("xmlns:svgjs", t2.svgjs, t2.xmlns);
    }, defs: function() {
      var l2;
      return this._defs || ((l2 = this.node.getElementsByTagName("defs")[0]) ? this._defs = t2.adopt(l2) : this._defs = new t2.Defs(), this.node.appendChild(this._defs.node)), this._defs;
    }, parent: function() {
      return this.node.parentNode && this.node.parentNode.nodeName != "#document" ? this.node.parentNode : null;
    }, remove: function() {
      return this.parent() && this.parent().removeChild(this.node), this;
    }, clear: function() {
      for (; this.node.hasChildNodes(); )
        this.node.removeChild(this.node.lastChild);
      return delete this._defs, t2.parser.draw && !t2.parser.draw.parentNode && this.node.appendChild(t2.parser.draw), this;
    }, clone: function(l2) {
      this.writeDataToDom();
      var u2 = this.node, x2 = b2(u2.cloneNode(true));
      return l2 ? (l2.node || l2).appendChild(x2.node) : u2.parentNode.insertBefore(x2.node, u2.nextSibling), x2;
    } } }), t2.extend(t2.Element, {}), t2.Gradient = t2.invent({ create: function(l2) {
      this.constructor.call(this, t2.create(l2 + "Gradient")), this.type = l2;
    }, inherit: t2.Container, extend: { at: function(l2, u2, x2) {
      return this.put(new t2.Stop()).update(l2, u2, x2);
    }, update: function(l2) {
      return this.clear(), typeof l2 == "function" && l2.call(this, this), this;
    }, fill: function() {
      return "url(#" + this.id() + ")";
    }, toString: function() {
      return this.fill();
    }, attr: function(l2, u2, x2) {
      return l2 == "transform" && (l2 = "gradientTransform"), t2.Container.prototype.attr.call(this, l2, u2, x2);
    } }, construct: { gradient: function(l2, u2) {
      return this.defs().gradient(l2, u2);
    } } }), t2.extend(t2.Gradient, t2.FX, { from: function(l2, u2) {
      return (this._target || this).type == "radial" ? this.attr({ fx: new t2.Number(l2), fy: new t2.Number(u2) }) : this.attr({ x1: new t2.Number(l2), y1: new t2.Number(u2) });
    }, to: function(l2, u2) {
      return (this._target || this).type == "radial" ? this.attr({ cx: new t2.Number(l2), cy: new t2.Number(u2) }) : this.attr({ x2: new t2.Number(l2), y2: new t2.Number(u2) });
    } }), t2.extend(t2.Defs, { gradient: function(l2, u2) {
      return this.put(new t2.Gradient(l2)).update(u2);
    } }), t2.Stop = t2.invent({ create: "stop", inherit: t2.Element, extend: { update: function(l2) {
      return (typeof l2 == "number" || l2 instanceof t2.Number) && (l2 = { offset: arguments[0], color: arguments[1], opacity: arguments[2] }), l2.opacity != null && this.attr("stop-opacity", l2.opacity), l2.color != null && this.attr("stop-color", l2.color), l2.offset != null && this.attr("offset", new t2.Number(l2.offset)), this;
    } } }), t2.Pattern = t2.invent({ create: "pattern", inherit: t2.Container, extend: { fill: function() {
      return "url(#" + this.id() + ")";
    }, update: function(l2) {
      return this.clear(), typeof l2 == "function" && l2.call(this, this), this;
    }, toString: function() {
      return this.fill();
    }, attr: function(l2, u2, x2) {
      return l2 == "transform" && (l2 = "patternTransform"), t2.Container.prototype.attr.call(this, l2, u2, x2);
    } }, construct: { pattern: function(l2, u2, x2) {
      return this.defs().pattern(l2, u2, x2);
    } } }), t2.extend(t2.Defs, { pattern: function(l2, u2, x2) {
      return this.put(new t2.Pattern()).update(x2).attr({ x: 0, y: 0, width: l2, height: u2, patternUnits: "userSpaceOnUse" });
    } }), t2.Shape = t2.invent({ create: function(l2) {
      this.constructor.call(this, l2);
    }, inherit: t2.Element }), t2.Symbol = t2.invent({ create: "symbol", inherit: t2.Container, construct: { symbol: function() {
      return this.put(new t2.Symbol());
    } } }), t2.Use = t2.invent({ create: "use", inherit: t2.Shape, extend: { element: function(l2, u2) {
      return this.attr("href", (u2 || "") + "#" + l2, t2.xlink);
    } }, construct: { use: function(l2, u2) {
      return this.put(new t2.Use()).element(l2, u2);
    } } }), t2.Rect = t2.invent({ create: "rect", inherit: t2.Shape, construct: { rect: function(l2, u2) {
      return this.put(new t2.Rect()).size(l2, u2);
    } } }), t2.Circle = t2.invent({ create: "circle", inherit: t2.Shape, construct: { circle: function(l2) {
      return this.put(new t2.Circle()).rx(new t2.Number(l2).divide(2)).move(0, 0);
    } } }), t2.extend(t2.Circle, t2.FX, { rx: function(l2) {
      return this.attr("r", l2);
    }, ry: function(l2) {
      return this.rx(l2);
    } }), t2.Ellipse = t2.invent({ create: "ellipse", inherit: t2.Shape, construct: { ellipse: function(l2, u2) {
      return this.put(new t2.Ellipse()).size(l2, u2).move(0, 0);
    } } }), t2.extend(t2.Ellipse, t2.Rect, t2.FX, { rx: function(l2) {
      return this.attr("rx", l2);
    }, ry: function(l2) {
      return this.attr("ry", l2);
    } }), t2.extend(t2.Circle, t2.Ellipse, { x: function(l2) {
      return l2 == null ? this.cx() - this.rx() : this.cx(l2 + this.rx());
    }, y: function(l2) {
      return l2 == null ? this.cy() - this.ry() : this.cy(l2 + this.ry());
    }, cx: function(l2) {
      return l2 == null ? this.attr("cx") : this.attr("cx", l2);
    }, cy: function(l2) {
      return l2 == null ? this.attr("cy") : this.attr("cy", l2);
    }, width: function(l2) {
      return l2 == null ? 2 * this.rx() : this.rx(new t2.Number(l2).divide(2));
    }, height: function(l2) {
      return l2 == null ? 2 * this.ry() : this.ry(new t2.Number(l2).divide(2));
    }, size: function(l2, u2) {
      var x2 = g2(this, l2, u2);
      return this.rx(new t2.Number(x2.width).divide(2)).ry(new t2.Number(x2.height).divide(2));
    } }), t2.Line = t2.invent({ create: "line", inherit: t2.Shape, extend: { array: function() {
      return new t2.PointArray([[this.attr("x1"), this.attr("y1")], [this.attr("x2"), this.attr("y2")]]);
    }, plot: function(l2, u2, x2, v2) {
      return l2 == null ? this.array() : (l2 = u2 !== void 0 ? { x1: l2, y1: u2, x2, y2: v2 } : new t2.PointArray(l2).toLine(), this.attr(l2));
    }, move: function(l2, u2) {
      return this.attr(this.array().move(l2, u2).toLine());
    }, size: function(l2, u2) {
      var x2 = g2(this, l2, u2);
      return this.attr(this.array().size(x2.width, x2.height).toLine());
    } }, construct: { line: function(l2, u2, x2, v2) {
      return t2.Line.prototype.plot.apply(this.put(new t2.Line()), l2 != null ? [l2, u2, x2, v2] : [0, 0, 0, 0]);
    } } }), t2.Polyline = t2.invent({ create: "polyline", inherit: t2.Shape, construct: { polyline: function(l2) {
      return this.put(new t2.Polyline()).plot(l2 || new t2.PointArray());
    } } }), t2.Polygon = t2.invent({ create: "polygon", inherit: t2.Shape, construct: { polygon: function(l2) {
      return this.put(new t2.Polygon()).plot(l2 || new t2.PointArray());
    } } }), t2.extend(t2.Polyline, t2.Polygon, { array: function() {
      return this._array || (this._array = new t2.PointArray(this.attr("points")));
    }, plot: function(l2) {
      return l2 == null ? this.array() : this.clear().attr("points", typeof l2 == "string" ? l2 : this._array = new t2.PointArray(l2));
    }, clear: function() {
      return delete this._array, this;
    }, move: function(l2, u2) {
      return this.attr("points", this.array().move(l2, u2));
    }, size: function(l2, u2) {
      var x2 = g2(this, l2, u2);
      return this.attr("points", this.array().size(x2.width, x2.height));
    } }), t2.extend(t2.Line, t2.Polyline, t2.Polygon, { morphArray: t2.PointArray, x: function(l2) {
      return l2 == null ? this.bbox().x : this.move(l2, this.bbox().y);
    }, y: function(l2) {
      return l2 == null ? this.bbox().y : this.move(this.bbox().x, l2);
    }, width: function(l2) {
      var u2 = this.bbox();
      return l2 == null ? u2.width : this.size(l2, u2.height);
    }, height: function(l2) {
      var u2 = this.bbox();
      return l2 == null ? u2.height : this.size(u2.width, l2);
    } }), t2.Path = t2.invent({ create: "path", inherit: t2.Shape, extend: { morphArray: t2.PathArray, array: function() {
      return this._array || (this._array = new t2.PathArray(this.attr("d")));
    }, plot: function(l2) {
      return l2 == null ? this.array() : this.clear().attr("d", typeof l2 == "string" ? l2 : this._array = new t2.PathArray(l2));
    }, clear: function() {
      return delete this._array, this;
    } }, construct: { path: function(l2) {
      return this.put(new t2.Path()).plot(l2 || new t2.PathArray());
    } } }), t2.Image = t2.invent({ create: "image", inherit: t2.Shape, extend: { load: function(l2) {
      if (!l2)
        return this;
      var u2 = this, x2 = new y2.Image();
      return t2.on(x2, "load", function() {
        t2.off(x2);
        var v2 = u2.parent(t2.Pattern);
        v2 !== null && (u2.width() == 0 && u2.height() == 0 && u2.size(x2.width, x2.height), v2 && v2.width() == 0 && v2.height() == 0 && v2.size(u2.width(), u2.height()), typeof u2._loaded == "function" && u2._loaded.call(u2, { width: x2.width, height: x2.height, ratio: x2.width / x2.height, url: l2 }));
      }), t2.on(x2, "error", function(v2) {
        t2.off(x2), typeof u2._error == "function" && u2._error.call(u2, v2);
      }), this.attr("href", x2.src = this.src = l2, t2.xlink);
    }, loaded: function(l2) {
      return this._loaded = l2, this;
    }, error: function(l2) {
      return this._error = l2, this;
    } }, construct: { image: function(l2, u2, x2) {
      return this.put(new t2.Image()).load(l2).size(u2 || 0, x2 || u2 || 0);
    } } }), t2.Text = t2.invent({ create: function() {
      this.constructor.call(this, t2.create("text")), this.dom.leading = new t2.Number(1.3), this._rebuild = true, this._build = false, this.attr("font-family", t2.defaults.attrs["font-family"]);
    }, inherit: t2.Shape, extend: { x: function(l2) {
      return l2 == null ? this.attr("x") : this.attr("x", l2);
    }, text: function(l2) {
      if (l2 === void 0) {
        l2 = "";
        for (var u2 = this.node.childNodes, x2 = 0, v2 = u2.length; x2 < v2; ++x2)
          x2 != 0 && u2[x2].nodeType != 3 && t2.adopt(u2[x2]).dom.newLined == 1 && (l2 += `
`), l2 += u2[x2].textContent;
        return l2;
      }
      if (this.clear().build(true), typeof l2 == "function")
        l2.call(this, this);
      else {
        x2 = 0;
        for (var k2 = (l2 = l2.split(`
`)).length; x2 < k2; x2++)
          this.tspan(l2[x2]).newLine();
      }
      return this.build(false).rebuild();
    }, size: function(l2) {
      return this.attr("font-size", l2).rebuild();
    }, leading: function(l2) {
      return l2 == null ? this.dom.leading : (this.dom.leading = new t2.Number(l2), this.rebuild());
    }, lines: function() {
      var l2 = (this.textPath && this.textPath() || this).node, u2 = t2.utils.map(t2.utils.filterSVGElements(l2.childNodes), function(x2) {
        return t2.adopt(x2);
      });
      return new t2.Set(u2);
    }, rebuild: function(l2) {
      if (typeof l2 == "boolean" && (this._rebuild = l2), this._rebuild) {
        var u2 = this, x2 = 0, v2 = this.dom.leading * new t2.Number(this.attr("font-size"));
        this.lines().each(function() {
          this.dom.newLined && (u2.textPath() || this.attr("x", u2.attr("x")), this.text() == `
` ? x2 += v2 : (this.attr("dy", v2 + x2), x2 = 0));
        }), this.fire("rebuild");
      }
      return this;
    }, build: function(l2) {
      return this._build = !!l2, this;
    }, setData: function(l2) {
      return this.dom = l2, this.dom.leading = new t2.Number(l2.leading || 1.3), this;
    } }, construct: { text: function(l2) {
      return this.put(new t2.Text()).text(l2);
    }, plain: function(l2) {
      return this.put(new t2.Text()).plain(l2);
    } } }), t2.Tspan = t2.invent({ create: "tspan", inherit: t2.Shape, extend: { text: function(l2) {
      return l2 == null ? this.node.textContent + (this.dom.newLined ? `
` : "") : (typeof l2 == "function" ? l2.call(this, this) : this.plain(l2), this);
    }, dx: function(l2) {
      return this.attr("dx", l2);
    }, dy: function(l2) {
      return this.attr("dy", l2);
    }, newLine: function() {
      var l2 = this.parent(t2.Text);
      return this.dom.newLined = true, this.dy(l2.dom.leading * l2.attr("font-size")).attr("x", l2.x());
    } } }), t2.extend(t2.Text, t2.Tspan, { plain: function(l2) {
      return this._build === false && this.clear(), this.node.appendChild(e2.createTextNode(l2)), this;
    }, tspan: function(l2) {
      var u2 = (this.textPath && this.textPath() || this).node, x2 = new t2.Tspan();
      return this._build === false && this.clear(), u2.appendChild(x2.node), x2.text(l2);
    }, clear: function() {
      for (var l2 = (this.textPath && this.textPath() || this).node; l2.hasChildNodes(); )
        l2.removeChild(l2.lastChild);
      return this;
    }, length: function() {
      return this.node.getComputedTextLength();
    } }), t2.TextPath = t2.invent({ create: "textPath", inherit: t2.Parent, parent: t2.Text, construct: { morphArray: t2.PathArray, array: function() {
      var l2 = this.track();
      return l2 ? l2.array() : null;
    }, plot: function(l2) {
      var u2 = this.track(), x2 = null;
      return u2 && (x2 = u2.plot(l2)), l2 == null ? x2 : this;
    }, track: function() {
      var l2 = this.textPath();
      if (l2)
        return l2.reference("href");
    }, textPath: function() {
      if (this.node.firstChild && this.node.firstChild.nodeName == "textPath")
        return t2.adopt(this.node.firstChild);
    } } }), t2.Nested = t2.invent({ create: function() {
      this.constructor.call(this, t2.create("svg")), this.style("overflow", "visible");
    }, inherit: t2.Container, construct: { nested: function() {
      return this.put(new t2.Nested());
    } } });
    var n2 = { stroke: ["color", "width", "opacity", "linecap", "linejoin", "miterlimit", "dasharray", "dashoffset"], fill: ["color", "opacity", "rule"], prefix: function(l2, u2) {
      return u2 == "color" ? l2 : l2 + "-" + u2;
    } };
    function o2(l2, u2, x2, v2) {
      return x2 + v2.replace(t2.regex.dots, " .");
    }
    function h2(l2) {
      return l2.toLowerCase().replace(/-(.)/g, function(u2, x2) {
        return x2.toUpperCase();
      });
    }
    function c2(l2) {
      return l2.charAt(0).toUpperCase() + l2.slice(1);
    }
    function d2(l2) {
      var u2 = l2.toString(16);
      return u2.length == 1 ? "0" + u2 : u2;
    }
    function g2(l2, u2, x2) {
      if (u2 == null || x2 == null) {
        var v2 = l2.bbox();
        u2 == null ? u2 = v2.width / v2.height * x2 : x2 == null && (x2 = v2.height / v2.width * u2);
      }
      return { width: u2, height: x2 };
    }
    function p2(l2, u2, x2) {
      return { x: u2 * l2.a + x2 * l2.c + 0, y: u2 * l2.b + x2 * l2.d + 0 };
    }
    function f2(l2) {
      return { a: l2[0], b: l2[1], c: l2[2], d: l2[3], e: l2[4], f: l2[5] };
    }
    function b2(l2) {
      for (var u2 = l2.childNodes.length - 1; u2 >= 0; u2--)
        l2.childNodes[u2] instanceof y2.SVGElement && b2(l2.childNodes[u2]);
      return t2.adopt(l2).id(t2.eid(l2.nodeName));
    }
    function m2(l2) {
      return Math.abs(l2) > 1e-37 ? l2 : 0;
    }
    ["fill", "stroke"].forEach(function(l2) {
      var u2 = {};
      u2[l2] = function(x2) {
        if (x2 === void 0)
          return this;
        if (typeof x2 == "string" || t2.Color.isRgb(x2) || x2 && typeof x2.fill == "function")
          this.attr(l2, x2);
        else
          for (var v2 = n2[l2].length - 1; v2 >= 0; v2--)
            x2[n2[l2][v2]] != null && this.attr(n2.prefix(l2, n2[l2][v2]), x2[n2[l2][v2]]);
        return this;
      }, t2.extend(t2.Element, t2.FX, u2);
    }), t2.extend(t2.Element, t2.FX, { translate: function(l2, u2) {
      return this.transform({ x: l2, y: u2 });
    }, matrix: function(l2) {
      return this.attr("transform", new t2.Matrix(arguments.length == 6 ? [].slice.call(arguments) : l2));
    }, opacity: function(l2) {
      return this.attr("opacity", l2);
    }, dx: function(l2) {
      return this.x(new t2.Number(l2).plus(this instanceof t2.FX ? 0 : this.x()), true);
    }, dy: function(l2) {
      return this.y(new t2.Number(l2).plus(this instanceof t2.FX ? 0 : this.y()), true);
    } }), t2.extend(t2.Path, { length: function() {
      return this.node.getTotalLength();
    }, pointAt: function(l2) {
      return this.node.getPointAtLength(l2);
    } }), t2.Set = t2.invent({ create: function(l2) {
      Array.isArray(l2) ? this.members = l2 : this.clear();
    }, extend: { add: function() {
      for (var l2 = [].slice.call(arguments), u2 = 0, x2 = l2.length; u2 < x2; u2++)
        this.members.push(l2[u2]);
      return this;
    }, remove: function(l2) {
      var u2 = this.index(l2);
      return u2 > -1 && this.members.splice(u2, 1), this;
    }, each: function(l2) {
      for (var u2 = 0, x2 = this.members.length; u2 < x2; u2++)
        l2.apply(this.members[u2], [u2, this.members]);
      return this;
    }, clear: function() {
      return this.members = [], this;
    }, length: function() {
      return this.members.length;
    }, has: function(l2) {
      return this.index(l2) >= 0;
    }, index: function(l2) {
      return this.members.indexOf(l2);
    }, get: function(l2) {
      return this.members[l2];
    }, first: function() {
      return this.get(0);
    }, last: function() {
      return this.get(this.members.length - 1);
    }, valueOf: function() {
      return this.members;
    } }, construct: { set: function(l2) {
      return new t2.Set(l2);
    } } }), t2.FX.Set = t2.invent({ create: function(l2) {
      this.set = l2;
    } }), t2.Set.inherit = function() {
      var l2 = [];
      for (var u2 in t2.Shape.prototype)
        typeof t2.Shape.prototype[u2] == "function" && typeof t2.Set.prototype[u2] != "function" && l2.push(u2);
      for (var u2 in l2.forEach(function(v2) {
        t2.Set.prototype[v2] = function() {
          for (var k2 = 0, S2 = this.members.length; k2 < S2; k2++)
            this.members[k2] && typeof this.members[k2][v2] == "function" && this.members[k2][v2].apply(this.members[k2], arguments);
          return v2 == "animate" ? this.fx || (this.fx = new t2.FX.Set(this)) : this;
        };
      }), l2 = [], t2.FX.prototype)
        typeof t2.FX.prototype[u2] == "function" && typeof t2.FX.Set.prototype[u2] != "function" && l2.push(u2);
      l2.forEach(function(x2) {
        t2.FX.Set.prototype[x2] = function() {
          for (var v2 = 0, k2 = this.set.members.length; v2 < k2; v2++)
            this.set.members[v2].fx[x2].apply(this.set.members[v2].fx, arguments);
          return this;
        };
      });
    }, t2.extend(t2.Element, {}), t2.extend(t2.Element, { remember: function(l2, u2) {
      if (U2(arguments[0]) === "object")
        for (var x2 in l2)
          this.remember(x2, l2[x2]);
      else {
        if (arguments.length == 1)
          return this.memory()[l2];
        this.memory()[l2] = u2;
      }
      return this;
    }, forget: function() {
      if (arguments.length == 0)
        this._memory = {};
      else
        for (var l2 = arguments.length - 1; l2 >= 0; l2--)
          delete this.memory()[arguments[l2]];
      return this;
    }, memory: function() {
      return this._memory || (this._memory = {});
    } }), t2.get = function(l2) {
      var u2 = e2.getElementById(function(x2) {
        var v2 = (x2 || "").toString().match(t2.regex.reference);
        if (v2)
          return v2[1];
      }(l2) || l2);
      return t2.adopt(u2);
    }, t2.select = function(l2, u2) {
      return new t2.Set(t2.utils.map((u2 || e2).querySelectorAll(l2), function(x2) {
        return t2.adopt(x2);
      }));
    }, t2.extend(t2.Parent, { select: function(l2) {
      return t2.select(l2, this.node);
    } });
    var w2 = "abcdef".split("");
    if (typeof y2.CustomEvent != "function") {
      var A2 = function(l2, u2) {
        u2 = u2 || { bubbles: false, cancelable: false, detail: void 0 };
        var x2 = e2.createEvent("CustomEvent");
        return x2.initCustomEvent(l2, u2.bubbles, u2.cancelable, u2.detail), x2;
      };
      A2.prototype = y2.Event.prototype, t2.CustomEvent = A2;
    } else
      t2.CustomEvent = y2.CustomEvent;
    return t2;
  }, U2(Re) === "object" ? _2.exports = be2.document ? Fe(be2, be2.document) : function(y2) {
    return Fe(y2, y2.document);
  } : be2.SVG = Fe(be2, be2.document), /*! svg.filter.js - v2.0.2 - 2016-02-24
  * https://github.com/wout/svg.filter.js
  * Copyright (c) 2016 Wout Fierens; Licensed MIT */
  (function() {
    SVG.Filter = SVG.invent({ create: "filter", inherit: SVG.Parent, extend: { source: "SourceGraphic", sourceAlpha: "SourceAlpha", background: "BackgroundImage", backgroundAlpha: "BackgroundAlpha", fill: "FillPaint", stroke: "StrokePaint", autoSetIn: true, put: function(r, n2) {
      return this.add(r, n2), !r.attr("in") && this.autoSetIn && r.attr("in", this.source), r.attr("result") || r.attr("result", r), r;
    }, blend: function(r, n2, o2) {
      return this.put(new SVG.BlendEffect(r, n2, o2));
    }, colorMatrix: function(r, n2) {
      return this.put(new SVG.ColorMatrixEffect(r, n2));
    }, convolveMatrix: function(r) {
      return this.put(new SVG.ConvolveMatrixEffect(r));
    }, componentTransfer: function(r) {
      return this.put(new SVG.ComponentTransferEffect(r));
    }, composite: function(r, n2, o2) {
      return this.put(new SVG.CompositeEffect(r, n2, o2));
    }, flood: function(r, n2) {
      return this.put(new SVG.FloodEffect(r, n2));
    }, offset: function(r, n2) {
      return this.put(new SVG.OffsetEffect(r, n2));
    }, image: function(r) {
      return this.put(new SVG.ImageEffect(r));
    }, merge: function() {
      var r = [void 0];
      for (var n2 in arguments)
        r.push(arguments[n2]);
      return this.put(new (SVG.MergeEffect.bind.apply(SVG.MergeEffect, r))());
    }, gaussianBlur: function(r, n2) {
      return this.put(new SVG.GaussianBlurEffect(r, n2));
    }, morphology: function(r, n2) {
      return this.put(new SVG.MorphologyEffect(r, n2));
    }, diffuseLighting: function(r, n2, o2) {
      return this.put(new SVG.DiffuseLightingEffect(r, n2, o2));
    }, displacementMap: function(r, n2, o2, h2, c2) {
      return this.put(new SVG.DisplacementMapEffect(r, n2, o2, h2, c2));
    }, specularLighting: function(r, n2, o2, h2) {
      return this.put(new SVG.SpecularLightingEffect(r, n2, o2, h2));
    }, tile: function() {
      return this.put(new SVG.TileEffect());
    }, turbulence: function(r, n2, o2, h2, c2) {
      return this.put(new SVG.TurbulenceEffect(r, n2, o2, h2, c2));
    }, toString: function() {
      return "url(#" + this.attr("id") + ")";
    } } }), SVG.extend(SVG.Defs, { filter: function(r) {
      var n2 = this.put(new SVG.Filter());
      return typeof r == "function" && r.call(n2, n2), n2;
    } }), SVG.extend(SVG.Container, { filter: function(r) {
      return this.defs().filter(r);
    } }), SVG.extend(SVG.Element, SVG.G, SVG.Nested, { filter: function(r) {
      return this.filterer = r instanceof SVG.Element ? r : this.doc().filter(r), this.doc() && this.filterer.doc() !== this.doc() && this.doc().defs().add(this.filterer), this.attr("filter", this.filterer), this.filterer;
    }, unfilter: function(r) {
      return this.filterer && r === true && this.filterer.remove(), delete this.filterer, this.attr("filter", null);
    } }), SVG.Effect = SVG.invent({ create: function() {
      this.constructor.call(this);
    }, inherit: SVG.Element, extend: { in: function(r) {
      return r == null ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", r);
    }, result: function(r) {
      return r == null ? this.attr("result") : this.attr("result", r);
    }, toString: function() {
      return this.result();
    } } }), SVG.ParentEffect = SVG.invent({ create: function() {
      this.constructor.call(this);
    }, inherit: SVG.Parent, extend: { in: function(r) {
      return r == null ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", r);
    }, result: function(r) {
      return r == null ? this.attr("result") : this.attr("result", r);
    }, toString: function() {
      return this.result();
    } } });
    var y2 = { blend: function(r, n2) {
      return this.parent() && this.parent().blend(this, r, n2);
    }, colorMatrix: function(r, n2) {
      return this.parent() && this.parent().colorMatrix(r, n2).in(this);
    }, convolveMatrix: function(r) {
      return this.parent() && this.parent().convolveMatrix(r).in(this);
    }, componentTransfer: function(r) {
      return this.parent() && this.parent().componentTransfer(r).in(this);
    }, composite: function(r, n2) {
      return this.parent() && this.parent().composite(this, r, n2);
    }, flood: function(r, n2) {
      return this.parent() && this.parent().flood(r, n2);
    }, offset: function(r, n2) {
      return this.parent() && this.parent().offset(r, n2).in(this);
    }, image: function(r) {
      return this.parent() && this.parent().image(r);
    }, merge: function() {
      return this.parent() && this.parent().merge.apply(this.parent(), [this].concat(arguments));
    }, gaussianBlur: function(r, n2) {
      return this.parent() && this.parent().gaussianBlur(r, n2).in(this);
    }, morphology: function(r, n2) {
      return this.parent() && this.parent().morphology(r, n2).in(this);
    }, diffuseLighting: function(r, n2, o2) {
      return this.parent() && this.parent().diffuseLighting(r, n2, o2).in(this);
    }, displacementMap: function(r, n2, o2, h2) {
      return this.parent() && this.parent().displacementMap(this, r, n2, o2, h2);
    }, specularLighting: function(r, n2, o2, h2) {
      return this.parent() && this.parent().specularLighting(r, n2, o2, h2).in(this);
    }, tile: function() {
      return this.parent() && this.parent().tile().in(this);
    }, turbulence: function(r, n2, o2, h2, c2) {
      return this.parent() && this.parent().turbulence(r, n2, o2, h2, c2).in(this);
    } };
    SVG.extend(SVG.Effect, y2), SVG.extend(SVG.ParentEffect, y2), SVG.ChildEffect = SVG.invent({ create: function() {
      this.constructor.call(this);
    }, inherit: SVG.Element, extend: { in: function(r) {
      this.attr("in", r);
    } } });
    var e2 = { blend: function(r, n2, o2) {
      this.attr({ in: r, in2: n2, mode: o2 || "normal" });
    }, colorMatrix: function(r, n2) {
      r == "matrix" && (n2 = a2(n2)), this.attr({ type: r, values: n2 === void 0 ? null : n2 });
    }, convolveMatrix: function(r) {
      r = a2(r), this.attr({ order: Math.sqrt(r.split(" ").length), kernelMatrix: r });
    }, composite: function(r, n2, o2) {
      this.attr({ in: r, in2: n2, operator: o2 });
    }, flood: function(r, n2) {
      this.attr("flood-color", r), n2 != null && this.attr("flood-opacity", n2);
    }, offset: function(r, n2) {
      this.attr({ dx: r, dy: n2 });
    }, image: function(r) {
      this.attr("href", r, SVG.xlink);
    }, displacementMap: function(r, n2, o2, h2, c2) {
      this.attr({ in: r, in2: n2, scale: o2, xChannelSelector: h2, yChannelSelector: c2 });
    }, gaussianBlur: function(r, n2) {
      r != null || n2 != null ? this.attr("stdDeviation", function(o2) {
        if (!Array.isArray(o2))
          return o2;
        for (var h2 = 0, c2 = o2.length, d2 = []; h2 < c2; h2++)
          d2.push(o2[h2]);
        return d2.join(" ");
      }(Array.prototype.slice.call(arguments))) : this.attr("stdDeviation", "0 0");
    }, morphology: function(r, n2) {
      this.attr({ operator: r, radius: n2 });
    }, tile: function() {
    }, turbulence: function(r, n2, o2, h2, c2) {
      this.attr({ numOctaves: n2, seed: o2, stitchTiles: h2, baseFrequency: r, type: c2 });
    } }, t2 = { merge: function() {
      var r;
      if (arguments[0] instanceof SVG.Set) {
        var n2 = this;
        arguments[0].each(function(h2) {
          this instanceof SVG.MergeNode ? n2.put(this) : (this instanceof SVG.Effect || this instanceof SVG.ParentEffect) && n2.put(new SVG.MergeNode(this));
        });
      } else {
        r = Array.isArray(arguments[0]) ? arguments[0] : arguments;
        for (var o2 = 0; o2 < r.length; o2++)
          r[o2] instanceof SVG.MergeNode ? this.put(r[o2]) : this.put(new SVG.MergeNode(r[o2]));
      }
    }, componentTransfer: function(r) {
      if (this.rgb = new SVG.Set(), ["r", "g", "b", "a"].forEach((function(o2) {
        this[o2] = new SVG["Func" + o2.toUpperCase()]("identity"), this.rgb.add(this[o2]), this.node.appendChild(this[o2].node);
      }).bind(this)), r)
        for (var n2 in r.rgb && (["r", "g", "b"].forEach((function(o2) {
          this[o2].attr(r.rgb);
        }).bind(this)), delete r.rgb), r)
          this[n2].attr(r[n2]);
    }, diffuseLighting: function(r, n2, o2) {
      this.attr({ surfaceScale: r, diffuseConstant: n2, kernelUnitLength: o2 });
    }, specularLighting: function(r, n2, o2, h2) {
      this.attr({ surfaceScale: r, diffuseConstant: n2, specularExponent: o2, kernelUnitLength: h2 });
    } }, i = { distantLight: function(r, n2) {
      this.attr({ azimuth: r, elevation: n2 });
    }, pointLight: function(r, n2, o2) {
      this.attr({ x: r, y: n2, z: o2 });
    }, spotLight: function(r, n2, o2, h2, c2, d2) {
      this.attr({ x: r, y: n2, z: o2, pointsAtX: h2, pointsAtY: c2, pointsAtZ: d2 });
    }, mergeNode: function(r) {
      this.attr("in", r);
    } };
    function a2(r) {
      return Array.isArray(r) && (r = new SVG.Array(r)), r.toString().replace(/^\s+/, "").replace(/\s+$/, "").replace(/\s+/g, " ");
    }
    function s2() {
      var r = function() {
      };
      for (var n2 in typeof arguments[arguments.length - 1] == "function" && (r = arguments[arguments.length - 1], Array.prototype.splice.call(arguments, arguments.length - 1, 1)), arguments)
        for (var o2 in arguments[n2])
          r(arguments[n2][o2], o2, arguments[n2]);
    }
    ["r", "g", "b", "a"].forEach(function(r) {
      i["Func" + r.toUpperCase()] = function(n2) {
        switch (this.attr("type", n2), n2) {
          case "table":
            this.attr("tableValues", arguments[1]);
            break;
          case "linear":
            this.attr("slope", arguments[1]), this.attr("intercept", arguments[2]);
            break;
          case "gamma":
            this.attr("amplitude", arguments[1]), this.attr("exponent", arguments[2]), this.attr("offset", arguments[2]);
        }
      };
    }), s2(e2, function(r, n2) {
      var o2 = n2.charAt(0).toUpperCase() + n2.slice(1);
      SVG[o2 + "Effect"] = SVG.invent({ create: function() {
        this.constructor.call(this, SVG.create("fe" + o2)), r.apply(this, arguments), this.result(this.attr("id") + "Out");
      }, inherit: SVG.Effect, extend: {} });
    }), s2(t2, function(r, n2) {
      var o2 = n2.charAt(0).toUpperCase() + n2.slice(1);
      SVG[o2 + "Effect"] = SVG.invent({ create: function() {
        this.constructor.call(this, SVG.create("fe" + o2)), r.apply(this, arguments), this.result(this.attr("id") + "Out");
      }, inherit: SVG.ParentEffect, extend: {} });
    }), s2(i, function(r, n2) {
      var o2 = n2.charAt(0).toUpperCase() + n2.slice(1);
      SVG[o2] = SVG.invent({ create: function() {
        this.constructor.call(this, SVG.create("fe" + o2)), r.apply(this, arguments);
      }, inherit: SVG.ChildEffect, extend: {} });
    }), SVG.extend(SVG.MergeEffect, { in: function(r) {
      return r instanceof SVG.MergeNode ? this.add(r, 0) : this.add(new SVG.MergeNode(r), 0), this;
    } }), SVG.extend(SVG.CompositeEffect, SVG.BlendEffect, SVG.DisplacementMapEffect, { in2: function(r) {
      return r == null ? this.parent() && this.parent().select('[result="' + this.attr("in2") + '"]').get(0) || this.attr("in2") : this.attr("in2", r);
    } }), SVG.filter = { sepiatone: [0.343, 0.669, 0.119, 0, 0, 0.249, 0.626, 0.13, 0, 0, 0.172, 0.334, 0.111, 0, 0, 0, 0, 0, 1, 0] };
  }).call(void 0), function() {
    function y2(s2, r, n2, o2, h2, c2, d2) {
      for (var g2 = s2.slice(r, n2 || d2), p2 = o2.slice(h2, c2 || d2), f2 = 0, b2 = { pos: [0, 0], start: [0, 0] }, m2 = { pos: [0, 0], start: [0, 0] }; g2[f2] = e2.call(b2, g2[f2]), p2[f2] = e2.call(m2, p2[f2]), g2[f2][0] != p2[f2][0] || g2[f2][0] == "M" || g2[f2][0] == "A" && (g2[f2][4] != p2[f2][4] || g2[f2][5] != p2[f2][5]) ? (Array.prototype.splice.apply(g2, [f2, 1].concat(i.call(b2, g2[f2]))), Array.prototype.splice.apply(p2, [f2, 1].concat(i.call(m2, p2[f2])))) : (g2[f2] = t2.call(b2, g2[f2]), p2[f2] = t2.call(m2, p2[f2])), !(++f2 == g2.length && f2 == p2.length); )
        f2 == g2.length && g2.push(["C", b2.pos[0], b2.pos[1], b2.pos[0], b2.pos[1], b2.pos[0], b2.pos[1]]), f2 == p2.length && p2.push(["C", m2.pos[0], m2.pos[1], m2.pos[0], m2.pos[1], m2.pos[0], m2.pos[1]]);
      return { start: g2, dest: p2 };
    }
    function e2(s2) {
      switch (s2[0]) {
        case "z":
        case "Z":
          s2[0] = "L", s2[1] = this.start[0], s2[2] = this.start[1];
          break;
        case "H":
          s2[0] = "L", s2[2] = this.pos[1];
          break;
        case "V":
          s2[0] = "L", s2[2] = s2[1], s2[1] = this.pos[0];
          break;
        case "T":
          s2[0] = "Q", s2[3] = s2[1], s2[4] = s2[2], s2[1] = this.reflection[1], s2[2] = this.reflection[0];
          break;
        case "S":
          s2[0] = "C", s2[6] = s2[4], s2[5] = s2[3], s2[4] = s2[2], s2[3] = s2[1], s2[2] = this.reflection[1], s2[1] = this.reflection[0];
      }
      return s2;
    }
    function t2(s2) {
      var r = s2.length;
      return this.pos = [s2[r - 2], s2[r - 1]], "SCQT".indexOf(s2[0]) != -1 && (this.reflection = [2 * this.pos[0] - s2[r - 4], 2 * this.pos[1] - s2[r - 3]]), s2;
    }
    function i(s2) {
      var r = [s2];
      switch (s2[0]) {
        case "M":
          return this.pos = this.start = [s2[1], s2[2]], r;
        case "L":
          s2[5] = s2[3] = s2[1], s2[6] = s2[4] = s2[2], s2[1] = this.pos[0], s2[2] = this.pos[1];
          break;
        case "Q":
          s2[6] = s2[4], s2[5] = s2[3], s2[4] = 1 * s2[4] / 3 + 2 * s2[2] / 3, s2[3] = 1 * s2[3] / 3 + 2 * s2[1] / 3, s2[2] = 1 * this.pos[1] / 3 + 2 * s2[2] / 3, s2[1] = 1 * this.pos[0] / 3 + 2 * s2[1] / 3;
          break;
        case "A":
          r = function(n2, o2) {
            var h2, c2, d2, g2, p2, f2, b2, m2, w2, A2, l2, u2, x2, v2, k2, S2, C2, L2, I2, z2, T2, E2, R2, O2, D2, W2, N2 = Math.abs(o2[1]), V2 = Math.abs(o2[2]), j2 = o2[3] % 360, se2 = o2[4], K2 = o2[5], le2 = o2[6], he2 = o2[7], $2 = new SVG.Point(n2), Q2 = new SVG.Point(le2, he2), dt2 = [];
            if (N2 === 0 || V2 === 0 || $2.x === Q2.x && $2.y === Q2.y)
              return [["C", $2.x, $2.y, Q2.x, Q2.y, Q2.x, Q2.y]];
            for (h2 = new SVG.Point(($2.x - Q2.x) / 2, ($2.y - Q2.y) / 2).transform(new SVG.Matrix().rotate(j2)), (c2 = h2.x * h2.x / (N2 * N2) + h2.y * h2.y / (V2 * V2)) > 1 && (N2 *= c2 = Math.sqrt(c2), V2 *= c2), d2 = new SVG.Matrix().rotate(j2).scale(1 / N2, 1 / V2).rotate(-j2), $2 = $2.transform(d2), Q2 = Q2.transform(d2), g2 = [Q2.x - $2.x, Q2.y - $2.y], f2 = g2[0] * g2[0] + g2[1] * g2[1], p2 = Math.sqrt(f2), g2[0] /= p2, g2[1] /= p2, b2 = f2 < 4 ? Math.sqrt(1 - f2 / 4) : 0, se2 === K2 && (b2 *= -1), m2 = new SVG.Point((Q2.x + $2.x) / 2 + b2 * -g2[1], (Q2.y + $2.y) / 2 + b2 * g2[0]), w2 = new SVG.Point($2.x - m2.x, $2.y - m2.y), A2 = new SVG.Point(Q2.x - m2.x, Q2.y - m2.y), l2 = Math.acos(w2.x / Math.sqrt(w2.x * w2.x + w2.y * w2.y)), w2.y < 0 && (l2 *= -1), u2 = Math.acos(A2.x / Math.sqrt(A2.x * A2.x + A2.y * A2.y)), A2.y < 0 && (u2 *= -1), K2 && l2 > u2 && (u2 += 2 * Math.PI), !K2 && l2 < u2 && (u2 -= 2 * Math.PI), v2 = Math.ceil(2 * Math.abs(l2 - u2) / Math.PI), S2 = [], C2 = l2, x2 = (u2 - l2) / v2, k2 = 4 * Math.tan(x2 / 4) / 3, T2 = 0; T2 <= v2; T2++)
              I2 = Math.cos(C2), L2 = Math.sin(C2), z2 = new SVG.Point(m2.x + I2, m2.y + L2), S2[T2] = [new SVG.Point(z2.x + k2 * L2, z2.y - k2 * I2), z2, new SVG.Point(z2.x - k2 * L2, z2.y + k2 * I2)], C2 += x2;
            for (S2[0][0] = S2[0][1].clone(), S2[S2.length - 1][2] = S2[S2.length - 1][1].clone(), d2 = new SVG.Matrix().rotate(j2).scale(N2, V2).rotate(-j2), T2 = 0, E2 = S2.length; T2 < E2; T2++)
              S2[T2][0] = S2[T2][0].transform(d2), S2[T2][1] = S2[T2][1].transform(d2), S2[T2][2] = S2[T2][2].transform(d2);
            for (T2 = 1, E2 = S2.length; T2 < E2; T2++)
              R2 = (z2 = S2[T2 - 1][2]).x, O2 = z2.y, D2 = (z2 = S2[T2][0]).x, W2 = z2.y, le2 = (z2 = S2[T2][1]).x, he2 = z2.y, dt2.push(["C", R2, O2, D2, W2, le2, he2]);
            return dt2;
          }(this.pos, s2), s2 = r[0];
      }
      return s2[0] = "C", this.pos = [s2[5], s2[6]], this.reflection = [2 * s2[5] - s2[3], 2 * s2[6] - s2[4]], r;
    }
    function a2(s2, r) {
      if (r === false)
        return false;
      for (var n2 = r, o2 = s2.length; n2 < o2; ++n2)
        if (s2[n2][0] == "M")
          return n2;
      return false;
    }
    SVG.extend(SVG.PathArray, { morph: function(s2) {
      for (var r = this.value, n2 = this.parse(s2), o2 = 0, h2 = 0, c2 = false, d2 = false; o2 !== false || h2 !== false; ) {
        var g2;
        c2 = a2(r, o2 !== false && o2 + 1), d2 = a2(n2, h2 !== false && h2 + 1), o2 === false && (o2 = (g2 = new SVG.PathArray(p2.start).bbox()).height == 0 || g2.width == 0 ? r.push(r[0]) - 1 : r.push(["M", g2.x + g2.width / 2, g2.y + g2.height / 2]) - 1), h2 === false && (h2 = (g2 = new SVG.PathArray(p2.dest).bbox()).height == 0 || g2.width == 0 ? n2.push(n2[0]) - 1 : n2.push(["M", g2.x + g2.width / 2, g2.y + g2.height / 2]) - 1);
        var p2 = y2(r, o2, c2, n2, h2, d2);
        r = r.slice(0, o2).concat(p2.start, c2 === false ? [] : r.slice(c2)), n2 = n2.slice(0, h2).concat(p2.dest, d2 === false ? [] : n2.slice(d2)), o2 = c2 !== false && o2 + p2.start.length, h2 = d2 !== false && h2 + p2.dest.length;
      }
      return this.value = r, this.destination = new SVG.PathArray(), this.destination.value = n2, this;
    } });
  }(), /*! svg.draggable.js - v2.2.2 - 2019-01-08
  * https://github.com/svgdotjs/svg.draggable.js
  * Copyright (c) 2019 Wout Fierens; Licensed MIT */
  (function() {
    function y2(e2) {
      e2.remember("_draggable", this), this.el = e2;
    }
    y2.prototype.init = function(e2, t2) {
      var i = this;
      this.constraint = e2, this.value = t2, this.el.on("mousedown.drag", function(a2) {
        i.start(a2);
      }), this.el.on("touchstart.drag", function(a2) {
        i.start(a2);
      });
    }, y2.prototype.transformPoint = function(e2, t2) {
      var i = (e2 = e2 || window.event).changedTouches && e2.changedTouches[0] || e2;
      return this.p.x = i.clientX - (t2 || 0), this.p.y = i.clientY, this.p.matrixTransform(this.m);
    }, y2.prototype.getBBox = function() {
      var e2 = this.el.bbox();
      return this.el instanceof SVG.Nested && (e2 = this.el.rbox()), (this.el instanceof SVG.G || this.el instanceof SVG.Use || this.el instanceof SVG.Nested) && (e2.x = this.el.x(), e2.y = this.el.y()), e2;
    }, y2.prototype.start = function(e2) {
      if (e2.type != "click" && e2.type != "mousedown" && e2.type != "mousemove" || (e2.which || e2.buttons) == 1) {
        var t2 = this;
        if (this.el.fire("beforedrag", { event: e2, handler: this }), !this.el.event().defaultPrevented) {
          e2.preventDefault(), e2.stopPropagation(), this.parent = this.parent || this.el.parent(SVG.Nested) || this.el.parent(SVG.Doc), this.p = this.parent.node.createSVGPoint(), this.m = this.el.node.getScreenCTM().inverse();
          var i, a2 = this.getBBox();
          if (this.el instanceof SVG.Text)
            switch (i = this.el.node.getComputedTextLength(), this.el.attr("text-anchor")) {
              case "middle":
                i /= 2;
                break;
              case "start":
                i = 0;
            }
          this.startPoints = { point: this.transformPoint(e2, i), box: a2, transform: this.el.transform() }, SVG.on(window, "mousemove.drag", function(s2) {
            t2.drag(s2);
          }), SVG.on(window, "touchmove.drag", function(s2) {
            t2.drag(s2);
          }), SVG.on(window, "mouseup.drag", function(s2) {
            t2.end(s2);
          }), SVG.on(window, "touchend.drag", function(s2) {
            t2.end(s2);
          }), this.el.fire("dragstart", { event: e2, p: this.startPoints.point, m: this.m, handler: this });
        }
      }
    }, y2.prototype.drag = function(e2) {
      var t2 = this.getBBox(), i = this.transformPoint(e2), a2 = this.startPoints.box.x + i.x - this.startPoints.point.x, s2 = this.startPoints.box.y + i.y - this.startPoints.point.y, r = this.constraint, n2 = i.x - this.startPoints.point.x, o2 = i.y - this.startPoints.point.y;
      if (this.el.fire("dragmove", { event: e2, p: i, m: this.m, handler: this }), this.el.event().defaultPrevented)
        return i;
      if (typeof r == "function") {
        var h2 = r.call(this.el, a2, s2, this.m);
        typeof h2 == "boolean" && (h2 = { x: h2, y: h2 }), h2.x === true ? this.el.x(a2) : h2.x !== false && this.el.x(h2.x), h2.y === true ? this.el.y(s2) : h2.y !== false && this.el.y(h2.y);
      } else
        typeof r == "object" && (r.minX != null && a2 < r.minX ? n2 = (a2 = r.minX) - this.startPoints.box.x : r.maxX != null && a2 > r.maxX - t2.width && (n2 = (a2 = r.maxX - t2.width) - this.startPoints.box.x), r.minY != null && s2 < r.minY ? o2 = (s2 = r.minY) - this.startPoints.box.y : r.maxY != null && s2 > r.maxY - t2.height && (o2 = (s2 = r.maxY - t2.height) - this.startPoints.box.y), r.snapToGrid != null && (a2 -= a2 % r.snapToGrid, s2 -= s2 % r.snapToGrid, n2 -= n2 % r.snapToGrid, o2 -= o2 % r.snapToGrid), this.el instanceof SVG.G ? this.el.matrix(this.startPoints.transform).transform({ x: n2, y: o2 }, true) : this.el.move(a2, s2));
      return i;
    }, y2.prototype.end = function(e2) {
      var t2 = this.drag(e2);
      this.el.fire("dragend", { event: e2, p: t2, m: this.m, handler: this }), SVG.off(window, "mousemove.drag"), SVG.off(window, "touchmove.drag"), SVG.off(window, "mouseup.drag"), SVG.off(window, "touchend.drag");
    }, SVG.extend(SVG.Element, { draggable: function(e2, t2) {
      typeof e2 != "function" && typeof e2 != "object" || (t2 = e2, e2 = true);
      var i = this.remember("_draggable") || new y2(this);
      return (e2 = e2 === void 0 || e2) ? i.init(t2 || {}, e2) : (this.off("mousedown.drag"), this.off("touchstart.drag")), this;
    } });
  }).call(void 0), function() {
    function y2(e2) {
      this.el = e2, e2.remember("_selectHandler", this), this.pointSelection = { isSelected: false }, this.rectSelection = { isSelected: false }, this.pointsList = { lt: [0, 0], rt: ["width", 0], rb: ["width", "height"], lb: [0, "height"], t: ["width", 0], r: ["width", "height"], b: ["width", "height"], l: [0, "height"] }, this.pointCoord = function(t2, i, a2) {
        var s2 = typeof t2 != "string" ? t2 : i[t2];
        return a2 ? s2 / 2 : s2;
      }, this.pointCoords = function(t2, i) {
        var a2 = this.pointsList[t2];
        return { x: this.pointCoord(a2[0], i, t2 === "t" || t2 === "b"), y: this.pointCoord(a2[1], i, t2 === "r" || t2 === "l") };
      };
    }
    y2.prototype.init = function(e2, t2) {
      var i = this.el.bbox();
      this.options = {};
      var a2 = this.el.selectize.defaults.points;
      for (var s2 in this.el.selectize.defaults)
        this.options[s2] = this.el.selectize.defaults[s2], t2[s2] !== void 0 && (this.options[s2] = t2[s2]);
      var r = ["points", "pointsExclude"];
      for (var s2 in r) {
        var n2 = this.options[r[s2]];
        typeof n2 == "string" ? n2 = n2.length > 0 ? n2.split(/\s*,\s*/i) : [] : typeof n2 == "boolean" && r[s2] === "points" && (n2 = n2 ? a2 : []), this.options[r[s2]] = n2;
      }
      this.options.points = [a2, this.options.points].reduce(function(o2, h2) {
        return o2.filter(function(c2) {
          return h2.indexOf(c2) > -1;
        });
      }), this.options.points = [this.options.points, this.options.pointsExclude].reduce(function(o2, h2) {
        return o2.filter(function(c2) {
          return h2.indexOf(c2) < 0;
        });
      }), this.parent = this.el.parent(), this.nested = this.nested || this.parent.group(), this.nested.matrix(new SVG.Matrix(this.el).translate(i.x, i.y)), this.options.deepSelect && ["line", "polyline", "polygon"].indexOf(this.el.type) !== -1 ? this.selectPoints(e2) : this.selectRect(e2), this.observe(), this.cleanup();
    }, y2.prototype.selectPoints = function(e2) {
      return this.pointSelection.isSelected = e2, this.pointSelection.set || (this.pointSelection.set = this.parent.set(), this.drawPoints()), this;
    }, y2.prototype.getPointArray = function() {
      var e2 = this.el.bbox();
      return this.el.array().valueOf().map(function(t2) {
        return [t2[0] - e2.x, t2[1] - e2.y];
      });
    }, y2.prototype.drawPoints = function() {
      for (var e2 = this, t2 = this.getPointArray(), i = 0, a2 = t2.length; i < a2; ++i) {
        var s2 = /* @__PURE__ */ function(n2) {
          return function(o2) {
            (o2 = o2 || window.event).preventDefault ? o2.preventDefault() : o2.returnValue = false, o2.stopPropagation();
            var h2 = o2.pageX || o2.touches[0].pageX, c2 = o2.pageY || o2.touches[0].pageY;
            e2.el.fire("point", { x: h2, y: c2, i: n2, event: o2 });
          };
        }(i), r = this.drawPoint(t2[i][0], t2[i][1]).addClass(this.options.classPoints).addClass(this.options.classPoints + "_point").on("touchstart", s2).on("mousedown", s2);
        this.pointSelection.set.add(r);
      }
    }, y2.prototype.drawPoint = function(e2, t2) {
      var i = this.options.pointType;
      switch (i) {
        case "circle":
          return this.drawCircle(e2, t2);
        case "rect":
          return this.drawRect(e2, t2);
        default:
          if (typeof i == "function")
            return i.call(this, e2, t2);
          throw new Error("Unknown " + i + " point type!");
      }
    }, y2.prototype.drawCircle = function(e2, t2) {
      return this.nested.circle(this.options.pointSize).center(e2, t2);
    }, y2.prototype.drawRect = function(e2, t2) {
      return this.nested.rect(this.options.pointSize, this.options.pointSize).center(e2, t2);
    }, y2.prototype.updatePointSelection = function() {
      var e2 = this.getPointArray();
      this.pointSelection.set.each(function(t2) {
        this.cx() === e2[t2][0] && this.cy() === e2[t2][1] || this.center(e2[t2][0], e2[t2][1]);
      });
    }, y2.prototype.updateRectSelection = function() {
      var e2 = this, t2 = this.el.bbox();
      if (this.rectSelection.set.get(0).attr({ width: t2.width, height: t2.height }), this.options.points.length && this.options.points.map(function(a2, s2) {
        var r = e2.pointCoords(a2, t2);
        e2.rectSelection.set.get(s2 + 1).center(r.x, r.y);
      }), this.options.rotationPoint) {
        var i = this.rectSelection.set.length();
        this.rectSelection.set.get(i - 1).center(t2.width / 2, 20);
      }
    }, y2.prototype.selectRect = function(e2) {
      var t2 = this, i = this.el.bbox();
      function a2(n2) {
        return function(o2) {
          (o2 = o2 || window.event).preventDefault ? o2.preventDefault() : o2.returnValue = false, o2.stopPropagation();
          var h2 = o2.pageX || o2.touches[0].pageX, c2 = o2.pageY || o2.touches[0].pageY;
          t2.el.fire(n2, { x: h2, y: c2, event: o2 });
        };
      }
      if (this.rectSelection.isSelected = e2, this.rectSelection.set = this.rectSelection.set || this.parent.set(), this.rectSelection.set.get(0) || this.rectSelection.set.add(this.nested.rect(i.width, i.height).addClass(this.options.classRect)), this.options.points.length && this.rectSelection.set.length() < 2 && (this.options.points.map(function(n2, o2) {
        var h2 = t2.pointCoords(n2, i), c2 = t2.drawPoint(h2.x, h2.y).attr("class", t2.options.classPoints + "_" + n2).on("mousedown", a2(n2)).on("touchstart", a2(n2));
        t2.rectSelection.set.add(c2);
      }), this.rectSelection.set.each(function() {
        this.addClass(t2.options.classPoints);
      })), this.options.rotationPoint && (this.options.points && !this.rectSelection.set.get(9) || !this.options.points && !this.rectSelection.set.get(1))) {
        var s2 = function(n2) {
          (n2 = n2 || window.event).preventDefault ? n2.preventDefault() : n2.returnValue = false, n2.stopPropagation();
          var o2 = n2.pageX || n2.touches[0].pageX, h2 = n2.pageY || n2.touches[0].pageY;
          t2.el.fire("rot", { x: o2, y: h2, event: n2 });
        }, r = this.drawPoint(i.width / 2, 20).attr("class", this.options.classPoints + "_rot").on("touchstart", s2).on("mousedown", s2);
        this.rectSelection.set.add(r);
      }
    }, y2.prototype.handler = function() {
      var e2 = this.el.bbox();
      this.nested.matrix(new SVG.Matrix(this.el).translate(e2.x, e2.y)), this.rectSelection.isSelected && this.updateRectSelection(), this.pointSelection.isSelected && this.updatePointSelection();
    }, y2.prototype.observe = function() {
      var e2 = this;
      if (MutationObserver)
        if (this.rectSelection.isSelected || this.pointSelection.isSelected)
          this.observerInst = this.observerInst || new MutationObserver(function() {
            e2.handler();
          }), this.observerInst.observe(this.el.node, { attributes: true });
        else
          try {
            this.observerInst.disconnect(), delete this.observerInst;
          } catch {
          }
      else
        this.el.off("DOMAttrModified.select"), (this.rectSelection.isSelected || this.pointSelection.isSelected) && this.el.on("DOMAttrModified.select", function() {
          e2.handler();
        });
    }, y2.prototype.cleanup = function() {
      !this.rectSelection.isSelected && this.rectSelection.set && (this.rectSelection.set.each(function() {
        this.remove();
      }), this.rectSelection.set.clear(), delete this.rectSelection.set), !this.pointSelection.isSelected && this.pointSelection.set && (this.pointSelection.set.each(function() {
        this.remove();
      }), this.pointSelection.set.clear(), delete this.pointSelection.set), this.pointSelection.isSelected || this.rectSelection.isSelected || (this.nested.remove(), delete this.nested);
    }, SVG.extend(SVG.Element, { selectize: function(e2, t2) {
      return typeof e2 == "object" && (t2 = e2, e2 = true), (this.remember("_selectHandler") || new y2(this)).init(e2 === void 0 || e2, t2 || {}), this;
    } }), SVG.Element.prototype.selectize.defaults = { points: ["lt", "rt", "rb", "lb", "t", "r", "b", "l"], pointsExclude: [], classRect: "svg_select_boundingRect", classPoints: "svg_select_points", pointSize: 7, rotationPoint: true, deepSelect: false, pointType: "circle" };
  }(), function() {
    (function() {
      function y2(e2) {
        e2.remember("_resizeHandler", this), this.el = e2, this.parameters = {}, this.lastUpdateCall = null, this.p = e2.doc().node.createSVGPoint();
      }
      y2.prototype.transformPoint = function(e2, t2, i) {
        return this.p.x = e2 - (this.offset.x - window.pageXOffset), this.p.y = t2 - (this.offset.y - window.pageYOffset), this.p.matrixTransform(i || this.m);
      }, y2.prototype._extractPosition = function(e2) {
        return { x: e2.clientX != null ? e2.clientX : e2.touches[0].clientX, y: e2.clientY != null ? e2.clientY : e2.touches[0].clientY };
      }, y2.prototype.init = function(e2) {
        var t2 = this;
        if (this.stop(), e2 !== "stop") {
          for (var i in this.options = {}, this.el.resize.defaults)
            this.options[i] = this.el.resize.defaults[i], e2[i] !== void 0 && (this.options[i] = e2[i]);
          this.el.on("lt.resize", function(a2) {
            t2.resize(a2 || window.event);
          }), this.el.on("rt.resize", function(a2) {
            t2.resize(a2 || window.event);
          }), this.el.on("rb.resize", function(a2) {
            t2.resize(a2 || window.event);
          }), this.el.on("lb.resize", function(a2) {
            t2.resize(a2 || window.event);
          }), this.el.on("t.resize", function(a2) {
            t2.resize(a2 || window.event);
          }), this.el.on("r.resize", function(a2) {
            t2.resize(a2 || window.event);
          }), this.el.on("b.resize", function(a2) {
            t2.resize(a2 || window.event);
          }), this.el.on("l.resize", function(a2) {
            t2.resize(a2 || window.event);
          }), this.el.on("rot.resize", function(a2) {
            t2.resize(a2 || window.event);
          }), this.el.on("point.resize", function(a2) {
            t2.resize(a2 || window.event);
          }), this.update();
        }
      }, y2.prototype.stop = function() {
        return this.el.off("lt.resize"), this.el.off("rt.resize"), this.el.off("rb.resize"), this.el.off("lb.resize"), this.el.off("t.resize"), this.el.off("r.resize"), this.el.off("b.resize"), this.el.off("l.resize"), this.el.off("rot.resize"), this.el.off("point.resize"), this;
      }, y2.prototype.resize = function(e2) {
        var t2 = this;
        this.m = this.el.node.getScreenCTM().inverse(), this.offset = { x: window.pageXOffset, y: window.pageYOffset };
        var i = this._extractPosition(e2.detail.event);
        if (this.parameters = { type: this.el.type, p: this.transformPoint(i.x, i.y), x: e2.detail.x, y: e2.detail.y, box: this.el.bbox(), rotation: this.el.transform().rotation }, this.el.type === "text" && (this.parameters.fontSize = this.el.attr()["font-size"]), e2.detail.i !== void 0) {
          var a2 = this.el.array().valueOf();
          this.parameters.i = e2.detail.i, this.parameters.pointCoords = [a2[e2.detail.i][0], a2[e2.detail.i][1]];
        }
        switch (e2.type) {
          case "lt":
            this.calc = function(s2, r) {
              var n2 = this.snapToGrid(s2, r);
              if (this.parameters.box.width - n2[0] > 0 && this.parameters.box.height - n2[1] > 0) {
                if (this.parameters.type === "text")
                  return this.el.move(this.parameters.box.x + n2[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - n2[0]);
                n2 = this.checkAspectRatio(n2), this.el.move(this.parameters.box.x + n2[0], this.parameters.box.y + n2[1]).size(this.parameters.box.width - n2[0], this.parameters.box.height - n2[1]);
              }
            };
            break;
          case "rt":
            this.calc = function(s2, r) {
              var n2 = this.snapToGrid(s2, r, 2);
              if (this.parameters.box.width + n2[0] > 0 && this.parameters.box.height - n2[1] > 0) {
                if (this.parameters.type === "text")
                  return this.el.move(this.parameters.box.x - n2[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + n2[0]);
                n2 = this.checkAspectRatio(n2, true), this.el.move(this.parameters.box.x, this.parameters.box.y + n2[1]).size(this.parameters.box.width + n2[0], this.parameters.box.height - n2[1]);
              }
            };
            break;
          case "rb":
            this.calc = function(s2, r) {
              var n2 = this.snapToGrid(s2, r, 0);
              if (this.parameters.box.width + n2[0] > 0 && this.parameters.box.height + n2[1] > 0) {
                if (this.parameters.type === "text")
                  return this.el.move(this.parameters.box.x - n2[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + n2[0]);
                n2 = this.checkAspectRatio(n2), this.el.move(this.parameters.box.x, this.parameters.box.y).size(this.parameters.box.width + n2[0], this.parameters.box.height + n2[1]);
              }
            };
            break;
          case "lb":
            this.calc = function(s2, r) {
              var n2 = this.snapToGrid(s2, r, 1);
              if (this.parameters.box.width - n2[0] > 0 && this.parameters.box.height + n2[1] > 0) {
                if (this.parameters.type === "text")
                  return this.el.move(this.parameters.box.x + n2[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - n2[0]);
                n2 = this.checkAspectRatio(n2, true), this.el.move(this.parameters.box.x + n2[0], this.parameters.box.y).size(this.parameters.box.width - n2[0], this.parameters.box.height + n2[1]);
              }
            };
            break;
          case "t":
            this.calc = function(s2, r) {
              var n2 = this.snapToGrid(s2, r, 2);
              if (this.parameters.box.height - n2[1] > 0) {
                if (this.parameters.type === "text")
                  return;
                this.el.move(this.parameters.box.x, this.parameters.box.y + n2[1]).height(this.parameters.box.height - n2[1]);
              }
            };
            break;
          case "r":
            this.calc = function(s2, r) {
              var n2 = this.snapToGrid(s2, r, 0);
              if (this.parameters.box.width + n2[0] > 0) {
                if (this.parameters.type === "text")
                  return;
                this.el.move(this.parameters.box.x, this.parameters.box.y).width(this.parameters.box.width + n2[0]);
              }
            };
            break;
          case "b":
            this.calc = function(s2, r) {
              var n2 = this.snapToGrid(s2, r, 0);
              if (this.parameters.box.height + n2[1] > 0) {
                if (this.parameters.type === "text")
                  return;
                this.el.move(this.parameters.box.x, this.parameters.box.y).height(this.parameters.box.height + n2[1]);
              }
            };
            break;
          case "l":
            this.calc = function(s2, r) {
              var n2 = this.snapToGrid(s2, r, 1);
              if (this.parameters.box.width - n2[0] > 0) {
                if (this.parameters.type === "text")
                  return;
                this.el.move(this.parameters.box.x + n2[0], this.parameters.box.y).width(this.parameters.box.width - n2[0]);
              }
            };
            break;
          case "rot":
            this.calc = function(s2, r) {
              var n2 = s2 + this.parameters.p.x, o2 = r + this.parameters.p.y, h2 = Math.atan2(this.parameters.p.y - this.parameters.box.y - this.parameters.box.height / 2, this.parameters.p.x - this.parameters.box.x - this.parameters.box.width / 2), c2 = Math.atan2(o2 - this.parameters.box.y - this.parameters.box.height / 2, n2 - this.parameters.box.x - this.parameters.box.width / 2), d2 = this.parameters.rotation + 180 * (c2 - h2) / Math.PI + this.options.snapToAngle / 2;
              this.el.center(this.parameters.box.cx, this.parameters.box.cy).rotate(d2 - d2 % this.options.snapToAngle, this.parameters.box.cx, this.parameters.box.cy);
            };
            break;
          case "point":
            this.calc = function(s2, r) {
              var n2 = this.snapToGrid(s2, r, this.parameters.pointCoords[0], this.parameters.pointCoords[1]), o2 = this.el.array().valueOf();
              o2[this.parameters.i][0] = this.parameters.pointCoords[0] + n2[0], o2[this.parameters.i][1] = this.parameters.pointCoords[1] + n2[1], this.el.plot(o2);
            };
        }
        this.el.fire("resizestart", { dx: this.parameters.x, dy: this.parameters.y, event: e2 }), SVG.on(window, "touchmove.resize", function(s2) {
          t2.update(s2 || window.event);
        }), SVG.on(window, "touchend.resize", function() {
          t2.done();
        }), SVG.on(window, "mousemove.resize", function(s2) {
          t2.update(s2 || window.event);
        }), SVG.on(window, "mouseup.resize", function() {
          t2.done();
        });
      }, y2.prototype.update = function(e2) {
        if (e2) {
          var t2 = this._extractPosition(e2), i = this.transformPoint(t2.x, t2.y), a2 = i.x - this.parameters.p.x, s2 = i.y - this.parameters.p.y;
          this.lastUpdateCall = [a2, s2], this.calc(a2, s2), this.el.fire("resizing", { dx: a2, dy: s2, event: e2 });
        } else
          this.lastUpdateCall && this.calc(this.lastUpdateCall[0], this.lastUpdateCall[1]);
      }, y2.prototype.done = function() {
        this.lastUpdateCall = null, SVG.off(window, "mousemove.resize"), SVG.off(window, "mouseup.resize"), SVG.off(window, "touchmove.resize"), SVG.off(window, "touchend.resize"), this.el.fire("resizedone");
      }, y2.prototype.snapToGrid = function(e2, t2, i, a2) {
        var s2;
        return a2 !== void 0 ? s2 = [(i + e2) % this.options.snapToGrid, (a2 + t2) % this.options.snapToGrid] : (i = i ?? 3, s2 = [(this.parameters.box.x + e2 + (1 & i ? 0 : this.parameters.box.width)) % this.options.snapToGrid, (this.parameters.box.y + t2 + (2 & i ? 0 : this.parameters.box.height)) % this.options.snapToGrid]), e2 < 0 && (s2[0] -= this.options.snapToGrid), t2 < 0 && (s2[1] -= this.options.snapToGrid), e2 -= Math.abs(s2[0]) < this.options.snapToGrid / 2 ? s2[0] : s2[0] - (e2 < 0 ? -this.options.snapToGrid : this.options.snapToGrid), t2 -= Math.abs(s2[1]) < this.options.snapToGrid / 2 ? s2[1] : s2[1] - (t2 < 0 ? -this.options.snapToGrid : this.options.snapToGrid), this.constraintToBox(e2, t2, i, a2);
      }, y2.prototype.constraintToBox = function(e2, t2, i, a2) {
        var s2, r, n2 = this.options.constraint || {};
        return a2 !== void 0 ? (s2 = i, r = a2) : (s2 = this.parameters.box.x + (1 & i ? 0 : this.parameters.box.width), r = this.parameters.box.y + (2 & i ? 0 : this.parameters.box.height)), n2.minX !== void 0 && s2 + e2 < n2.minX && (e2 = n2.minX - s2), n2.maxX !== void 0 && s2 + e2 > n2.maxX && (e2 = n2.maxX - s2), n2.minY !== void 0 && r + t2 < n2.minY && (t2 = n2.minY - r), n2.maxY !== void 0 && r + t2 > n2.maxY && (t2 = n2.maxY - r), [e2, t2];
      }, y2.prototype.checkAspectRatio = function(e2, t2) {
        if (!this.options.saveAspectRatio)
          return e2;
        var i = e2.slice(), a2 = this.parameters.box.width / this.parameters.box.height, s2 = this.parameters.box.width + e2[0], r = this.parameters.box.height - e2[1], n2 = s2 / r;
        return n2 < a2 ? (i[1] = s2 / a2 - this.parameters.box.height, t2 && (i[1] = -i[1])) : n2 > a2 && (i[0] = this.parameters.box.width - r * a2, t2 && (i[0] = -i[0])), i;
      }, SVG.extend(SVG.Element, { resize: function(e2) {
        return (this.remember("_resizeHandler") || new y2(this)).init(e2 || {}), this;
      } }), SVG.Element.prototype.resize.defaults = { snapToAngle: 0.1, snapToGrid: 1, constraint: {}, saveAspectRatio: false };
    }).call(this);
  }(), window.Apex === void 0 && (window.Apex = {});
  var ht2 = function() {
    function y2(e2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w;
    }
    return Y2(y2, [{ key: "initModules", value: function() {
      this.ctx.publicMethods = ["updateOptions", "updateSeries", "appendData", "appendSeries", "isSeriesHidden", "toggleSeries", "showSeries", "hideSeries", "setLocale", "resetSeries", "zoomX", "toggleDataPointSelection", "dataURI", "exportToCSV", "addXaxisAnnotation", "addYaxisAnnotation", "addPointAnnotation", "clearAnnotations", "removeAnnotation", "paper", "destroy"], this.ctx.eventList = ["click", "mousedown", "mousemove", "mouseleave", "touchstart", "touchmove", "touchleave", "mouseup", "touchend"], this.ctx.animations = new de2(this.ctx), this.ctx.axes = new mt2(this.ctx), this.ctx.core = new Gt2(this.ctx.el, this.ctx), this.ctx.config = new Le2({}), this.ctx.data = new Je(this.ctx), this.ctx.grid = new Qe(this.ctx), this.ctx.graphics = new M2(this.ctx), this.ctx.coreUtils = new q2(this.ctx), this.ctx.crosshairs = new We(this.ctx), this.ctx.events = new xt2(this.ctx), this.ctx.exports = new Ee(this.ctx), this.ctx.localization = new bt2(this.ctx), this.ctx.options = new G2(), this.ctx.responsive = new vt2(this.ctx), this.ctx.series = new te2(this.ctx), this.ctx.theme = new yt2(this.ctx), this.ctx.formatters = new re2(this.ctx), this.ctx.titleSubtitle = new wt2(this.ctx), this.ctx.legend = new Ke(this.ctx), this.ctx.toolbar = new et2(this.ctx), this.ctx.tooltip = new at2(this.ctx), this.ctx.dimensions = new Ye(this.ctx), this.ctx.updateHelpers = new Vt2(this.ctx), this.ctx.zoomPanSelection = new Pt2(this.ctx), this.ctx.w.globals.tooltip = new at2(this.ctx);
    } }]), y2;
  }(), ct2 = function() {
    function y2(e2) {
      F2(this, y2), this.ctx = e2, this.w = e2.w;
    }
    return Y2(y2, [{ key: "clear", value: function(e2) {
      var t2 = e2.isUpdating;
      this.ctx.zoomPanSelection && this.ctx.zoomPanSelection.destroy(), this.ctx.toolbar && this.ctx.toolbar.destroy(), this.ctx.animations = null, this.ctx.axes = null, this.ctx.annotations = null, this.ctx.core = null, this.ctx.data = null, this.ctx.grid = null, this.ctx.series = null, this.ctx.responsive = null, this.ctx.theme = null, this.ctx.formatters = null, this.ctx.titleSubtitle = null, this.ctx.legend = null, this.ctx.dimensions = null, this.ctx.options = null, this.ctx.crosshairs = null, this.ctx.zoomPanSelection = null, this.ctx.updateHelpers = null, this.ctx.toolbar = null, this.ctx.localization = null, this.ctx.w.globals.tooltip = null, this.clearDomElements({ isUpdating: t2 });
    } }, { key: "killSVG", value: function(e2) {
      e2.each(function(t2, i) {
        this.removeClass("*"), this.off(), this.stop();
      }, true), e2.ungroup(), e2.clear();
    } }, { key: "clearDomElements", value: function(e2) {
      var t2 = this, i = e2.isUpdating, a2 = this.w.globals.dom.Paper.node;
      a2.parentNode && a2.parentNode.parentNode && !i && (a2.parentNode.parentNode.style.minHeight = "unset");
      var s2 = this.w.globals.dom.baseEl;
      s2 && this.ctx.eventList.forEach(function(n2) {
        s2.removeEventListener(n2, t2.ctx.events.documentEvent);
      });
      var r = this.w.globals.dom;
      if (this.ctx.el !== null)
        for (; this.ctx.el.firstChild; )
          this.ctx.el.removeChild(this.ctx.el.firstChild);
      this.killSVG(r.Paper), r.Paper.remove(), r.elWrap = null, r.elGraphical = null, r.elLegendWrap = null, r.elLegendForeign = null, r.baseEl = null, r.elGridRect = null, r.elGridRectMask = null, r.elGridRectMarkerMask = null, r.elForecastMask = null, r.elNonForecastMask = null, r.elDefs = null;
    } }]), y2;
  }(), _e = /* @__PURE__ */ new WeakMap(), jt2 = function() {
    function y2(e2, t2) {
      F2(this, y2), this.opts = t2, this.ctx = this, this.w = new ft2(t2).init(), this.el = e2, this.w.globals.cuid = P2.randomId(), this.w.globals.chartID = this.w.config.chart.id ? P2.escapeString(this.w.config.chart.id) : this.w.globals.cuid, new ht2(this).initModules(), this.create = P2.bind(this.create, this), this.windowResizeHandler = this._windowResizeHandler.bind(this), this.parentResizeHandler = this._parentResizeCallback.bind(this);
    }
    return Y2(y2, [{ key: "render", value: function() {
      var e2 = this;
      return new Promise(function(t2, i) {
        if (e2.el !== null) {
          Apex._chartInstances === void 0 && (Apex._chartInstances = []), e2.w.config.chart.id && Apex._chartInstances.push({ id: e2.w.globals.chartID, group: e2.w.config.chart.group, chart: e2 }), e2.setLocale(e2.w.config.chart.defaultLocale);
          var a2 = e2.w.config.chart.events.beforeMount;
          if (typeof a2 == "function" && a2(e2, e2.w), e2.events.fireEvent("beforeMount", [e2, e2.w]), window.addEventListener("resize", e2.windowResizeHandler), function(g2, p2) {
            var f2 = false;
            if (g2.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
              var b2 = g2.getBoundingClientRect();
              g2.style.display !== "none" && b2.width !== 0 || (f2 = true);
            }
            var m2 = new ResizeObserver(function(w2) {
              f2 && p2.call(g2, w2), f2 = true;
            });
            g2.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? Array.from(g2.children).forEach(function(w2) {
              return m2.observe(w2);
            }) : m2.observe(g2), _e.set(p2, m2);
          }(e2.el.parentNode, e2.parentResizeHandler), !e2.css) {
            var s2 = e2.el.getRootNode && e2.el.getRootNode(), r = P2.is("ShadowRoot", s2), n2 = e2.el.ownerDocument, o2 = n2.getElementById("apexcharts-css");
            if (r || !o2) {
              var h2;
              e2.css = document.createElement("style"), e2.css.id = "apexcharts-css", e2.css.textContent = `@keyframes opaque {
  0% {
      opacity: 0
  }

  to {
      opacity: 1
  }
}

@keyframes resizeanim {
  0%,to {
      opacity: 0
  }
}

.apexcharts-canvas {
  position: relative;
  user-select: none
}

.apexcharts-canvas ::-webkit-scrollbar {
  -webkit-appearance: none;
  width: 6px
}

.apexcharts-canvas ::-webkit-scrollbar-thumb {
  border-radius: 4px;
  background-color: rgba(0,0,0,.5);
  box-shadow: 0 0 1px rgba(255,255,255,.5);
  -webkit-box-shadow: 0 0 1px rgba(255,255,255,.5)
}

.apexcharts-inner {
  position: relative
}

.apexcharts-text tspan {
  font-family: inherit
}

.legend-mouseover-inactive {
  transition: .15s ease all;
  opacity: .2
}

.apexcharts-legend-text {
  padding-left: 15px;
  margin-left: -15px;
}

.apexcharts-series-collapsed {
  opacity: 0
}

.apexcharts-tooltip {
  border-radius: 5px;
  box-shadow: 2px 2px 6px -4px #999;
  cursor: default;
  font-size: 14px;
  left: 62px;
  opacity: 0;
  pointer-events: none;
  position: absolute;
  top: 20px;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  white-space: nowrap;
  z-index: 12;
  transition: .15s ease all
}

.apexcharts-tooltip.apexcharts-active {
  opacity: 1;
  transition: .15s ease all
}

.apexcharts-tooltip.apexcharts-theme-light {
  border: 1px solid #e3e3e3;
  background: rgba(255,255,255,.96)
}

.apexcharts-tooltip.apexcharts-theme-dark {
  color: #fff;
  background: rgba(30,30,30,.8)
}

.apexcharts-tooltip * {
  font-family: inherit
}

.apexcharts-tooltip-title {
  padding: 6px;
  font-size: 15px;
  margin-bottom: 4px
}

.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {
  background: #eceff1;
  border-bottom: 1px solid #ddd
}

.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {
  background: rgba(0,0,0,.7);
  border-bottom: 1px solid #333
}

.apexcharts-tooltip-text-goals-value,.apexcharts-tooltip-text-y-value,.apexcharts-tooltip-text-z-value {
  display: inline-block;
  margin-left: 5px;
  font-weight: 600
}

.apexcharts-tooltip-text-goals-label:empty,.apexcharts-tooltip-text-goals-value:empty,.apexcharts-tooltip-text-y-label:empty,.apexcharts-tooltip-text-y-value:empty,.apexcharts-tooltip-text-z-value:empty,.apexcharts-tooltip-title:empty {
  display: none
}

.apexcharts-tooltip-text-goals-label,.apexcharts-tooltip-text-goals-value {
  padding: 6px 0 5px
}

.apexcharts-tooltip-goals-group,.apexcharts-tooltip-text-goals-label,.apexcharts-tooltip-text-goals-value {
  display: flex
}

.apexcharts-tooltip-text-goals-label:not(:empty),.apexcharts-tooltip-text-goals-value:not(:empty) {
  margin-top: -6px
}

.apexcharts-tooltip-marker {
  width: 12px;
  height: 12px;
  position: relative;
  top: 0;
  margin-right: 10px;
  border-radius: 50%
}

.apexcharts-tooltip-series-group {
  padding: 0 10px;
  display: none;
  text-align: left;
  justify-content: left;
  align-items: center
}

.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {
  opacity: 1
}

.apexcharts-tooltip-series-group.apexcharts-active,.apexcharts-tooltip-series-group:last-child {
  padding-bottom: 4px
}

.apexcharts-tooltip-series-group-hidden {
  opacity: 0;
  height: 0;
  line-height: 0;
  padding: 0!important
}

.apexcharts-tooltip-y-group {
  padding: 6px 0 5px
}

.apexcharts-custom-tooltip,.apexcharts-tooltip-box {
  padding: 4px 8px
}

.apexcharts-tooltip-boxPlot {
  display: flex;
  flex-direction: column-reverse
}

.apexcharts-tooltip-box>div {
  margin: 4px 0
}

.apexcharts-tooltip-box span.value {
  font-weight: 700
}

.apexcharts-tooltip-rangebar {
  padding: 5px 8px
}

.apexcharts-tooltip-rangebar .category {
  font-weight: 600;
  color: #777
}

.apexcharts-tooltip-rangebar .series-name {
  font-weight: 700;
  display: block;
  margin-bottom: 5px
}

.apexcharts-xaxistooltip,.apexcharts-yaxistooltip {
  opacity: 0;
  pointer-events: none;
  color: #373d3f;
  font-size: 13px;
  text-align: center;
  border-radius: 2px;
  position: absolute;
  z-index: 10;
  background: #eceff1;
  border: 1px solid #90a4ae
}

.apexcharts-xaxistooltip {
  padding: 9px 10px;
  transition: .15s ease all
}

.apexcharts-xaxistooltip.apexcharts-theme-dark {
  background: rgba(0,0,0,.7);
  border: 1px solid rgba(0,0,0,.5);
  color: #fff
}

.apexcharts-xaxistooltip:after,.apexcharts-xaxistooltip:before {
  left: 50%;
  border: solid transparent;
  content: " ";
  height: 0;
  width: 0;
  position: absolute;
  pointer-events: none
}

.apexcharts-xaxistooltip:after {
  border-color: transparent;
  border-width: 6px;
  margin-left: -6px
}

.apexcharts-xaxistooltip:before {
  border-color: transparent;
  border-width: 7px;
  margin-left: -7px
}

.apexcharts-xaxistooltip-bottom:after,.apexcharts-xaxistooltip-bottom:before {
  bottom: 100%
}

.apexcharts-xaxistooltip-top:after,.apexcharts-xaxistooltip-top:before {
  top: 100%
}

.apexcharts-xaxistooltip-bottom:after {
  border-bottom-color: #eceff1
}

.apexcharts-xaxistooltip-bottom:before {
  border-bottom-color: #90a4ae
}

.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after,.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {
  border-bottom-color: rgba(0,0,0,.5)
}

.apexcharts-xaxistooltip-top:after {
  border-top-color: #eceff1
}

.apexcharts-xaxistooltip-top:before {
  border-top-color: #90a4ae
}

.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after,.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {
  border-top-color: rgba(0,0,0,.5)
}

.apexcharts-xaxistooltip.apexcharts-active {
  opacity: 1;
  transition: .15s ease all
}

.apexcharts-yaxistooltip {
  padding: 4px 10px
}

.apexcharts-yaxistooltip.apexcharts-theme-dark {
  background: rgba(0,0,0,.7);
  border: 1px solid rgba(0,0,0,.5);
  color: #fff
}

.apexcharts-yaxistooltip:after,.apexcharts-yaxistooltip:before {
  top: 50%;
  border: solid transparent;
  content: " ";
  height: 0;
  width: 0;
  position: absolute;
  pointer-events: none
}

.apexcharts-yaxistooltip:after {
  border-color: transparent;
  border-width: 6px;
  margin-top: -6px
}

.apexcharts-yaxistooltip:before {
  border-color: transparent;
  border-width: 7px;
  margin-top: -7px
}

.apexcharts-yaxistooltip-left:after,.apexcharts-yaxistooltip-left:before {
  left: 100%
}

.apexcharts-yaxistooltip-right:after,.apexcharts-yaxistooltip-right:before {
  right: 100%
}

.apexcharts-yaxistooltip-left:after {
  border-left-color: #eceff1
}

.apexcharts-yaxistooltip-left:before {
  border-left-color: #90a4ae
}

.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after,.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {
  border-left-color: rgba(0,0,0,.5)
}

.apexcharts-yaxistooltip-right:after {
  border-right-color: #eceff1
}

.apexcharts-yaxistooltip-right:before {
  border-right-color: #90a4ae
}

.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after,.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {
  border-right-color: rgba(0,0,0,.5)
}

.apexcharts-yaxistooltip.apexcharts-active {
  opacity: 1
}

.apexcharts-yaxistooltip-hidden {
  display: none
}

.apexcharts-xcrosshairs,.apexcharts-ycrosshairs {
  pointer-events: none;
  opacity: 0;
  transition: .15s ease all
}

.apexcharts-xcrosshairs.apexcharts-active,.apexcharts-ycrosshairs.apexcharts-active {
  opacity: 1;
  transition: .15s ease all
}

.apexcharts-ycrosshairs-hidden {
  opacity: 0
}

.apexcharts-selection-rect {
  cursor: move
}

.svg_select_boundingRect,.svg_select_points_rot {
  pointer-events: none;
  opacity: 0;
  visibility: hidden
}

.apexcharts-selection-rect+g .svg_select_boundingRect,.apexcharts-selection-rect+g .svg_select_points_rot {
  opacity: 0;
  visibility: hidden
}

.apexcharts-selection-rect+g .svg_select_points_l,.apexcharts-selection-rect+g .svg_select_points_r {
  cursor: ew-resize;
  opacity: 1;
  visibility: visible
}

.svg_select_points {
  fill: #efefef;
  stroke: #333;
  rx: 2
}

.apexcharts-svg.apexcharts-zoomable.hovering-zoom {
  cursor: crosshair
}

.apexcharts-svg.apexcharts-zoomable.hovering-pan {
  cursor: move
}

.apexcharts-menu-icon,.apexcharts-pan-icon,.apexcharts-reset-icon,.apexcharts-selection-icon,.apexcharts-toolbar-custom-icon,.apexcharts-zoom-icon,.apexcharts-zoomin-icon,.apexcharts-zoomout-icon {
  cursor: pointer;
  width: 20px;
  height: 20px;
  line-height: 24px;
  color: #6e8192;
  text-align: center
}

.apexcharts-menu-icon svg,.apexcharts-reset-icon svg,.apexcharts-zoom-icon svg,.apexcharts-zoomin-icon svg,.apexcharts-zoomout-icon svg {
  fill: #6e8192
}

.apexcharts-selection-icon svg {
  fill: #444;
  transform: scale(.76)
}

.apexcharts-theme-dark .apexcharts-menu-icon svg,.apexcharts-theme-dark .apexcharts-pan-icon svg,.apexcharts-theme-dark .apexcharts-reset-icon svg,.apexcharts-theme-dark .apexcharts-selection-icon svg,.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg,.apexcharts-theme-dark .apexcharts-zoom-icon svg,.apexcharts-theme-dark .apexcharts-zoomin-icon svg,.apexcharts-theme-dark .apexcharts-zoomout-icon svg {
  fill: #f3f4f5
}

.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg,.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg {
  fill: #008ffb
}

.apexcharts-theme-light .apexcharts-menu-icon:hover svg,.apexcharts-theme-light .apexcharts-reset-icon:hover svg,.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,.apexcharts-theme-light .apexcharts-zoomin-icon:hover svg,.apexcharts-theme-light .apexcharts-zoomout-icon:hover svg {
  fill: #333
}

.apexcharts-menu-icon,.apexcharts-selection-icon {
  position: relative
}

.apexcharts-reset-icon {
  margin-left: 5px
}

.apexcharts-menu-icon,.apexcharts-reset-icon,.apexcharts-zoom-icon {
  transform: scale(.85)
}

.apexcharts-zoomin-icon,.apexcharts-zoomout-icon {
  transform: scale(.7)
}

.apexcharts-zoomout-icon {
  margin-right: 3px
}

.apexcharts-pan-icon {
  transform: scale(.62);
  position: relative;
  left: 1px;
  top: 0
}

.apexcharts-pan-icon svg {
  fill: #fff;
  stroke: #6e8192;
  stroke-width: 2
}

.apexcharts-pan-icon.apexcharts-selected svg {
  stroke: #008ffb
}

.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {
  stroke: #333
}

.apexcharts-toolbar {
  position: absolute;
  z-index: 11;
  max-width: 176px;
  text-align: right;
  border-radius: 3px;
  padding: 0 6px 2px;
  display: flex;
  justify-content: space-between;
  align-items: center
}

.apexcharts-menu {
  background: #fff;
  position: absolute;
  top: 100%;
  border: 1px solid #ddd;
  border-radius: 3px;
  padding: 3px;
  right: 10px;
  opacity: 0;
  min-width: 110px;
  transition: .15s ease all;
  pointer-events: none
}

.apexcharts-menu.apexcharts-menu-open {
  opacity: 1;
  pointer-events: all;
  transition: .15s ease all
}

.apexcharts-menu-item {
  padding: 6px 7px;
  font-size: 12px;
  cursor: pointer
}

.apexcharts-theme-light .apexcharts-menu-item:hover {
  background: #eee
}

.apexcharts-theme-dark .apexcharts-menu {
  background: rgba(0,0,0,.7);
  color: #fff
}

@media screen and (min-width:768px) {
  .apexcharts-canvas:hover .apexcharts-toolbar {
      opacity: 1
  }
}

.apexcharts-canvas .apexcharts-element-hidden,.apexcharts-datalabel.apexcharts-element-hidden,.apexcharts-hide .apexcharts-series-points {
  opacity: 0
}

.apexcharts-hidden-element-shown {
  opacity: 1;
  transition: 0.25s ease all;
}
.apexcharts-datalabel,.apexcharts-datalabel-label,.apexcharts-datalabel-value,.apexcharts-datalabels,.apexcharts-pie-label {
  cursor: default;
  pointer-events: none
}

.apexcharts-pie-label-delay {
  opacity: 0;
  animation-name: opaque;
  animation-duration: .3s;
  animation-fill-mode: forwards;
  animation-timing-function: ease
}

.apexcharts-radialbar-label {
  cursor: pointer;
}

.apexcharts-annotation-rect,.apexcharts-area-series .apexcharts-area,.apexcharts-area-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,.apexcharts-gridline,.apexcharts-line,.apexcharts-line-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,.apexcharts-point-annotation-label,.apexcharts-radar-series path,.apexcharts-radar-series polygon,.apexcharts-toolbar svg,.apexcharts-tooltip .apexcharts-marker,.apexcharts-xaxis-annotation-label,.apexcharts-yaxis-annotation-label,.apexcharts-zoom-rect {
  pointer-events: none
}

.apexcharts-marker {
  transition: .15s ease all
}

.resize-triggers {
  animation: 1ms resizeanim;
  visibility: hidden;
  opacity: 0;
  height: 100%;
  width: 100%;
  overflow: hidden
}

.contract-trigger:before,.resize-triggers,.resize-triggers>div {
  content: " ";
  display: block;
  position: absolute;
  top: 0;
  left: 0
}

.resize-triggers>div {
  height: 100%;
  width: 100%;
  background: #eee;
  overflow: auto
}

.contract-trigger:before {
  overflow: hidden;
  width: 200%;
  height: 200%
}

.apexcharts-bar-goals-markers{
  pointer-events: none
}

.apexcharts-bar-shadows{
  pointer-events: none
}

.apexcharts-rangebar-goals-markers{
  pointer-events: none
}`;
              var c2 = ((h2 = e2.opts.chart) === null || h2 === void 0 ? void 0 : h2.nonce) || e2.w.config.chart.nonce;
              c2 && e2.css.setAttribute("nonce", c2), r ? s2.prepend(e2.css) : n2.head.appendChild(e2.css);
            }
          }
          var d2 = e2.create(e2.w.config.series, {});
          if (!d2)
            return t2(e2);
          e2.mount(d2).then(function() {
            typeof e2.w.config.chart.events.mounted == "function" && e2.w.config.chart.events.mounted(e2, e2.w), e2.events.fireEvent("mounted", [e2, e2.w]), t2(d2);
          }).catch(function(g2) {
            i(g2);
          });
        } else
          i(new Error("Element not found"));
      });
    } }, { key: "create", value: function(e2, t2) {
      var i = this.w;
      new ht2(this).initModules();
      var a2 = this.w.globals;
      if (a2.noData = false, a2.animationEnded = false, this.responsive.checkResponsiveConfig(t2), i.config.xaxis.convertedCatToNumeric && new oe2(i.config).convertCatToNumericXaxis(i.config, this.ctx), this.el === null || (this.core.setupElements(), i.config.chart.type === "treemap" && (i.config.grid.show = false, i.config.yaxis[0].show = false), a2.svgWidth === 0))
        return a2.animationEnded = true, null;
      var s2 = q2.checkComboSeries(e2);
      a2.comboCharts = s2.comboCharts, a2.comboBarCount = s2.comboBarCount;
      var r = e2.every(function(c2) {
        return c2.data && c2.data.length === 0;
      });
      (e2.length === 0 || r) && this.series.handleNoData(), this.events.setupEventHandlers(), this.data.parseData(e2), this.theme.init(), new Pe(this).setGlobalMarkerSize(), this.formatters.setLabelFormatters(), this.titleSubtitle.draw(), a2.noData && a2.collapsedSeries.length !== a2.series.length && !i.config.legend.showForSingleSeries || this.legend.init(), this.series.hasAllSeriesEqualX(), a2.axisCharts && (this.core.coreCalculations(), i.config.xaxis.type !== "category" && this.formatters.setLabelFormatters(), this.ctx.toolbar.minX = i.globals.minX, this.ctx.toolbar.maxX = i.globals.maxX), this.formatters.heatmapLabelFormatters(), new q2(this).getLargestMarkerSize(), this.dimensions.plotCoords();
      var n2 = this.core.xySettings();
      this.grid.createGridMask();
      var o2 = this.core.plotChartType(e2, n2), h2 = new ye2(this);
      return h2.bringForward(), i.config.dataLabels.background.enabled && h2.dataLabelsBackground(), this.core.shiftGraphPosition(), { elGraph: o2, xyRatios: n2, dimensions: { plot: { left: i.globals.translateX, top: i.globals.translateY, width: i.globals.gridWidth, height: i.globals.gridHeight } } };
    } }, { key: "mount", value: function() {
      var e2 = this, t2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, i = this, a2 = i.w;
      return new Promise(function(s2, r) {
        if (i.el === null)
          return r(new Error("Not enough data to display or target element not found"));
        (t2 === null || a2.globals.allSeriesCollapsed) && i.series.handleNoData(), i.grid = new Qe(i);
        var n2, o2, h2 = i.grid.drawGrid();
        if (i.annotations = new ie2(i), i.annotations.drawImageAnnos(), i.annotations.drawTextAnnos(), a2.config.grid.position === "back" && (h2 && a2.globals.dom.elGraphical.add(h2.el), h2 != null && (n2 = h2.elGridBorders) !== null && n2 !== void 0 && n2.node && a2.globals.dom.elGraphical.add(h2.elGridBorders)), Array.isArray(t2.elGraph))
          for (var c2 = 0; c2 < t2.elGraph.length; c2++)
            a2.globals.dom.elGraphical.add(t2.elGraph[c2]);
        else
          a2.globals.dom.elGraphical.add(t2.elGraph);
        a2.config.grid.position === "front" && (h2 && a2.globals.dom.elGraphical.add(h2.el), h2 != null && (o2 = h2.elGridBorders) !== null && o2 !== void 0 && o2.node && a2.globals.dom.elGraphical.add(h2.elGridBorders)), a2.config.xaxis.crosshairs.position === "front" && i.crosshairs.drawXCrosshairs(), a2.config.yaxis[0].crosshairs.position === "front" && i.crosshairs.drawYCrosshairs(), a2.config.chart.type !== "treemap" && i.axes.drawAxis(a2.config.chart.type, h2);
        var d2 = new Ie(e2.ctx, h2), g2 = new Ne2(e2.ctx, h2);
        if (h2 !== null && (d2.xAxisLabelCorrections(h2.xAxisTickWidth), g2.setYAxisTextAlignments(), a2.config.yaxis.map(function(f2, b2) {
          a2.globals.ignoreYAxisIndexes.indexOf(b2) === -1 && g2.yAxisTitleRotate(b2, f2.opposite);
        })), i.annotations.drawAxesAnnotations(), !a2.globals.noData) {
          if (a2.config.tooltip.enabled && !a2.globals.noData && i.w.globals.tooltip.drawTooltip(t2.xyRatios), a2.globals.axisCharts && (a2.globals.isXNumeric || a2.config.xaxis.convertedCatToNumeric || a2.globals.isRangeBar))
            (a2.config.chart.zoom.enabled || a2.config.chart.selection && a2.config.chart.selection.enabled || a2.config.chart.pan && a2.config.chart.pan.enabled) && i.zoomPanSelection.init({ xyRatios: t2.xyRatios });
          else {
            var p2 = a2.config.chart.toolbar.tools;
            ["zoom", "zoomin", "zoomout", "selection", "pan", "reset"].forEach(function(f2) {
              p2[f2] = false;
            });
          }
          a2.config.chart.toolbar.show && !a2.globals.allSeriesCollapsed && i.toolbar.createToolbar();
        }
        a2.globals.memory.methodsToExec.length > 0 && a2.globals.memory.methodsToExec.forEach(function(f2) {
          f2.method(f2.params, false, f2.context);
        }), a2.globals.axisCharts || a2.globals.noData || i.core.resizeNonAxisCharts(), s2(i);
      });
    } }, { key: "destroy", value: function() {
      var e2, t2;
      window.removeEventListener("resize", this.windowResizeHandler), this.el.parentNode, e2 = this.parentResizeHandler, (t2 = _e.get(e2)) && (t2.disconnect(), _e.delete(e2));
      var i = this.w.config.chart.id;
      i && Apex._chartInstances.forEach(function(a2, s2) {
        a2.id === P2.escapeString(i) && Apex._chartInstances.splice(s2, 1);
      }), new ct2(this.ctx).clear({ isUpdating: false });
    } }, { key: "updateOptions", value: function(e2) {
      var t2 = this, i = arguments.length > 1 && arguments[1] !== void 0 && arguments[1], a2 = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2], s2 = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3], r = !(arguments.length > 4 && arguments[4] !== void 0) || arguments[4], n2 = this.w;
      return n2.globals.selection = void 0, e2.series && (this.series.resetSeries(false, true, false), e2.series.length && e2.series[0].data && (e2.series = e2.series.map(function(o2, h2) {
        return t2.updateHelpers._extendSeries(o2, h2);
      })), this.updateHelpers.revertDefaultAxisMinMax()), e2.xaxis && (e2 = this.updateHelpers.forceXAxisUpdate(e2)), e2.yaxis && (e2 = this.updateHelpers.forceYAxisUpdate(e2)), n2.globals.collapsedSeriesIndices.length > 0 && this.series.clearPreviousPaths(), e2.theme && (e2 = this.theme.updateThemeOptions(e2)), this.updateHelpers._updateOptions(e2, i, a2, s2, r);
    } }, { key: "updateSeries", value: function() {
      var e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t2 = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2];
      return this.series.resetSeries(false), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(e2, t2, i);
    } }, { key: "appendSeries", value: function(e2) {
      var t2 = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2], a2 = this.w.config.series.slice();
      return a2.push(e2), this.series.resetSeries(false), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(a2, t2, i);
    } }, { key: "appendData", value: function(e2) {
      var t2 = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = this;
      i.w.globals.dataChanged = true, i.series.getPreviousPaths();
      for (var a2 = i.w.config.series.slice(), s2 = 0; s2 < a2.length; s2++)
        if (e2[s2] !== null && e2[s2] !== void 0)
          for (var r = 0; r < e2[s2].data.length; r++)
            a2[s2].data.push(e2[s2].data[r]);
      return i.w.config.series = a2, t2 && (i.w.globals.initialSeries = P2.clone(i.w.config.series)), this.update();
    } }, { key: "update", value: function(e2) {
      var t2 = this;
      return new Promise(function(i, a2) {
        new ct2(t2.ctx).clear({ isUpdating: true });
        var s2 = t2.create(t2.w.config.series, e2);
        if (!s2)
          return i(t2);
        t2.mount(s2).then(function() {
          typeof t2.w.config.chart.events.updated == "function" && t2.w.config.chart.events.updated(t2, t2.w), t2.events.fireEvent("updated", [t2, t2.w]), t2.w.globals.isDirty = true, i(t2);
        }).catch(function(r) {
          a2(r);
        });
      });
    } }, { key: "getSyncedCharts", value: function() {
      var e2 = this.getGroupedCharts(), t2 = [this];
      return e2.length && (t2 = [], e2.forEach(function(i) {
        t2.push(i);
      })), t2;
    } }, { key: "getGroupedCharts", value: function() {
      var e2 = this;
      return Apex._chartInstances.filter(function(t2) {
        if (t2.group)
          return true;
      }).map(function(t2) {
        return e2.w.config.chart.group === t2.group ? t2.chart : e2;
      });
    } }, { key: "toggleSeries", value: function(e2) {
      return this.series.toggleSeries(e2);
    } }, { key: "highlightSeriesOnLegendHover", value: function(e2, t2) {
      return this.series.toggleSeriesOnHover(e2, t2);
    } }, { key: "showSeries", value: function(e2) {
      this.series.showSeries(e2);
    } }, { key: "hideSeries", value: function(e2) {
      this.series.hideSeries(e2);
    } }, { key: "isSeriesHidden", value: function(e2) {
      this.series.isSeriesHidden(e2);
    } }, { key: "resetSeries", value: function() {
      var e2 = !(arguments.length > 0 && arguments[0] !== void 0) || arguments[0], t2 = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
      this.series.resetSeries(e2, t2);
    } }, { key: "addEventListener", value: function(e2, t2) {
      this.events.addEventListener(e2, t2);
    } }, { key: "removeEventListener", value: function(e2, t2) {
      this.events.removeEventListener(e2, t2);
    } }, { key: "addXaxisAnnotation", value: function(e2) {
      var t2 = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0, a2 = this;
      i && (a2 = i), a2.annotations.addXaxisAnnotationExternal(e2, t2, a2);
    } }, { key: "addYaxisAnnotation", value: function(e2) {
      var t2 = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0, a2 = this;
      i && (a2 = i), a2.annotations.addYaxisAnnotationExternal(e2, t2, a2);
    } }, { key: "addPointAnnotation", value: function(e2) {
      var t2 = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0, a2 = this;
      i && (a2 = i), a2.annotations.addPointAnnotationExternal(e2, t2, a2);
    } }, { key: "clearAnnotations", value: function() {
      var e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0, t2 = this;
      e2 && (t2 = e2), t2.annotations.clearAnnotations(t2);
    } }, { key: "removeAnnotation", value: function(e2) {
      var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0, i = this;
      t2 && (i = t2), i.annotations.removeAnnotation(i, e2);
    } }, { key: "getChartArea", value: function() {
      return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner");
    } }, { key: "getSeriesTotalXRange", value: function(e2, t2) {
      return this.coreUtils.getSeriesTotalsXRange(e2, t2);
    } }, { key: "getHighestValueInSeries", value: function() {
      var e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return new De(this.ctx).getMinYMaxY(e2).highestY;
    } }, { key: "getLowestValueInSeries", value: function() {
      var e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return new De(this.ctx).getMinYMaxY(e2).lowestY;
    } }, { key: "getSeriesTotal", value: function() {
      return this.w.globals.seriesTotals;
    } }, { key: "toggleDataPointSelection", value: function(e2, t2) {
      return this.updateHelpers.toggleDataPointSelection(e2, t2);
    } }, { key: "zoomX", value: function(e2, t2) {
      this.ctx.toolbar.zoomUpdateOptions(e2, t2);
    } }, { key: "setLocale", value: function(e2) {
      this.localization.setCurrentLocaleValues(e2);
    } }, { key: "dataURI", value: function(e2) {
      return new Ee(this.ctx).dataURI(e2);
    } }, { key: "exportToCSV", value: function() {
      var e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return new Ee(this.ctx).exportToCSV(e2);
    } }, { key: "paper", value: function() {
      return this.w.globals.dom.Paper;
    } }, { key: "_parentResizeCallback", value: function() {
      this.w.globals.animationEnded && this.w.config.chart.redrawOnParentResize && this._windowResize();
    } }, { key: "_windowResize", value: function() {
      var e2 = this;
      clearTimeout(this.w.globals.resizeTimer), this.w.globals.resizeTimer = window.setTimeout(function() {
        e2.w.globals.resized = true, e2.w.globals.dataChanged = false, e2.ctx.update();
      }, 150);
    } }, { key: "_windowResizeHandler", value: function() {
      var e2 = this.w.config.chart.redrawOnWindowResize;
      typeof e2 == "function" && (e2 = e2()), e2 && this._windowResize();
    } }], [{ key: "getChartByID", value: function(e2) {
      var t2 = P2.escapeString(e2);
      if (Apex._chartInstances) {
        var i = Apex._chartInstances.filter(function(a2) {
          return a2.id === t2;
        })[0];
        return i && i.chart;
      }
    } }, { key: "initOnLoad", value: function() {
      for (var e2 = document.querySelectorAll("[data-apexcharts]"), t2 = 0; t2 < e2.length; t2++)
        new y2(e2[t2], JSON.parse(e2[t2].getAttribute("data-options"))).render();
    } }, { key: "exec", value: function(e2, t2) {
      var i = this.getChartByID(e2);
      if (i) {
        i.w.globals.isExecCalled = true;
        var a2 = null;
        if (i.publicMethods.indexOf(t2) !== -1) {
          for (var s2 = arguments.length, r = new Array(s2 > 2 ? s2 - 2 : 0), n2 = 2; n2 < s2; n2++)
            r[n2 - 2] = arguments[n2];
          a2 = i[t2].apply(i, r);
        }
        return a2;
      }
    } }, { key: "merge", value: function(e2, t2) {
      return P2.extend(e2, t2);
    } }]), y2;
  }();
  _2.exports = jt2;
})(Ue, Ue.exports);
var ti = Ue.exports;
const ut$1 = /* @__PURE__ */ ei(ti), pt$1 = [
  "animationEnd",
  "beforeMount",
  "mounted",
  "updated",
  "click",
  "mouseMove",
  "mouseLeave",
  "legendClick",
  "markerClick",
  "selection",
  "dataPointSelection",
  "dataPointMouseEnter",
  "dataPointMouseLeave",
  "beforeZoom",
  "beforeResetZoom",
  "zoomed",
  "scrolled",
  "brushScrolled"
], qe = /* @__PURE__ */ defineComponent({
  name: "apexchart",
  props: {
    options: {
      type: Object
    },
    type: {
      type: String
    },
    series: {
      type: Array,
      required: true
    },
    width: {
      default: "100%"
    },
    height: {
      default: "auto"
    }
  },
  // events emitted by this component
  emits: pt$1,
  setup(_2, { emit: Re }) {
    const Ae = ref(null), X2 = ref(null), U2 = (H4) => H4 && typeof H4 == "object" && !Array.isArray(H4) && H4 != null, F2 = (H4, G2) => {
      typeof Object.assign != "function" && function() {
        Object.assign = function(B3) {
          if (B3 == null)
            throw new TypeError("Cannot convert undefined or null to object");
          let re2 = Object(B3);
          for (let fe2 = 1; fe2 < arguments.length; fe2++) {
            let ne2 = arguments[fe2];
            if (ne2 != null)
              for (let oe2 in ne2)
                ne2.hasOwnProperty(oe2) && (re2[oe2] = ne2[oe2]);
          }
          return re2;
        };
      }();
      let ie2 = Object.assign({}, H4);
      return U2(H4) && U2(G2) && Object.keys(G2).forEach((B3) => {
        U2(G2[B3]) ? B3 in H4 ? ie2[B3] = F2(H4[B3], G2[B3]) : Object.assign(ie2, {
          [B3]: G2[B3]
        }) : Object.assign(ie2, {
          [B3]: G2[B3]
        });
      }), ie2;
    }, ce2 = async () => {
      if (await nextTick$1(), X2.value)
        return;
      const H4 = {
        chart: {
          type: _2.type || _2.options.chart.type || "line",
          height: _2.height,
          width: _2.width,
          events: {}
        },
        series: _2.series
      };
      pt$1.forEach((ie2) => {
        let B3 = (...re2) => Re(ie2, ...re2);
        H4.chart.events[ie2] = B3;
      });
      const G2 = F2(_2.options, H4);
      return X2.value = new ut$1(Ae.value, G2), X2.value.render();
    }, Y2 = () => (ee2(), ce2()), ee2 = () => {
      X2.value.destroy();
    }, ge2 = (H4, G2) => X2.value.updateSeries(H4, G2), me2 = (H4, G2, ie2, B3) => X2.value.updateOptions(H4, G2, ie2, B3), Se = (H4) => X2.value.toggleSeries(H4), ze = (H4) => {
      X2.value.showSeries(H4);
    }, ue2 = (H4) => {
      X2.value.hideSeries(H4);
    }, Me = (H4, G2) => X2.value.appendSeries(H4, G2), J2 = () => {
      X2.value.resetSeries();
    }, Xe = (H4, G2) => {
      X2.value.toggleDataPointSelection(H4, G2);
    }, Ce = (H4) => X2.value.appendData(H4), P2 = (H4, G2) => X2.value.zoomX(H4, G2), de2 = (H4) => X2.value.dataURI(H4), Z2 = (H4) => X2.value.setLocale(H4), M2 = (H4, G2) => {
      X2.value.addXaxisAnnotation(H4, G2);
    }, q2 = (H4, G2) => {
      X2.value.addYaxisAnnotation(H4, G2);
    }, ve2 = (H4, G2) => {
      X2.value.addPointAnnotation(H4, G2);
    }, Oe = (H4, G2) => {
      X2.value.removeAnnotation(H4, G2);
    }, He = () => {
      X2.value.clearAnnotations();
    };
    onBeforeMount(() => {
      window.ApexCharts = ut$1;
    }), onMounted(() => {
      Ae.value = getCurrentInstance().proxy.$el, ce2();
    }), onBeforeUnmount(() => {
      X2.value && ee2();
    });
    const pe2 = toRefs(_2);
    return watch(pe2.options, () => {
      !X2.value && _2.options ? ce2() : X2.value.updateOptions(_2.options);
    }), watch(
      pe2.series,
      () => {
        !X2.value && _2.series ? ce2() : X2.value.updateSeries(_2.series);
      },
      { deep: true }
    ), watch(pe2.type, () => {
      Y2();
    }), watch(pe2.width, () => {
      Y2();
    }), watch(pe2.height, () => {
      Y2();
    }), {
      chart: X2,
      init: ce2,
      refresh: Y2,
      destroy: ee2,
      updateOptions: me2,
      updateSeries: ge2,
      toggleSeries: Se,
      showSeries: ze,
      hideSeries: ue2,
      resetSeries: J2,
      zoomX: P2,
      toggleDataPointSelection: Xe,
      appendData: Ce,
      appendSeries: Me,
      addXaxisAnnotation: M2,
      addYaxisAnnotation: q2,
      addPointAnnotation: ve2,
      removeAnnotation: Oe,
      clearAnnotations: He,
      setLocale: Z2,
      dataURI: de2
    };
  },
  render() {
    return h$1("div", {
      class: "vue-apexcharts"
    });
  }
}), ii = (_2) => {
  _2.component(qe.name, qe);
};
qe.install = ii;
const QForm = createComponent({
  name: "QForm",
  props: {
    autofocus: Boolean,
    noErrorFocus: Boolean,
    noResetFocus: Boolean,
    greedy: Boolean,
    onSubmit: Function
  },
  emits: ["reset", "validationSuccess", "validationError"],
  setup(props2, { slots, emit: emit2 }) {
    const vm2 = getCurrentInstance();
    const rootRef = ref(null);
    let validateIndex = 0;
    const registeredComponents = [];
    function validate(shouldFocus) {
      const focus2 = typeof shouldFocus === "boolean" ? shouldFocus : props2.noErrorFocus !== true;
      const index = ++validateIndex;
      const emitEvent = (res, ref2) => {
        emit2(`validation${res === true ? "Success" : "Error"}`, ref2);
      };
      const validateComponent = (comp) => {
        const valid = comp.validate();
        return typeof valid.then === "function" ? valid.then(
          (valid2) => ({ valid: valid2, comp }),
          (err) => ({ valid: false, comp, err })
        ) : Promise.resolve({ valid, comp });
      };
      const errorsPromise = props2.greedy === true ? Promise.all(registeredComponents.map(validateComponent)).then((res) => res.filter((r) => r.valid !== true)) : registeredComponents.reduce(
        (acc, comp) => acc.then(() => {
          return validateComponent(comp).then((r) => {
            if (r.valid === false) {
              return Promise.reject(r);
            }
          });
        }),
        Promise.resolve()
      ).catch((error) => [error]);
      return errorsPromise.then((errors) => {
        if (errors === void 0 || errors.length === 0) {
          index === validateIndex && emitEvent(true);
          return true;
        }
        if (index === validateIndex) {
          const { comp, err } = errors[0];
          err !== void 0 && console.error(err);
          emitEvent(false, comp);
          if (focus2 === true) {
            const activeError = errors.find(({ comp: comp2 }) => typeof comp2.focus === "function" && vmIsDestroyed(comp2.$) === false);
            if (activeError !== void 0) {
              activeError.comp.focus();
            }
          }
        }
        return false;
      });
    }
    function resetValidation() {
      validateIndex++;
      registeredComponents.forEach((comp) => {
        typeof comp.resetValidation === "function" && comp.resetValidation();
      });
    }
    function submit(evt) {
      evt !== void 0 && stopAndPrevent(evt);
      const index = validateIndex + 1;
      validate().then((val) => {
        if (index === validateIndex && val === true) {
          if (props2.onSubmit !== void 0) {
            emit2("submit", evt);
          } else if (evt !== void 0 && evt.target !== void 0 && typeof evt.target.submit === "function") {
            evt.target.submit();
          }
        }
      });
    }
    function reset(evt) {
      evt !== void 0 && stopAndPrevent(evt);
      emit2("reset");
      nextTick$1(() => {
        resetValidation();
        if (props2.autofocus === true && props2.noResetFocus !== true) {
          focus();
        }
      });
    }
    function focus() {
      addFocusFn(() => {
        if (rootRef.value === null) return;
        const target2 = rootRef.value.querySelector("[autofocus][tabindex], [data-autofocus][tabindex]") || rootRef.value.querySelector("[autofocus] [tabindex], [data-autofocus] [tabindex]") || rootRef.value.querySelector("[autofocus], [data-autofocus]") || Array.prototype.find.call(rootRef.value.querySelectorAll("[tabindex]"), (el) => el.tabIndex !== -1);
        target2 !== null && target2 !== void 0 && target2.focus({ preventScroll: true });
      });
    }
    provide(formKey, {
      bindComponent(vmProxy) {
        registeredComponents.push(vmProxy);
      },
      unbindComponent(vmProxy) {
        const index = registeredComponents.indexOf(vmProxy);
        if (index !== -1) {
          registeredComponents.splice(index, 1);
        }
      }
    });
    let shouldActivate = false;
    onDeactivated(() => {
      shouldActivate = true;
    });
    onActivated(() => {
      shouldActivate === true && props2.autofocus === true && focus();
    });
    onMounted(() => {
      props2.autofocus === true && focus();
    });
    Object.assign(vm2.proxy, {
      validate,
      resetValidation,
      submit,
      reset,
      focus,
      getValidationComponents: () => registeredComponents
    });
    return () => h$1("form", {
      class: "q-form",
      ref: rootRef,
      onSubmit: submit,
      onReset: reset
    }, hSlot(slots.default));
  }
});
const _imports_0 = "/assets/logo-CWmRKnZA.ico";
function useQuasar() {
  return inject(quasarKey);
}
class InvalidTokenError extends Error {
}
InvalidTokenError.prototype.name = "InvalidTokenError";
function b64DecodeUnicode(str) {
  return decodeURIComponent(atob(str).replace(/(.)/g, (m2, p2) => {
    let code = p2.charCodeAt(0).toString(16).toUpperCase();
    if (code.length < 2) {
      code = "0" + code;
    }
    return "%" + code;
  }));
}
function base64UrlDecode(str) {
  let output = str.replace(/-/g, "+").replace(/_/g, "/");
  switch (output.length % 4) {
    case 0:
      break;
    case 2:
      output += "==";
      break;
    case 3:
      output += "=";
      break;
    default:
      throw new Error("base64 string is not of the correct length");
  }
  try {
    return b64DecodeUnicode(output);
  } catch (err) {
    return atob(output);
  }
}
function jwtDecode(token2, options) {
  if (typeof token2 !== "string") {
    throw new InvalidTokenError("Invalid token specified: must be a string");
  }
  options || (options = {});
  const pos = options.header === true ? 0 : 1;
  const part = token2.split(".")[pos];
  if (typeof part !== "string") {
    throw new InvalidTokenError(`Invalid token specified: missing part #${pos + 1}`);
  }
  let decoded;
  try {
    decoded = base64UrlDecode(part);
  } catch (e2) {
    throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${pos + 1} (${e2.message})`);
  }
  try {
    return JSON.parse(decoded);
  } catch (e2) {
    throw new InvalidTokenError(`Invalid token specified: invalid json for part #${pos + 1} (${e2.message})`);
  }
}
/*! js-cookie v3.0.5 | MIT */
function assign$1(target2) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      target2[key] = source[key];
    }
  }
  return target2;
}
var defaultConverter = {
  read: function(value2) {
    if (value2[0] === '"') {
      value2 = value2.slice(1, -1);
    }
    return value2.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
  },
  write: function(value2) {
    return encodeURIComponent(value2).replace(
      /%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,
      decodeURIComponent
    );
  }
};
function init(converter, defaultAttributes) {
  function set2(name, value2, attributes) {
    if (typeof document === "undefined") {
      return;
    }
    attributes = assign$1({}, defaultAttributes, attributes);
    if (typeof attributes.expires === "number") {
      attributes.expires = new Date(Date.now() + attributes.expires * 864e5);
    }
    if (attributes.expires) {
      attributes.expires = attributes.expires.toUTCString();
    }
    name = encodeURIComponent(name).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
    var stringifiedAttributes = "";
    for (var attributeName in attributes) {
      if (!attributes[attributeName]) {
        continue;
      }
      stringifiedAttributes += "; " + attributeName;
      if (attributes[attributeName] === true) {
        continue;
      }
      stringifiedAttributes += "=" + attributes[attributeName].split(";")[0];
    }
    return document.cookie = name + "=" + converter.write(value2, name) + stringifiedAttributes;
  }
  function get2(name) {
    if (typeof document === "undefined" || arguments.length && !name) {
      return;
    }
    var cookies2 = document.cookie ? document.cookie.split("; ") : [];
    var jar = {};
    for (var i = 0; i < cookies2.length; i++) {
      var parts2 = cookies2[i].split("=");
      var value2 = parts2.slice(1).join("=");
      try {
        var found = decodeURIComponent(parts2[0]);
        jar[found] = converter.read(value2, found);
        if (name === found) {
          break;
        }
      } catch (e2) {
      }
    }
    return name ? jar[name] : jar;
  }
  return Object.create(
    {
      set: set2,
      get: get2,
      remove: function(name, attributes) {
        set2(
          name,
          "",
          assign$1({}, attributes, {
            expires: -1
          })
        );
      },
      withAttributes: function(attributes) {
        return init(this.converter, assign$1({}, this.attributes, attributes));
      },
      withConverter: function(converter2) {
        return init(assign$1({}, this.converter, converter2), this.attributes);
      }
    },
    {
      attributes: { value: Object.freeze(defaultAttributes) },
      converter: { value: Object.freeze(converter) }
    }
  );
}
var api = init(defaultConverter, { path: "/" });
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}
const { toString: toString$1 } = Object.prototype;
const { getPrototypeOf } = Object;
const kindOf = /* @__PURE__ */ ((cache2) => (thing) => {
  const str = toString$1.call(thing);
  return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
const typeOfTest = (type) => (thing) => typeof thing === type;
const { isArray: isArray$1 } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString = typeOfTest("string");
const isFunction = typeOfTest("function");
const isNumber = typeOfTest("number");
const isObject$1 = (thing) => thing !== null && typeof thing === "object";
const isBoolean = (thing) => thing === true || thing === false;
const isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
const isDate = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject$1(val) && isFunction(val.pipe);
const isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l2;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray$1(obj)) {
    for (i = 0, l2 = obj.length; i < l2; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray$1(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l2 = arguments.length; i < l2; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
const extend = (a2, b2, thisArg, { allOwnKeys } = {}) => {
  forEach(b2, (val, key) => {
    if (thisArg && isFunction(val)) {
      a2[key] = bind(val, thisArg);
    } else {
      a2[key] = val;
    }
  }, { allOwnKeys });
  return a2;
};
const stripBOM = (content2) => {
  if (content2.charCodeAt(0) === 65279) {
    content2 = content2.slice(1);
  }
  return content2;
};
const inherits = (constructor, superConstructor, props2, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props2 && Object.assign(constructor.prototype, props2);
};
const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props2;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props2 = Object.getOwnPropertyNames(sourceObj);
    i = props2.length;
    while (i-- > 0) {
      prop = props2[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str, searchString, position2) => {
  str = String(str);
  if (position2 === void 0 || position2 > str.length) {
    position2 = str.length;
  }
  position2 -= searchString.length;
  const lastIndex = str.indexOf(searchString, position2);
  return lastIndex !== -1 && lastIndex === position2;
};
const toArray$1 = (thing) => {
  if (!thing) return null;
  if (isArray$1(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
const isTypedArray = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str) => {
  let matches2;
  const arr = [];
  while ((matches2 = regExp.exec(str)) !== null) {
    arr.push(matches2);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer2(m2, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value2 = obj[name];
    if (!isFunction(value2)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value2) => {
      obj[value2] = true;
    });
  };
  isArray$1(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
const noop$1 = () => {
};
const toFiniteNumber = (value2, defaultValue) => {
  return value2 != null && Number.isFinite(value2 = +value2) ? value2 : defaultValue;
};
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size2 = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet;
  while (size2--) {
    str += alphabet[Math.random() * length | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
const toJSONObject = (obj) => {
  const stack2 = new Array(10);
  const visit = (source, i) => {
    if (isObject$1(source)) {
      if (stack2.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack2[i] = source;
        const target2 = isArray$1(source) ? [] : {};
        forEach(source, (value2, key) => {
          const reducedValue = visit(value2, i + 1);
          !isUndefined(reducedValue) && (target2[key] = reducedValue);
        });
        stack2[i] = void 0;
        return target2;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing) => thing && (isObject$1(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
const utils$1 = {
  isArray: isArray$1,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject: isObject$1,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray: toArray$1,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop$1,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}
utils$1.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$1.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const prototype$1 = AxiosError.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils$1.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
const httpAdapter = null;
function isVisitable(thing) {
  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
}
function removeBrackets(key) {
  return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token2, i) {
    token2 = removeBrackets(token2);
    return !dots && i ? "[" + token2 + "]" : token2;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils$1.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils$1.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new FormData();
  options = utils$1.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils$1.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
  if (!utils$1.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value2) {
    if (value2 === null) return "";
    if (utils$1.isDate(value2)) {
      return value2.toISOString();
    }
    if (!useBlob && utils$1.isBlob(value2)) {
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    }
    if (utils$1.isArrayBuffer(value2) || utils$1.isTypedArray(value2)) {
      return useBlob && typeof Blob === "function" ? new Blob([value2]) : Buffer.from(value2);
    }
    return value2;
  }
  function defaultVisitor(value2, key, path) {
    let arr = value2;
    if (value2 && !path && typeof value2 === "object") {
      if (utils$1.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value2 = JSON.stringify(value2);
      } else if (utils$1.isArray(value2) && isFlatArray(value2) || (utils$1.isFileList(value2) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value2))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils$1.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value2)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value2));
    return false;
  }
  const stack2 = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value2, path) {
    if (utils$1.isUndefined(value2)) return;
    if (stack2.indexOf(value2) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack2.push(value2);
    utils$1.forEach(value2, function each(el, key) {
      const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils$1.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack2.pop();
  }
  if (!utils$1.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
function encode$2(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer2(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name, value2) {
  this._pairs.push([name, value2]);
};
prototype.toString = function toString(encoder) {
  const _encode = encoder ? function(value2) {
    return encoder.call(this, value2, encode$2);
  } : encode$2;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode$1(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url2, params, options) {
  if (!params) {
    return url2;
  }
  const _encode = options && options.encode || encode$1;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url2.indexOf("#");
    if (hashmarkIndex !== -1) {
      url2 = url2.slice(0, hashmarkIndex);
    }
    url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url2;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id2) {
    if (this.handlers[id2]) {
      this.handlers[id2] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils$1.forEach(this.handlers, function forEachHandler(h2) {
      if (h2 !== null) {
        fn(h2);
      }
    });
  }
}
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
const platform$1 = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
const hasStandardBrowserEnv = ((product) => {
  return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
})(typeof navigator !== "undefined" && navigator.product);
const hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const origin = hasBrowserEnv && window.location.href || "http://localhost";
const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv,
  origin
}, Symbol.toStringTag, { value: "Module" }));
const platform = {
  ...utils,
  ...platform$1
};
function toURLEncodedForm(data, options) {
  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value2, key, path, helpers) {
      if (platform.isNode && utils$1.isBuffer(value2)) {
        this.append(key, value2.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
function parsePropPath(name) {
  return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value2, target2, index) {
    let name = path[index++];
    if (name === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils$1.isArray(target2) ? target2.length : name;
    if (isLast) {
      if (utils$1.hasOwnProp(target2, name)) {
        target2[name] = [target2[name], value2];
      } else {
        target2[name] = value2;
      }
      return !isNumericKey;
    }
    if (!target2[name] || !utils$1.isObject(target2[name])) {
      target2[name] = [];
    }
    const result = buildPath(path, value2, target2[name], index);
    if (result && utils$1.isArray(target2[name])) {
      target2[name] = arrayToObject(target2[name]);
    }
    return !isNumericKey;
  }
  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
    const obj = {};
    utils$1.forEachEntry(formData, (name, value2) => {
      buildPath(parsePropPath(name), value2, obj, 0);
    });
    return obj;
  }
  return null;
}
function stringifySafely(rawValue, parser2, encoder) {
  if (utils$1.isString(rawValue)) {
    try {
      (parser2 || JSON.parse)(rawValue);
      return utils$1.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
const defaults = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils$1.isObject(data);
    if (isObjectPayload && utils$1.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils$1.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }
    if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
      return data;
    }
    if (utils$1.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$1.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
      return data;
    }
    if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw AxiosError.from(e2, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e2;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
const ignoreDuplicateOf = utils$1.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser2(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value2) {
  if (value2 === false || value2 == null) {
    return value2;
  }
  return utils$1.isArray(value2) ? value2.map(normalizeValue) : String(value2);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value2, header, filter2, isHeaderNameFilter) {
  if (utils$1.isFunction(filter2)) {
    return filter2.call(this, value2, header);
  }
  if (isHeaderNameFilter) {
    value2 = header;
  }
  if (!utils$1.isString(value2)) return;
  if (utils$1.isString(filter2)) {
    return value2.indexOf(filter2) !== -1;
  }
  if (utils$1.isRegExp(filter2)) {
    return filter2.test(value2);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils$1.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils$1.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else if (utils$1.isHeaders(header)) {
      for (const [key, value2] of header.entries()) {
        setHeader(value2, key, rewrite);
      }
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser2) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$1.findKey(this, header);
      if (key) {
        const value2 = this[key];
        if (!parser2) {
          return value2;
        }
        if (parser2 === true) {
          return parseTokens(value2);
        }
        if (utils$1.isFunction(parser2)) {
          return parser2.call(this, value2, key);
        }
        if (utils$1.isRegExp(parser2)) {
          return parser2.exec(value2);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$1.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils$1.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils$1.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key = keys[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils$1.forEach(this, (value2, header) => {
      const key = utils$1.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value2);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value2);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils$1.forEach(this, (value2, header) => {
      value2 != null && value2 !== false && (obj[header] = asStrings && utils$1.isArray(value2) ? value2.join(", ") : value2);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value2]) => header + ": " + value2).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed2 = new this(first);
    targets.forEach((target2) => computed2.set(target2));
    return computed2;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value: value2 }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value2,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils$1.freezeMethods(AxiosHeaders);
function transformData(fns, response) {
  const config = this || defaults;
  const context = response || config;
  const headers = AxiosHeaders.from(context.headers);
  let data = context.data;
  utils$1.forEach(fns, function transform2(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}
function isCancel(value2) {
  return !!(value2 && value2.__CANCEL__);
}
function CanceledError(message, config, request) {
  AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils$1.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});
function settle(resolve2, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve2(response);
  } else {
    reject(new AxiosError(
      "Request failed with status code " + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
function parseProtocol(url2) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
  return match && match[1] || "";
}
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function throttle(fn, freq) {
  let timestamp = 0;
  const threshold = 1e3 / freq;
  let timer = null;
  return function throttled() {
    const force = this === true;
    const now = Date.now();
    if (force || now - timestamp > threshold) {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      timestamp = now;
      return fn.apply(null, arguments);
    }
    if (!timer) {
      timer = setTimeout(() => {
        timer = null;
        timestamp = Date.now();
        return fn.apply(null, arguments);
      }, threshold - (now - timestamp));
    }
  };
}
const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return throttle((e2) => {
    const loaded = e2.loaded;
    const total = e2.lengthComputable ? e2.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e2,
      lengthComputable: total != null
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener(data);
  }, freq);
};
const isURLSameOrigin = platform.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url2) {
      let href2 = url2;
      if (msie) {
        urlParsingNode.setAttribute("href", href2);
        href2 = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href2);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin2(requestURL) {
      const parsed = utils$1.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function nonStandardBrowserEnv() {
    return function isURLSameOrigin2() {
      return true;
    };
  }()
);
const cookies = platform.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value2, expires, path, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value2)];
      utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils$1.isString(path) && cookie.push("path=" + path);
      utils$1.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function isAbsoluteURL(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
const headersToObject = (thing) => thing instanceof AxiosHeaders ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target2, source, caseless) {
    if (utils$1.isPlainObject(target2) && utils$1.isPlainObject(source)) {
      return utils$1.merge.call({ caseless }, target2, source);
    } else if (utils$1.isPlainObject(source)) {
      return utils$1.merge({}, source);
    } else if (utils$1.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a2, b2, caseless) {
    if (!utils$1.isUndefined(b2)) {
      return getMergedValue(a2, b2, caseless);
    } else if (!utils$1.isUndefined(a2)) {
      return getMergedValue(void 0, a2, caseless);
    }
  }
  function valueFromConfig2(a2, b2) {
    if (!utils$1.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    }
  }
  function defaultToConfig2(a2, b2) {
    if (!utils$1.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    } else if (!utils$1.isUndefined(a2)) {
      return getMergedValue(void 0, a2);
    }
  }
  function mergeDirectKeys(a2, b2, prop) {
    if (prop in config2) {
      return getMergedValue(a2, b2);
    } else if (prop in config1) {
      return getMergedValue(void 0, a2);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a2, b2) => mergeDeepProperties(headersToObject(a2), headersToObject(b2), true)
  };
  utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}
const resolveConfig = (config) => {
  const newConfig = mergeConfig({}, config);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth: auth2 } = newConfig;
  newConfig.headers = headers = AxiosHeaders.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config.params, config.paramsSerializer);
  if (auth2) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth2.username || "") + ":" + (auth2.password ? unescape(encodeURIComponent(auth2.password)) : ""))
    );
  }
  let contentType;
  if (utils$1.isFormData(data)) {
    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if ((contentType = headers.getContentType()) !== false) {
      const [type, ...tokens] = contentType ? contentType.split(";").map((token2) => token2.trim()).filter(Boolean) : [];
      headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
    }
  }
  if (platform.hasStandardBrowserEnv) {
    withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve2, reject) {
    const _config = resolveConfig(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders.from(_config.headers).normalize();
    let { responseType } = _config;
    let onCanceled;
    function done() {
      if (_config.cancelToken) {
        _config.cancelToken.unsubscribe(onCanceled);
      }
      if (_config.signal) {
        _config.signal.removeEventListener("abort", onCanceled);
      }
    }
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value2) {
        resolve2(value2);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, _config, request));
      request = null;
    };
    request.onerror = function handleError2() {
      reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, _config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitionalDefaults;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        _config,
        request
      ));
      request = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils$1.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (typeof _config.onDownloadProgress === "function") {
      request.addEventListener("progress", progressEventReducer(_config.onDownloadProgress, true));
    }
    if (typeof _config.onUploadProgress === "function" && request.upload) {
      request.upload.addEventListener("progress", progressEventReducer(_config.onUploadProgress));
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol2 = parseProtocol(_config.url);
    if (protocol2 && platform.protocols.indexOf(protocol2) === -1) {
      reject(new AxiosError("Unsupported protocol " + protocol2 + ":", AxiosError.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};
const composeSignals = (signals, timeout2) => {
  let controller = new AbortController();
  let aborted;
  const onabort = function(cancel) {
    if (!aborted) {
      aborted = true;
      unsubscribe();
      const err = cancel instanceof Error ? cancel : this.reason;
      controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
    }
  };
  let timer = timeout2 && setTimeout(() => {
    onabort(new AxiosError(`timeout ${timeout2} of ms exceeded`, AxiosError.ETIMEDOUT));
  }, timeout2);
  const unsubscribe = () => {
    if (signals) {
      timer && clearTimeout(timer);
      timer = null;
      signals.forEach((signal2) => {
        signal2 && (signal2.removeEventListener ? signal2.removeEventListener("abort", onabort) : signal2.unsubscribe(onabort));
      });
      signals = null;
    }
  };
  signals.forEach((signal2) => signal2 && signal2.addEventListener && signal2.addEventListener("abort", onabort));
  const { signal } = controller;
  signal.unsubscribe = unsubscribe;
  return [signal, () => {
    timer && clearTimeout(timer);
    timer = null;
  }];
};
const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
const readBytes = async function* (iterable, chunkSize, encode2) {
  for await (const chunk of iterable) {
    yield* streamChunk(ArrayBuffer.isView(chunk) ? chunk : await encode2(String(chunk)), chunkSize);
  }
};
const trackStream = (stream, chunkSize, onProgress, onFinish, encode2) => {
  const iterator = readBytes(stream, chunkSize, encode2);
  let bytes = 0;
  return new ReadableStream({
    type: "bytes",
    async pull(controller) {
      const { done, value: value2 } = await iterator.next();
      if (done) {
        controller.close();
        onFinish();
        return;
      }
      let len = value2.byteLength;
      onProgress && onProgress(bytes += len);
      controller.enqueue(new Uint8Array(value2));
    },
    cancel(reason) {
      onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  });
};
const fetchProgressDecorator = (total, fn) => {
  const lengthComputable = total != null;
  return (loaded) => setTimeout(() => fn({
    lengthComputable,
    total,
    loaded
  }));
};
const isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
const supportsRequestStream = isReadableStreamSupported && (() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
})();
const DEFAULT_CHUNK_SIZE = 64 * 1024;
const supportsResponseStream = isReadableStreamSupported && !!(() => {
  try {
    return utils$1.isReadableStream(new Response("").body);
  } catch (err) {
  }
})();
const resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};
isFetchSupported && ((res) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
    !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? (res2) => res2[type]() : (_2, config) => {
      throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);
    });
  });
})(new Response());
const getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }
  if (utils$1.isBlob(body)) {
    return body.size;
  }
  if (utils$1.isSpecCompliantForm(body)) {
    return (await new Request(body).arrayBuffer()).byteLength;
  }
  if (utils$1.isArrayBufferView(body)) {
    return body.byteLength;
  }
  if (utils$1.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils$1.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};
const resolveBodyLength = async (headers, body) => {
  const length = utils$1.toFiniteNumber(headers.getContentLength());
  return length == null ? getBodyLength(body) : length;
};
const fetchAdapter = isFetchSupported && (async (config) => {
  let {
    url: url2,
    method,
    data,
    signal,
    cancelToken,
    timeout: timeout2,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig(config);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let [composedSignal, stopTimeout] = signal || cancelToken || timeout2 ? composeSignals([signal, cancelToken], timeout2) : [];
  let finished, request;
  const onFinish = () => {
    !finished && setTimeout(() => {
      composedSignal && composedSignal.unsubscribe();
    });
    finished = true;
  };
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
      let _request = new Request(url2, {
        method: "POST",
        body: data,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, fetchProgressDecorator(
          requestContentLength,
          progressEventReducer(onUploadProgress)
        ), null, encodeText);
      }
    }
    if (!utils$1.isString(withCredentials)) {
      withCredentials = withCredentials ? "cors" : "omit";
    }
    request = new Request(url2, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      withCredentials
    });
    let response = await fetch(request);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse)) {
      const options = {};
      ["status", "statusText", "headers"].forEach((prop) => {
        options[prop] = response[prop];
      });
      const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onDownloadProgress && fetchProgressDecorator(
          responseContentLength,
          progressEventReducer(onDownloadProgress, true)
        ), isStreamResponse && onFinish, encodeText),
        options
      );
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config);
    !isStreamResponse && onFinish();
    stopTimeout && stopTimeout();
    return await new Promise((resolve2, reject) => {
      settle(resolve2, reject, {
        data: responseData,
        headers: AxiosHeaders.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request
      });
    });
  } catch (err) {
    onFinish();
    if (err && err.name === "TypeError" && /fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request),
        {
          cause: err.cause || err
        }
      );
    }
    throw AxiosError.from(err, err && err.code, config, request);
  }
});
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: fetchAdapter
};
utils$1.forEach(knownAdapters, (fn, value2) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value: value2 });
    } catch (e2) {
    }
    Object.defineProperty(fn, "adapterName", { value: value2 });
  }
});
const renderReason = (reason) => `- ${reason}`;
const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
const adapters = {
  getAdapter: (adapters2) => {
    adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
    const { length } = adapters2;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters2[i];
      let id2;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id2 = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError(`Unknown adapter '${id2}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id2 || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id2, state]) => `adapter ${id2} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s2 = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError(
        `There is no suitable adapter to dispatch the request ` + s2,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters.getAdapter(config.adapter || defaults.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const VERSION = "1.7.2";
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version2, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value2, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError(
        formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
        AxiosError.ERR_DEPRECATED
      );
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value2, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator2 = schema[opt];
    if (validator2) {
      const value2 = options[opt];
      const result = value2 === void 0 || validator2(value2, opt, options);
      if (result !== true) {
        throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy;
        Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
        const stack2 = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack2;
          } else if (stack2 && !String(err.stack).endsWith(stack2.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack2;
          }
        } catch (e2) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils$1.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils$1.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils$1.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}
utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url2, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url: url2,
      data: (config || {}).data
    }));
  };
});
utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url2, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: url2,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve2) {
      resolvePromise = resolve2;
    });
    const token2 = this;
    this.promise.then((cancel) => {
      if (!token2._listeners) return;
      let i = token2._listeners.length;
      while (i-- > 0) {
        token2._listeners[i](cancel);
      }
      token2._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve2) => {
        token2.subscribe(resolve2);
        _resolve = resolve2;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token2.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token2.reason) {
        return;
      }
      token2.reason = new CanceledError(message, config, request);
      resolvePromise(token2.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token2 = new CancelToken(function executor(c2) {
      cancel = c2;
    });
    return {
      token: token2,
      cancel
    };
  }
}
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError(payload) {
  return utils$1.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value2]) => {
  HttpStatusCode[value2] = key;
});
function createInstance(defaultConfig) {
  const context = new Axios(defaultConfig);
  const instance = bind(Axios.prototype.request, context);
  utils$1.extend(instance, Axios.prototype, context, { allOwnKeys: true });
  utils$1.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
const axios = createInstance(defaults);
axios.Axios = Axios;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders;
axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode;
axios.default = axios;
const axiosInstance = axios.create({
  baseURL: "https://secadodecafe.online/api/v1"
});
axiosInstance.defaults.withCredentials = true;
axiosInstance.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response.status === 401) {
      api.remove("access_token");
      window.location.href = "/login";
    }
    return Promise.reject(error);
  }
);
const notifyErrorRequest$1 = (msg, position2 = "top") => {
  Notify.create({
    color: "negative",
    message: msg,
    icon: "error",
    position: position2,
    timeout: 4500
  });
};
const getUsersApi = async () => {
  try {
    const response = await axiosInstance.get(`/users`);
    console.log(response);
    return response.data;
  } catch (error) {
    console.error(error);
    const message = error.response.data.message || "Error al obtener los usuarios";
    notifyErrorRequest$1(message);
  }
};
const getUserApi = async (id2) => {
  try {
    const response = await axiosInstance.get(`/users/${id2}`);
    console.log(response);
    return response.data;
  } catch (error) {
    console.error(error);
    const message = error.response.data.message || "Error al obtener el usuario";
    notifyErrorRequest$1(message);
  }
};
const createUserApi = async (dataUser) => {
  try {
    const response = await axiosInstance.post(`/users/create`, dataUser);
    console.log(response);
    return response;
  } catch (error) {
    console.error(error);
    const message = error.response.data.message || "Error al crear el usuario";
    notifyErrorRequest$1(message);
  }
};
const updateUserApi = async (dataUser) => {
  try {
    const response = await axiosInstance.put(`/users/update`, dataUser);
    console.log(response);
    return response;
  } catch (error) {
    console.error(error);
    const message = error.response.data.message || "Error al actualizar el usuario";
    notifyErrorRequest$1(message);
  }
};
const storeUsers = defineStore(
  "storeUsers",
  () => {
    let farms = ref("");
    let farm = ref("");
    let user = ref({});
    const setUser = () => {
      const cookie = api.get("access_token");
      if (cookie) {
        const decoded = jwtDecode(cookie);
        user.value = {
          id: (decoded == null ? void 0 : decoded.id) || null,
          username: decoded.username,
          email: decoded.email,
          role: decoded.role == "ADMIN" ? "ADMINISTRADOR" : "USUARIO"
        };
      }
    };
    const setFarms = async () => {
      try {
        const response = await getUserApi(user.value.id);
        console.log("response", response.data);
        farms.value = response.data.farms;
        console.log("farms", farms.value);
      } catch (error) {
        console.error(error);
        const message = error.response.data.message || "Error al obtener las fincas";
        notifyErrorRequest(message);
      }
    };
    const setFarm = (farmId = null) => {
      if (!farmId) {
        farm.value = farms.value[0];
        return;
      }
      farm.value = farms.value.find((farm2) => farm2._id === farmId);
    };
    return {
      farms,
      farm,
      user,
      setFarms,
      setFarm,
      setUser
    };
  },
  {
    persist: true
  }
);
/*!
  * vue-router v4.4.0
  * (c) 2024 Eduardo San Martin Morote
  * @license MIT
  */
const isBrowser = typeof document !== "undefined";
function isESModule(obj) {
  return obj.__esModule || obj[Symbol.toStringTag] === "Module";
}
const assign = Object.assign;
function applyToParams(fn, params) {
  const newParams = {};
  for (const key in params) {
    const value2 = params[key];
    newParams[key] = isArray(value2) ? value2.map(fn) : fn(value2);
  }
  return newParams;
}
const noop = () => {
};
const isArray = Array.isArray;
const HASH_RE = /#/g;
const AMPERSAND_RE = /&/g;
const SLASH_RE = /\//g;
const EQUAL_RE = /=/g;
const IM_RE = /\?/g;
const PLUS_RE = /\+/g;
const ENC_BRACKET_OPEN_RE = /%5B/g;
const ENC_BRACKET_CLOSE_RE = /%5D/g;
const ENC_CARET_RE = /%5E/g;
const ENC_BACKTICK_RE = /%60/g;
const ENC_CURLY_OPEN_RE = /%7B/g;
const ENC_PIPE_RE = /%7C/g;
const ENC_CURLY_CLOSE_RE = /%7D/g;
const ENC_SPACE_RE = /%20/g;
function commonEncode(text) {
  return encodeURI("" + text).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
}
function encodeHash(text) {
  return commonEncode(text).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryValue(text) {
  return commonEncode(text).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryKey(text) {
  return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
}
function encodePath(text) {
  return commonEncode(text).replace(HASH_RE, "%23").replace(IM_RE, "%3F");
}
function encodeParam(text) {
  return text == null ? "" : encodePath(text).replace(SLASH_RE, "%2F");
}
function decode$4(text) {
  try {
    return decodeURIComponent("" + text);
  } catch (err) {
  }
  return "" + text;
}
const TRAILING_SLASH_RE = /\/$/;
const removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, "");
function parseURL(parseQuery2, location2, currentLocation = "/") {
  let path, query = {}, searchString = "", hash = "";
  const hashPos = location2.indexOf("#");
  let searchPos = location2.indexOf("?");
  if (hashPos < searchPos && hashPos >= 0) {
    searchPos = -1;
  }
  if (searchPos > -1) {
    path = location2.slice(0, searchPos);
    searchString = location2.slice(searchPos + 1, hashPos > -1 ? hashPos : location2.length);
    query = parseQuery2(searchString);
  }
  if (hashPos > -1) {
    path = path || location2.slice(0, hashPos);
    hash = location2.slice(hashPos, location2.length);
  }
  path = resolveRelativePath(path != null ? path : location2, currentLocation);
  return {
    fullPath: path + (searchString && "?") + searchString + hash,
    path,
    query,
    hash: decode$4(hash)
  };
}
function stringifyURL(stringifyQuery2, location2) {
  const query = location2.query ? stringifyQuery2(location2.query) : "";
  return location2.path + (query && "?") + query + (location2.hash || "");
}
function stripBase(pathname, base) {
  if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase()))
    return pathname;
  return pathname.slice(base.length) || "/";
}
function isSameRouteLocation(stringifyQuery2, a2, b2) {
  const aLastIndex = a2.matched.length - 1;
  const bLastIndex = b2.matched.length - 1;
  return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a2.matched[aLastIndex], b2.matched[bLastIndex]) && isSameRouteLocationParams(a2.params, b2.params) && stringifyQuery2(a2.query) === stringifyQuery2(b2.query) && a2.hash === b2.hash;
}
function isSameRouteRecord(a2, b2) {
  return (a2.aliasOf || a2) === (b2.aliasOf || b2);
}
function isSameRouteLocationParams(a2, b2) {
  if (Object.keys(a2).length !== Object.keys(b2).length)
    return false;
  for (const key in a2) {
    if (!isSameRouteLocationParamsValue(a2[key], b2[key]))
      return false;
  }
  return true;
}
function isSameRouteLocationParamsValue(a2, b2) {
  return isArray(a2) ? isEquivalentArray(a2, b2) : isArray(b2) ? isEquivalentArray(b2, a2) : a2 === b2;
}
function isEquivalentArray(a2, b2) {
  return isArray(b2) ? a2.length === b2.length && a2.every((value2, i) => value2 === b2[i]) : a2.length === 1 && a2[0] === b2;
}
function resolveRelativePath(to, from) {
  if (to.startsWith("/"))
    return to;
  if (!to)
    return from;
  const fromSegments = from.split("/");
  const toSegments = to.split("/");
  const lastToSegment = toSegments[toSegments.length - 1];
  if (lastToSegment === ".." || lastToSegment === ".") {
    toSegments.push("");
  }
  let position2 = fromSegments.length - 1;
  let toPosition;
  let segment;
  for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
    segment = toSegments[toPosition];
    if (segment === ".")
      continue;
    if (segment === "..") {
      if (position2 > 1)
        position2--;
    } else
      break;
  }
  return fromSegments.slice(0, position2).join("/") + "/" + toSegments.slice(toPosition).join("/");
}
const START_LOCATION_NORMALIZED = {
  path: "/",
  // TODO: could we use a symbol in the future?
  name: void 0,
  params: {},
  query: {},
  hash: "",
  fullPath: "/",
  matched: [],
  meta: {},
  redirectedFrom: void 0
};
var NavigationType;
(function(NavigationType2) {
  NavigationType2["pop"] = "pop";
  NavigationType2["push"] = "push";
})(NavigationType || (NavigationType = {}));
var NavigationDirection;
(function(NavigationDirection2) {
  NavigationDirection2["back"] = "back";
  NavigationDirection2["forward"] = "forward";
  NavigationDirection2["unknown"] = "";
})(NavigationDirection || (NavigationDirection = {}));
function normalizeBase(base) {
  if (!base) {
    if (isBrowser) {
      const baseEl = document.querySelector("base");
      base = baseEl && baseEl.getAttribute("href") || "/";
      base = base.replace(/^\w+:\/\/[^\/]+/, "");
    } else {
      base = "/";
    }
  }
  if (base[0] !== "/" && base[0] !== "#")
    base = "/" + base;
  return removeTrailingSlash(base);
}
const BEFORE_HASH_RE = /^[^#]+#/;
function createHref(base, location2) {
  return base.replace(BEFORE_HASH_RE, "#") + location2;
}
function getElementPosition(el, offset) {
  const docRect = document.documentElement.getBoundingClientRect();
  const elRect = el.getBoundingClientRect();
  return {
    behavior: offset.behavior,
    left: elRect.left - docRect.left - (offset.left || 0),
    top: elRect.top - docRect.top - (offset.top || 0)
  };
}
const computeScrollPosition = () => ({
  left: window.scrollX,
  top: window.scrollY
});
function scrollToPosition(position2) {
  let scrollToOptions;
  if ("el" in position2) {
    const positionEl = position2.el;
    const isIdSelector = typeof positionEl === "string" && positionEl.startsWith("#");
    const el = typeof positionEl === "string" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;
    if (!el) {
      return;
    }
    scrollToOptions = getElementPosition(el, position2);
  } else {
    scrollToOptions = position2;
  }
  if ("scrollBehavior" in document.documentElement.style)
    window.scrollTo(scrollToOptions);
  else {
    window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.scrollX, scrollToOptions.top != null ? scrollToOptions.top : window.scrollY);
  }
}
function getScrollKey(path, delta) {
  const position2 = history.state ? history.state.position - delta : -1;
  return position2 + path;
}
const scrollPositions = /* @__PURE__ */ new Map();
function saveScrollPosition(key, scrollPosition) {
  scrollPositions.set(key, scrollPosition);
}
function getSavedScrollPosition(key) {
  const scroll = scrollPositions.get(key);
  scrollPositions.delete(key);
  return scroll;
}
let createBaseLocation = () => location.protocol + "//" + location.host;
function createCurrentLocation(base, location2) {
  const { pathname, search, hash } = location2;
  const hashPos = base.indexOf("#");
  if (hashPos > -1) {
    let slicePos = hash.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;
    let pathFromHash = hash.slice(slicePos);
    if (pathFromHash[0] !== "/")
      pathFromHash = "/" + pathFromHash;
    return stripBase(pathFromHash, "");
  }
  const path = stripBase(pathname, base);
  return path + search + hash;
}
function useHistoryListeners(base, historyState, currentLocation, replace) {
  let listeners = [];
  let teardowns = [];
  let pauseState = null;
  const popStateHandler = ({ state }) => {
    const to = createCurrentLocation(base, location);
    const from = currentLocation.value;
    const fromState = historyState.value;
    let delta = 0;
    if (state) {
      currentLocation.value = to;
      historyState.value = state;
      if (pauseState && pauseState === from) {
        pauseState = null;
        return;
      }
      delta = fromState ? state.position - fromState.position : 0;
    } else {
      replace(to);
    }
    listeners.forEach((listener) => {
      listener(currentLocation.value, from, {
        delta,
        type: NavigationType.pop,
        direction: delta ? delta > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown
      });
    });
  };
  function pauseListeners() {
    pauseState = currentLocation.value;
  }
  function listen(callback) {
    listeners.push(callback);
    const teardown = () => {
      const index = listeners.indexOf(callback);
      if (index > -1)
        listeners.splice(index, 1);
    };
    teardowns.push(teardown);
    return teardown;
  }
  function beforeUnloadListener() {
    const { history: history2 } = window;
    if (!history2.state)
      return;
    history2.replaceState(assign({}, history2.state, { scroll: computeScrollPosition() }), "");
  }
  function destroy() {
    for (const teardown of teardowns)
      teardown();
    teardowns = [];
    window.removeEventListener("popstate", popStateHandler);
    window.removeEventListener("beforeunload", beforeUnloadListener);
  }
  window.addEventListener("popstate", popStateHandler);
  window.addEventListener("beforeunload", beforeUnloadListener, {
    passive: true
  });
  return {
    pauseListeners,
    listen,
    destroy
  };
}
function buildState(back, current, forward, replaced = false, computeScroll = false) {
  return {
    back,
    current,
    forward,
    replaced,
    position: window.history.length,
    scroll: computeScroll ? computeScrollPosition() : null
  };
}
function useHistoryStateNavigation(base) {
  const { history: history2, location: location2 } = window;
  const currentLocation = {
    value: createCurrentLocation(base, location2)
  };
  const historyState = { value: history2.state };
  if (!historyState.value) {
    changeLocation(currentLocation.value, {
      back: null,
      current: currentLocation.value,
      forward: null,
      // the length is off by one, we need to decrease it
      position: history2.length - 1,
      replaced: true,
      // don't add a scroll as the user may have an anchor, and we want
      // scrollBehavior to be triggered without a saved position
      scroll: null
    }, true);
  }
  function changeLocation(to, state, replace2) {
    const hashIndex = base.indexOf("#");
    const url2 = hashIndex > -1 ? (location2.host && document.querySelector("base") ? base : base.slice(hashIndex)) + to : createBaseLocation() + base + to;
    try {
      history2[replace2 ? "replaceState" : "pushState"](state, "", url2);
      historyState.value = state;
    } catch (err) {
      {
        console.error(err);
      }
      location2[replace2 ? "replace" : "assign"](url2);
    }
  }
  function replace(to, data) {
    const state = assign({}, history2.state, buildState(
      historyState.value.back,
      // keep back and forward entries but override current position
      to,
      historyState.value.forward,
      true
    ), data, { position: historyState.value.position });
    changeLocation(to, state, true);
    currentLocation.value = to;
  }
  function push(to, data) {
    const currentState = assign(
      {},
      // use current history state to gracefully handle a wrong call to
      // history.replaceState
      // https://github.com/vuejs/router/issues/366
      historyState.value,
      history2.state,
      {
        forward: to,
        scroll: computeScrollPosition()
      }
    );
    changeLocation(currentState.current, currentState, true);
    const state = assign({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data);
    changeLocation(to, state, false);
    currentLocation.value = to;
  }
  return {
    location: currentLocation,
    state: historyState,
    push,
    replace
  };
}
function createWebHistory(base) {
  base = normalizeBase(base);
  const historyNavigation = useHistoryStateNavigation(base);
  const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);
  function go(delta, triggerListeners = true) {
    if (!triggerListeners)
      historyListeners.pauseListeners();
    history.go(delta);
  }
  const routerHistory = assign({
    // it's overridden right after
    location: "",
    base,
    go,
    createHref: createHref.bind(null, base)
  }, historyNavigation, historyListeners);
  Object.defineProperty(routerHistory, "location", {
    enumerable: true,
    get: () => historyNavigation.location.value
  });
  Object.defineProperty(routerHistory, "state", {
    enumerable: true,
    get: () => historyNavigation.state.value
  });
  return routerHistory;
}
function createWebHashHistory(base) {
  base = location.host ? base || location.pathname + location.search : "";
  if (!base.includes("#"))
    base += "#";
  return createWebHistory(base);
}
function isRouteLocation(route) {
  return typeof route === "string" || route && typeof route === "object";
}
function isRouteName(name) {
  return typeof name === "string" || typeof name === "symbol";
}
const NavigationFailureSymbol = Symbol("");
var NavigationFailureType;
(function(NavigationFailureType2) {
  NavigationFailureType2[NavigationFailureType2["aborted"] = 4] = "aborted";
  NavigationFailureType2[NavigationFailureType2["cancelled"] = 8] = "cancelled";
  NavigationFailureType2[NavigationFailureType2["duplicated"] = 16] = "duplicated";
})(NavigationFailureType || (NavigationFailureType = {}));
function createRouterError(type, params) {
  {
    return assign(new Error(), {
      type,
      [NavigationFailureSymbol]: true
    }, params);
  }
}
function isNavigationFailure(error, type) {
  return error instanceof Error && NavigationFailureSymbol in error && (type == null || !!(error.type & type));
}
const BASE_PARAM_PATTERN = "[^/]+?";
const BASE_PATH_PARSER_OPTIONS = {
  sensitive: false,
  strict: false,
  start: true,
  end: true
};
const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
function tokensToParser(segments, extraOptions) {
  const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
  const score = [];
  let pattern = options.start ? "^" : "";
  const keys = [];
  for (const segment of segments) {
    const segmentScores = segment.length ? [] : [
      90
      /* PathScore.Root */
    ];
    if (options.strict && !segment.length)
      pattern += "/";
    for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
      const token2 = segment[tokenIndex];
      let subSegmentScore = 40 + (options.sensitive ? 0.25 : 0);
      if (token2.type === 0) {
        if (!tokenIndex)
          pattern += "/";
        pattern += token2.value.replace(REGEX_CHARS_RE, "\\$&");
        subSegmentScore += 40;
      } else if (token2.type === 1) {
        const { value: value2, repeatable, optional, regexp } = token2;
        keys.push({
          name: value2,
          repeatable,
          optional
        });
        const re22 = regexp ? regexp : BASE_PARAM_PATTERN;
        if (re22 !== BASE_PARAM_PATTERN) {
          subSegmentScore += 10;
          try {
            new RegExp(`(${re22})`);
          } catch (err) {
            throw new Error(`Invalid custom RegExp for param "${value2}" (${re22}): ` + err.message);
          }
        }
        let subPattern = repeatable ? `((?:${re22})(?:/(?:${re22}))*)` : `(${re22})`;
        if (!tokenIndex)
          subPattern = // avoid an optional / if there are more segments e.g. /:p?-static
          // or /:p?-:p2
          optional && segment.length < 2 ? `(?:/${subPattern})` : "/" + subPattern;
        if (optional)
          subPattern += "?";
        pattern += subPattern;
        subSegmentScore += 20;
        if (optional)
          subSegmentScore += -8;
        if (repeatable)
          subSegmentScore += -20;
        if (re22 === ".*")
          subSegmentScore += -50;
      }
      segmentScores.push(subSegmentScore);
    }
    score.push(segmentScores);
  }
  if (options.strict && options.end) {
    const i = score.length - 1;
    score[i][score[i].length - 1] += 0.7000000000000001;
  }
  if (!options.strict)
    pattern += "/?";
  if (options.end)
    pattern += "$";
  else if (options.strict)
    pattern += "(?:/|$)";
  const re2 = new RegExp(pattern, options.sensitive ? "" : "i");
  function parse2(path) {
    const match = path.match(re2);
    const params = {};
    if (!match)
      return null;
    for (let i = 1; i < match.length; i++) {
      const value2 = match[i] || "";
      const key = keys[i - 1];
      params[key.name] = value2 && key.repeatable ? value2.split("/") : value2;
    }
    return params;
  }
  function stringify(params) {
    let path = "";
    let avoidDuplicatedSlash = false;
    for (const segment of segments) {
      if (!avoidDuplicatedSlash || !path.endsWith("/"))
        path += "/";
      avoidDuplicatedSlash = false;
      for (const token2 of segment) {
        if (token2.type === 0) {
          path += token2.value;
        } else if (token2.type === 1) {
          const { value: value2, repeatable, optional } = token2;
          const param = value2 in params ? params[value2] : "";
          if (isArray(param) && !repeatable) {
            throw new Error(`Provided param "${value2}" is an array but it is not repeatable (* or + modifiers)`);
          }
          const text = isArray(param) ? param.join("/") : param;
          if (!text) {
            if (optional) {
              if (segment.length < 2) {
                if (path.endsWith("/"))
                  path = path.slice(0, -1);
                else
                  avoidDuplicatedSlash = true;
              }
            } else
              throw new Error(`Missing required param "${value2}"`);
          }
          path += text;
        }
      }
    }
    return path || "/";
  }
  return {
    re: re2,
    score,
    keys,
    parse: parse2,
    stringify
  };
}
function compareScoreArray(a2, b2) {
  let i = 0;
  while (i < a2.length && i < b2.length) {
    const diff = b2[i] - a2[i];
    if (diff)
      return diff;
    i++;
  }
  if (a2.length < b2.length) {
    return a2.length === 1 && a2[0] === 40 + 40 ? -1 : 1;
  } else if (a2.length > b2.length) {
    return b2.length === 1 && b2[0] === 40 + 40 ? 1 : -1;
  }
  return 0;
}
function comparePathParserScore(a2, b2) {
  let i = 0;
  const aScore = a2.score;
  const bScore = b2.score;
  while (i < aScore.length && i < bScore.length) {
    const comp = compareScoreArray(aScore[i], bScore[i]);
    if (comp)
      return comp;
    i++;
  }
  if (Math.abs(bScore.length - aScore.length) === 1) {
    if (isLastScoreNegative(aScore))
      return 1;
    if (isLastScoreNegative(bScore))
      return -1;
  }
  return bScore.length - aScore.length;
}
function isLastScoreNegative(score) {
  const last = score[score.length - 1];
  return score.length > 0 && last[last.length - 1] < 0;
}
const ROOT_TOKEN = {
  type: 0,
  value: ""
};
const VALID_PARAM_RE = /[a-zA-Z0-9_]/;
function tokenizePath(path) {
  if (!path)
    return [[]];
  if (path === "/")
    return [[ROOT_TOKEN]];
  if (!path.startsWith("/")) {
    throw new Error(`Invalid path "${path}"`);
  }
  function crash(message) {
    throw new Error(`ERR (${state})/"${buffer}": ${message}`);
  }
  let state = 0;
  let previousState = state;
  const tokens = [];
  let segment;
  function finalizeSegment() {
    if (segment)
      tokens.push(segment);
    segment = [];
  }
  let i = 0;
  let char;
  let buffer = "";
  let customRe = "";
  function consumeBuffer() {
    if (!buffer)
      return;
    if (state === 0) {
      segment.push({
        type: 0,
        value: buffer
      });
    } else if (state === 1 || state === 2 || state === 3) {
      if (segment.length > 1 && (char === "*" || char === "+"))
        crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);
      segment.push({
        type: 1,
        value: buffer,
        regexp: customRe,
        repeatable: char === "*" || char === "+",
        optional: char === "*" || char === "?"
      });
    } else {
      crash("Invalid state to consume buffer");
    }
    buffer = "";
  }
  function addCharToBuffer() {
    buffer += char;
  }
  while (i < path.length) {
    char = path[i++];
    if (char === "\\" && state !== 2) {
      previousState = state;
      state = 4;
      continue;
    }
    switch (state) {
      case 0:
        if (char === "/") {
          if (buffer) {
            consumeBuffer();
          }
          finalizeSegment();
        } else if (char === ":") {
          consumeBuffer();
          state = 1;
        } else {
          addCharToBuffer();
        }
        break;
      case 4:
        addCharToBuffer();
        state = previousState;
        break;
      case 1:
        if (char === "(") {
          state = 2;
        } else if (VALID_PARAM_RE.test(char)) {
          addCharToBuffer();
        } else {
          consumeBuffer();
          state = 0;
          if (char !== "*" && char !== "?" && char !== "+")
            i--;
        }
        break;
      case 2:
        if (char === ")") {
          if (customRe[customRe.length - 1] == "\\")
            customRe = customRe.slice(0, -1) + char;
          else
            state = 3;
        } else {
          customRe += char;
        }
        break;
      case 3:
        consumeBuffer();
        state = 0;
        if (char !== "*" && char !== "?" && char !== "+")
          i--;
        customRe = "";
        break;
      default:
        crash("Unknown state");
        break;
    }
  }
  if (state === 2)
    crash(`Unfinished custom RegExp for param "${buffer}"`);
  consumeBuffer();
  finalizeSegment();
  return tokens;
}
function createRouteRecordMatcher(record, parent, options) {
  const parser2 = tokensToParser(tokenizePath(record.path), options);
  const matcher = assign(parser2, {
    record,
    parent,
    // these needs to be populated by the parent
    children: [],
    alias: []
  });
  if (parent) {
    if (!matcher.record.aliasOf === !parent.record.aliasOf)
      parent.children.push(matcher);
  }
  return matcher;
}
function createRouterMatcher(routes2, globalOptions) {
  const matchers = [];
  const matcherMap = /* @__PURE__ */ new Map();
  globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);
  function getRecordMatcher(name) {
    return matcherMap.get(name);
  }
  function addRoute(record, parent, originalRecord) {
    const isRootAdd = !originalRecord;
    const mainNormalizedRecord = normalizeRouteRecord(record);
    mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
    const options = mergeOptions(globalOptions, record);
    const normalizedRecords = [
      mainNormalizedRecord
    ];
    if ("alias" in record) {
      const aliases = typeof record.alias === "string" ? [record.alias] : record.alias;
      for (const alias of aliases) {
        normalizedRecords.push(assign({}, mainNormalizedRecord, {
          // this allows us to hold a copy of the `components` option
          // so that async components cache is hold on the original record
          components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,
          path: alias,
          // we might be the child of an alias
          aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord
          // the aliases are always of the same kind as the original since they
          // are defined on the same record
        }));
      }
    }
    let matcher;
    let originalMatcher;
    for (const normalizedRecord of normalizedRecords) {
      const { path } = normalizedRecord;
      if (parent && path[0] !== "/") {
        const parentPath = parent.record.path;
        const connectingSlash = parentPath[parentPath.length - 1] === "/" ? "" : "/";
        normalizedRecord.path = parent.record.path + (path && connectingSlash + path);
      }
      matcher = createRouteRecordMatcher(normalizedRecord, parent, options);
      if (originalRecord) {
        originalRecord.alias.push(matcher);
      } else {
        originalMatcher = originalMatcher || matcher;
        if (originalMatcher !== matcher)
          originalMatcher.alias.push(matcher);
        if (isRootAdd && record.name && !isAliasRecord(matcher))
          removeRoute(record.name);
      }
      if (isMatchable(matcher)) {
        insertMatcher(matcher);
      }
      if (mainNormalizedRecord.children) {
        const children = mainNormalizedRecord.children;
        for (let i = 0; i < children.length; i++) {
          addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);
        }
      }
      originalRecord = originalRecord || matcher;
    }
    return originalMatcher ? () => {
      removeRoute(originalMatcher);
    } : noop;
  }
  function removeRoute(matcherRef) {
    if (isRouteName(matcherRef)) {
      const matcher = matcherMap.get(matcherRef);
      if (matcher) {
        matcherMap.delete(matcherRef);
        matchers.splice(matchers.indexOf(matcher), 1);
        matcher.children.forEach(removeRoute);
        matcher.alias.forEach(removeRoute);
      }
    } else {
      const index = matchers.indexOf(matcherRef);
      if (index > -1) {
        matchers.splice(index, 1);
        if (matcherRef.record.name)
          matcherMap.delete(matcherRef.record.name);
        matcherRef.children.forEach(removeRoute);
        matcherRef.alias.forEach(removeRoute);
      }
    }
  }
  function getRoutes() {
    return matchers;
  }
  function insertMatcher(matcher) {
    const index = findInsertionIndex(matcher, matchers);
    matchers.splice(index, 0, matcher);
    if (matcher.record.name && !isAliasRecord(matcher))
      matcherMap.set(matcher.record.name, matcher);
  }
  function resolve2(location2, currentLocation) {
    let matcher;
    let params = {};
    let path;
    let name;
    if ("name" in location2 && location2.name) {
      matcher = matcherMap.get(location2.name);
      if (!matcher)
        throw createRouterError(1, {
          location: location2
        });
      name = matcher.record.name;
      params = assign(
        // paramsFromLocation is a new object
        paramsFromLocation(
          currentLocation.params,
          // only keep params that exist in the resolved location
          // only keep optional params coming from a parent record
          matcher.keys.filter((k2) => !k2.optional).concat(matcher.parent ? matcher.parent.keys.filter((k2) => k2.optional) : []).map((k2) => k2.name)
        ),
        // discard any existing params in the current location that do not exist here
        // #1497 this ensures better active/exact matching
        location2.params && paramsFromLocation(location2.params, matcher.keys.map((k2) => k2.name))
      );
      path = matcher.stringify(params);
    } else if (location2.path != null) {
      path = location2.path;
      matcher = matchers.find((m2) => m2.re.test(path));
      if (matcher) {
        params = matcher.parse(path);
        name = matcher.record.name;
      }
    } else {
      matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find((m2) => m2.re.test(currentLocation.path));
      if (!matcher)
        throw createRouterError(1, {
          location: location2,
          currentLocation
        });
      name = matcher.record.name;
      params = assign({}, currentLocation.params, location2.params);
      path = matcher.stringify(params);
    }
    const matched = [];
    let parentMatcher = matcher;
    while (parentMatcher) {
      matched.unshift(parentMatcher.record);
      parentMatcher = parentMatcher.parent;
    }
    return {
      name,
      path,
      params,
      matched,
      meta: mergeMetaFields(matched)
    };
  }
  routes2.forEach((route) => addRoute(route));
  function clearRoutes() {
    matchers.length = 0;
    matcherMap.clear();
  }
  return {
    addRoute,
    resolve: resolve2,
    removeRoute,
    clearRoutes,
    getRoutes,
    getRecordMatcher
  };
}
function paramsFromLocation(params, keys) {
  const newParams = {};
  for (const key of keys) {
    if (key in params)
      newParams[key] = params[key];
  }
  return newParams;
}
function normalizeRouteRecord(record) {
  return {
    path: record.path,
    redirect: record.redirect,
    name: record.name,
    meta: record.meta || {},
    aliasOf: void 0,
    beforeEnter: record.beforeEnter,
    props: normalizeRecordProps(record),
    children: record.children || [],
    instances: {},
    leaveGuards: /* @__PURE__ */ new Set(),
    updateGuards: /* @__PURE__ */ new Set(),
    enterCallbacks: {},
    components: "components" in record ? record.components || null : record.component && { default: record.component }
  };
}
function normalizeRecordProps(record) {
  const propsObject = {};
  const props2 = record.props || false;
  if ("component" in record) {
    propsObject.default = props2;
  } else {
    for (const name in record.components)
      propsObject[name] = typeof props2 === "object" ? props2[name] : props2;
  }
  return propsObject;
}
function isAliasRecord(record) {
  while (record) {
    if (record.record.aliasOf)
      return true;
    record = record.parent;
  }
  return false;
}
function mergeMetaFields(matched) {
  return matched.reduce((meta, record) => assign(meta, record.meta), {});
}
function mergeOptions(defaults2, partialOptions) {
  const options = {};
  for (const key in defaults2) {
    options[key] = key in partialOptions ? partialOptions[key] : defaults2[key];
  }
  return options;
}
function findInsertionIndex(matcher, matchers) {
  let lower = 0;
  let upper = matchers.length;
  while (lower !== upper) {
    const mid = lower + upper >> 1;
    const sortOrder = comparePathParserScore(matcher, matchers[mid]);
    if (sortOrder < 0) {
      upper = mid;
    } else {
      lower = mid + 1;
    }
  }
  const insertionAncestor = getInsertionAncestor(matcher);
  if (insertionAncestor) {
    upper = matchers.lastIndexOf(insertionAncestor, upper - 1);
  }
  return upper;
}
function getInsertionAncestor(matcher) {
  let ancestor = matcher;
  while (ancestor = ancestor.parent) {
    if (isMatchable(ancestor) && comparePathParserScore(matcher, ancestor) === 0) {
      return ancestor;
    }
  }
  return;
}
function isMatchable({ record }) {
  return !!(record.name || record.components && Object.keys(record.components).length || record.redirect);
}
function parseQuery(search) {
  const query = {};
  if (search === "" || search === "?")
    return query;
  const hasLeadingIM = search[0] === "?";
  const searchParams = (hasLeadingIM ? search.slice(1) : search).split("&");
  for (let i = 0; i < searchParams.length; ++i) {
    const searchParam = searchParams[i].replace(PLUS_RE, " ");
    const eqPos = searchParam.indexOf("=");
    const key = decode$4(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
    const value2 = eqPos < 0 ? null : decode$4(searchParam.slice(eqPos + 1));
    if (key in query) {
      let currentValue = query[key];
      if (!isArray(currentValue)) {
        currentValue = query[key] = [currentValue];
      }
      currentValue.push(value2);
    } else {
      query[key] = value2;
    }
  }
  return query;
}
function stringifyQuery(query) {
  let search = "";
  for (let key in query) {
    const value2 = query[key];
    key = encodeQueryKey(key);
    if (value2 == null) {
      if (value2 !== void 0) {
        search += (search.length ? "&" : "") + key;
      }
      continue;
    }
    const values = isArray(value2) ? value2.map((v2) => v2 && encodeQueryValue(v2)) : [value2 && encodeQueryValue(value2)];
    values.forEach((value22) => {
      if (value22 !== void 0) {
        search += (search.length ? "&" : "") + key;
        if (value22 != null)
          search += "=" + value22;
      }
    });
  }
  return search;
}
function normalizeQuery(query) {
  const normalizedQuery = {};
  for (const key in query) {
    const value2 = query[key];
    if (value2 !== void 0) {
      normalizedQuery[key] = isArray(value2) ? value2.map((v2) => v2 == null ? null : "" + v2) : value2 == null ? value2 : "" + value2;
    }
  }
  return normalizedQuery;
}
const matchedRouteKey = Symbol("");
const viewDepthKey = Symbol("");
const routerKey = Symbol("");
const routeLocationKey = Symbol("");
const routerViewLocationKey = Symbol("");
function useCallbacks() {
  let handlers2 = [];
  function add2(handler) {
    handlers2.push(handler);
    return () => {
      const i = handlers2.indexOf(handler);
      if (i > -1)
        handlers2.splice(i, 1);
    };
  }
  function reset() {
    handlers2 = [];
  }
  return {
    add: add2,
    list: () => handlers2.slice(),
    reset
  };
}
function guardToPromiseFn(guard, to, from, record, name, runWithContext = (fn) => fn()) {
  const enterCallbackArray = record && // name is defined if record is because of the function overload
  (record.enterCallbacks[name] = record.enterCallbacks[name] || []);
  return () => new Promise((resolve2, reject) => {
    const next = (valid) => {
      if (valid === false) {
        reject(createRouterError(4, {
          from,
          to
        }));
      } else if (valid instanceof Error) {
        reject(valid);
      } else if (isRouteLocation(valid)) {
        reject(createRouterError(2, {
          from: to,
          to: valid
        }));
      } else {
        if (enterCallbackArray && // since enterCallbackArray is truthy, both record and name also are
        record.enterCallbacks[name] === enterCallbackArray && typeof valid === "function") {
          enterCallbackArray.push(valid);
        }
        resolve2();
      }
    };
    const guardReturn = runWithContext(() => guard.call(record && record.instances[name], to, from, next));
    let guardCall = Promise.resolve(guardReturn);
    if (guard.length < 3)
      guardCall = guardCall.then(next);
    guardCall.catch((err) => reject(err));
  });
}
function extractComponentsGuards(matched, guardType, to, from, runWithContext = (fn) => fn()) {
  const guards = [];
  for (const record of matched) {
    for (const name in record.components) {
      let rawComponent = record.components[name];
      if (guardType !== "beforeRouteEnter" && !record.instances[name])
        continue;
      if (isRouteComponent(rawComponent)) {
        const options = rawComponent.__vccOpts || rawComponent;
        const guard = options[guardType];
        guard && guards.push(guardToPromiseFn(guard, to, from, record, name, runWithContext));
      } else {
        let componentPromise = rawComponent();
        guards.push(() => componentPromise.then((resolved) => {
          if (!resolved)
            return Promise.reject(new Error(`Couldn't resolve component "${name}" at "${record.path}"`));
          const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;
          record.components[name] = resolvedComponent;
          const options = resolvedComponent.__vccOpts || resolvedComponent;
          const guard = options[guardType];
          return guard && guardToPromiseFn(guard, to, from, record, name, runWithContext)();
        }));
      }
    }
  }
  return guards;
}
function isRouteComponent(component) {
  return typeof component === "object" || "displayName" in component || "props" in component || "__vccOpts" in component;
}
function useLink(props2) {
  const router2 = inject(routerKey);
  const currentRoute = inject(routeLocationKey);
  const route = computed(() => {
    const to = unref(props2.to);
    return router2.resolve(to);
  });
  const activeRecordIndex = computed(() => {
    const { matched } = route.value;
    const { length } = matched;
    const routeMatched = matched[length - 1];
    const currentMatched = currentRoute.matched;
    if (!routeMatched || !currentMatched.length)
      return -1;
    const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
    if (index > -1)
      return index;
    const parentRecordPath = getOriginalPath(matched[length - 2]);
    return (
      // we are dealing with nested routes
      length > 1 && // if the parent and matched route have the same path, this link is
      // referring to the empty child. Or we currently are on a different
      // child of the same parent
      getOriginalPath(routeMatched) === parentRecordPath && // avoid comparing the child with its parent
      currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index
    );
  });
  const isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));
  const isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));
  function navigate(e2 = {}) {
    if (guardEvent(e2)) {
      return router2[unref(props2.replace) ? "replace" : "push"](
        unref(props2.to)
        // avoid uncaught errors are they are logged anyway
      ).catch(noop);
    }
    return Promise.resolve();
  }
  return {
    route,
    href: computed(() => route.value.href),
    isActive,
    isExactActive,
    navigate
  };
}
const RouterLinkImpl = /* @__PURE__ */ defineComponent({
  name: "RouterLink",
  compatConfig: { MODE: 3 },
  props: {
    to: {
      type: [String, Object],
      required: true
    },
    replace: Boolean,
    activeClass: String,
    // inactiveClass: String,
    exactActiveClass: String,
    custom: Boolean,
    ariaCurrentValue: {
      type: String,
      default: "page"
    }
  },
  useLink,
  setup(props2, { slots }) {
    const link = reactive(useLink(props2));
    const { options } = inject(routerKey);
    const elClass = computed(() => ({
      [getLinkClass(props2.activeClass, options.linkActiveClass, "router-link-active")]: link.isActive,
      // [getLinkClass(
      //   props.inactiveClass,
      //   options.linkInactiveClass,
      //   'router-link-inactive'
      // )]: !link.isExactActive,
      [getLinkClass(props2.exactActiveClass, options.linkExactActiveClass, "router-link-exact-active")]: link.isExactActive
    }));
    return () => {
      const children = slots.default && slots.default(link);
      return props2.custom ? children : h$1("a", {
        "aria-current": link.isExactActive ? props2.ariaCurrentValue : null,
        href: link.href,
        // this would override user added attrs but Vue will still add
        // the listener, so we end up triggering both
        onClick: link.navigate,
        class: elClass.value
      }, children);
    };
  }
});
const RouterLink = RouterLinkImpl;
function guardEvent(e2) {
  if (e2.metaKey || e2.altKey || e2.ctrlKey || e2.shiftKey)
    return;
  if (e2.defaultPrevented)
    return;
  if (e2.button !== void 0 && e2.button !== 0)
    return;
  if (e2.currentTarget && e2.currentTarget.getAttribute) {
    const target2 = e2.currentTarget.getAttribute("target");
    if (/\b_blank\b/i.test(target2))
      return;
  }
  if (e2.preventDefault)
    e2.preventDefault();
  return true;
}
function includesParams(outer, inner) {
  for (const key in inner) {
    const innerValue = inner[key];
    const outerValue = outer[key];
    if (typeof innerValue === "string") {
      if (innerValue !== outerValue)
        return false;
    } else {
      if (!isArray(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value2, i) => value2 !== outerValue[i]))
        return false;
    }
  }
  return true;
}
function getOriginalPath(record) {
  return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
}
const getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;
const RouterViewImpl = /* @__PURE__ */ defineComponent({
  name: "RouterView",
  // #674 we manually inherit them
  inheritAttrs: false,
  props: {
    name: {
      type: String,
      default: "default"
    },
    route: Object
  },
  // Better compat for @vue/compat users
  // https://github.com/vuejs/router/issues/1315
  compatConfig: { MODE: 3 },
  setup(props2, { attrs, slots }) {
    const injectedRoute = inject(routerViewLocationKey);
    const routeToDisplay = computed(() => props2.route || injectedRoute.value);
    const injectedDepth = inject(viewDepthKey, 0);
    const depth = computed(() => {
      let initialDepth = unref(injectedDepth);
      const { matched } = routeToDisplay.value;
      let matchedRoute;
      while ((matchedRoute = matched[initialDepth]) && !matchedRoute.components) {
        initialDepth++;
      }
      return initialDepth;
    });
    const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth.value]);
    provide(viewDepthKey, computed(() => depth.value + 1));
    provide(matchedRouteKey, matchedRouteRef);
    provide(routerViewLocationKey, routeToDisplay);
    const viewRef = ref();
    watch(() => [viewRef.value, matchedRouteRef.value, props2.name], ([instance, to, name], [oldInstance, from, oldName]) => {
      if (to) {
        to.instances[name] = instance;
        if (from && from !== to && instance && instance === oldInstance) {
          if (!to.leaveGuards.size) {
            to.leaveGuards = from.leaveGuards;
          }
          if (!to.updateGuards.size) {
            to.updateGuards = from.updateGuards;
          }
        }
      }
      if (instance && to && // if there is no instance but to and from are the same this might be
      // the first visit
      (!from || !isSameRouteRecord(to, from) || !oldInstance)) {
        (to.enterCallbacks[name] || []).forEach((callback) => callback(instance));
      }
    }, { flush: "post" });
    return () => {
      const route = routeToDisplay.value;
      const currentName = props2.name;
      const matchedRoute = matchedRouteRef.value;
      const ViewComponent = matchedRoute && matchedRoute.components[currentName];
      if (!ViewComponent) {
        return normalizeSlot(slots.default, { Component: ViewComponent, route });
      }
      const routePropsOption = matchedRoute.props[currentName];
      const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === "function" ? routePropsOption(route) : routePropsOption : null;
      const onVnodeUnmounted = (vnode) => {
        if (vnode.component.isUnmounted) {
          matchedRoute.instances[currentName] = null;
        }
      };
      const component = h$1(ViewComponent, assign({}, routeProps, attrs, {
        onVnodeUnmounted,
        ref: viewRef
      }));
      return (
        // pass the vnode to the slot as a prop.
        // h and <component :is="..."> both accept vnodes
        normalizeSlot(slots.default, { Component: component, route }) || component
      );
    };
  }
});
function normalizeSlot(slot, data) {
  if (!slot)
    return null;
  const slotContent = slot(data);
  return slotContent.length === 1 ? slotContent[0] : slotContent;
}
const RouterView = RouterViewImpl;
function createRouter(options) {
  const matcher = createRouterMatcher(options.routes, options);
  const parseQuery$1 = options.parseQuery || parseQuery;
  const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
  const routerHistory = options.history;
  const beforeGuards = useCallbacks();
  const beforeResolveGuards = useCallbacks();
  const afterGuards = useCallbacks();
  const currentRoute = shallowRef(START_LOCATION_NORMALIZED);
  let pendingLocation = START_LOCATION_NORMALIZED;
  if (isBrowser && options.scrollBehavior && "scrollRestoration" in history) {
    history.scrollRestoration = "manual";
  }
  const normalizeParams = applyToParams.bind(null, (paramValue) => "" + paramValue);
  const encodeParams = applyToParams.bind(null, encodeParam);
  const decodeParams = (
    // @ts-expect-error: intentionally avoid the type check
    applyToParams.bind(null, decode$4)
  );
  function addRoute(parentOrRoute, route) {
    let parent;
    let record;
    if (isRouteName(parentOrRoute)) {
      parent = matcher.getRecordMatcher(parentOrRoute);
      record = route;
    } else {
      record = parentOrRoute;
    }
    return matcher.addRoute(record, parent);
  }
  function removeRoute(name) {
    const recordMatcher = matcher.getRecordMatcher(name);
    if (recordMatcher) {
      matcher.removeRoute(recordMatcher);
    }
  }
  function getRoutes() {
    return matcher.getRoutes().map((routeMatcher) => routeMatcher.record);
  }
  function hasRoute(name) {
    return !!matcher.getRecordMatcher(name);
  }
  function resolve2(rawLocation, currentLocation) {
    currentLocation = assign({}, currentLocation || currentRoute.value);
    if (typeof rawLocation === "string") {
      const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
      const matchedRoute2 = matcher.resolve({ path: locationNormalized.path }, currentLocation);
      const href22 = routerHistory.createHref(locationNormalized.fullPath);
      return assign(locationNormalized, matchedRoute2, {
        params: decodeParams(matchedRoute2.params),
        hash: decode$4(locationNormalized.hash),
        redirectedFrom: void 0,
        href: href22
      });
    }
    let matcherLocation;
    if (rawLocation.path != null) {
      matcherLocation = assign({}, rawLocation, {
        path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path
      });
    } else {
      const targetParams = assign({}, rawLocation.params);
      for (const key in targetParams) {
        if (targetParams[key] == null) {
          delete targetParams[key];
        }
      }
      matcherLocation = assign({}, rawLocation, {
        params: encodeParams(targetParams)
      });
      currentLocation.params = encodeParams(currentLocation.params);
    }
    const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
    const hash = rawLocation.hash || "";
    matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
    const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {
      hash: encodeHash(hash),
      path: matchedRoute.path
    }));
    const href2 = routerHistory.createHref(fullPath);
    return assign({
      fullPath,
      // keep the hash encoded so fullPath is effectively path + encodedQuery +
      // hash
      hash,
      query: (
        // if the user is using a custom query lib like qs, we might have
        // nested objects, so we keep the query as is, meaning it can contain
        // numbers at `$route.query`, but at the point, the user will have to
        // use their own type anyway.
        // https://github.com/vuejs/router/issues/328#issuecomment-649481567
        stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}
      )
    }, matchedRoute, {
      redirectedFrom: void 0,
      href: href2
    });
  }
  function locationAsObject(to) {
    return typeof to === "string" ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign({}, to);
  }
  function checkCanceledNavigation(to, from) {
    if (pendingLocation !== to) {
      return createRouterError(8, {
        from,
        to
      });
    }
  }
  function push(to) {
    return pushWithRedirect(to);
  }
  function replace(to) {
    return push(assign(locationAsObject(to), { replace: true }));
  }
  function handleRedirectRecord(to) {
    const lastMatched = to.matched[to.matched.length - 1];
    if (lastMatched && lastMatched.redirect) {
      const { redirect } = lastMatched;
      let newTargetLocation = typeof redirect === "function" ? redirect(to) : redirect;
      if (typeof newTargetLocation === "string") {
        newTargetLocation = newTargetLocation.includes("?") || newTargetLocation.includes("#") ? newTargetLocation = locationAsObject(newTargetLocation) : (
          // force empty params
          { path: newTargetLocation }
        );
        newTargetLocation.params = {};
      }
      return assign({
        query: to.query,
        hash: to.hash,
        // avoid transferring params if the redirect has a path
        params: newTargetLocation.path != null ? {} : to.params
      }, newTargetLocation);
    }
  }
  function pushWithRedirect(to, redirectedFrom) {
    const targetLocation = pendingLocation = resolve2(to);
    const from = currentRoute.value;
    const data = to.state;
    const force = to.force;
    const replace2 = to.replace === true;
    const shouldRedirect = handleRedirectRecord(targetLocation);
    if (shouldRedirect)
      return pushWithRedirect(
        assign(locationAsObject(shouldRedirect), {
          state: typeof shouldRedirect === "object" ? assign({}, data, shouldRedirect.state) : data,
          force,
          replace: replace2
        }),
        // keep original redirectedFrom if it exists
        redirectedFrom || targetLocation
      );
    const toLocation = targetLocation;
    toLocation.redirectedFrom = redirectedFrom;
    let failure;
    if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {
      failure = createRouterError(16, { to: toLocation, from });
      handleScroll(
        from,
        from,
        // this is a push, the only way for it to be triggered from a
        // history.listen is with a redirect, which makes it become a push
        true,
        // This cannot be the first navigation because the initial location
        // cannot be manually navigated to
        false
      );
    }
    return (failure ? Promise.resolve(failure) : navigate(toLocation, from)).catch((error) => isNavigationFailure(error) ? (
      // navigation redirects still mark the router as ready
      isNavigationFailure(
        error,
        2
        /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
      ) ? error : markAsReady(error)
    ) : (
      // reject any unknown error
      triggerError(error, toLocation, from)
    )).then((failure2) => {
      if (failure2) {
        if (isNavigationFailure(
          failure2,
          2
          /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
        )) {
          return pushWithRedirect(
            // keep options
            assign({
              // preserve an existing replacement but allow the redirect to override it
              replace: replace2
            }, locationAsObject(failure2.to), {
              state: typeof failure2.to === "object" ? assign({}, data, failure2.to.state) : data,
              force
            }),
            // preserve the original redirectedFrom if any
            redirectedFrom || toLocation
          );
        }
      } else {
        failure2 = finalizeNavigation(toLocation, from, true, replace2, data);
      }
      triggerAfterEach(toLocation, from, failure2);
      return failure2;
    });
  }
  function checkCanceledNavigationAndReject(to, from) {
    const error = checkCanceledNavigation(to, from);
    return error ? Promise.reject(error) : Promise.resolve();
  }
  function runWithContext(fn) {
    const app2 = installedApps.values().next().value;
    return app2 && typeof app2.runWithContext === "function" ? app2.runWithContext(fn) : fn();
  }
  function navigate(to, from) {
    let guards;
    const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);
    guards = extractComponentsGuards(leavingRecords.reverse(), "beforeRouteLeave", to, from);
    for (const record of leavingRecords) {
      record.leaveGuards.forEach((guard) => {
        guards.push(guardToPromiseFn(guard, to, from));
      });
    }
    const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);
    guards.push(canceledNavigationCheck);
    return runGuardQueue(guards).then(() => {
      guards = [];
      for (const guard of beforeGuards.list()) {
        guards.push(guardToPromiseFn(guard, to, from));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = extractComponentsGuards(updatingRecords, "beforeRouteUpdate", to, from);
      for (const record of updatingRecords) {
        record.updateGuards.forEach((guard) => {
          guards.push(guardToPromiseFn(guard, to, from));
        });
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const record of enteringRecords) {
        if (record.beforeEnter) {
          if (isArray(record.beforeEnter)) {
            for (const beforeEnter of record.beforeEnter)
              guards.push(guardToPromiseFn(beforeEnter, to, from));
          } else {
            guards.push(guardToPromiseFn(record.beforeEnter, to, from));
          }
        }
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      to.matched.forEach((record) => record.enterCallbacks = {});
      guards = extractComponentsGuards(enteringRecords, "beforeRouteEnter", to, from, runWithContext);
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const guard of beforeResolveGuards.list()) {
        guards.push(guardToPromiseFn(guard, to, from));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).catch((err) => isNavigationFailure(
      err,
      8
      /* ErrorTypes.NAVIGATION_CANCELLED */
    ) ? err : Promise.reject(err));
  }
  function triggerAfterEach(to, from, failure) {
    afterGuards.list().forEach((guard) => runWithContext(() => guard(to, from, failure)));
  }
  function finalizeNavigation(toLocation, from, isPush, replace2, data) {
    const error = checkCanceledNavigation(toLocation, from);
    if (error)
      return error;
    const isFirstNavigation = from === START_LOCATION_NORMALIZED;
    const state = !isBrowser ? {} : history.state;
    if (isPush) {
      if (replace2 || isFirstNavigation)
        routerHistory.replace(toLocation.fullPath, assign({
          scroll: isFirstNavigation && state && state.scroll
        }, data));
      else
        routerHistory.push(toLocation.fullPath, data);
    }
    currentRoute.value = toLocation;
    handleScroll(toLocation, from, isPush, isFirstNavigation);
    markAsReady();
  }
  let removeHistoryListener;
  function setupListeners() {
    if (removeHistoryListener)
      return;
    removeHistoryListener = routerHistory.listen((to, _from, info) => {
      if (!router2.listening)
        return;
      const toLocation = resolve2(to);
      const shouldRedirect = handleRedirectRecord(toLocation);
      if (shouldRedirect) {
        pushWithRedirect(assign(shouldRedirect, { replace: true }), toLocation).catch(noop);
        return;
      }
      pendingLocation = toLocation;
      const from = currentRoute.value;
      if (isBrowser) {
        saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());
      }
      navigate(toLocation, from).catch((error) => {
        if (isNavigationFailure(
          error,
          4 | 8
          /* ErrorTypes.NAVIGATION_CANCELLED */
        )) {
          return error;
        }
        if (isNavigationFailure(
          error,
          2
          /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
        )) {
          pushWithRedirect(
            error.to,
            toLocation
            // avoid an uncaught rejection, let push call triggerError
          ).then((failure) => {
            if (isNavigationFailure(
              failure,
              4 | 16
              /* ErrorTypes.NAVIGATION_DUPLICATED */
            ) && !info.delta && info.type === NavigationType.pop) {
              routerHistory.go(-1, false);
            }
          }).catch(noop);
          return Promise.reject();
        }
        if (info.delta) {
          routerHistory.go(-info.delta, false);
        }
        return triggerError(error, toLocation, from);
      }).then((failure) => {
        failure = failure || finalizeNavigation(
          // after navigation, all matched components are resolved
          toLocation,
          from,
          false
        );
        if (failure) {
          if (info.delta && // a new navigation has been triggered, so we do not want to revert, that will change the current history
          // entry while a different route is displayed
          !isNavigationFailure(
            failure,
            8
            /* ErrorTypes.NAVIGATION_CANCELLED */
          )) {
            routerHistory.go(-info.delta, false);
          } else if (info.type === NavigationType.pop && isNavigationFailure(
            failure,
            4 | 16
            /* ErrorTypes.NAVIGATION_DUPLICATED */
          )) {
            routerHistory.go(-1, false);
          }
        }
        triggerAfterEach(toLocation, from, failure);
      }).catch(noop);
    });
  }
  let readyHandlers = useCallbacks();
  let errorListeners = useCallbacks();
  let ready;
  function triggerError(error, to, from) {
    markAsReady(error);
    const list = errorListeners.list();
    if (list.length) {
      list.forEach((handler) => handler(error, to, from));
    } else {
      console.error(error);
    }
    return Promise.reject(error);
  }
  function isReady() {
    if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)
      return Promise.resolve();
    return new Promise((resolve22, reject) => {
      readyHandlers.add([resolve22, reject]);
    });
  }
  function markAsReady(err) {
    if (!ready) {
      ready = !err;
      setupListeners();
      readyHandlers.list().forEach(([resolve22, reject]) => err ? reject(err) : resolve22());
      readyHandlers.reset();
    }
    return err;
  }
  function handleScroll(to, from, isPush, isFirstNavigation) {
    const { scrollBehavior } = options;
    if (!isBrowser || !scrollBehavior)
      return Promise.resolve();
    const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;
    return nextTick$1().then(() => scrollBehavior(to, from, scrollPosition)).then((position2) => position2 && scrollToPosition(position2)).catch((err) => triggerError(err, to, from));
  }
  const go = (delta) => routerHistory.go(delta);
  let started;
  const installedApps = /* @__PURE__ */ new Set();
  const router2 = {
    currentRoute,
    listening: true,
    addRoute,
    removeRoute,
    clearRoutes: matcher.clearRoutes,
    hasRoute,
    getRoutes,
    resolve: resolve2,
    options,
    push,
    replace,
    go,
    back: () => go(-1),
    forward: () => go(1),
    beforeEach: beforeGuards.add,
    beforeResolve: beforeResolveGuards.add,
    afterEach: afterGuards.add,
    onError: errorListeners.add,
    isReady,
    install(app2) {
      const router22 = this;
      app2.component("RouterLink", RouterLink);
      app2.component("RouterView", RouterView);
      app2.config.globalProperties.$router = router22;
      Object.defineProperty(app2.config.globalProperties, "$route", {
        enumerable: true,
        get: () => unref(currentRoute)
      });
      if (isBrowser && // used for the initial navigation client side to avoid pushing
      // multiple times when the router is used in multiple apps
      !started && currentRoute.value === START_LOCATION_NORMALIZED) {
        started = true;
        push(routerHistory.location).catch((err) => {
        });
      }
      const reactiveRoute = {};
      for (const key in START_LOCATION_NORMALIZED) {
        Object.defineProperty(reactiveRoute, key, {
          get: () => currentRoute.value[key],
          enumerable: true
        });
      }
      app2.provide(routerKey, router22);
      app2.provide(routeLocationKey, shallowReactive(reactiveRoute));
      app2.provide(routerViewLocationKey, currentRoute);
      const unmountApp = app2.unmount;
      installedApps.add(app2);
      app2.unmount = function() {
        installedApps.delete(app2);
        if (installedApps.size < 1) {
          pendingLocation = START_LOCATION_NORMALIZED;
          removeHistoryListener && removeHistoryListener();
          removeHistoryListener = null;
          currentRoute.value = START_LOCATION_NORMALIZED;
          started = false;
          ready = false;
        }
        unmountApp();
      };
    }
  };
  function runGuardQueue(guards) {
    return guards.reduce((promise, guard) => promise.then(() => runWithContext(guard)), Promise.resolve());
  }
  return router2;
}
function extractChangingRecords(to, from) {
  const leavingRecords = [];
  const updatingRecords = [];
  const enteringRecords = [];
  const len = Math.max(from.matched.length, to.matched.length);
  for (let i = 0; i < len; i++) {
    const recordFrom = from.matched[i];
    if (recordFrom) {
      if (to.matched.find((record) => isSameRouteRecord(record, recordFrom)))
        updatingRecords.push(recordFrom);
      else
        leavingRecords.push(recordFrom);
    }
    const recordTo = to.matched[i];
    if (recordTo) {
      if (!from.matched.find((record) => isSameRouteRecord(record, recordTo))) {
        enteringRecords.push(recordTo);
      }
    }
  }
  return [leavingRecords, updatingRecords, enteringRecords];
}
function useRouter() {
  return inject(routerKey);
}
function useRoute(_name) {
  return inject(routeLocationKey);
}
const login = async ({ email, password }) => {
  try {
    const response = await axiosInstance.post(`/users/login`, { email, password });
    console.log(response);
    return response.data;
  } catch (error) {
    console.error(error);
    const message = error.response.data.error || "Error al iniciar sesión";
    notifyErrorRequest$1(message);
  }
};
const _withScopeId$d = (n2) => (pushScopeId("data-v-8db609e2"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$h = { id: "login" };
const _hoisted_2$h = { class: "login-card" };
const _hoisted_3$h = /* @__PURE__ */ _withScopeId$d(() => /* @__PURE__ */ createBaseVNode("div", { class: "logo-container" }, [
  /* @__PURE__ */ createBaseVNode("img", {
    src: _imports_0,
    alt: "Logo",
    class: "logo"
  })
], -1));
const _hoisted_4$g = /* @__PURE__ */ _withScopeId$d(() => /* @__PURE__ */ createBaseVNode("div", { class: "text-white text-center text-h5 q-mb-xl q-mt-lg" }, " Sistema IOT - Secado del Café ", -1));
const _hoisted_5$d = { id: "contBtnLogin" };
const _hoisted_6$b = { id: "cont-forgot-password" };
const _sfc_main$h = {
  __name: "Login",
  setup(__props) {
    const router2 = useRouter();
    const useUsers = storeUsers();
    useQuasar();
    let form = ref({
      email: "",
      password: ""
    });
    const loadBtn = ref(false);
    async function onSubmit() {
      try {
        loadBtn.value = true;
        const response = await login(form.value);
        const dateNow = (/* @__PURE__ */ new Date()).toISOString();
        localStorage.setItem("token", response.token);
        localStorage.setItem("dateLogin", dateNow);
        await useUsers.setUser();
        await useUsers.setFarms();
        useUsers.setFarm();
        router2.push("/nav");
      } catch (error) {
        console.log(error);
      } finally {
        loadBtn.value = false;
      }
    }
    const seePassword = ref(false);
    return (_ctx, _cache) => {
      const _component_router_link = resolveComponent("router-link");
      return openBlock(), createElementBlock("div", _hoisted_1$h, [
        createBaseVNode("div", _hoisted_2$h, [
          _hoisted_3$h,
          _hoisted_4$g,
          createVNode(QForm, {
            onSubmit,
            class: "q-gutter-md"
          }, {
            default: withCtx(() => [
              createVNode(QInput, {
                color: "white",
                "label-color": "dark",
                outlined: "",
                type: "email",
                modelValue: unref(form).email,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(form).email = $event),
                label: "Correo electrónico *",
                "lazy-rules": "",
                rules: [
                  (val) => val && val.length > 0 || "Correo electrónico requerido",
                  (val) => /.+@.+\..+/.test(val) || "Correo electrónico inválido"
                ],
                "bg-color": "white"
              }, null, 8, ["modelValue", "rules"]),
              createVNode(QInput, {
                color: "white",
                "label-color": "dark",
                outlined: "",
                type: seePassword.value ? "text" : "password",
                modelValue: unref(form).password,
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => unref(form).password = $event),
                label: "Contraseña *",
                "lazy-rules": "",
                rules: [
                  (val) => val !== null && val !== "" || "Contraseña requerida"
                ],
                "bg-color": "white"
              }, {
                append: withCtx(() => [
                  createVNode(QIcon, {
                    name: seePassword.value ? "visibility" : "visibility_off",
                    class: "cursor-pointer",
                    onClick: _cache[1] || (_cache[1] = ($event) => seePassword.value = !seePassword.value)
                  }, null, 8, ["name"])
                ]),
                _: 1
              }, 8, ["type", "modelValue", "rules"]),
              createBaseVNode("div", _hoisted_5$d, [
                createVNode(QBtn, {
                  class: "button_style",
                  label: "Iniciar Sesión",
                  type: "submit",
                  loading: loadBtn.value
                }, null, 8, ["loading"])
              ])
            ]),
            _: 1
          }),
          createBaseVNode("div", _hoisted_6$b, [
            createVNode(_component_router_link, { to: "/forgot-password" }, {
              default: withCtx(() => [
                createTextVNode("Recuperar contraseña")
              ]),
              _: 1
            })
          ])
        ])
      ]);
    };
  }
};
const Login = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["__scopeId", "data-v-8db609e2"]]);
var apexcharts_common = { exports: {} };
/*!
 * ApexCharts v3.49.2
 * (c) 2018-2024 ApexCharts
 * Released under the MIT License.
 */
(function(module, exports) {
  function t2(t3, e3) {
    var i2 = Object.keys(t3);
    if (Object.getOwnPropertySymbols) {
      var a3 = Object.getOwnPropertySymbols(t3);
      e3 && (a3 = a3.filter(function(e4) {
        return Object.getOwnPropertyDescriptor(t3, e4).enumerable;
      })), i2.push.apply(i2, a3);
    }
    return i2;
  }
  function e2(e3) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var a3 = null != arguments[i2] ? arguments[i2] : {};
      i2 % 2 ? t2(Object(a3), true).forEach(function(t3) {
        o2(e3, t3, a3[t3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(a3)) : t2(Object(a3)).forEach(function(t3) {
        Object.defineProperty(e3, t3, Object.getOwnPropertyDescriptor(a3, t3));
      });
    }
    return e3;
  }
  function i(t3) {
    return i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
      return typeof t4;
    } : function(t4) {
      return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
    }, i(t3);
  }
  function a2(t3, e3) {
    if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
  }
  function s2(t3, e3) {
    for (var i2 = 0; i2 < e3.length; i2++) {
      var a3 = e3[i2];
      a3.enumerable = a3.enumerable || false, a3.configurable = true, "value" in a3 && (a3.writable = true), Object.defineProperty(t3, a3.key, a3);
    }
  }
  function r(t3, e3, i2) {
    return e3 && s2(t3.prototype, e3), i2 && s2(t3, i2), t3;
  }
  function o2(t3, e3, i2) {
    return e3 in t3 ? Object.defineProperty(t3, e3, { value: i2, enumerable: true, configurable: true, writable: true }) : t3[e3] = i2, t3;
  }
  function n2(t3, e3) {
    if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function");
    t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), e3 && h2(t3, e3);
  }
  function l2(t3) {
    return l2 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t4) {
      return t4.__proto__ || Object.getPrototypeOf(t4);
    }, l2(t3);
  }
  function h2(t3, e3) {
    return h2 = Object.setPrototypeOf || function(t4, e4) {
      return t4.__proto__ = e4, t4;
    }, h2(t3, e3);
  }
  function c2(t3) {
    if (void 0 === t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return t3;
  }
  function d2(t3) {
    var e3 = function() {
      if ("undefined" == typeof Reflect || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if ("function" == typeof Proxy) return true;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), true;
      } catch (t4) {
        return false;
      }
    }();
    return function() {
      var i2, a3 = l2(t3);
      if (e3) {
        var s3 = l2(this).constructor;
        i2 = Reflect.construct(a3, arguments, s3);
      } else i2 = a3.apply(this, arguments);
      return function(t4, e4) {
        if (e4 && ("object" == typeof e4 || "function" == typeof e4)) return e4;
        if (void 0 !== e4) throw new TypeError("Derived constructors may only return object or undefined");
        return c2(t4);
      }(this, i2);
    };
  }
  function g2(t3, e3) {
    return function(t4) {
      if (Array.isArray(t4)) return t4;
    }(t3) || function(t4, e4) {
      var i2 = null == t4 ? null : "undefined" != typeof Symbol && t4[Symbol.iterator] || t4["@@iterator"];
      if (null == i2) return;
      var a3, s3, r2 = [], o3 = true, n3 = false;
      try {
        for (i2 = i2.call(t4); !(o3 = (a3 = i2.next()).done) && (r2.push(a3.value), !e4 || r2.length !== e4); o3 = true) ;
      } catch (t5) {
        n3 = true, s3 = t5;
      } finally {
        try {
          o3 || null == i2.return || i2.return();
        } finally {
          if (n3) throw s3;
        }
      }
      return r2;
    }(t3, e3) || p2(t3, e3) || function() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }
  function u2(t3) {
    return function(t4) {
      if (Array.isArray(t4)) return f2(t4);
    }(t3) || function(t4) {
      if ("undefined" != typeof Symbol && null != t4[Symbol.iterator] || null != t4["@@iterator"]) return Array.from(t4);
    }(t3) || p2(t3) || function() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }
  function p2(t3, e3) {
    if (t3) {
      if ("string" == typeof t3) return f2(t3, e3);
      var i2 = Object.prototype.toString.call(t3).slice(8, -1);
      return "Object" === i2 && t3.constructor && (i2 = t3.constructor.name), "Map" === i2 || "Set" === i2 ? Array.from(t3) : "Arguments" === i2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i2) ? f2(t3, e3) : void 0;
    }
  }
  function f2(t3, e3) {
    (null == e3 || e3 > t3.length) && (e3 = t3.length);
    for (var i2 = 0, a3 = new Array(e3); i2 < e3; i2++) a3[i2] = t3[i2];
    return a3;
  }
  var x2 = function() {
    function t3() {
      a2(this, t3);
    }
    return r(t3, [{ key: "shadeRGBColor", value: function(t4, e3) {
      var i2 = e3.split(","), a3 = t4 < 0 ? 0 : 255, s3 = t4 < 0 ? -1 * t4 : t4, r2 = parseInt(i2[0].slice(4), 10), o3 = parseInt(i2[1], 10), n3 = parseInt(i2[2], 10);
      return "rgb(" + (Math.round((a3 - r2) * s3) + r2) + "," + (Math.round((a3 - o3) * s3) + o3) + "," + (Math.round((a3 - n3) * s3) + n3) + ")";
    } }, { key: "shadeHexColor", value: function(t4, e3) {
      var i2 = parseInt(e3.slice(1), 16), a3 = t4 < 0 ? 0 : 255, s3 = t4 < 0 ? -1 * t4 : t4, r2 = i2 >> 16, o3 = i2 >> 8 & 255, n3 = 255 & i2;
      return "#" + (16777216 + 65536 * (Math.round((a3 - r2) * s3) + r2) + 256 * (Math.round((a3 - o3) * s3) + o3) + (Math.round((a3 - n3) * s3) + n3)).toString(16).slice(1);
    } }, { key: "shadeColor", value: function(e3, i2) {
      return t3.isColorHex(i2) ? this.shadeHexColor(e3, i2) : this.shadeRGBColor(e3, i2);
    } }], [{ key: "bind", value: function(t4, e3) {
      return function() {
        return t4.apply(e3, arguments);
      };
    } }, { key: "isObject", value: function(t4) {
      return t4 && "object" === i(t4) && !Array.isArray(t4) && null != t4;
    } }, { key: "is", value: function(t4, e3) {
      return Object.prototype.toString.call(e3) === "[object " + t4 + "]";
    } }, { key: "listToArray", value: function(t4) {
      var e3, i2 = [];
      for (e3 = 0; e3 < t4.length; e3++) i2[e3] = t4[e3];
      return i2;
    } }, { key: "extend", value: function(t4, e3) {
      var i2 = this;
      "function" != typeof Object.assign && (Object.assign = function(t5) {
        if (null == t5) throw new TypeError("Cannot convert undefined or null to object");
        for (var e4 = Object(t5), i3 = 1; i3 < arguments.length; i3++) {
          var a4 = arguments[i3];
          if (null != a4) for (var s3 in a4) a4.hasOwnProperty(s3) && (e4[s3] = a4[s3]);
        }
        return e4;
      });
      var a3 = Object.assign({}, t4);
      return this.isObject(t4) && this.isObject(e3) && Object.keys(e3).forEach(function(s3) {
        i2.isObject(e3[s3]) && s3 in t4 ? a3[s3] = i2.extend(t4[s3], e3[s3]) : Object.assign(a3, o2({}, s3, e3[s3]));
      }), a3;
    } }, { key: "extendArray", value: function(e3, i2) {
      var a3 = [];
      return e3.map(function(e4) {
        a3.push(t3.extend(i2, e4));
      }), e3 = a3;
    } }, { key: "monthMod", value: function(t4) {
      return t4 % 12;
    } }, { key: "clone", value: function(e3) {
      if (t3.is("Array", e3)) {
        for (var a3 = [], s3 = 0; s3 < e3.length; s3++) a3[s3] = this.clone(e3[s3]);
        return a3;
      }
      if (t3.is("Null", e3)) return null;
      if (t3.is("Date", e3)) return e3;
      if ("object" === i(e3)) {
        var r2 = {};
        for (var o3 in e3) e3.hasOwnProperty(o3) && (r2[o3] = this.clone(e3[o3]));
        return r2;
      }
      return e3;
    } }, { key: "log10", value: function(t4) {
      return Math.log(t4) / Math.LN10;
    } }, { key: "roundToBase10", value: function(t4) {
      return Math.pow(10, Math.floor(Math.log10(t4)));
    } }, { key: "roundToBase", value: function(t4, e3) {
      return Math.pow(e3, Math.floor(Math.log(t4) / Math.log(e3)));
    } }, { key: "parseNumber", value: function(t4) {
      return null === t4 ? t4 : parseFloat(t4);
    } }, { key: "stripNumber", value: function(t4) {
      var e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2;
      return Number.isInteger(t4) ? t4 : parseFloat(t4.toPrecision(e3));
    } }, { key: "randomId", value: function() {
      return (Math.random() + 1).toString(36).substring(4);
    } }, { key: "noExponents", value: function(t4) {
      var e3 = String(t4).split(/[eE]/);
      if (1 === e3.length) return e3[0];
      var i2 = "", a3 = t4 < 0 ? "-" : "", s3 = e3[0].replace(".", ""), r2 = Number(e3[1]) + 1;
      if (r2 < 0) {
        for (i2 = a3 + "0."; r2++; ) i2 += "0";
        return i2 + s3.replace(/^-/, "");
      }
      for (r2 -= s3.length; r2--; ) i2 += "0";
      return s3 + i2;
    } }, { key: "getDimensions", value: function(t4) {
      var e3 = getComputedStyle(t4, null), i2 = t4.clientHeight, a3 = t4.clientWidth;
      return i2 -= parseFloat(e3.paddingTop) + parseFloat(e3.paddingBottom), [a3 -= parseFloat(e3.paddingLeft) + parseFloat(e3.paddingRight), i2];
    } }, { key: "getBoundingClientRect", value: function(t4) {
      var e3 = t4.getBoundingClientRect();
      return { top: e3.top, right: e3.right, bottom: e3.bottom, left: e3.left, width: t4.clientWidth, height: t4.clientHeight, x: e3.left, y: e3.top };
    } }, { key: "getLargestStringFromArr", value: function(t4) {
      return t4.reduce(function(t5, e3) {
        return Array.isArray(e3) && (e3 = e3.reduce(function(t6, e4) {
          return t6.length > e4.length ? t6 : e4;
        })), t5.length > e3.length ? t5 : e3;
      }, 0);
    } }, { key: "hexToRgba", value: function() {
      var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "#999999", e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0.6;
      "#" !== t4.substring(0, 1) && (t4 = "#999999");
      var i2 = t4.replace("#", "");
      i2 = i2.match(new RegExp("(.{" + i2.length / 3 + "})", "g"));
      for (var a3 = 0; a3 < i2.length; a3++) i2[a3] = parseInt(1 === i2[a3].length ? i2[a3] + i2[a3] : i2[a3], 16);
      return void 0 !== e3 && i2.push(e3), "rgba(" + i2.join(",") + ")";
    } }, { key: "getOpacityFromRGBA", value: function(t4) {
      return parseFloat(t4.replace(/^.*,(.+)\)/, "$1"));
    } }, { key: "rgb2hex", value: function(t4) {
      return (t4 = t4.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && 4 === t4.length ? "#" + ("0" + parseInt(t4[1], 10).toString(16)).slice(-2) + ("0" + parseInt(t4[2], 10).toString(16)).slice(-2) + ("0" + parseInt(t4[3], 10).toString(16)).slice(-2) : "";
    } }, { key: "isColorHex", value: function(t4) {
      return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(t4);
    } }, { key: "getPolygonPos", value: function(t4, e3) {
      for (var i2 = [], a3 = 2 * Math.PI / e3, s3 = 0; s3 < e3; s3++) {
        var r2 = {};
        r2.x = t4 * Math.sin(s3 * a3), r2.y = -t4 * Math.cos(s3 * a3), i2.push(r2);
      }
      return i2;
    } }, { key: "polarToCartesian", value: function(t4, e3, i2, a3) {
      var s3 = (a3 - 90) * Math.PI / 180;
      return { x: t4 + i2 * Math.cos(s3), y: e3 + i2 * Math.sin(s3) };
    } }, { key: "escapeString", value: function(t4) {
      var e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "x", i2 = t4.toString().slice();
      return i2 = i2.replace(/[` ~!@#$%^&*()|+\=?;:'",.<>{}[\]\\/]/gi, e3);
    } }, { key: "negToZero", value: function(t4) {
      return t4 < 0 ? 0 : t4;
    } }, { key: "moveIndexInArray", value: function(t4, e3, i2) {
      if (i2 >= t4.length) for (var a3 = i2 - t4.length + 1; a3--; ) t4.push(void 0);
      return t4.splice(i2, 0, t4.splice(e3, 1)[0]), t4;
    } }, { key: "extractNumber", value: function(t4) {
      return parseFloat(t4.replace(/[^\d.]*/g, ""));
    } }, { key: "findAncestor", value: function(t4, e3) {
      for (; (t4 = t4.parentElement) && !t4.classList.contains(e3); ) ;
      return t4;
    } }, { key: "setELstyles", value: function(t4, e3) {
      for (var i2 in e3) e3.hasOwnProperty(i2) && (t4.style.key = e3[i2]);
    } }, { key: "isNumber", value: function(t4) {
      return !isNaN(t4) && parseFloat(Number(t4)) === t4 && !isNaN(parseInt(t4, 10));
    } }, { key: "isFloat", value: function(t4) {
      return Number(t4) === t4 && t4 % 1 != 0;
    } }, { key: "isSafari", value: function() {
      return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    } }, { key: "isFirefox", value: function() {
      return navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
    } }, { key: "isIE11", value: function() {
      if (-1 !== window.navigator.userAgent.indexOf("MSIE") || window.navigator.appVersion.indexOf("Trident/") > -1) return true;
    } }, { key: "isIE", value: function() {
      var t4 = window.navigator.userAgent, e3 = t4.indexOf("MSIE ");
      if (e3 > 0) return parseInt(t4.substring(e3 + 5, t4.indexOf(".", e3)), 10);
      if (t4.indexOf("Trident/") > 0) {
        var i2 = t4.indexOf("rv:");
        return parseInt(t4.substring(i2 + 3, t4.indexOf(".", i2)), 10);
      }
      var a3 = t4.indexOf("Edge/");
      return a3 > 0 && parseInt(t4.substring(a3 + 5, t4.indexOf(".", a3)), 10);
    } }, { key: "getGCD", value: function(t4, e3) {
      var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 7, a3 = Math.pow(10, i2 - Math.floor(Math.log10(Math.max(t4, e3))));
      for (t4 = Math.round(Math.abs(t4) * a3), e3 = Math.round(Math.abs(e3) * a3); e3; ) {
        var s3 = e3;
        e3 = t4 % e3, t4 = s3;
      }
      return t4 / a3;
    } }, { key: "getPrimeFactors", value: function(t4) {
      for (var e3 = [], i2 = 2; t4 >= 2; ) t4 % i2 == 0 ? (e3.push(i2), t4 /= i2) : i2++;
      return e3;
    } }, { key: "mod", value: function(t4, e3) {
      var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 7, a3 = Math.pow(10, i2 - Math.floor(Math.log10(Math.max(t4, e3))));
      return (t4 = Math.round(Math.abs(t4) * a3)) % (e3 = Math.round(Math.abs(e3) * a3)) / a3;
    } }]), t3;
  }(), b2 = function() {
    function t3(e3) {
      a2(this, t3), this.ctx = e3, this.w = e3.w, this.setEasingFunctions();
    }
    return r(t3, [{ key: "setEasingFunctions", value: function() {
      var t4;
      if (!this.w.globals.easing) {
        switch (this.w.config.chart.animations.easing) {
          case "linear":
            t4 = "-";
            break;
          case "easein":
            t4 = "<";
            break;
          case "easeout":
            t4 = ">";
            break;
          case "easeinout":
          default:
            t4 = "<>";
            break;
          case "swing":
            t4 = function(t5) {
              var e3 = 1.70158;
              return (t5 -= 1) * t5 * ((e3 + 1) * t5 + e3) + 1;
            };
            break;
          case "bounce":
            t4 = function(t5) {
              return t5 < 1 / 2.75 ? 7.5625 * t5 * t5 : t5 < 2 / 2.75 ? 7.5625 * (t5 -= 1.5 / 2.75) * t5 + 0.75 : t5 < 2.5 / 2.75 ? 7.5625 * (t5 -= 2.25 / 2.75) * t5 + 0.9375 : 7.5625 * (t5 -= 2.625 / 2.75) * t5 + 0.984375;
            };
            break;
          case "elastic":
            t4 = function(t5) {
              return t5 === !!t5 ? t5 : Math.pow(2, -10 * t5) * Math.sin((t5 - 0.075) * (2 * Math.PI) / 0.3) + 1;
            };
        }
        this.w.globals.easing = t4;
      }
    } }, { key: "animateLine", value: function(t4, e3, i2, a3) {
      t4.attr(e3).animate(a3).attr(i2);
    } }, { key: "animateMarker", value: function(t4, e3, i2, a3, s3, r2) {
      e3 || (e3 = 0), t4.attr({ r: e3, width: e3, height: e3 }).animate(a3, s3).attr({ r: i2, width: i2.width, height: i2.height }).afterAll(function() {
        r2();
      });
    } }, { key: "animateCircle", value: function(t4, e3, i2, a3, s3) {
      t4.attr({ r: e3.r, cx: e3.cx, cy: e3.cy }).animate(a3, s3).attr({ r: i2.r, cx: i2.cx, cy: i2.cy });
    } }, { key: "animateRect", value: function(t4, e3, i2, a3, s3) {
      t4.attr(e3).animate(a3).attr(i2).afterAll(function() {
        return s3();
      });
    } }, { key: "animatePathsGradually", value: function(t4) {
      var e3 = t4.el, i2 = t4.realIndex, a3 = t4.j, s3 = t4.fill, r2 = t4.pathFrom, o3 = t4.pathTo, n3 = t4.speed, l3 = t4.delay, h3 = this.w, c3 = 0;
      h3.config.chart.animations.animateGradually.enabled && (c3 = h3.config.chart.animations.animateGradually.delay), h3.config.chart.animations.dynamicAnimation.enabled && h3.globals.dataChanged && "bar" !== h3.config.chart.type && (c3 = 0), this.morphSVG(e3, i2, a3, "line" !== h3.config.chart.type || h3.globals.comboCharts ? s3 : "stroke", r2, o3, n3, l3 * c3);
    } }, { key: "showDelayedElements", value: function() {
      this.w.globals.delayedElements.forEach(function(t4) {
        var e3 = t4.el;
        e3.classList.remove("apexcharts-element-hidden"), e3.classList.add("apexcharts-hidden-element-shown");
      });
    } }, { key: "animationCompleted", value: function(t4) {
      var e3 = this.w;
      e3.globals.animationEnded || (e3.globals.animationEnded = true, this.showDelayedElements(), "function" == typeof e3.config.chart.events.animationEnd && e3.config.chart.events.animationEnd(this.ctx, { el: t4, w: e3 }));
    } }, { key: "morphSVG", value: function(t4, e3, i2, a3, s3, r2, o3, n3) {
      var l3 = this, h3 = this.w;
      s3 || (s3 = t4.attr("pathFrom")), r2 || (r2 = t4.attr("pathTo"));
      var c3 = function(t5) {
        return "radar" === h3.config.chart.type && (o3 = 1), "M 0 ".concat(h3.globals.gridHeight);
      };
      (!s3 || s3.indexOf("undefined") > -1 || s3.indexOf("NaN") > -1) && (s3 = c3()), (!r2 || r2.indexOf("undefined") > -1 || r2.indexOf("NaN") > -1) && (r2 = c3()), h3.globals.shouldAnimate || (o3 = 1), t4.plot(s3).animate(1, h3.globals.easing, n3).plot(s3).animate(o3, h3.globals.easing, n3).plot(r2).afterAll(function() {
        x2.isNumber(i2) ? i2 === h3.globals.series[h3.globals.maxValsInArrayIndex].length - 2 && h3.globals.shouldAnimate && l3.animationCompleted(t4) : "none" !== a3 && h3.globals.shouldAnimate && (!h3.globals.comboCharts && e3 === h3.globals.series.length - 1 || h3.globals.comboCharts) && l3.animationCompleted(t4), l3.showDelayedElements();
      });
    } }]), t3;
  }(), v2 = function() {
    function t3(e3) {
      a2(this, t3), this.ctx = e3, this.w = e3.w;
    }
    return r(t3, [{ key: "getDefaultFilter", value: function(t4, e3) {
      var i2 = this.w;
      t4.unfilter(true), new window.SVG.Filter().size("120%", "180%", "-5%", "-40%"), "none" !== i2.config.states.normal.filter ? this.applyFilter(t4, e3, i2.config.states.normal.filter.type, i2.config.states.normal.filter.value) : i2.config.chart.dropShadow.enabled && this.dropShadow(t4, i2.config.chart.dropShadow, e3);
    } }, { key: "addNormalFilter", value: function(t4, e3) {
      var i2 = this.w;
      i2.config.chart.dropShadow.enabled && !t4.node.classList.contains("apexcharts-marker") && this.dropShadow(t4, i2.config.chart.dropShadow, e3);
    } }, { key: "addLightenFilter", value: function(t4, e3, i2) {
      var a3 = this, s3 = this.w, r2 = i2.intensity;
      t4.unfilter(true);
      new window.SVG.Filter();
      t4.filter(function(t5) {
        var i3 = s3.config.chart.dropShadow;
        (i3.enabled ? a3.addShadow(t5, e3, i3) : t5).componentTransfer({ rgb: { type: "linear", slope: 1.5, intercept: r2 } });
      }), t4.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t4.filterer.node);
    } }, { key: "addDarkenFilter", value: function(t4, e3, i2) {
      var a3 = this, s3 = this.w, r2 = i2.intensity;
      t4.unfilter(true);
      new window.SVG.Filter();
      t4.filter(function(t5) {
        var i3 = s3.config.chart.dropShadow;
        (i3.enabled ? a3.addShadow(t5, e3, i3) : t5).componentTransfer({ rgb: { type: "linear", slope: r2 } });
      }), t4.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t4.filterer.node);
    } }, { key: "applyFilter", value: function(t4, e3, i2) {
      var a3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0.5;
      switch (i2) {
        case "none":
          this.addNormalFilter(t4, e3);
          break;
        case "lighten":
          this.addLightenFilter(t4, e3, { intensity: a3 });
          break;
        case "darken":
          this.addDarkenFilter(t4, e3, { intensity: a3 });
      }
    } }, { key: "addShadow", value: function(t4, e3, i2) {
      var a3, s3 = this.w, r2 = i2.blur, o3 = i2.top, n3 = i2.left, l3 = i2.color, h3 = i2.opacity;
      if ((null === (a3 = s3.config.chart.dropShadow.enabledOnSeries) || void 0 === a3 ? void 0 : a3.length) > 0 && -1 === s3.config.chart.dropShadow.enabledOnSeries.indexOf(e3)) return t4;
      var c3 = t4.flood(Array.isArray(l3) ? l3[e3] : l3, h3).composite(t4.sourceAlpha, "in").offset(n3, o3).gaussianBlur(r2).merge(t4.source);
      return t4.blend(t4.source, c3);
    } }, { key: "dropShadow", value: function(t4, e3) {
      var i2, a3, s3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r2 = e3.top, o3 = e3.left, n3 = e3.blur, l3 = e3.color, h3 = e3.opacity, c3 = e3.noUserSpaceOnUse, d3 = this.w;
      if (t4.unfilter(true), x2.isIE() && "radialBar" === d3.config.chart.type) return t4;
      if ((null === (i2 = d3.config.chart.dropShadow.enabledOnSeries) || void 0 === i2 ? void 0 : i2.length) > 0 && -1 === (null === (a3 = d3.config.chart.dropShadow.enabledOnSeries) || void 0 === a3 ? void 0 : a3.indexOf(s3))) return t4;
      return l3 = Array.isArray(l3) ? l3[s3] : l3, t4.filter(function(t5) {
        var e4 = null;
        e4 = x2.isSafari() || x2.isFirefox() || x2.isIE() ? t5.flood(l3, h3).composite(t5.sourceAlpha, "in").offset(o3, r2).gaussianBlur(n3) : t5.flood(l3, h3).composite(t5.sourceAlpha, "in").offset(o3, r2).gaussianBlur(n3).merge(t5.source), t5.blend(t5.source, e4);
      }), c3 || t4.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t4.filterer.node), t4;
    } }, { key: "setSelectionFilter", value: function(t4, e3, i2) {
      var a3 = this.w;
      if (void 0 !== a3.globals.selectedDataPoints[e3] && a3.globals.selectedDataPoints[e3].indexOf(i2) > -1) {
        t4.node.setAttribute("selected", true);
        var s3 = a3.config.states.active.filter;
        "none" !== s3 && this.applyFilter(t4, e3, s3.type, s3.value);
      }
    } }, { key: "_scaleFilterSize", value: function(t4) {
      !function(e3) {
        for (var i2 in e3) e3.hasOwnProperty(i2) && t4.setAttribute(i2, e3[i2]);
      }({ width: "200%", height: "200%", x: "-50%", y: "-50%" });
    } }]), t3;
  }(), m2 = function() {
    function t3(e3) {
      a2(this, t3), this.ctx = e3, this.w = e3.w;
    }
    return r(t3, [{ key: "roundPathCorners", value: function(t4, e3) {
      function i2(t5, e4, i3) {
        var s4 = e4.x - t5.x, r3 = e4.y - t5.y, o4 = Math.sqrt(s4 * s4 + r3 * r3);
        return a3(t5, e4, Math.min(1, i3 / o4));
      }
      function a3(t5, e4, i3) {
        return { x: t5.x + (e4.x - t5.x) * i3, y: t5.y + (e4.y - t5.y) * i3 };
      }
      function s3(t5, e4) {
        t5.length > 2 && (t5[t5.length - 2] = e4.x, t5[t5.length - 1] = e4.y);
      }
      function r2(t5) {
        return { x: parseFloat(t5[t5.length - 2]), y: parseFloat(t5[t5.length - 1]) };
      }
      t4.indexOf("NaN") > -1 && (t4 = "");
      var o3 = t4.split(/[,\s]/).reduce(function(t5, e4) {
        var i3 = e4.match("([a-zA-Z])(.+)");
        return i3 ? (t5.push(i3[1]), t5.push(i3[2])) : t5.push(e4), t5;
      }, []).reduce(function(t5, e4) {
        return parseFloat(e4) == e4 && t5.length ? t5[t5.length - 1].push(e4) : t5.push([e4]), t5;
      }, []), n3 = [];
      if (o3.length > 1) {
        var l3 = r2(o3[0]), h3 = null;
        "Z" == o3[o3.length - 1][0] && o3[0].length > 2 && (h3 = ["L", l3.x, l3.y], o3[o3.length - 1] = h3), n3.push(o3[0]);
        for (var c3 = 1; c3 < o3.length; c3++) {
          var d3 = n3[n3.length - 1], g3 = o3[c3], u3 = g3 == h3 ? o3[1] : o3[c3 + 1];
          if (u3 && d3 && d3.length > 2 && "L" == g3[0] && u3.length > 2 && "L" == u3[0]) {
            var p3, f3, x3 = r2(d3), b3 = r2(g3), v3 = r2(u3);
            p3 = i2(b3, x3, e3), f3 = i2(b3, v3, e3), s3(g3, p3), g3.origPoint = b3, n3.push(g3);
            var m3 = a3(p3, b3, 0.5), y3 = a3(b3, f3, 0.5), w3 = ["C", m3.x, m3.y, y3.x, y3.y, f3.x, f3.y];
            w3.origPoint = b3, n3.push(w3);
          } else n3.push(g3);
        }
        if (h3) {
          var k3 = r2(n3[n3.length - 1]);
          n3.push(["Z"]), s3(n3[0], k3);
        }
      } else n3 = o3;
      return n3.reduce(function(t5, e4) {
        return t5 + e4.join(" ") + " ";
      }, "");
    } }, { key: "drawLine", value: function(t4, e3, i2, a3) {
      var s3 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "#a8a8a8", r2 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0, o3 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null, n3 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : "butt";
      return this.w.globals.dom.Paper.line().attr({ x1: t4, y1: e3, x2: i2, y2: a3, stroke: s3, "stroke-dasharray": r2, "stroke-width": o3, "stroke-linecap": n3 });
    } }, { key: "drawRect", value: function() {
      var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, a3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, s3 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, r2 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "#fefefe", o3 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 1, n3 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null, l3 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : null, h3 = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 0, c3 = this.w.globals.dom.Paper.rect();
      return c3.attr({ x: t4, y: e3, width: i2 > 0 ? i2 : 0, height: a3 > 0 ? a3 : 0, rx: s3, ry: s3, opacity: o3, "stroke-width": null !== n3 ? n3 : 0, stroke: null !== l3 ? l3 : "none", "stroke-dasharray": h3 }), c3.node.setAttribute("fill", r2), c3;
    } }, { key: "drawPolygon", value: function(t4) {
      var e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "#e1e1e1", i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, a3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "none";
      return this.w.globals.dom.Paper.polygon(t4).attr({ fill: a3, stroke: e3, "stroke-width": i2 });
    } }, { key: "drawCircle", value: function(t4) {
      var e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
      t4 < 0 && (t4 = 0);
      var i2 = this.w.globals.dom.Paper.circle(2 * t4);
      return null !== e3 && i2.attr(e3), i2;
    } }, { key: "drawPath", value: function(t4) {
      var e3 = t4.d, i2 = void 0 === e3 ? "" : e3, a3 = t4.stroke, s3 = void 0 === a3 ? "#a8a8a8" : a3, r2 = t4.strokeWidth, o3 = void 0 === r2 ? 1 : r2, n3 = t4.fill, l3 = t4.fillOpacity, h3 = void 0 === l3 ? 1 : l3, c3 = t4.strokeOpacity, d3 = void 0 === c3 ? 1 : c3, g3 = t4.classes, u3 = t4.strokeLinecap, p3 = void 0 === u3 ? null : u3, f3 = t4.strokeDashArray, x3 = void 0 === f3 ? 0 : f3, b3 = this.w;
      return null === p3 && (p3 = b3.config.stroke.lineCap), (i2.indexOf("undefined") > -1 || i2.indexOf("NaN") > -1) && (i2 = "M 0 ".concat(b3.globals.gridHeight)), b3.globals.dom.Paper.path(i2).attr({ fill: n3, "fill-opacity": h3, stroke: s3, "stroke-opacity": d3, "stroke-linecap": p3, "stroke-width": o3, "stroke-dasharray": x3, class: g3 });
    } }, { key: "group", value: function() {
      var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, e3 = this.w.globals.dom.Paper.group();
      return null !== t4 && e3.attr(t4), e3;
    } }, { key: "move", value: function(t4, e3) {
      var i2 = ["M", t4, e3].join(" ");
      return i2;
    } }, { key: "line", value: function(t4, e3) {
      var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a3 = null;
      return null === i2 ? a3 = [" L", t4, e3].join(" ") : "H" === i2 ? a3 = [" H", t4].join(" ") : "V" === i2 && (a3 = [" V", e3].join(" ")), a3;
    } }, { key: "curve", value: function(t4, e3, i2, a3, s3, r2) {
      var o3 = ["C", t4, e3, i2, a3, s3, r2].join(" ");
      return o3;
    } }, { key: "quadraticCurve", value: function(t4, e3, i2, a3) {
      return ["Q", t4, e3, i2, a3].join(" ");
    } }, { key: "arc", value: function(t4, e3, i2, a3, s3, r2, o3) {
      var n3 = "A";
      arguments.length > 7 && void 0 !== arguments[7] && arguments[7] && (n3 = "a");
      var l3 = [n3, t4, e3, i2, a3, s3, r2, o3].join(" ");
      return l3;
    } }, { key: "renderPaths", value: function(t4) {
      var i2, a3 = t4.j, s3 = t4.realIndex, r2 = t4.pathFrom, o3 = t4.pathTo, n3 = t4.stroke, l3 = t4.strokeWidth, h3 = t4.strokeLinecap, c3 = t4.fill, d3 = t4.animationDelay, g3 = t4.initialSpeed, u3 = t4.dataChangeSpeed, p3 = t4.className, f3 = t4.shouldClipToGrid, x3 = void 0 === f3 || f3, m3 = t4.bindEventsOnPaths, y3 = void 0 === m3 || m3, w3 = t4.drawShadow, k3 = void 0 === w3 || w3, A3 = this.w, S3 = new v2(this.ctx), C3 = new b2(this.ctx), L3 = this.w.config.chart.animations.enabled, P3 = L3 && this.w.config.chart.animations.dynamicAnimation.enabled, M3 = !!(L3 && !A3.globals.resized || P3 && A3.globals.dataChanged && A3.globals.shouldAnimate);
      M3 ? i2 = r2 : (i2 = o3, A3.globals.animationEnded = true);
      var I3 = A3.config.stroke.dashArray, T3 = 0;
      T3 = Array.isArray(I3) ? I3[s3] : A3.config.stroke.dashArray;
      var z3 = this.drawPath({ d: i2, stroke: n3, strokeWidth: l3, fill: c3, fillOpacity: 1, classes: p3, strokeLinecap: h3, strokeDashArray: T3 });
      if (z3.attr("index", s3), x3 && z3.attr({ "clip-path": "url(#gridRectMask".concat(A3.globals.cuid, ")") }), "none" !== A3.config.states.normal.filter.type) S3.getDefaultFilter(z3, s3);
      else if (A3.config.chart.dropShadow.enabled && k3) {
        var X3 = A3.config.chart.dropShadow;
        S3.dropShadow(z3, X3, s3);
      }
      y3 && (z3.node.addEventListener("mouseenter", this.pathMouseEnter.bind(this, z3)), z3.node.addEventListener("mouseleave", this.pathMouseLeave.bind(this, z3)), z3.node.addEventListener("mousedown", this.pathMouseDown.bind(this, z3))), z3.attr({ pathTo: o3, pathFrom: r2 });
      var E3 = { el: z3, j: a3, realIndex: s3, pathFrom: r2, pathTo: o3, fill: c3, strokeWidth: l3, delay: d3 };
      return !L3 || A3.globals.resized || A3.globals.dataChanged ? !A3.globals.resized && A3.globals.dataChanged || C3.showDelayedElements() : C3.animatePathsGradually(e2(e2({}, E3), {}, { speed: g3 })), A3.globals.dataChanged && P3 && M3 && C3.animatePathsGradually(e2(e2({}, E3), {}, { speed: u3 })), z3;
    } }, { key: "drawPattern", value: function(t4, e3, i2) {
      var a3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "#a8a8a8", s3 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
      return this.w.globals.dom.Paper.pattern(e3, i2, function(r2) {
        "horizontalLines" === t4 ? r2.line(0, 0, i2, 0).stroke({ color: a3, width: s3 + 1 }) : "verticalLines" === t4 ? r2.line(0, 0, 0, e3).stroke({ color: a3, width: s3 + 1 }) : "slantedLines" === t4 ? r2.line(0, 0, e3, i2).stroke({ color: a3, width: s3 }) : "squares" === t4 ? r2.rect(e3, i2).fill("none").stroke({ color: a3, width: s3 }) : "circles" === t4 && r2.circle(e3).fill("none").stroke({ color: a3, width: s3 });
      });
    } }, { key: "drawGradient", value: function(t4, e3, i2, a3, s3) {
      var r2, o3 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null, n3 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null, l3 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null, h3 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0, c3 = this.w;
      e3.length < 9 && 0 === e3.indexOf("#") && (e3 = x2.hexToRgba(e3, a3)), i2.length < 9 && 0 === i2.indexOf("#") && (i2 = x2.hexToRgba(i2, s3));
      var d3 = 0, g3 = 1, u3 = 1, p3 = null;
      null !== n3 && (d3 = void 0 !== n3[0] ? n3[0] / 100 : 0, g3 = void 0 !== n3[1] ? n3[1] / 100 : 1, u3 = void 0 !== n3[2] ? n3[2] / 100 : 1, p3 = void 0 !== n3[3] ? n3[3] / 100 : null);
      var f3 = !("donut" !== c3.config.chart.type && "pie" !== c3.config.chart.type && "polarArea" !== c3.config.chart.type && "bubble" !== c3.config.chart.type);
      if (r2 = null === l3 || 0 === l3.length ? c3.globals.dom.Paper.gradient(f3 ? "radial" : "linear", function(t5) {
        t5.at(d3, e3, a3), t5.at(g3, i2, s3), t5.at(u3, i2, s3), null !== p3 && t5.at(p3, e3, a3);
      }) : c3.globals.dom.Paper.gradient(f3 ? "radial" : "linear", function(t5) {
        (Array.isArray(l3[h3]) ? l3[h3] : l3).forEach(function(e4) {
          t5.at(e4.offset / 100, e4.color, e4.opacity);
        });
      }), f3) {
        var b3 = c3.globals.gridWidth / 2, v3 = c3.globals.gridHeight / 2;
        "bubble" !== c3.config.chart.type ? r2.attr({ gradientUnits: "userSpaceOnUse", cx: b3, cy: v3, r: o3 }) : r2.attr({ cx: 0.5, cy: 0.5, r: 0.8, fx: 0.2, fy: 0.2 });
      } else "vertical" === t4 ? r2.from(0, 0).to(0, 1) : "diagonal" === t4 ? r2.from(0, 0).to(1, 1) : "horizontal" === t4 ? r2.from(0, 1).to(1, 1) : "diagonal2" === t4 && r2.from(1, 0).to(0, 1);
      return r2;
    } }, { key: "getTextBasedOnMaxWidth", value: function(t4) {
      var e3 = t4.text, i2 = t4.maxWidth, a3 = t4.fontSize, s3 = t4.fontFamily, r2 = this.getTextRects(e3, a3, s3), o3 = r2.width / e3.length, n3 = Math.floor(i2 / o3);
      return i2 < r2.width ? e3.slice(0, n3 - 3) + "..." : e3;
    } }, { key: "drawText", value: function(t4) {
      var i2 = this, a3 = t4.x, s3 = t4.y, r2 = t4.text, o3 = t4.textAnchor, n3 = t4.fontSize, l3 = t4.fontFamily, h3 = t4.fontWeight, c3 = t4.foreColor, d3 = t4.opacity, g3 = t4.maxWidth, u3 = t4.cssClass, p3 = void 0 === u3 ? "" : u3, f3 = t4.isPlainText, x3 = void 0 === f3 || f3, b3 = t4.dominantBaseline, v3 = void 0 === b3 ? "auto" : b3, m3 = this.w;
      void 0 === r2 && (r2 = "");
      var y3 = r2;
      o3 || (o3 = "start"), c3 && c3.length || (c3 = m3.config.chart.foreColor), l3 = l3 || m3.config.chart.fontFamily, h3 = h3 || "regular";
      var w3, k3 = { maxWidth: g3, fontSize: n3 = n3 || "11px", fontFamily: l3 };
      return Array.isArray(r2) ? w3 = m3.globals.dom.Paper.text(function(t5) {
        for (var a4 = 0; a4 < r2.length; a4++) y3 = r2[a4], g3 && (y3 = i2.getTextBasedOnMaxWidth(e2({ text: r2[a4] }, k3))), 0 === a4 ? t5.tspan(y3) : t5.tspan(y3).newLine();
      }) : (g3 && (y3 = this.getTextBasedOnMaxWidth(e2({ text: r2 }, k3))), w3 = x3 ? m3.globals.dom.Paper.plain(r2) : m3.globals.dom.Paper.text(function(t5) {
        return t5.tspan(y3);
      })), w3.attr({ x: a3, y: s3, "text-anchor": o3, "dominant-baseline": v3, "font-size": n3, "font-family": l3, "font-weight": h3, fill: c3, class: "apexcharts-text " + p3 }), w3.node.style.fontFamily = l3, w3.node.style.opacity = d3, w3;
    } }, { key: "createGroupWithAttributes", value: function(t4, e3, i2, a3) {
      var s3 = this.group();
      return i2.forEach(function(t5) {
        return s3.add(t5);
      }), s3.attr({ class: a3.class ? a3.class : "", cy: e3, cx: t4 }), s3;
    } }, { key: "drawPlus", value: function(t4, e3, i2, a3) {
      var s3 = i2 / 2, r2 = this.drawLine(t4, e3 - s3, t4, e3 + s3, a3.pointStrokeColor, a3.pointStrokeDashArray, a3.pointStrokeWidth, a3.pointStrokeLineCap), o3 = this.drawLine(t4 - s3, e3, t4 + s3, e3, a3.pointStrokeColor, a3.pointStrokeDashArray, a3.pointStrokeWidth, a3.pointStrokeLineCap);
      return this.createGroupWithAttributes(t4, e3, [r2, o3], a3);
    } }, { key: "drawX", value: function(t4, e3, i2, a3) {
      var s3 = i2 / 2, r2 = this.drawLine(t4 - s3, e3 - s3, t4 + s3, e3 + s3, a3.pointStrokeColor, a3.pointStrokeDashArray, a3.pointStrokeWidth, a3.pointStrokeLineCap), o3 = this.drawLine(t4 - s3, e3 + s3, t4 + s3, e3 - s3, a3.pointStrokeColor, a3.pointStrokeDashArray, a3.pointStrokeWidth, a3.pointStrokeLineCap);
      return this.createGroupWithAttributes(t4, e3, [r2, o3], a3);
    } }, { key: "drawMarker", value: function(t4, e3, i2) {
      t4 = t4 || 0;
      var a3 = i2.pSize || 0, s3 = null;
      if ("X" === (null == i2 ? void 0 : i2.shape) || "x" === (null == i2 ? void 0 : i2.shape)) s3 = this.drawX(t4, e3, a3, i2);
      else if ("plus" === (null == i2 ? void 0 : i2.shape) || "+" === (null == i2 ? void 0 : i2.shape)) s3 = this.drawPlus(t4, e3, a3, i2);
      else if ("square" === i2.shape || "rect" === i2.shape) {
        var r2 = void 0 === i2.pRadius ? a3 / 2 : i2.pRadius;
        null !== e3 && a3 || (a3 = 0, r2 = 0);
        var o3 = 1.2 * a3 + r2, n3 = this.drawRect(o3, o3, o3, o3, r2);
        n3.attr({ x: t4 - o3 / 2, y: e3 - o3 / 2, cx: t4, cy: e3, class: i2.class ? i2.class : "", fill: i2.pointFillColor, "fill-opacity": i2.pointFillOpacity ? i2.pointFillOpacity : 1, stroke: i2.pointStrokeColor, "stroke-width": i2.pointStrokeWidth ? i2.pointStrokeWidth : 0, "stroke-opacity": i2.pointStrokeOpacity ? i2.pointStrokeOpacity : 1 }), s3 = n3;
      } else "circle" !== i2.shape && i2.shape || (x2.isNumber(e3) || (a3 = 0, e3 = 0), s3 = this.drawCircle(a3, { cx: t4, cy: e3, class: i2.class ? i2.class : "", stroke: i2.pointStrokeColor, fill: i2.pointFillColor, "fill-opacity": i2.pointFillOpacity ? i2.pointFillOpacity : 1, "stroke-width": i2.pointStrokeWidth ? i2.pointStrokeWidth : 0, "stroke-opacity": i2.pointStrokeOpacity ? i2.pointStrokeOpacity : 1 }));
      return s3;
    } }, { key: "pathMouseEnter", value: function(t4, e3) {
      var i2 = this.w, a3 = new v2(this.ctx), s3 = parseInt(t4.node.getAttribute("index"), 10), r2 = parseInt(t4.node.getAttribute("j"), 10);
      if ("function" == typeof i2.config.chart.events.dataPointMouseEnter && i2.config.chart.events.dataPointMouseEnter(e3, this.ctx, { seriesIndex: s3, dataPointIndex: r2, w: i2 }), this.ctx.events.fireEvent("dataPointMouseEnter", [e3, this.ctx, { seriesIndex: s3, dataPointIndex: r2, w: i2 }]), ("none" === i2.config.states.active.filter.type || "true" !== t4.node.getAttribute("selected")) && "none" !== i2.config.states.hover.filter.type && !i2.globals.isTouchDevice) {
        var o3 = i2.config.states.hover.filter;
        a3.applyFilter(t4, s3, o3.type, o3.value);
      }
    } }, { key: "pathMouseLeave", value: function(t4, e3) {
      var i2 = this.w, a3 = new v2(this.ctx), s3 = parseInt(t4.node.getAttribute("index"), 10), r2 = parseInt(t4.node.getAttribute("j"), 10);
      "function" == typeof i2.config.chart.events.dataPointMouseLeave && i2.config.chart.events.dataPointMouseLeave(e3, this.ctx, { seriesIndex: s3, dataPointIndex: r2, w: i2 }), this.ctx.events.fireEvent("dataPointMouseLeave", [e3, this.ctx, { seriesIndex: s3, dataPointIndex: r2, w: i2 }]), "none" !== i2.config.states.active.filter.type && "true" === t4.node.getAttribute("selected") || "none" !== i2.config.states.hover.filter.type && a3.getDefaultFilter(t4, s3);
    } }, { key: "pathMouseDown", value: function(t4, e3) {
      var i2 = this.w, a3 = new v2(this.ctx), s3 = parseInt(t4.node.getAttribute("index"), 10), r2 = parseInt(t4.node.getAttribute("j"), 10), o3 = "false";
      if ("true" === t4.node.getAttribute("selected")) {
        if (t4.node.setAttribute("selected", "false"), i2.globals.selectedDataPoints[s3].indexOf(r2) > -1) {
          var n3 = i2.globals.selectedDataPoints[s3].indexOf(r2);
          i2.globals.selectedDataPoints[s3].splice(n3, 1);
        }
      } else {
        if (!i2.config.states.active.allowMultipleDataPointsSelection && i2.globals.selectedDataPoints.length > 0) {
          i2.globals.selectedDataPoints = [];
          var l3 = i2.globals.dom.Paper.select(".apexcharts-series path").members, h3 = i2.globals.dom.Paper.select(".apexcharts-series circle, .apexcharts-series rect").members, c3 = function(t5) {
            Array.prototype.forEach.call(t5, function(t6) {
              t6.node.setAttribute("selected", "false"), a3.getDefaultFilter(t6, s3);
            });
          };
          c3(l3), c3(h3);
        }
        t4.node.setAttribute("selected", "true"), o3 = "true", void 0 === i2.globals.selectedDataPoints[s3] && (i2.globals.selectedDataPoints[s3] = []), i2.globals.selectedDataPoints[s3].push(r2);
      }
      if ("true" === o3) {
        var d3 = i2.config.states.active.filter;
        if ("none" !== d3) a3.applyFilter(t4, s3, d3.type, d3.value);
        else if ("none" !== i2.config.states.hover.filter && !i2.globals.isTouchDevice) {
          var g3 = i2.config.states.hover.filter;
          a3.applyFilter(t4, s3, g3.type, g3.value);
        }
      } else if ("none" !== i2.config.states.active.filter.type) if ("none" === i2.config.states.hover.filter.type || i2.globals.isTouchDevice) a3.getDefaultFilter(t4, s3);
      else {
        g3 = i2.config.states.hover.filter;
        a3.applyFilter(t4, s3, g3.type, g3.value);
      }
      "function" == typeof i2.config.chart.events.dataPointSelection && i2.config.chart.events.dataPointSelection(e3, this.ctx, { selectedDataPoints: i2.globals.selectedDataPoints, seriesIndex: s3, dataPointIndex: r2, w: i2 }), e3 && this.ctx.events.fireEvent("dataPointSelection", [e3, this.ctx, { selectedDataPoints: i2.globals.selectedDataPoints, seriesIndex: s3, dataPointIndex: r2, w: i2 }]);
    } }, { key: "rotateAroundCenter", value: function(t4) {
      var e3 = {};
      return t4 && "function" == typeof t4.getBBox && (e3 = t4.getBBox()), { x: e3.x + e3.width / 2, y: e3.y + e3.height / 2 };
    } }, { key: "getTextRects", value: function(t4, e3, i2, a3) {
      var s3 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4], r2 = this.w, o3 = this.drawText({ x: -200, y: -200, text: t4, textAnchor: "start", fontSize: e3, fontFamily: i2, foreColor: "#fff", opacity: 0 });
      a3 && o3.attr("transform", a3), r2.globals.dom.Paper.add(o3);
      var n3 = o3.bbox();
      return s3 || (n3 = o3.node.getBoundingClientRect()), o3.remove(), { width: n3.width, height: n3.height };
    } }, { key: "placeTextWithEllipsis", value: function(t4, e3, i2) {
      if ("function" == typeof t4.getComputedTextLength && (t4.textContent = e3, e3.length > 0 && t4.getComputedTextLength() >= i2 / 1.1)) {
        for (var a3 = e3.length - 3; a3 > 0; a3 -= 3) if (t4.getSubStringLength(0, a3) <= i2 / 1.1) return void (t4.textContent = e3.substring(0, a3) + "...");
        t4.textContent = ".";
      }
    } }], [{ key: "setAttrs", value: function(t4, e3) {
      for (var i2 in e3) e3.hasOwnProperty(i2) && t4.setAttribute(i2, e3[i2]);
    } }]), t3;
  }(), y2 = function() {
    function t3(e3) {
      a2(this, t3), this.ctx = e3, this.w = e3.w;
    }
    return r(t3, [{ key: "getStackedSeriesTotals", value: function() {
      var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e3 = this.w, i2 = [];
      if (0 === e3.globals.series.length) return i2;
      for (var a3 = 0; a3 < e3.globals.series[e3.globals.maxValsInArrayIndex].length; a3++) {
        for (var s3 = 0, r2 = 0; r2 < e3.globals.series.length; r2++) void 0 !== e3.globals.series[r2][a3] && -1 === t4.indexOf(r2) && (s3 += e3.globals.series[r2][a3]);
        i2.push(s3);
      }
      return i2;
    } }, { key: "getSeriesTotalByIndex", value: function() {
      var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
      return null === t4 ? this.w.config.series.reduce(function(t5, e3) {
        return t5 + e3;
      }, 0) : this.w.globals.series[t4].reduce(function(t5, e3) {
        return t5 + e3;
      }, 0);
    } }, { key: "getStackedSeriesTotalsByGroups", value: function() {
      var t4 = this, e3 = this.w, i2 = [];
      return e3.globals.seriesGroups.forEach(function(a3) {
        var s3 = [];
        e3.config.series.forEach(function(t5, i3) {
          a3.indexOf(e3.globals.seriesNames[i3]) > -1 && s3.push(i3);
        });
        var r2 = e3.globals.series.map(function(t5, e4) {
          return -1 === s3.indexOf(e4) ? e4 : -1;
        }).filter(function(t5) {
          return -1 !== t5;
        });
        i2.push(t4.getStackedSeriesTotals(r2));
      }), i2;
    } }, { key: "setSeriesYAxisMappings", value: function() {
      var t4 = this.w.globals, e3 = this.w.config, i2 = [], a3 = [], s3 = [], r2 = t4.series.length > e3.yaxis.length || e3.yaxis.some(function(t5) {
        return Array.isArray(t5.seriesName);
      });
      e3.series.forEach(function(t5, e4) {
        s3.push(e4), a3.push(null);
      }), e3.yaxis.forEach(function(t5, e4) {
        i2[e4] = [];
      });
      var o3 = [];
      e3.yaxis.forEach(function(t5, a4) {
        var n4 = false;
        if (t5.seriesName) {
          var l4 = [];
          Array.isArray(t5.seriesName) ? l4 = t5.seriesName : l4.push(t5.seriesName), l4.forEach(function(t6) {
            e3.series.forEach(function(e4, o4) {
              if (e4.name === t6) {
                var l5 = o4;
                a4 === o4 || r2 ? !r2 || s3.indexOf(o4) > -1 ? i2[a4].push([a4, o4]) : console.warn("Series '" + e4.name + "' referenced more than once in what looks like the new style. That is, when using either seriesName: [], or when there are more series than yaxes.") : (i2[o4].push([o4, a4]), l5 = a4), n4 = true, -1 !== (l5 = s3.indexOf(l5)) && s3.splice(l5, 1);
              }
            });
          });
        }
        n4 || o3.push(a4);
      }), i2 = i2.map(function(t5, e4) {
        var i3 = [];
        return t5.forEach(function(t6) {
          a3[t6[1]] = t6[0], i3.push(t6[1]);
        }), i3;
      });
      for (var n3 = e3.yaxis.length - 1, l3 = 0; l3 < o3.length && (n3 = o3[l3], i2[n3] = [], s3); l3++) {
        var h3 = s3[0];
        s3.shift(), i2[n3].push(h3), a3[h3] = n3;
      }
      s3.forEach(function(t5) {
        i2[n3].push(t5), a3[t5] = n3;
      }), t4.seriesYAxisMap = i2.map(function(t5) {
        return t5;
      }), t4.seriesYAxisReverseMap = a3.map(function(t5) {
        return t5;
      }), t4.seriesYAxisMap.forEach(function(t5, i3) {
        t5.forEach(function(t6) {
          e3.series[t6] && void 0 === e3.series[t6].group && (e3.series[t6].group = "apexcharts-axis-".concat(i3.toString()));
        });
      });
    } }, { key: "isSeriesNull", value: function() {
      var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
      return 0 === (null === t4 ? this.w.config.series.filter(function(t5) {
        return null !== t5;
      }) : this.w.config.series[t4].data.filter(function(t5) {
        return null !== t5;
      })).length;
    } }, { key: "seriesHaveSameValues", value: function(t4) {
      return this.w.globals.series[t4].every(function(t5, e3, i2) {
        return t5 === i2[0];
      });
    } }, { key: "getCategoryLabels", value: function(t4) {
      var e3 = this.w, i2 = t4.slice();
      return e3.config.xaxis.convertedCatToNumeric && (i2 = t4.map(function(t5, i3) {
        return e3.config.xaxis.labels.formatter(t5 - e3.globals.minX + 1);
      })), i2;
    } }, { key: "getLargestSeries", value: function() {
      var t4 = this.w;
      t4.globals.maxValsInArrayIndex = t4.globals.series.map(function(t5) {
        return t5.length;
      }).indexOf(Math.max.apply(Math, t4.globals.series.map(function(t5) {
        return t5.length;
      })));
    } }, { key: "getLargestMarkerSize", value: function() {
      var t4 = this.w, e3 = 0;
      return t4.globals.markers.size.forEach(function(t5) {
        e3 = Math.max(e3, t5);
      }), t4.config.markers.discrete && t4.config.markers.discrete.length && t4.config.markers.discrete.forEach(function(t5) {
        e3 = Math.max(e3, t5.size);
      }), e3 > 0 && (e3 += t4.config.markers.hover.sizeOffset + 1), t4.globals.markers.largestSize = e3, e3;
    } }, { key: "getSeriesTotals", value: function() {
      var t4 = this.w;
      t4.globals.seriesTotals = t4.globals.series.map(function(t5, e3) {
        var i2 = 0;
        if (Array.isArray(t5)) for (var a3 = 0; a3 < t5.length; a3++) i2 += t5[a3];
        else i2 += t5;
        return i2;
      });
    } }, { key: "getSeriesTotalsXRange", value: function(t4, e3) {
      var i2 = this.w;
      return i2.globals.series.map(function(a3, s3) {
        for (var r2 = 0, o3 = 0; o3 < a3.length; o3++) i2.globals.seriesX[s3][o3] > t4 && i2.globals.seriesX[s3][o3] < e3 && (r2 += a3[o3]);
        return r2;
      });
    } }, { key: "getPercentSeries", value: function() {
      var t4 = this.w;
      t4.globals.seriesPercent = t4.globals.series.map(function(e3, i2) {
        var a3 = [];
        if (Array.isArray(e3)) for (var s3 = 0; s3 < e3.length; s3++) {
          var r2 = t4.globals.stackedSeriesTotals[s3], o3 = 0;
          r2 && (o3 = 100 * e3[s3] / r2), a3.push(o3);
        }
        else {
          var n3 = 100 * e3 / t4.globals.seriesTotals.reduce(function(t5, e4) {
            return t5 + e4;
          }, 0);
          a3.push(n3);
        }
        return a3;
      });
    } }, { key: "getCalculatedRatios", value: function() {
      var t4, e3, i2, a3 = this, s3 = this.w, r2 = s3.globals, o3 = [], n3 = 0, l3 = [], h3 = 0.1, c3 = 0;
      if (r2.yRange = [], r2.isMultipleYAxis) for (var d3 = 0; d3 < r2.minYArr.length; d3++) r2.yRange.push(Math.abs(r2.minYArr[d3] - r2.maxYArr[d3])), l3.push(0);
      else r2.yRange.push(Math.abs(r2.minY - r2.maxY));
      r2.xRange = Math.abs(r2.maxX - r2.minX), r2.zRange = Math.abs(r2.maxZ - r2.minZ);
      for (var g3 = 0; g3 < r2.yRange.length; g3++) o3.push(r2.yRange[g3] / r2.gridHeight);
      if (e3 = r2.xRange / r2.gridWidth, t4 = r2.yRange / r2.gridWidth, i2 = r2.xRange / r2.gridHeight, (n3 = r2.zRange / r2.gridHeight * 16) || (n3 = 1), r2.minY !== Number.MIN_VALUE && 0 !== Math.abs(r2.minY) && (r2.hasNegs = true), s3.globals.seriesYAxisReverseMap.length > 0) {
        var u3 = function(t5, e4) {
          var i3 = s3.config.yaxis[s3.globals.seriesYAxisReverseMap[e4]], r3 = t5 < 0 ? -1 : 1;
          return t5 = Math.abs(t5), i3.logarithmic && (t5 = a3.getBaseLog(i3.logBase, t5)), -r3 * t5 / o3[e4];
        };
        if (r2.isMultipleYAxis) {
          l3 = [];
          for (var p3 = 0; p3 < o3.length; p3++) l3.push(u3(r2.minYArr[p3], p3));
        } else (l3 = []).push(u3(r2.minY, 0)), r2.minY !== Number.MIN_VALUE && 0 !== Math.abs(r2.minY) && (h3 = -r2.minY / t4, c3 = r2.minX / e3);
      } else (l3 = []).push(0), h3 = 0, c3 = 0;
      return { yRatio: o3, invertedYRatio: t4, zRatio: n3, xRatio: e3, invertedXRatio: i2, baseLineInvertedY: h3, baseLineY: l3, baseLineX: c3 };
    } }, { key: "getLogSeries", value: function(t4) {
      var e3 = this, i2 = this.w;
      return i2.globals.seriesLog = t4.map(function(t5, a3) {
        var s3 = i2.globals.seriesYAxisReverseMap[a3];
        return i2.config.yaxis[s3] && i2.config.yaxis[s3].logarithmic ? t5.map(function(t6) {
          return null === t6 ? null : e3.getLogVal(i2.config.yaxis[s3].logBase, t6, a3);
        }) : t5;
      }), i2.globals.invalidLogScale ? t4 : i2.globals.seriesLog;
    } }, { key: "getBaseLog", value: function(t4, e3) {
      return Math.log(e3) / Math.log(t4);
    } }, { key: "getLogVal", value: function(t4, e3, i2) {
      if (e3 <= 0) return 0;
      var a3 = this.w, s3 = 0 === a3.globals.minYArr[i2] ? -1 : this.getBaseLog(t4, a3.globals.minYArr[i2]), r2 = (0 === a3.globals.maxYArr[i2] ? 0 : this.getBaseLog(t4, a3.globals.maxYArr[i2])) - s3;
      return e3 < 1 ? e3 / r2 : (this.getBaseLog(t4, e3) - s3) / r2;
    } }, { key: "getLogYRatios", value: function(t4) {
      var e3 = this, i2 = this.w, a3 = this.w.globals;
      return a3.yLogRatio = t4.slice(), a3.logYRange = a3.yRange.map(function(t5, s3) {
        var r2 = i2.globals.seriesYAxisReverseMap[s3];
        if (i2.config.yaxis[r2] && e3.w.config.yaxis[r2].logarithmic) {
          var o3, n3 = -Number.MAX_VALUE, l3 = Number.MIN_VALUE;
          return a3.seriesLog.forEach(function(t6, e4) {
            t6.forEach(function(t7) {
              i2.config.yaxis[e4] && i2.config.yaxis[e4].logarithmic && (n3 = Math.max(t7, n3), l3 = Math.min(t7, l3));
            });
          }), o3 = Math.pow(a3.yRange[s3], Math.abs(l3 - n3) / a3.yRange[s3]), a3.yLogRatio[s3] = o3 / a3.gridHeight, o3;
        }
      }), a3.invalidLogScale ? t4.slice() : a3.yLogRatio;
    } }, { key: "drawSeriesByGroup", value: function(t4, e3, i2, a3) {
      var s3 = this.w, r2 = [];
      return t4.series.length > 0 && e3.forEach(function(e4) {
        var o3 = [], n3 = [];
        t4.i.forEach(function(i3, a4) {
          s3.config.series[i3].group === e4 && (o3.push(t4.series[a4]), n3.push(i3));
        }), o3.length > 0 && r2.push(a3.draw(o3, i2, n3));
      }), r2;
    } }], [{ key: "checkComboSeries", value: function(t4, e3) {
      var i2 = false, a3 = 0, s3 = 0;
      return void 0 === e3 && (e3 = "line"), t4.length && void 0 !== t4[0].type && t4.forEach(function(t5) {
        "bar" !== t5.type && "column" !== t5.type && "candlestick" !== t5.type && "boxPlot" !== t5.type || a3++, void 0 !== t5.type && t5.type !== e3 && s3++;
      }), s3 > 0 && (i2 = true), { comboBarCount: a3, comboCharts: i2 };
    } }, { key: "extendArrayProps", value: function(t4, e3, i2) {
      var a3, s3, r2, o3, n3, l3;
      (null !== (a3 = e3) && void 0 !== a3 && a3.yaxis && (e3 = t4.extendYAxis(e3, i2)), null !== (s3 = e3) && void 0 !== s3 && s3.annotations) && (e3.annotations.yaxis && (e3 = t4.extendYAxisAnnotations(e3)), null !== (r2 = e3) && void 0 !== r2 && null !== (o3 = r2.annotations) && void 0 !== o3 && o3.xaxis && (e3 = t4.extendXAxisAnnotations(e3)), null !== (n3 = e3) && void 0 !== n3 && null !== (l3 = n3.annotations) && void 0 !== l3 && l3.points && (e3 = t4.extendPointAnnotations(e3)));
      return e3;
    } }]), t3;
  }(), w2 = function() {
    function t3(e3) {
      a2(this, t3), this.w = e3.w, this.annoCtx = e3;
    }
    return r(t3, [{ key: "setOrientations", value: function(t4) {
      var e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, i2 = this.w;
      if ("vertical" === t4.label.orientation) {
        var a3 = null !== e3 ? e3 : 0, s3 = i2.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(a3, "']"));
        if (null !== s3) {
          var r2 = s3.getBoundingClientRect();
          s3.setAttribute("x", parseFloat(s3.getAttribute("x")) - r2.height + 4), "top" === t4.label.position ? s3.setAttribute("y", parseFloat(s3.getAttribute("y")) + r2.width) : s3.setAttribute("y", parseFloat(s3.getAttribute("y")) - r2.width);
          var o3 = this.annoCtx.graphics.rotateAroundCenter(s3), n3 = o3.x, l3 = o3.y;
          s3.setAttribute("transform", "rotate(-90 ".concat(n3, " ").concat(l3, ")"));
        }
      }
    } }, { key: "addBackgroundToAnno", value: function(t4, e3) {
      var i2 = this.w;
      if (!t4 || void 0 === e3.label.text || void 0 !== e3.label.text && !String(e3.label.text).trim()) return null;
      var a3 = i2.globals.dom.baseEl.querySelector(".apexcharts-grid").getBoundingClientRect(), s3 = t4.getBoundingClientRect(), r2 = e3.label.style.padding.left, o3 = e3.label.style.padding.right, n3 = e3.label.style.padding.top, l3 = e3.label.style.padding.bottom;
      "vertical" === e3.label.orientation && (n3 = e3.label.style.padding.left, l3 = e3.label.style.padding.right, r2 = e3.label.style.padding.top, o3 = e3.label.style.padding.bottom);
      var h3 = s3.left - a3.left - r2, c3 = s3.top - a3.top - n3, d3 = this.annoCtx.graphics.drawRect(h3 - i2.globals.barPadForNumericAxis, c3, s3.width + r2 + o3, s3.height + n3 + l3, e3.label.borderRadius, e3.label.style.background, 1, e3.label.borderWidth, e3.label.borderColor, 0);
      return e3.id && d3.node.classList.add(e3.id), d3;
    } }, { key: "annotationsBackground", value: function() {
      var t4 = this, e3 = this.w, i2 = function(i3, a3, s3) {
        var r2 = e3.globals.dom.baseEl.querySelector(".apexcharts-".concat(s3, "-annotations .apexcharts-").concat(s3, "-annotation-label[rel='").concat(a3, "']"));
        if (r2) {
          var o3 = r2.parentNode, n3 = t4.addBackgroundToAnno(r2, i3);
          n3 && (o3.insertBefore(n3.node, r2), i3.label.mouseEnter && n3.node.addEventListener("mouseenter", i3.label.mouseEnter.bind(t4, i3)), i3.label.mouseLeave && n3.node.addEventListener("mouseleave", i3.label.mouseLeave.bind(t4, i3)), i3.label.click && n3.node.addEventListener("click", i3.label.click.bind(t4, i3)));
        }
      };
      e3.config.annotations.xaxis.map(function(t5, e4) {
        i2(t5, e4, "xaxis");
      }), e3.config.annotations.yaxis.map(function(t5, e4) {
        i2(t5, e4, "yaxis");
      }), e3.config.annotations.points.map(function(t5, e4) {
        i2(t5, e4, "point");
      });
    } }, { key: "getY1Y2", value: function(t4, e3) {
      var i2, a3 = "y1" === t4 ? e3.y : e3.y2, s3 = false, r2 = this.w;
      if (this.annoCtx.invertAxis) {
        var o3 = r2.globals.labels;
        r2.config.xaxis.convertedCatToNumeric && (o3 = r2.globals.categoryLabels);
        var n3 = o3.indexOf(a3), l3 = r2.globals.dom.baseEl.querySelector(".apexcharts-yaxis-texts-g text:nth-child(" + (n3 + 1) + ")");
        i2 = l3 ? parseFloat(l3.getAttribute("y")) : (r2.globals.gridHeight / o3.length - 1) * (n3 + 1) - r2.globals.barHeight, void 0 !== e3.seriesIndex && r2.globals.barHeight && (i2 = i2 - r2.globals.barHeight / 2 * (r2.globals.series.length - 1) + r2.globals.barHeight * e3.seriesIndex);
      } else {
        var h3, c3 = r2.globals.seriesYAxisMap[e3.yAxisIndex][0];
        if (r2.config.yaxis[e3.yAxisIndex].logarithmic) h3 = (a3 = new y2(this.annoCtx.ctx).getLogVal(r2.config.yaxis[e3.yAxisIndex].logBase, a3, c3)) / r2.globals.yLogRatio[c3];
        else h3 = (a3 - r2.globals.minYArr[c3]) / (r2.globals.yRange[c3] / r2.globals.gridHeight);
        h3 > r2.globals.gridHeight ? (h3 = r2.globals.gridHeight, s3 = true) : h3 < 0 && (h3 = 0, s3 = true), i2 = r2.globals.gridHeight - h3, !e3.marker || void 0 !== e3.y && null !== e3.y || (i2 = 0), r2.config.yaxis[e3.yAxisIndex] && r2.config.yaxis[e3.yAxisIndex].reversed && (i2 = h3);
      }
      return "string" == typeof a3 && a3.indexOf("px") > -1 && (i2 = parseFloat(a3)), { yP: i2, clipped: s3 };
    } }, { key: "getX1X2", value: function(t4, e3) {
      var i2, a3 = "x1" === t4 ? e3.x : e3.x2, s3 = this.w, r2 = this.annoCtx.invertAxis ? s3.globals.minY : s3.globals.minX, o3 = this.annoCtx.invertAxis ? s3.globals.maxY : s3.globals.maxX, n3 = this.annoCtx.invertAxis ? s3.globals.yRange[0] : s3.globals.xRange, l3 = false;
      return i2 = this.annoCtx.inversedReversedAxis ? (o3 - a3) / (n3 / s3.globals.gridWidth) : (a3 - r2) / (n3 / s3.globals.gridWidth), "category" !== s3.config.xaxis.type && !s3.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || s3.globals.dataFormatXNumeric || s3.config.chart.sparkline.enabled || (i2 = this.getStringX(a3)), "string" == typeof a3 && a3.indexOf("px") > -1 && (i2 = parseFloat(a3)), null == a3 && e3.marker && (i2 = s3.globals.gridWidth), void 0 !== e3.seriesIndex && s3.globals.barWidth && !this.annoCtx.invertAxis && (i2 = i2 - s3.globals.barWidth / 2 * (s3.globals.series.length - 1) + s3.globals.barWidth * e3.seriesIndex), i2 > s3.globals.gridWidth ? (i2 = s3.globals.gridWidth, l3 = true) : i2 < 0 && (i2 = 0, l3 = true), { x: i2, clipped: l3 };
    } }, { key: "getStringX", value: function(t4) {
      var e3 = this.w, i2 = t4;
      e3.config.xaxis.convertedCatToNumeric && e3.globals.categoryLabels.length && (t4 = e3.globals.categoryLabels.indexOf(t4) + 1);
      var a3 = e3.globals.labels.indexOf(t4), s3 = e3.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g text:nth-child(" + (a3 + 1) + ")");
      return s3 && (i2 = parseFloat(s3.getAttribute("x"))), i2;
    } }]), t3;
  }(), k2 = function() {
    function t3(e3) {
      a2(this, t3), this.w = e3.w, this.annoCtx = e3, this.invertAxis = this.annoCtx.invertAxis, this.helpers = new w2(this.annoCtx);
    }
    return r(t3, [{ key: "addXaxisAnnotation", value: function(t4, e3, i2) {
      var a3, s3 = this.w, r2 = this.helpers.getX1X2("x1", t4), o3 = r2.x, n3 = r2.clipped, l3 = true, h3 = t4.label.text, c3 = t4.strokeDashArray;
      if (x2.isNumber(o3)) {
        if (null === t4.x2 || void 0 === t4.x2) {
          if (!n3) {
            var d3 = this.annoCtx.graphics.drawLine(o3 + t4.offsetX, 0 + t4.offsetY, o3 + t4.offsetX, s3.globals.gridHeight + t4.offsetY, t4.borderColor, c3, t4.borderWidth);
            e3.appendChild(d3.node), t4.id && d3.node.classList.add(t4.id);
          }
        } else {
          var g3 = this.helpers.getX1X2("x2", t4);
          if (a3 = g3.x, l3 = g3.clipped, !n3 || !l3) {
            if (a3 < o3) {
              var u3 = o3;
              o3 = a3, a3 = u3;
            }
            var p3 = this.annoCtx.graphics.drawRect(o3 + t4.offsetX, 0 + t4.offsetY, a3 - o3, s3.globals.gridHeight + t4.offsetY, 0, t4.fillColor, t4.opacity, 1, t4.borderColor, c3);
            p3.node.classList.add("apexcharts-annotation-rect"), p3.attr("clip-path", "url(#gridRectMask".concat(s3.globals.cuid, ")")), e3.appendChild(p3.node), t4.id && p3.node.classList.add(t4.id);
          }
        }
        if (!n3 || !l3) {
          var f3 = this.annoCtx.graphics.getTextRects(h3, parseFloat(t4.label.style.fontSize)), b3 = "top" === t4.label.position ? 4 : "center" === t4.label.position ? s3.globals.gridHeight / 2 + ("vertical" === t4.label.orientation ? f3.width / 2 : 0) : s3.globals.gridHeight, v3 = this.annoCtx.graphics.drawText({ x: o3 + t4.label.offsetX, y: b3 + t4.label.offsetY - ("vertical" === t4.label.orientation ? "top" === t4.label.position ? f3.width / 2 - 12 : -f3.width / 2 : 0), text: h3, textAnchor: t4.label.textAnchor, fontSize: t4.label.style.fontSize, fontFamily: t4.label.style.fontFamily, fontWeight: t4.label.style.fontWeight, foreColor: t4.label.style.color, cssClass: "apexcharts-xaxis-annotation-label ".concat(t4.label.style.cssClass, " ").concat(t4.id ? t4.id : "") });
          v3.attr({ rel: i2 }), e3.appendChild(v3.node), this.annoCtx.helpers.setOrientations(t4, i2);
        }
      }
    } }, { key: "drawXAxisAnnotations", value: function() {
      var t4 = this, e3 = this.w, i2 = this.annoCtx.graphics.group({ class: "apexcharts-xaxis-annotations" });
      return e3.config.annotations.xaxis.map(function(e4, a3) {
        t4.addXaxisAnnotation(e4, i2.node, a3);
      }), i2;
    } }]), t3;
  }(), A2 = function() {
    function t3(e3) {
      a2(this, t3), this.ctx = e3, this.w = e3.w, this.months31 = [1, 3, 5, 7, 8, 10, 12], this.months30 = [2, 4, 6, 9, 11], this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
    }
    return r(t3, [{ key: "isValidDate", value: function(t4) {
      return "number" != typeof t4 && !isNaN(this.parseDate(t4));
    } }, { key: "getTimeStamp", value: function(t4) {
      return Date.parse(t4) ? this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t4).toISOString().substr(0, 25)).getTime() : new Date(t4).getTime() : t4;
    } }, { key: "getDate", value: function(t4) {
      return this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t4).toUTCString()) : new Date(t4);
    } }, { key: "parseDate", value: function(t4) {
      var e3 = Date.parse(t4);
      if (!isNaN(e3)) return this.getTimeStamp(t4);
      var i2 = Date.parse(t4.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
      return i2 = this.getTimeStamp(i2);
    } }, { key: "parseDateWithTimezone", value: function(t4) {
      return Date.parse(t4.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
    } }, { key: "formatDate", value: function(t4, e3) {
      var i2 = this.w.globals.locale, a3 = this.w.config.xaxis.labels.datetimeUTC, s3 = ["\0"].concat(u2(i2.months)), r2 = [""].concat(u2(i2.shortMonths)), o3 = [""].concat(u2(i2.days)), n3 = [""].concat(u2(i2.shortDays));
      function l3(t5, e4) {
        var i3 = t5 + "";
        for (e4 = e4 || 2; i3.length < e4; ) i3 = "0" + i3;
        return i3;
      }
      var h3 = a3 ? t4.getUTCFullYear() : t4.getFullYear();
      e3 = (e3 = (e3 = e3.replace(/(^|[^\\])yyyy+/g, "$1" + h3)).replace(/(^|[^\\])yy/g, "$1" + h3.toString().substr(2, 2))).replace(/(^|[^\\])y/g, "$1" + h3);
      var c3 = (a3 ? t4.getUTCMonth() : t4.getMonth()) + 1;
      e3 = (e3 = (e3 = (e3 = e3.replace(/(^|[^\\])MMMM+/g, "$1" + s3[0])).replace(/(^|[^\\])MMM/g, "$1" + r2[0])).replace(/(^|[^\\])MM/g, "$1" + l3(c3))).replace(/(^|[^\\])M/g, "$1" + c3);
      var d3 = a3 ? t4.getUTCDate() : t4.getDate();
      e3 = (e3 = (e3 = (e3 = e3.replace(/(^|[^\\])dddd+/g, "$1" + o3[0])).replace(/(^|[^\\])ddd/g, "$1" + n3[0])).replace(/(^|[^\\])dd/g, "$1" + l3(d3))).replace(/(^|[^\\])d/g, "$1" + d3);
      var g3 = a3 ? t4.getUTCHours() : t4.getHours(), p3 = g3 > 12 ? g3 - 12 : 0 === g3 ? 12 : g3;
      e3 = (e3 = (e3 = (e3 = e3.replace(/(^|[^\\])HH+/g, "$1" + l3(g3))).replace(/(^|[^\\])H/g, "$1" + g3)).replace(/(^|[^\\])hh+/g, "$1" + l3(p3))).replace(/(^|[^\\])h/g, "$1" + p3);
      var f3 = a3 ? t4.getUTCMinutes() : t4.getMinutes();
      e3 = (e3 = e3.replace(/(^|[^\\])mm+/g, "$1" + l3(f3))).replace(/(^|[^\\])m/g, "$1" + f3);
      var x3 = a3 ? t4.getUTCSeconds() : t4.getSeconds();
      e3 = (e3 = e3.replace(/(^|[^\\])ss+/g, "$1" + l3(x3))).replace(/(^|[^\\])s/g, "$1" + x3);
      var b3 = a3 ? t4.getUTCMilliseconds() : t4.getMilliseconds();
      e3 = e3.replace(/(^|[^\\])fff+/g, "$1" + l3(b3, 3)), b3 = Math.round(b3 / 10), e3 = e3.replace(/(^|[^\\])ff/g, "$1" + l3(b3)), b3 = Math.round(b3 / 10);
      var v3 = g3 < 12 ? "AM" : "PM";
      e3 = (e3 = (e3 = e3.replace(/(^|[^\\])f/g, "$1" + b3)).replace(/(^|[^\\])TT+/g, "$1" + v3)).replace(/(^|[^\\])T/g, "$1" + v3.charAt(0));
      var m3 = v3.toLowerCase();
      e3 = (e3 = e3.replace(/(^|[^\\])tt+/g, "$1" + m3)).replace(/(^|[^\\])t/g, "$1" + m3.charAt(0));
      var y3 = -t4.getTimezoneOffset(), w3 = a3 || !y3 ? "Z" : y3 > 0 ? "+" : "-";
      if (!a3) {
        var k3 = (y3 = Math.abs(y3)) % 60;
        w3 += l3(Math.floor(y3 / 60)) + ":" + l3(k3);
      }
      e3 = e3.replace(/(^|[^\\])K/g, "$1" + w3);
      var A3 = (a3 ? t4.getUTCDay() : t4.getDay()) + 1;
      return e3 = (e3 = (e3 = (e3 = (e3 = e3.replace(new RegExp(o3[0], "g"), o3[A3])).replace(new RegExp(n3[0], "g"), n3[A3])).replace(new RegExp(s3[0], "g"), s3[c3])).replace(new RegExp(r2[0], "g"), r2[c3])).replace(/\\(.)/g, "$1");
    } }, { key: "getTimeUnitsfromTimestamp", value: function(t4, e3, i2) {
      var a3 = this.w;
      void 0 !== a3.config.xaxis.min && (t4 = a3.config.xaxis.min), void 0 !== a3.config.xaxis.max && (e3 = a3.config.xaxis.max);
      var s3 = this.getDate(t4), r2 = this.getDate(e3), o3 = this.formatDate(s3, "yyyy MM dd HH mm ss fff").split(" "), n3 = this.formatDate(r2, "yyyy MM dd HH mm ss fff").split(" ");
      return { minMillisecond: parseInt(o3[6], 10), maxMillisecond: parseInt(n3[6], 10), minSecond: parseInt(o3[5], 10), maxSecond: parseInt(n3[5], 10), minMinute: parseInt(o3[4], 10), maxMinute: parseInt(n3[4], 10), minHour: parseInt(o3[3], 10), maxHour: parseInt(n3[3], 10), minDate: parseInt(o3[2], 10), maxDate: parseInt(n3[2], 10), minMonth: parseInt(o3[1], 10) - 1, maxMonth: parseInt(n3[1], 10) - 1, minYear: parseInt(o3[0], 10), maxYear: parseInt(n3[0], 10) };
    } }, { key: "isLeapYear", value: function(t4) {
      return t4 % 4 == 0 && t4 % 100 != 0 || t4 % 400 == 0;
    } }, { key: "calculcateLastDaysOfMonth", value: function(t4, e3, i2) {
      return this.determineDaysOfMonths(t4, e3) - i2;
    } }, { key: "determineDaysOfYear", value: function(t4) {
      var e3 = 365;
      return this.isLeapYear(t4) && (e3 = 366), e3;
    } }, { key: "determineRemainingDaysOfYear", value: function(t4, e3, i2) {
      var a3 = this.daysCntOfYear[e3] + i2;
      return e3 > 1 && this.isLeapYear() && a3++, a3;
    } }, { key: "determineDaysOfMonths", value: function(t4, e3) {
      var i2 = 30;
      switch (t4 = x2.monthMod(t4), true) {
        case this.months30.indexOf(t4) > -1:
          2 === t4 && (i2 = this.isLeapYear(e3) ? 29 : 28);
          break;
        case this.months31.indexOf(t4) > -1:
        default:
          i2 = 31;
      }
      return i2;
    } }]), t3;
  }(), S2 = function() {
    function t3(e3) {
      a2(this, t3), this.ctx = e3, this.w = e3.w, this.tooltipKeyFormat = "dd MMM";
    }
    return r(t3, [{ key: "xLabelFormat", value: function(t4, e3, i2, a3) {
      var s3 = this.w;
      if ("datetime" === s3.config.xaxis.type && void 0 === s3.config.xaxis.labels.formatter && void 0 === s3.config.tooltip.x.formatter) {
        var r2 = new A2(this.ctx);
        return r2.formatDate(r2.getDate(e3), s3.config.tooltip.x.format);
      }
      return t4(e3, i2, a3);
    } }, { key: "defaultGeneralFormatter", value: function(t4) {
      return Array.isArray(t4) ? t4.map(function(t5) {
        return t5;
      }) : t4;
    } }, { key: "defaultYFormatter", value: function(t4, e3, i2) {
      var a3 = this.w;
      if (x2.isNumber(t4)) if (0 !== a3.globals.yValueDecimal) t4 = t4.toFixed(void 0 !== e3.decimalsInFloat ? e3.decimalsInFloat : a3.globals.yValueDecimal);
      else {
        var s3 = t4.toFixed(0);
        t4 = t4 == s3 ? s3 : t4.toFixed(1);
      }
      return t4;
    } }, { key: "setLabelFormatters", value: function() {
      var t4 = this, e3 = this.w;
      return e3.globals.xaxisTooltipFormatter = function(e4) {
        return t4.defaultGeneralFormatter(e4);
      }, e3.globals.ttKeyFormatter = function(e4) {
        return t4.defaultGeneralFormatter(e4);
      }, e3.globals.ttZFormatter = function(t5) {
        return t5;
      }, e3.globals.legendFormatter = function(e4) {
        return t4.defaultGeneralFormatter(e4);
      }, void 0 !== e3.config.xaxis.labels.formatter ? e3.globals.xLabelFormatter = e3.config.xaxis.labels.formatter : e3.globals.xLabelFormatter = function(t5) {
        if (x2.isNumber(t5)) {
          if (!e3.config.xaxis.convertedCatToNumeric && "numeric" === e3.config.xaxis.type) {
            if (x2.isNumber(e3.config.xaxis.decimalsInFloat)) return t5.toFixed(e3.config.xaxis.decimalsInFloat);
            var i2 = e3.globals.maxX - e3.globals.minX;
            return i2 > 0 && i2 < 100 ? t5.toFixed(1) : t5.toFixed(0);
          }
          if (e3.globals.isBarHorizontal) {
            if (e3.globals.maxY - e3.globals.minYArr < 4) return t5.toFixed(1);
          }
          return t5.toFixed(0);
        }
        return t5;
      }, "function" == typeof e3.config.tooltip.x.formatter ? e3.globals.ttKeyFormatter = e3.config.tooltip.x.formatter : e3.globals.ttKeyFormatter = e3.globals.xLabelFormatter, "function" == typeof e3.config.xaxis.tooltip.formatter && (e3.globals.xaxisTooltipFormatter = e3.config.xaxis.tooltip.formatter), (Array.isArray(e3.config.tooltip.y) || void 0 !== e3.config.tooltip.y.formatter) && (e3.globals.ttVal = e3.config.tooltip.y), void 0 !== e3.config.tooltip.z.formatter && (e3.globals.ttZFormatter = e3.config.tooltip.z.formatter), void 0 !== e3.config.legend.formatter && (e3.globals.legendFormatter = e3.config.legend.formatter), e3.config.yaxis.forEach(function(i2, a3) {
        void 0 !== i2.labels.formatter ? e3.globals.yLabelFormatters[a3] = i2.labels.formatter : e3.globals.yLabelFormatters[a3] = function(s3) {
          return e3.globals.xyCharts ? Array.isArray(s3) ? s3.map(function(e4) {
            return t4.defaultYFormatter(e4, i2, a3);
          }) : t4.defaultYFormatter(s3, i2, a3) : s3;
        };
      }), e3.globals;
    } }, { key: "heatmapLabelFormatters", value: function() {
      var t4 = this.w;
      if ("heatmap" === t4.config.chart.type) {
        t4.globals.yAxisScale[0].result = t4.globals.seriesNames.slice();
        var e3 = t4.globals.seriesNames.reduce(function(t5, e4) {
          return t5.length > e4.length ? t5 : e4;
        }, 0);
        t4.globals.yAxisScale[0].niceMax = e3, t4.globals.yAxisScale[0].niceMin = e3;
      }
    } }]), t3;
  }(), C2 = function() {
    function t3(e3) {
      a2(this, t3), this.ctx = e3, this.w = e3.w;
    }
    return r(t3, [{ key: "getLabel", value: function(t4, e3, i2, a3) {
      var s3 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : [], r2 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "12px", o3 = !(arguments.length > 6 && void 0 !== arguments[6]) || arguments[6], n3 = this.w, l3 = void 0 === t4[a3] ? "" : t4[a3], h3 = l3, c3 = n3.globals.xLabelFormatter, d3 = n3.config.xaxis.labels.formatter, g3 = false, u3 = new S2(this.ctx), p3 = l3;
      o3 && (h3 = u3.xLabelFormat(c3, l3, p3, { i: a3, dateFormatter: new A2(this.ctx).formatDate, w: n3 }), void 0 !== d3 && (h3 = d3(l3, t4[a3], { i: a3, dateFormatter: new A2(this.ctx).formatDate, w: n3 })));
      var f3, x3;
      e3.length > 0 ? (f3 = e3[a3].unit, x3 = null, e3.forEach(function(t5) {
        "month" === t5.unit ? x3 = "year" : "day" === t5.unit ? x3 = "month" : "hour" === t5.unit ? x3 = "day" : "minute" === t5.unit && (x3 = "hour");
      }), g3 = x3 === f3, i2 = e3[a3].position, h3 = e3[a3].value) : "datetime" === n3.config.xaxis.type && void 0 === d3 && (h3 = ""), void 0 === h3 && (h3 = ""), h3 = Array.isArray(h3) ? h3 : h3.toString();
      var b3 = new m2(this.ctx), v3 = {};
      v3 = n3.globals.rotateXLabels && o3 ? b3.getTextRects(h3, parseInt(r2, 10), null, "rotate(".concat(n3.config.xaxis.labels.rotate, " 0 0)"), false) : b3.getTextRects(h3, parseInt(r2, 10));
      var y3 = !n3.config.xaxis.labels.showDuplicates && this.ctx.timeScale;
      return !Array.isArray(h3) && ("NaN" === String(h3) || s3.indexOf(h3) >= 0 && y3) && (h3 = ""), { x: i2, text: h3, textRect: v3, isBold: g3 };
    } }, { key: "checkLabelBasedOnTickamount", value: function(t4, e3, i2) {
      var a3 = this.w, s3 = a3.config.xaxis.tickAmount;
      return "dataPoints" === s3 && (s3 = Math.round(a3.globals.gridWidth / 120)), s3 > i2 || t4 % Math.round(i2 / (s3 + 1)) == 0 || (e3.text = ""), e3;
    } }, { key: "checkForOverflowingLabels", value: function(t4, e3, i2, a3, s3) {
      var r2 = this.w;
      if (0 === t4 && r2.globals.skipFirstTimelinelabel && (e3.text = ""), t4 === i2 - 1 && r2.globals.skipLastTimelinelabel && (e3.text = ""), r2.config.xaxis.labels.hideOverlappingLabels && a3.length > 0) {
        var o3 = s3[s3.length - 1];
        e3.x < o3.textRect.width / (r2.globals.rotateXLabels ? Math.abs(r2.config.xaxis.labels.rotate) / 12 : 1.01) + o3.x && (e3.text = "");
      }
      return e3;
    } }, { key: "checkForReversedLabels", value: function(t4, e3) {
      var i2 = this.w;
      return i2.config.yaxis[t4] && i2.config.yaxis[t4].reversed && e3.reverse(), e3;
    } }, { key: "yAxisAllSeriesCollapsed", value: function(t4) {
      var e3 = this.w.globals;
      return !e3.seriesYAxisMap[t4].some(function(t5) {
        return -1 === e3.collapsedSeriesIndices.indexOf(t5);
      });
    } }, { key: "translateYAxisIndex", value: function(t4) {
      var e3 = this.w, i2 = e3.globals, a3 = e3.config.yaxis;
      return i2.series.length > a3.length || a3.some(function(t5) {
        return Array.isArray(t5.seriesName);
      }) ? t4 : i2.seriesYAxisReverseMap[t4];
    } }, { key: "isYAxisHidden", value: function(t4) {
      var e3 = this.w, i2 = e3.config.yaxis[t4];
      if (!i2.show || this.yAxisAllSeriesCollapsed(t4)) return true;
      if (!i2.showForNullSeries) {
        var a3 = e3.globals.seriesYAxisMap[t4], s3 = new y2(this.ctx);
        return a3.every(function(t5) {
          return s3.isSeriesNull(t5);
        });
      }
      return false;
    } }, { key: "getYAxisForeColor", value: function(t4, e3) {
      var i2 = this.w;
      return Array.isArray(t4) && i2.globals.yAxisScale[e3] && this.ctx.theme.pushExtraColors(t4, i2.globals.yAxisScale[e3].result.length, false), t4;
    } }, { key: "drawYAxisTicks", value: function(t4, e3, i2, a3, s3, r2, o3) {
      var n3 = this.w, l3 = new m2(this.ctx), h3 = n3.globals.translateY + n3.config.yaxis[s3].labels.offsetY;
      if (n3.globals.isBarHorizontal ? h3 = 0 : "heatmap" === n3.config.chart.type && (h3 += r2 / 2), a3.show && e3 > 0) {
        true === n3.config.yaxis[s3].opposite && (t4 += a3.width);
        for (var c3 = e3; c3 >= 0; c3--) {
          var d3 = l3.drawLine(t4 + i2.offsetX - a3.width + a3.offsetX, h3 + a3.offsetY, t4 + i2.offsetX + a3.offsetX, h3 + a3.offsetY, a3.color);
          o3.add(d3), h3 += r2;
        }
      }
    } }]), t3;
  }(), L2 = function() {
    function t3(e3) {
      a2(this, t3), this.w = e3.w, this.annoCtx = e3, this.helpers = new w2(this.annoCtx), this.axesUtils = new C2(this.annoCtx);
    }
    return r(t3, [{ key: "addYaxisAnnotation", value: function(t4, e3, i2) {
      var a3, s3 = this.w, r2 = t4.strokeDashArray, o3 = this.helpers.getY1Y2("y1", t4), n3 = o3.yP, l3 = o3.clipped, h3 = true, c3 = false, d3 = t4.label.text;
      if (null === t4.y2 || void 0 === t4.y2) {
        if (!l3) {
          c3 = true;
          var g3 = this.annoCtx.graphics.drawLine(0 + t4.offsetX, n3 + t4.offsetY, this._getYAxisAnnotationWidth(t4), n3 + t4.offsetY, t4.borderColor, r2, t4.borderWidth);
          e3.appendChild(g3.node), t4.id && g3.node.classList.add(t4.id);
        }
      } else {
        if (a3 = (o3 = this.helpers.getY1Y2("y2", t4)).yP, h3 = o3.clipped, a3 > n3) {
          var u3 = n3;
          n3 = a3, a3 = u3;
        }
        if (!l3 || !h3) {
          c3 = true;
          var p3 = this.annoCtx.graphics.drawRect(0 + t4.offsetX, a3 + t4.offsetY, this._getYAxisAnnotationWidth(t4), n3 - a3, 0, t4.fillColor, t4.opacity, 1, t4.borderColor, r2);
          p3.node.classList.add("apexcharts-annotation-rect"), p3.attr("clip-path", "url(#gridRectMask".concat(s3.globals.cuid, ")")), e3.appendChild(p3.node), t4.id && p3.node.classList.add(t4.id);
        }
      }
      if (c3) {
        var f3 = "right" === t4.label.position ? s3.globals.gridWidth : "center" === t4.label.position ? s3.globals.gridWidth / 2 : 0, x3 = this.annoCtx.graphics.drawText({ x: f3 + t4.label.offsetX, y: (null != a3 ? a3 : n3) + t4.label.offsetY - 3, text: d3, textAnchor: t4.label.textAnchor, fontSize: t4.label.style.fontSize, fontFamily: t4.label.style.fontFamily, fontWeight: t4.label.style.fontWeight, foreColor: t4.label.style.color, cssClass: "apexcharts-yaxis-annotation-label ".concat(t4.label.style.cssClass, " ").concat(t4.id ? t4.id : "") });
        x3.attr({ rel: i2 }), e3.appendChild(x3.node);
      }
    } }, { key: "_getYAxisAnnotationWidth", value: function(t4) {
      var e3 = this.w;
      e3.globals.gridWidth;
      return (t4.width.indexOf("%") > -1 ? e3.globals.gridWidth * parseInt(t4.width, 10) / 100 : parseInt(t4.width, 10)) + t4.offsetX;
    } }, { key: "drawYAxisAnnotations", value: function() {
      var t4 = this, e3 = this.w, i2 = this.annoCtx.graphics.group({ class: "apexcharts-yaxis-annotations" });
      return e3.config.annotations.yaxis.forEach(function(e4, a3) {
        e4.yAxisIndex = t4.axesUtils.translateYAxisIndex(e4.yAxisIndex), t4.axesUtils.isYAxisHidden(e4.yAxisIndex) && t4.axesUtils.yAxisAllSeriesCollapsed(e4.yAxisIndex) || t4.addYaxisAnnotation(e4, i2.node, a3);
      }), i2;
    } }]), t3;
  }(), P2 = function() {
    function t3(e3) {
      a2(this, t3), this.w = e3.w, this.annoCtx = e3, this.helpers = new w2(this.annoCtx);
    }
    return r(t3, [{ key: "addPointAnnotation", value: function(t4, e3, i2) {
      if (!(this.w.globals.collapsedSeriesIndices.indexOf(t4.seriesIndex) > -1)) {
        var a3 = this.helpers.getX1X2("x1", t4), s3 = a3.x, r2 = a3.clipped, o3 = (a3 = this.helpers.getY1Y2("y1", t4)).yP, n3 = a3.clipped;
        if (x2.isNumber(s3) && !n3 && !r2) {
          var l3 = { pSize: t4.marker.size, pointStrokeWidth: t4.marker.strokeWidth, pointFillColor: t4.marker.fillColor, pointStrokeColor: t4.marker.strokeColor, shape: t4.marker.shape, pRadius: t4.marker.radius, class: "apexcharts-point-annotation-marker ".concat(t4.marker.cssClass, " ").concat(t4.id ? t4.id : "") }, h3 = this.annoCtx.graphics.drawMarker(s3 + t4.marker.offsetX, o3 + t4.marker.offsetY, l3);
          e3.appendChild(h3.node);
          var c3 = t4.label.text ? t4.label.text : "", d3 = this.annoCtx.graphics.drawText({ x: s3 + t4.label.offsetX, y: o3 + t4.label.offsetY - t4.marker.size - parseFloat(t4.label.style.fontSize) / 1.6, text: c3, textAnchor: t4.label.textAnchor, fontSize: t4.label.style.fontSize, fontFamily: t4.label.style.fontFamily, fontWeight: t4.label.style.fontWeight, foreColor: t4.label.style.color, cssClass: "apexcharts-point-annotation-label ".concat(t4.label.style.cssClass, " ").concat(t4.id ? t4.id : "") });
          if (d3.attr({ rel: i2 }), e3.appendChild(d3.node), t4.customSVG.SVG) {
            var g3 = this.annoCtx.graphics.group({ class: "apexcharts-point-annotations-custom-svg " + t4.customSVG.cssClass });
            g3.attr({ transform: "translate(".concat(s3 + t4.customSVG.offsetX, ", ").concat(o3 + t4.customSVG.offsetY, ")") }), g3.node.innerHTML = t4.customSVG.SVG, e3.appendChild(g3.node);
          }
          if (t4.image.path) {
            var u3 = t4.image.width ? t4.image.width : 20, p3 = t4.image.height ? t4.image.height : 20;
            h3 = this.annoCtx.addImage({ x: s3 + t4.image.offsetX - u3 / 2, y: o3 + t4.image.offsetY - p3 / 2, width: u3, height: p3, path: t4.image.path, appendTo: ".apexcharts-point-annotations" });
          }
          t4.mouseEnter && h3.node.addEventListener("mouseenter", t4.mouseEnter.bind(this, t4)), t4.mouseLeave && h3.node.addEventListener("mouseleave", t4.mouseLeave.bind(this, t4)), t4.click && h3.node.addEventListener("click", t4.click.bind(this, t4));
        }
      }
    } }, { key: "drawPointAnnotations", value: function() {
      var t4 = this, e3 = this.w, i2 = this.annoCtx.graphics.group({ class: "apexcharts-point-annotations" });
      return e3.config.annotations.points.map(function(e4, a3) {
        t4.addPointAnnotation(e4, i2.node, a3);
      }), i2;
    } }]), t3;
  }();
  var M2 = { name: "en", options: { months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], toolbar: { exportToSVG: "Download SVG", exportToPNG: "Download PNG", exportToCSV: "Download CSV", menu: "Menu", selection: "Selection", selectionZoom: "Selection Zoom", zoomIn: "Zoom In", zoomOut: "Zoom Out", pan: "Panning", reset: "Reset Zoom" } } }, I2 = function() {
    function t3() {
      a2(this, t3), this.yAxis = { show: true, showAlways: false, showForNullSeries: true, seriesName: void 0, opposite: false, reversed: false, logarithmic: false, logBase: 10, tickAmount: void 0, stepSize: void 0, forceNiceScale: false, max: void 0, min: void 0, floating: false, decimalsInFloat: void 0, labels: { show: true, minWidth: 0, maxWidth: 160, offsetX: 0, offsetY: 0, align: void 0, rotate: 0, padding: 20, style: { colors: [], fontSize: "11px", fontWeight: 400, fontFamily: void 0, cssClass: "" }, formatter: void 0 }, axisBorder: { show: false, color: "#e0e0e0", width: 1, offsetX: 0, offsetY: 0 }, axisTicks: { show: false, color: "#e0e0e0", width: 6, offsetX: 0, offsetY: 0 }, title: { text: void 0, rotate: -90, offsetY: 0, offsetX: 0, style: { color: void 0, fontSize: "11px", fontWeight: 900, fontFamily: void 0, cssClass: "" } }, tooltip: { enabled: false, offsetX: 0 }, crosshairs: { show: true, position: "front", stroke: { color: "#b6b6b6", width: 1, dashArray: 0 } } }, this.pointAnnotation = { id: void 0, x: 0, y: null, yAxisIndex: 0, seriesIndex: void 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, marker: { size: 4, fillColor: "#fff", strokeWidth: 2, strokeColor: "#333", shape: "circle", offsetX: 0, offsetY: 0, radius: 2, cssClass: "" }, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "middle", offsetX: 0, offsetY: 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } }, customSVG: { SVG: void 0, cssClass: void 0, offsetX: 0, offsetY: 0 }, image: { path: void 0, width: 20, height: 20, offsetX: 0, offsetY: 0 } }, this.yAxisAnnotation = { id: void 0, y: 0, y2: null, strokeDashArray: 1, fillColor: "#c2c2c2", borderColor: "#c2c2c2", borderWidth: 1, opacity: 0.3, offsetX: 0, offsetY: 0, width: "100%", yAxisIndex: 0, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "end", position: "right", offsetX: 0, offsetY: -3, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } } }, this.xAxisAnnotation = { id: void 0, x: 0, x2: null, strokeDashArray: 1, fillColor: "#c2c2c2", borderColor: "#c2c2c2", borderWidth: 1, opacity: 0.3, offsetX: 0, offsetY: 0, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "middle", orientation: "vertical", position: "top", offsetX: 0, offsetY: 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } } }, this.text = { x: 0, y: 0, text: "", textAnchor: "start", foreColor: void 0, fontSize: "13px", fontFamily: void 0, fontWeight: 400, appendTo: ".apexcharts-annotations", backgroundColor: "transparent", borderColor: "#c2c2c2", borderRadius: 0, borderWidth: 0, paddingLeft: 4, paddingRight: 4, paddingTop: 2, paddingBottom: 2 };
    }
    return r(t3, [{ key: "init", value: function() {
      return { annotations: { yaxis: [this.yAxisAnnotation], xaxis: [this.xAxisAnnotation], points: [this.pointAnnotation], texts: [], images: [], shapes: [] }, chart: { animations: { enabled: true, easing: "easeinout", speed: 800, animateGradually: { delay: 150, enabled: true }, dynamicAnimation: { enabled: true, speed: 350 } }, background: "transparent", locales: [M2], defaultLocale: "en", dropShadow: { enabled: false, enabledOnSeries: void 0, top: 2, left: 2, blur: 4, color: "#000", opacity: 0.35 }, events: { animationEnd: void 0, beforeMount: void 0, mounted: void 0, updated: void 0, click: void 0, mouseMove: void 0, mouseLeave: void 0, xAxisLabelClick: void 0, legendClick: void 0, markerClick: void 0, selection: void 0, dataPointSelection: void 0, dataPointMouseEnter: void 0, dataPointMouseLeave: void 0, beforeZoom: void 0, beforeResetZoom: void 0, zoomed: void 0, scrolled: void 0, brushScrolled: void 0 }, foreColor: "#373d3f", fontFamily: "Helvetica, Arial, sans-serif", height: "auto", parentHeightOffset: 15, redrawOnParentResize: true, redrawOnWindowResize: true, id: void 0, group: void 0, nonce: void 0, offsetX: 0, offsetY: 0, selection: { enabled: false, type: "x", fill: { color: "#24292e", opacity: 0.1 }, stroke: { width: 1, color: "#24292e", opacity: 0.4, dashArray: 3 }, xaxis: { min: void 0, max: void 0 }, yaxis: { min: void 0, max: void 0 } }, sparkline: { enabled: false }, brush: { enabled: false, autoScaleYaxis: true, target: void 0, targets: void 0 }, stacked: false, stackOnlyBar: true, stackType: "normal", toolbar: { show: true, offsetX: 0, offsetY: 0, tools: { download: true, selection: true, zoom: true, zoomin: true, zoomout: true, pan: true, reset: true, customIcons: [] }, export: { csv: { filename: void 0, columnDelimiter: ",", headerCategory: "category", headerValue: "value", dateFormatter: function(t4) {
        return new Date(t4).toDateString();
      } }, png: { filename: void 0 }, svg: { filename: void 0 } }, autoSelected: "zoom" }, type: "line", width: "100%", zoom: { enabled: true, type: "x", autoScaleYaxis: false, zoomedArea: { fill: { color: "#90CAF9", opacity: 0.4 }, stroke: { color: "#0D47A1", opacity: 0.4, width: 1 } } } }, plotOptions: { line: { isSlopeChart: false }, area: { fillTo: "origin" }, bar: { horizontal: false, columnWidth: "70%", barHeight: "70%", distributed: false, borderRadius: 0, borderRadiusApplication: "around", borderRadiusWhenStacked: "last", rangeBarOverlap: true, rangeBarGroupRows: false, hideZeroBarsWhenGrouped: false, isDumbbell: false, dumbbellColors: void 0, isFunnel: false, isFunnel3d: true, colors: { ranges: [], backgroundBarColors: [], backgroundBarOpacity: 1, backgroundBarRadius: 0 }, dataLabels: { position: "top", maxItems: 100, hideOverflowingLabels: true, orientation: "horizontal", total: { enabled: false, formatter: void 0, offsetX: 0, offsetY: 0, style: { color: "#373d3f", fontSize: "12px", fontFamily: void 0, fontWeight: 600 } } } }, bubble: { zScaling: true, minBubbleRadius: void 0, maxBubbleRadius: void 0 }, candlestick: { colors: { upward: "#00B746", downward: "#EF403C" }, wick: { useFillColor: true } }, boxPlot: { colors: { upper: "#00E396", lower: "#008FFB" } }, heatmap: { radius: 2, enableShades: true, shadeIntensity: 0.5, reverseNegativeShade: false, distributed: false, useFillColorAsStroke: false, colorScale: { inverse: false, ranges: [], min: void 0, max: void 0 } }, treemap: { enableShades: true, shadeIntensity: 0.5, distributed: false, reverseNegativeShade: false, useFillColorAsStroke: false, borderRadius: 4, dataLabels: { format: "scale" }, colorScale: { inverse: false, ranges: [], min: void 0, max: void 0 } }, radialBar: { inverseOrder: false, startAngle: 0, endAngle: 360, offsetX: 0, offsetY: 0, hollow: { margin: 5, size: "50%", background: "transparent", image: void 0, imageWidth: 150, imageHeight: 150, imageOffsetX: 0, imageOffsetY: 0, imageClipped: true, position: "front", dropShadow: { enabled: false, top: 0, left: 0, blur: 3, color: "#000", opacity: 0.5 } }, track: { show: true, startAngle: void 0, endAngle: void 0, background: "#f2f2f2", strokeWidth: "97%", opacity: 1, margin: 5, dropShadow: { enabled: false, top: 0, left: 0, blur: 3, color: "#000", opacity: 0.5 } }, dataLabels: { show: true, name: { show: true, fontSize: "16px", fontFamily: void 0, fontWeight: 600, color: void 0, offsetY: 0, formatter: function(t4) {
        return t4;
      } }, value: { show: true, fontSize: "14px", fontFamily: void 0, fontWeight: 400, color: void 0, offsetY: 16, formatter: function(t4) {
        return t4 + "%";
      } }, total: { show: false, label: "Total", fontSize: "16px", fontWeight: 600, fontFamily: void 0, color: void 0, formatter: function(t4) {
        return t4.globals.seriesTotals.reduce(function(t5, e3) {
          return t5 + e3;
        }, 0) / t4.globals.series.length + "%";
      } } }, barLabels: { enabled: false, margin: 5, useSeriesColors: true, fontFamily: void 0, fontWeight: 600, fontSize: "16px", formatter: function(t4) {
        return t4;
      }, onClick: void 0 } }, pie: { customScale: 1, offsetX: 0, offsetY: 0, startAngle: 0, endAngle: 360, expandOnClick: true, dataLabels: { offset: 0, minAngleToShowLabel: 10 }, donut: { size: "65%", background: "transparent", labels: { show: false, name: { show: true, fontSize: "16px", fontFamily: void 0, fontWeight: 600, color: void 0, offsetY: -10, formatter: function(t4) {
        return t4;
      } }, value: { show: true, fontSize: "20px", fontFamily: void 0, fontWeight: 400, color: void 0, offsetY: 10, formatter: function(t4) {
        return t4;
      } }, total: { show: false, showAlways: false, label: "Total", fontSize: "16px", fontWeight: 400, fontFamily: void 0, color: void 0, formatter: function(t4) {
        return t4.globals.seriesTotals.reduce(function(t5, e3) {
          return t5 + e3;
        }, 0);
      } } } } }, polarArea: { rings: { strokeWidth: 1, strokeColor: "#e8e8e8" }, spokes: { strokeWidth: 1, connectorColors: "#e8e8e8" } }, radar: { size: void 0, offsetX: 0, offsetY: 0, polygons: { strokeWidth: 1, strokeColors: "#e8e8e8", connectorColors: "#e8e8e8", fill: { colors: void 0 } } } }, colors: void 0, dataLabels: { enabled: true, enabledOnSeries: void 0, formatter: function(t4) {
        return null !== t4 ? t4 : "";
      }, textAnchor: "middle", distributed: false, offsetX: 0, offsetY: 0, style: { fontSize: "12px", fontFamily: void 0, fontWeight: 600, colors: void 0 }, background: { enabled: true, foreColor: "#fff", borderRadius: 2, padding: 4, opacity: 0.9, borderWidth: 1, borderColor: "#fff", dropShadow: { enabled: false, top: 1, left: 1, blur: 1, color: "#000", opacity: 0.45 } }, dropShadow: { enabled: false, top: 1, left: 1, blur: 1, color: "#000", opacity: 0.45 } }, fill: { type: "solid", colors: void 0, opacity: 0.85, gradient: { shade: "dark", type: "horizontal", shadeIntensity: 0.5, gradientToColors: void 0, inverseColors: true, opacityFrom: 1, opacityTo: 1, stops: [0, 50, 100], colorStops: [] }, image: { src: [], width: void 0, height: void 0 }, pattern: { style: "squares", width: 6, height: 6, strokeWidth: 2 } }, forecastDataPoints: { count: 0, fillOpacity: 0.5, strokeWidth: void 0, dashArray: 4 }, grid: { show: true, borderColor: "#e0e0e0", strokeDashArray: 0, position: "back", xaxis: { lines: { show: false } }, yaxis: { lines: { show: true } }, row: { colors: void 0, opacity: 0.5 }, column: { colors: void 0, opacity: 0.5 }, padding: { top: 0, right: 10, bottom: 0, left: 12 } }, labels: [], legend: { show: true, showForSingleSeries: false, showForNullSeries: true, showForZeroSeries: true, floating: false, position: "bottom", horizontalAlign: "center", inverseOrder: false, fontSize: "12px", fontFamily: void 0, fontWeight: 400, width: void 0, height: void 0, formatter: void 0, tooltipHoverFormatter: void 0, offsetX: -20, offsetY: 4, customLegendItems: [], labels: { colors: void 0, useSeriesColors: false }, markers: { width: 12, height: 12, strokeWidth: 0, fillColors: void 0, strokeColor: "#fff", radius: 12, customHTML: void 0, offsetX: 0, offsetY: 0, onClick: void 0 }, itemMargin: { horizontal: 5, vertical: 2 }, onItemClick: { toggleDataSeries: true }, onItemHover: { highlightDataSeries: true } }, markers: { discrete: [], size: 0, colors: void 0, strokeColors: "#fff", strokeWidth: 2, strokeOpacity: 0.9, strokeDashArray: 0, fillOpacity: 1, shape: "circle", width: 8, height: 8, radius: 2, offsetX: 0, offsetY: 0, onClick: void 0, onDblClick: void 0, showNullDataPoints: true, hover: { size: void 0, sizeOffset: 3 } }, noData: { text: void 0, align: "center", verticalAlign: "middle", offsetX: 0, offsetY: 0, style: { color: void 0, fontSize: "14px", fontFamily: void 0 } }, responsive: [], series: void 0, states: { normal: { filter: { type: "none", value: 0 } }, hover: { filter: { type: "lighten", value: 0.1 } }, active: { allowMultipleDataPointsSelection: false, filter: { type: "darken", value: 0.5 } } }, title: { text: void 0, align: "left", margin: 5, offsetX: 0, offsetY: 0, floating: false, style: { fontSize: "14px", fontWeight: 900, fontFamily: void 0, color: void 0 } }, subtitle: { text: void 0, align: "left", margin: 5, offsetX: 0, offsetY: 30, floating: false, style: { fontSize: "12px", fontWeight: 400, fontFamily: void 0, color: void 0 } }, stroke: { show: true, curve: "smooth", lineCap: "butt", width: 2, colors: void 0, dashArray: 0, fill: { type: "solid", colors: void 0, opacity: 0.85, gradient: { shade: "dark", type: "horizontal", shadeIntensity: 0.5, gradientToColors: void 0, inverseColors: true, opacityFrom: 1, opacityTo: 1, stops: [0, 50, 100], colorStops: [] } } }, tooltip: { enabled: true, enabledOnSeries: void 0, shared: true, hideEmptySeries: false, followCursor: false, intersect: false, inverseOrder: false, custom: void 0, fillSeriesColor: false, theme: "light", cssClass: "", style: { fontSize: "12px", fontFamily: void 0 }, onDatasetHover: { highlightDataSeries: false }, x: { show: true, format: "dd MMM", formatter: void 0 }, y: { formatter: void 0, title: { formatter: function(t4) {
        return t4 ? t4 + ": " : "";
      } } }, z: { formatter: void 0, title: "Size: " }, marker: { show: true, fillColors: void 0 }, items: { display: "flex" }, fixed: { enabled: false, position: "topRight", offsetX: 0, offsetY: 0 } }, xaxis: { type: "category", categories: [], convertedCatToNumeric: false, offsetX: 0, offsetY: 0, overwriteCategories: void 0, labels: { show: true, rotate: -45, rotateAlways: false, hideOverlappingLabels: true, trim: false, minHeight: void 0, maxHeight: 120, showDuplicates: true, style: { colors: [], fontSize: "12px", fontWeight: 400, fontFamily: void 0, cssClass: "" }, offsetX: 0, offsetY: 0, format: void 0, formatter: void 0, datetimeUTC: true, datetimeFormatter: { year: "yyyy", month: "MMM 'yy", day: "dd MMM", hour: "HH:mm", minute: "HH:mm:ss", second: "HH:mm:ss" } }, group: { groups: [], style: { colors: [], fontSize: "12px", fontWeight: 400, fontFamily: void 0, cssClass: "" } }, axisBorder: { show: true, color: "#e0e0e0", width: "100%", height: 1, offsetX: 0, offsetY: 0 }, axisTicks: { show: true, color: "#e0e0e0", height: 6, offsetX: 0, offsetY: 0 }, stepSize: void 0, tickAmount: void 0, tickPlacement: "on", min: void 0, max: void 0, range: void 0, floating: false, decimalsInFloat: void 0, position: "bottom", title: { text: void 0, offsetX: 0, offsetY: 0, style: { color: void 0, fontSize: "12px", fontWeight: 900, fontFamily: void 0, cssClass: "" } }, crosshairs: { show: true, width: 1, position: "back", opacity: 0.9, stroke: { color: "#b6b6b6", width: 1, dashArray: 3 }, fill: { type: "solid", color: "#B1B9C4", gradient: { colorFrom: "#D8E3F0", colorTo: "#BED1E6", stops: [0, 100], opacityFrom: 0.4, opacityTo: 0.5 } }, dropShadow: { enabled: false, left: 0, top: 0, blur: 1, opacity: 0.4 } }, tooltip: { enabled: true, offsetY: 0, formatter: void 0, style: { fontSize: "12px", fontFamily: void 0 } } }, yaxis: this.yAxis, theme: { mode: "light", palette: "palette1", monochrome: { enabled: false, color: "#008FFB", shadeTo: "light", shadeIntensity: 0.65 } } };
    } }]), t3;
  }(), T2 = function() {
    function t3(e3) {
      a2(this, t3), this.ctx = e3, this.w = e3.w, this.graphics = new m2(this.ctx), this.w.globals.isBarHorizontal && (this.invertAxis = true), this.helpers = new w2(this), this.xAxisAnnotations = new k2(this), this.yAxisAnnotations = new L2(this), this.pointsAnnotations = new P2(this), this.w.globals.isBarHorizontal && this.w.config.yaxis[0].reversed && (this.inversedReversedAxis = true), this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints;
    }
    return r(t3, [{ key: "drawAxesAnnotations", value: function() {
      var t4 = this.w;
      if (t4.globals.axisCharts) {
        for (var e3 = this.yAxisAnnotations.drawYAxisAnnotations(), i2 = this.xAxisAnnotations.drawXAxisAnnotations(), a3 = this.pointsAnnotations.drawPointAnnotations(), s3 = t4.config.chart.animations.enabled, r2 = [e3, i2, a3], o3 = [i2.node, e3.node, a3.node], n3 = 0; n3 < 3; n3++) t4.globals.dom.elGraphical.add(r2[n3]), !s3 || t4.globals.resized || t4.globals.dataChanged || "scatter" !== t4.config.chart.type && "bubble" !== t4.config.chart.type && t4.globals.dataPoints > 1 && o3[n3].classList.add("apexcharts-element-hidden"), t4.globals.delayedElements.push({ el: o3[n3], index: 0 });
        this.helpers.annotationsBackground();
      }
    } }, { key: "drawImageAnnos", value: function() {
      var t4 = this;
      this.w.config.annotations.images.map(function(e3, i2) {
        t4.addImage(e3, i2);
      });
    } }, { key: "drawTextAnnos", value: function() {
      var t4 = this;
      this.w.config.annotations.texts.map(function(e3, i2) {
        t4.addText(e3, i2);
      });
    } }, { key: "addXaxisAnnotation", value: function(t4, e3, i2) {
      this.xAxisAnnotations.addXaxisAnnotation(t4, e3, i2);
    } }, { key: "addYaxisAnnotation", value: function(t4, e3, i2) {
      this.yAxisAnnotations.addYaxisAnnotation(t4, e3, i2);
    } }, { key: "addPointAnnotation", value: function(t4, e3, i2) {
      this.pointsAnnotations.addPointAnnotation(t4, e3, i2);
    } }, { key: "addText", value: function(t4, e3) {
      var i2 = t4.x, a3 = t4.y, s3 = t4.text, r2 = t4.textAnchor, o3 = t4.foreColor, n3 = t4.fontSize, l3 = t4.fontFamily, h3 = t4.fontWeight, c3 = t4.cssClass, d3 = t4.backgroundColor, g3 = t4.borderWidth, u3 = t4.strokeDashArray, p3 = t4.borderRadius, f3 = t4.borderColor, x3 = t4.appendTo, b3 = void 0 === x3 ? ".apexcharts-svg" : x3, v3 = t4.paddingLeft, m3 = void 0 === v3 ? 4 : v3, y3 = t4.paddingRight, w3 = void 0 === y3 ? 4 : y3, k3 = t4.paddingBottom, A3 = void 0 === k3 ? 2 : k3, S3 = t4.paddingTop, C3 = void 0 === S3 ? 2 : S3, L3 = this.w, P3 = this.graphics.drawText({ x: i2, y: a3, text: s3, textAnchor: r2 || "start", fontSize: n3 || "12px", fontWeight: h3 || "regular", fontFamily: l3 || L3.config.chart.fontFamily, foreColor: o3 || L3.config.chart.foreColor, cssClass: c3 }), M3 = L3.globals.dom.baseEl.querySelector(b3);
      M3 && M3.appendChild(P3.node);
      var I3 = P3.bbox();
      if (s3) {
        var T3 = this.graphics.drawRect(I3.x - m3, I3.y - C3, I3.width + m3 + w3, I3.height + A3 + C3, p3, d3 || "transparent", 1, g3, f3, u3);
        M3.insertBefore(T3.node, P3.node);
      }
    } }, { key: "addImage", value: function(t4, e3) {
      var i2 = this.w, a3 = t4.path, s3 = t4.x, r2 = void 0 === s3 ? 0 : s3, o3 = t4.y, n3 = void 0 === o3 ? 0 : o3, l3 = t4.width, h3 = void 0 === l3 ? 20 : l3, c3 = t4.height, d3 = void 0 === c3 ? 20 : c3, g3 = t4.appendTo, u3 = void 0 === g3 ? ".apexcharts-svg" : g3, p3 = i2.globals.dom.Paper.image(a3);
      p3.size(h3, d3).move(r2, n3);
      var f3 = i2.globals.dom.baseEl.querySelector(u3);
      return f3 && f3.appendChild(p3.node), p3;
    } }, { key: "addXaxisAnnotationExternal", value: function(t4, e3, i2) {
      return this.addAnnotationExternal({ params: t4, pushToMemory: e3, context: i2, type: "xaxis", contextMethod: i2.addXaxisAnnotation }), i2;
    } }, { key: "addYaxisAnnotationExternal", value: function(t4, e3, i2) {
      return this.addAnnotationExternal({ params: t4, pushToMemory: e3, context: i2, type: "yaxis", contextMethod: i2.addYaxisAnnotation }), i2;
    } }, { key: "addPointAnnotationExternal", value: function(t4, e3, i2) {
      return void 0 === this.invertAxis && (this.invertAxis = i2.w.globals.isBarHorizontal), this.addAnnotationExternal({ params: t4, pushToMemory: e3, context: i2, type: "point", contextMethod: i2.addPointAnnotation }), i2;
    } }, { key: "addAnnotationExternal", value: function(t4) {
      var e3 = t4.params, i2 = t4.pushToMemory, a3 = t4.context, s3 = t4.type, r2 = t4.contextMethod, o3 = a3, n3 = o3.w, l3 = n3.globals.dom.baseEl.querySelector(".apexcharts-".concat(s3, "-annotations")), h3 = l3.childNodes.length + 1, c3 = new I2(), d3 = Object.assign({}, "xaxis" === s3 ? c3.xAxisAnnotation : "yaxis" === s3 ? c3.yAxisAnnotation : c3.pointAnnotation), g3 = x2.extend(d3, e3);
      switch (s3) {
        case "xaxis":
          this.addXaxisAnnotation(g3, l3, h3);
          break;
        case "yaxis":
          this.addYaxisAnnotation(g3, l3, h3);
          break;
        case "point":
          this.addPointAnnotation(g3, l3, h3);
      }
      var u3 = n3.globals.dom.baseEl.querySelector(".apexcharts-".concat(s3, "-annotations .apexcharts-").concat(s3, "-annotation-label[rel='").concat(h3, "']")), p3 = this.helpers.addBackgroundToAnno(u3, g3);
      return p3 && l3.insertBefore(p3.node, u3), i2 && n3.globals.memory.methodsToExec.push({ context: o3, id: g3.id ? g3.id : x2.randomId(), method: r2, label: "addAnnotation", params: e3 }), a3;
    } }, { key: "clearAnnotations", value: function(t4) {
      var e3 = t4.w, i2 = e3.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations");
      e3.globals.memory.methodsToExec.map(function(t5, i3) {
        "addText" !== t5.label && "addAnnotation" !== t5.label || e3.globals.memory.methodsToExec.splice(i3, 1);
      }), i2 = x2.listToArray(i2), Array.prototype.forEach.call(i2, function(t5) {
        for (; t5.firstChild; ) t5.removeChild(t5.firstChild);
      });
    } }, { key: "removeAnnotation", value: function(t4, e3) {
      var i2 = t4.w, a3 = i2.globals.dom.baseEl.querySelectorAll(".".concat(e3));
      a3 && (i2.globals.memory.methodsToExec.map(function(t5, a4) {
        t5.id === e3 && i2.globals.memory.methodsToExec.splice(a4, 1);
      }), Array.prototype.forEach.call(a3, function(t5) {
        t5.parentElement.removeChild(t5);
      }));
    } }]), t3;
  }(), z2 = function(t3) {
    var e3, i2 = t3.isTimeline, a3 = t3.ctx, s3 = t3.seriesIndex, r2 = t3.dataPointIndex, o3 = t3.y1, n3 = t3.y2, l3 = t3.w, h3 = l3.globals.seriesRangeStart[s3][r2], c3 = l3.globals.seriesRangeEnd[s3][r2], d3 = l3.globals.labels[r2], g3 = l3.config.series[s3].name ? l3.config.series[s3].name : "", u3 = l3.globals.ttKeyFormatter, p3 = l3.config.tooltip.y.title.formatter, f3 = { w: l3, seriesIndex: s3, dataPointIndex: r2, start: h3, end: c3 };
    ("function" == typeof p3 && (g3 = p3(g3, f3)), null !== (e3 = l3.config.series[s3].data[r2]) && void 0 !== e3 && e3.x && (d3 = l3.config.series[s3].data[r2].x), i2) || "datetime" === l3.config.xaxis.type && (d3 = new S2(a3).xLabelFormat(l3.globals.ttKeyFormatter, d3, d3, { i: void 0, dateFormatter: new A2(a3).formatDate, w: l3 }));
    "function" == typeof u3 && (d3 = u3(d3, f3)), Number.isFinite(o3) && Number.isFinite(n3) && (h3 = o3, c3 = n3);
    var x3 = "", b3 = "", v3 = l3.globals.colors[s3];
    if (void 0 === l3.config.tooltip.x.formatter) if ("datetime" === l3.config.xaxis.type) {
      var m3 = new A2(a3);
      x3 = m3.formatDate(m3.getDate(h3), l3.config.tooltip.x.format), b3 = m3.formatDate(m3.getDate(c3), l3.config.tooltip.x.format);
    } else x3 = h3, b3 = c3;
    else x3 = l3.config.tooltip.x.formatter(h3), b3 = l3.config.tooltip.x.formatter(c3);
    return { start: h3, end: c3, startVal: x3, endVal: b3, ylabel: d3, color: v3, seriesName: g3 };
  }, X2 = function(t3) {
    var e3 = t3.color, i2 = t3.seriesName, a3 = t3.ylabel, s3 = t3.start, r2 = t3.end, o3 = t3.seriesIndex, n3 = t3.dataPointIndex, l3 = t3.ctx.tooltip.tooltipLabels.getFormatters(o3);
    s3 = l3.yLbFormatter(s3), r2 = l3.yLbFormatter(r2);
    var h3 = l3.yLbFormatter(t3.w.globals.series[o3][n3]), c3 = '<span class="value start-value">\n  '.concat(s3, '\n  </span> <span class="separator">-</span> <span class="value end-value">\n  ').concat(r2, "\n  </span>");
    return '<div class="apexcharts-tooltip-rangebar"><div> <span class="series-name" style="color: ' + e3 + '">' + (i2 || "") + '</span></div><div> <span class="category">' + a3 + ": </span> " + (t3.w.globals.comboCharts ? "rangeArea" === t3.w.config.series[o3].type || "rangeBar" === t3.w.config.series[o3].type ? c3 : "<span>".concat(h3, "</span>") : c3) + " </div></div>";
  }, E2 = function() {
    function t3(e3) {
      a2(this, t3), this.opts = e3;
    }
    return r(t3, [{ key: "hideYAxis", value: function() {
      this.opts.yaxis[0].show = false, this.opts.yaxis[0].title.text = "", this.opts.yaxis[0].axisBorder.show = false, this.opts.yaxis[0].axisTicks.show = false, this.opts.yaxis[0].floating = true;
    } }, { key: "line", value: function() {
      return { chart: { animations: { easing: "swing" } }, dataLabels: { enabled: false }, stroke: { width: 5, curve: "straight" }, markers: { size: 0, hover: { sizeOffset: 6 } }, xaxis: { crosshairs: { width: 1 } } };
    } }, { key: "sparkline", value: function(t4) {
      this.hideYAxis();
      return x2.extend(t4, { grid: { show: false, padding: { left: 0, right: 0, top: 0, bottom: 0 } }, legend: { show: false }, xaxis: { labels: { show: false }, tooltip: { enabled: false }, axisBorder: { show: false }, axisTicks: { show: false } }, chart: { toolbar: { show: false }, zoom: { enabled: false } }, dataLabels: { enabled: false } });
    } }, { key: "slope", value: function() {
      return this.hideYAxis(), { chart: { toolbar: { show: false }, zoom: { enabled: false } }, dataLabels: { enabled: true, formatter: function(t4, e3) {
        var i2 = e3.w.config.series[e3.seriesIndex].name;
        return null !== t4 ? i2 + ": " + t4 : "";
      }, background: { enabled: false }, offsetX: -5 }, grid: { xaxis: { lines: { show: true } }, yaxis: { lines: { show: false } } }, xaxis: { position: "top", labels: { style: { fontSize: 14, fontWeight: 900 } }, tooltip: { enabled: false }, crosshairs: { show: false } }, markers: { size: 8, hover: { sizeOffset: 1 } }, legend: { show: false }, tooltip: { shared: false, intersect: true, followCursor: true }, stroke: { width: 5, curve: "straight" } };
    } }, { key: "bar", value: function() {
      return { chart: { stacked: false, animations: { easing: "swing" } }, plotOptions: { bar: { dataLabels: { position: "center" } } }, dataLabels: { style: { colors: ["#fff"] }, background: { enabled: false } }, stroke: { width: 0, lineCap: "round" }, fill: { opacity: 0.85 }, legend: { markers: { shape: "square", radius: 2, size: 8 } }, tooltip: { shared: false, intersect: true }, xaxis: { tooltip: { enabled: false }, tickPlacement: "between", crosshairs: { width: "barWidth", position: "back", fill: { type: "gradient" }, dropShadow: { enabled: false }, stroke: { width: 0 } } } };
    } }, { key: "funnel", value: function() {
      return this.hideYAxis(), e2(e2({}, this.bar()), {}, { chart: { animations: { easing: "linear", speed: 800, animateGradually: { enabled: false } } }, plotOptions: { bar: { horizontal: true, borderRadiusApplication: "around", borderRadius: 0, dataLabels: { position: "center" } } }, grid: { show: false, padding: { left: 0, right: 0 } }, xaxis: { labels: { show: false }, tooltip: { enabled: false }, axisBorder: { show: false }, axisTicks: { show: false } } });
    } }, { key: "candlestick", value: function() {
      var t4 = this;
      return { stroke: { width: 1, colors: ["#333"] }, fill: { opacity: 1 }, dataLabels: { enabled: false }, tooltip: { shared: true, custom: function(e3) {
        var i2 = e3.seriesIndex, a3 = e3.dataPointIndex, s3 = e3.w;
        return t4._getBoxTooltip(s3, i2, a3, ["Open", "High", "", "Low", "Close"], "candlestick");
      } }, states: { active: { filter: { type: "none" } } }, xaxis: { crosshairs: { width: 1 } } };
    } }, { key: "boxPlot", value: function() {
      var t4 = this;
      return { chart: { animations: { dynamicAnimation: { enabled: false } } }, stroke: { width: 1, colors: ["#24292e"] }, dataLabels: { enabled: false }, tooltip: { shared: true, custom: function(e3) {
        var i2 = e3.seriesIndex, a3 = e3.dataPointIndex, s3 = e3.w;
        return t4._getBoxTooltip(s3, i2, a3, ["Minimum", "Q1", "Median", "Q3", "Maximum"], "boxPlot");
      } }, markers: { size: 5, strokeWidth: 1, strokeColors: "#111" }, xaxis: { crosshairs: { width: 1 } } };
    } }, { key: "rangeBar", value: function() {
      return { chart: { animations: { animateGradually: false } }, stroke: { width: 0, lineCap: "square" }, plotOptions: { bar: { borderRadius: 0, dataLabels: { position: "center" } } }, dataLabels: { enabled: false, formatter: function(t4, e3) {
        e3.ctx;
        var i2 = e3.seriesIndex, a3 = e3.dataPointIndex, s3 = e3.w, r2 = function() {
          var t5 = s3.globals.seriesRangeStart[i2][a3];
          return s3.globals.seriesRangeEnd[i2][a3] - t5;
        };
        return s3.globals.comboCharts ? "rangeBar" === s3.config.series[i2].type || "rangeArea" === s3.config.series[i2].type ? r2() : t4 : r2();
      }, background: { enabled: false }, style: { colors: ["#fff"] } }, markers: { size: 10 }, tooltip: { shared: false, followCursor: true, custom: function(t4) {
        return t4.w.config.plotOptions && t4.w.config.plotOptions.bar && t4.w.config.plotOptions.bar.horizontal ? function(t5) {
          var i2 = z2(e2(e2({}, t5), {}, { isTimeline: true })), a3 = i2.color, s3 = i2.seriesName, r2 = i2.ylabel, o3 = i2.startVal, n3 = i2.endVal;
          return X2(e2(e2({}, t5), {}, { color: a3, seriesName: s3, ylabel: r2, start: o3, end: n3 }));
        }(t4) : function(t5) {
          var i2 = z2(t5), a3 = i2.color, s3 = i2.seriesName, r2 = i2.ylabel, o3 = i2.start, n3 = i2.end;
          return X2(e2(e2({}, t5), {}, { color: a3, seriesName: s3, ylabel: r2, start: o3, end: n3 }));
        }(t4);
      } }, xaxis: { tickPlacement: "between", tooltip: { enabled: false }, crosshairs: { stroke: { width: 0 } } } };
    } }, { key: "dumbbell", value: function(t4) {
      var e3, i2;
      return null !== (e3 = t4.plotOptions.bar) && void 0 !== e3 && e3.barHeight || (t4.plotOptions.bar.barHeight = 2), null !== (i2 = t4.plotOptions.bar) && void 0 !== i2 && i2.columnWidth || (t4.plotOptions.bar.columnWidth = 2), t4;
    } }, { key: "area", value: function() {
      return { stroke: { width: 4, fill: { type: "solid", gradient: { inverseColors: false, shade: "light", type: "vertical", opacityFrom: 0.65, opacityTo: 0.5, stops: [0, 100, 100] } } }, fill: { type: "gradient", gradient: { inverseColors: false, shade: "light", type: "vertical", opacityFrom: 0.65, opacityTo: 0.5, stops: [0, 100, 100] } }, markers: { size: 0, hover: { sizeOffset: 6 } }, tooltip: { followCursor: false } };
    } }, { key: "rangeArea", value: function() {
      return { stroke: { curve: "straight", width: 0 }, fill: { type: "solid", opacity: 0.6 }, markers: { size: 0 }, states: { hover: { filter: { type: "none" } }, active: { filter: { type: "none" } } }, tooltip: { intersect: false, shared: true, followCursor: true, custom: function(t4) {
        return function(t5) {
          var i2 = z2(t5), a3 = i2.color, s3 = i2.seriesName, r2 = i2.ylabel, o3 = i2.start, n3 = i2.end;
          return X2(e2(e2({}, t5), {}, { color: a3, seriesName: s3, ylabel: r2, start: o3, end: n3 }));
        }(t4);
      } } };
    } }, { key: "brush", value: function(t4) {
      return x2.extend(t4, { chart: { toolbar: { autoSelected: "selection", show: false }, zoom: { enabled: false } }, dataLabels: { enabled: false }, stroke: { width: 1 }, tooltip: { enabled: false }, xaxis: { tooltip: { enabled: false } } });
    } }, { key: "stacked100", value: function(t4) {
      t4.dataLabels = t4.dataLabels || {}, t4.dataLabels.formatter = t4.dataLabels.formatter || void 0;
      var e3 = t4.dataLabels.formatter;
      return t4.yaxis.forEach(function(e4, i2) {
        t4.yaxis[i2].min = 0, t4.yaxis[i2].max = 100;
      }), "bar" === t4.chart.type && (t4.dataLabels.formatter = e3 || function(t5) {
        return "number" == typeof t5 && t5 ? t5.toFixed(0) + "%" : t5;
      }), t4;
    } }, { key: "stackedBars", value: function() {
      var t4 = this.bar();
      return e2(e2({}, t4), {}, { plotOptions: e2(e2({}, t4.plotOptions), {}, { bar: e2(e2({}, t4.plotOptions.bar), {}, { borderRadiusApplication: "end", borderRadiusWhenStacked: "last" }) }) });
    } }, { key: "convertCatToNumeric", value: function(t4) {
      return t4.xaxis.convertedCatToNumeric = true, t4;
    } }, { key: "convertCatToNumericXaxis", value: function(t4, e3, i2) {
      t4.xaxis.type = "numeric", t4.xaxis.labels = t4.xaxis.labels || {}, t4.xaxis.labels.formatter = t4.xaxis.labels.formatter || function(t5) {
        return x2.isNumber(t5) ? Math.floor(t5) : t5;
      };
      var a3 = t4.xaxis.labels.formatter, s3 = t4.xaxis.categories && t4.xaxis.categories.length ? t4.xaxis.categories : t4.labels;
      return i2 && i2.length && (s3 = i2.map(function(t5) {
        return Array.isArray(t5) ? t5 : String(t5);
      })), s3 && s3.length && (t4.xaxis.labels.formatter = function(t5) {
        return x2.isNumber(t5) ? a3(s3[Math.floor(t5) - 1]) : a3(t5);
      }), t4.xaxis.categories = [], t4.labels = [], t4.xaxis.tickAmount = t4.xaxis.tickAmount || "dataPoints", t4;
    } }, { key: "bubble", value: function() {
      return { dataLabels: { style: { colors: ["#fff"] } }, tooltip: { shared: false, intersect: true }, xaxis: { crosshairs: { width: 0 } }, fill: { type: "solid", gradient: { shade: "light", inverse: true, shadeIntensity: 0.55, opacityFrom: 0.4, opacityTo: 0.8 } } };
    } }, { key: "scatter", value: function() {
      return { dataLabels: { enabled: false }, tooltip: { shared: false, intersect: true }, markers: { size: 6, strokeWidth: 1, hover: { sizeOffset: 2 } } };
    } }, { key: "heatmap", value: function() {
      return { chart: { stacked: false }, fill: { opacity: 1 }, dataLabels: { style: { colors: ["#fff"] } }, stroke: { colors: ["#fff"] }, tooltip: { followCursor: true, marker: { show: false }, x: { show: false } }, legend: { position: "top", markers: { shape: "square", size: 10, offsetY: 2 } }, grid: { padding: { right: 20 } } };
    } }, { key: "treemap", value: function() {
      return { chart: { zoom: { enabled: false } }, dataLabels: { style: { fontSize: 14, fontWeight: 600, colors: ["#fff"] } }, stroke: { show: true, width: 2, colors: ["#fff"] }, legend: { show: false }, fill: { opacity: 1, gradient: { stops: [0, 100] } }, tooltip: { followCursor: true, x: { show: false } }, grid: { padding: { left: 0, right: 0 } }, xaxis: { crosshairs: { show: false }, tooltip: { enabled: false } } };
    } }, { key: "pie", value: function() {
      return { chart: { toolbar: { show: false } }, plotOptions: { pie: { donut: { labels: { show: false } } } }, dataLabels: { formatter: function(t4) {
        return t4.toFixed(1) + "%";
      }, style: { colors: ["#fff"] }, background: { enabled: false }, dropShadow: { enabled: true } }, stroke: { colors: ["#fff"] }, fill: { opacity: 1, gradient: { shade: "light", stops: [0, 100] } }, tooltip: { theme: "dark", fillSeriesColor: true }, legend: { position: "right" } };
    } }, { key: "donut", value: function() {
      return { chart: { toolbar: { show: false } }, dataLabels: { formatter: function(t4) {
        return t4.toFixed(1) + "%";
      }, style: { colors: ["#fff"] }, background: { enabled: false }, dropShadow: { enabled: true } }, stroke: { colors: ["#fff"] }, fill: { opacity: 1, gradient: { shade: "light", shadeIntensity: 0.35, stops: [80, 100], opacityFrom: 1, opacityTo: 1 } }, tooltip: { theme: "dark", fillSeriesColor: true }, legend: { position: "right" } };
    } }, { key: "polarArea", value: function() {
      return { chart: { toolbar: { show: false } }, dataLabels: { formatter: function(t4) {
        return t4.toFixed(1) + "%";
      }, enabled: false }, stroke: { show: true, width: 2 }, fill: { opacity: 0.7 }, tooltip: { theme: "dark", fillSeriesColor: true }, legend: { position: "right" } };
    } }, { key: "radar", value: function() {
      return this.opts.yaxis[0].labels.offsetY = this.opts.yaxis[0].labels.offsetY ? this.opts.yaxis[0].labels.offsetY : 6, { dataLabels: { enabled: false, style: { fontSize: "11px" } }, stroke: { width: 2 }, markers: { size: 3, strokeWidth: 1, strokeOpacity: 1 }, fill: { opacity: 0.2 }, tooltip: { shared: false, intersect: true, followCursor: true }, grid: { show: false }, xaxis: { labels: { formatter: function(t4) {
        return t4;
      }, style: { colors: ["#a8a8a8"], fontSize: "11px" } }, tooltip: { enabled: false }, crosshairs: { show: false } } };
    } }, { key: "radialBar", value: function() {
      return { chart: { animations: { dynamicAnimation: { enabled: true, speed: 800 } }, toolbar: { show: false } }, fill: { gradient: { shade: "dark", shadeIntensity: 0.4, inverseColors: false, type: "diagonal2", opacityFrom: 1, opacityTo: 1, stops: [70, 98, 100] } }, legend: { show: false, position: "right" }, tooltip: { enabled: false, fillSeriesColor: true } };
    } }, { key: "_getBoxTooltip", value: function(t4, e3, i2, a3, s3) {
      var r2 = t4.globals.seriesCandleO[e3][i2], o3 = t4.globals.seriesCandleH[e3][i2], n3 = t4.globals.seriesCandleM[e3][i2], l3 = t4.globals.seriesCandleL[e3][i2], h3 = t4.globals.seriesCandleC[e3][i2];
      return t4.config.series[e3].type && t4.config.series[e3].type !== s3 ? '<div class="apexcharts-custom-tooltip">\n          '.concat(t4.config.series[e3].name ? t4.config.series[e3].name : "series-" + (e3 + 1), ": <strong>").concat(t4.globals.series[e3][i2], "</strong>\n        </div>") : '<div class="apexcharts-tooltip-box apexcharts-tooltip-'.concat(t4.config.chart.type, '">') + "<div>".concat(a3[0], ': <span class="value">') + r2 + "</span></div>" + "<div>".concat(a3[1], ': <span class="value">') + o3 + "</span></div>" + (n3 ? "<div>".concat(a3[2], ': <span class="value">') + n3 + "</span></div>" : "") + "<div>".concat(a3[3], ': <span class="value">') + l3 + "</span></div>" + "<div>".concat(a3[4], ': <span class="value">') + h3 + "</span></div></div>";
    } }]), t3;
  }(), Y2 = function() {
    function t3(e3) {
      a2(this, t3), this.opts = e3;
    }
    return r(t3, [{ key: "init", value: function(t4) {
      var e3 = t4.responsiveOverride, a3 = this.opts, s3 = new I2(), r2 = new E2(a3);
      this.chartType = a3.chart.type, a3 = this.extendYAxis(a3), a3 = this.extendAnnotations(a3);
      var o3 = s3.init(), n3 = {};
      if (a3 && "object" === i(a3)) {
        var l3, h3, c3, d3, g3, u3, p3, f3, b3, v3, m3 = {};
        m3 = -1 !== ["line", "area", "bar", "candlestick", "boxPlot", "rangeBar", "rangeArea", "bubble", "scatter", "heatmap", "treemap", "pie", "polarArea", "donut", "radar", "radialBar"].indexOf(a3.chart.type) ? r2[a3.chart.type]() : r2.line(), null !== (l3 = a3.plotOptions) && void 0 !== l3 && null !== (h3 = l3.bar) && void 0 !== h3 && h3.isFunnel && (m3 = r2.funnel()), a3.chart.stacked && "bar" === a3.chart.type && (m3 = r2.stackedBars()), null !== (c3 = a3.chart.brush) && void 0 !== c3 && c3.enabled && (m3 = r2.brush(m3)), null !== (d3 = a3.plotOptions) && void 0 !== d3 && null !== (g3 = d3.line) && void 0 !== g3 && g3.isSlopeChart && (m3 = r2.slope()), a3.chart.stacked && "100%" === a3.chart.stackType && (a3 = r2.stacked100(a3)), null !== (u3 = a3.plotOptions) && void 0 !== u3 && null !== (p3 = u3.bar) && void 0 !== p3 && p3.isDumbbell && (a3 = r2.dumbbell(a3)), this.checkForDarkTheme(window.Apex), this.checkForDarkTheme(a3), a3.xaxis = a3.xaxis || window.Apex.xaxis || {}, e3 || (a3.xaxis.convertedCatToNumeric = false), (null !== (f3 = (a3 = this.checkForCatToNumericXAxis(this.chartType, m3, a3)).chart.sparkline) && void 0 !== f3 && f3.enabled || null !== (b3 = window.Apex.chart) && void 0 !== b3 && null !== (v3 = b3.sparkline) && void 0 !== v3 && v3.enabled) && (m3 = r2.sparkline(m3)), n3 = x2.extend(o3, m3);
      }
      var y3 = x2.extend(n3, window.Apex);
      return o3 = x2.extend(y3, a3), o3 = this.handleUserInputErrors(o3);
    } }, { key: "checkForCatToNumericXAxis", value: function(t4, e3, i2) {
      var a3, s3, r2 = new E2(i2), o3 = ("bar" === t4 || "boxPlot" === t4) && (null === (a3 = i2.plotOptions) || void 0 === a3 || null === (s3 = a3.bar) || void 0 === s3 ? void 0 : s3.horizontal), n3 = "pie" === t4 || "polarArea" === t4 || "donut" === t4 || "radar" === t4 || "radialBar" === t4 || "heatmap" === t4, l3 = "datetime" !== i2.xaxis.type && "numeric" !== i2.xaxis.type, h3 = i2.xaxis.tickPlacement ? i2.xaxis.tickPlacement : e3.xaxis && e3.xaxis.tickPlacement;
      return o3 || n3 || !l3 || "between" === h3 || (i2 = r2.convertCatToNumeric(i2)), i2;
    } }, { key: "extendYAxis", value: function(t4, e3) {
      var i2 = new I2();
      (void 0 === t4.yaxis || !t4.yaxis || Array.isArray(t4.yaxis) && 0 === t4.yaxis.length) && (t4.yaxis = {}), t4.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array && (t4.yaxis = x2.extend(t4.yaxis, window.Apex.yaxis)), t4.yaxis.constructor !== Array ? t4.yaxis = [x2.extend(i2.yAxis, t4.yaxis)] : t4.yaxis = x2.extendArray(t4.yaxis, i2.yAxis);
      var a3 = false;
      t4.yaxis.forEach(function(t5) {
        t5.logarithmic && (a3 = true);
      });
      var s3 = t4.series;
      return e3 && !s3 && (s3 = e3.config.series), a3 && s3.length !== t4.yaxis.length && s3.length && (t4.yaxis = s3.map(function(e4, a4) {
        if (e4.name || (s3[a4].name = "series-".concat(a4 + 1)), t4.yaxis[a4]) return t4.yaxis[a4].seriesName = s3[a4].name, t4.yaxis[a4];
        var r2 = x2.extend(i2.yAxis, t4.yaxis[0]);
        return r2.show = false, r2;
      })), a3 && s3.length > 1 && s3.length !== t4.yaxis.length && console.warn("A multi-series logarithmic chart should have equal number of series and y-axes"), t4;
    } }, { key: "extendAnnotations", value: function(t4) {
      return void 0 === t4.annotations && (t4.annotations = {}, t4.annotations.yaxis = [], t4.annotations.xaxis = [], t4.annotations.points = []), t4 = this.extendYAxisAnnotations(t4), t4 = this.extendXAxisAnnotations(t4), t4 = this.extendPointAnnotations(t4);
    } }, { key: "extendYAxisAnnotations", value: function(t4) {
      var e3 = new I2();
      return t4.annotations.yaxis = x2.extendArray(void 0 !== t4.annotations.yaxis ? t4.annotations.yaxis : [], e3.yAxisAnnotation), t4;
    } }, { key: "extendXAxisAnnotations", value: function(t4) {
      var e3 = new I2();
      return t4.annotations.xaxis = x2.extendArray(void 0 !== t4.annotations.xaxis ? t4.annotations.xaxis : [], e3.xAxisAnnotation), t4;
    } }, { key: "extendPointAnnotations", value: function(t4) {
      var e3 = new I2();
      return t4.annotations.points = x2.extendArray(void 0 !== t4.annotations.points ? t4.annotations.points : [], e3.pointAnnotation), t4;
    } }, { key: "checkForDarkTheme", value: function(t4) {
      t4.theme && "dark" === t4.theme.mode && (t4.tooltip || (t4.tooltip = {}), "light" !== t4.tooltip.theme && (t4.tooltip.theme = "dark"), t4.chart.foreColor || (t4.chart.foreColor = "#f6f7f8"), t4.chart.background || (t4.chart.background = "#424242"), t4.theme.palette || (t4.theme.palette = "palette4"));
    } }, { key: "handleUserInputErrors", value: function(t4) {
      var e3 = t4;
      if (e3.tooltip.shared && e3.tooltip.intersect) throw new Error("tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.");
      if ("bar" === e3.chart.type && e3.plotOptions.bar.horizontal) {
        if (e3.yaxis.length > 1) throw new Error("Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false");
        e3.yaxis[0].reversed && (e3.yaxis[0].opposite = true), e3.xaxis.tooltip.enabled = false, e3.yaxis[0].tooltip.enabled = false, e3.chart.zoom.enabled = false;
      }
      return "bar" !== e3.chart.type && "rangeBar" !== e3.chart.type || e3.tooltip.shared && "barWidth" === e3.xaxis.crosshairs.width && e3.series.length > 1 && (e3.xaxis.crosshairs.width = "tickWidth"), "candlestick" !== e3.chart.type && "boxPlot" !== e3.chart.type || e3.yaxis[0].reversed && (console.warn("Reversed y-axis in ".concat(e3.chart.type, " chart is not supported.")), e3.yaxis[0].reversed = false), e3;
    } }]), t3;
  }(), F2 = function() {
    function t3() {
      a2(this, t3);
    }
    return r(t3, [{ key: "initGlobalVars", value: function(t4) {
      t4.series = [], t4.seriesCandleO = [], t4.seriesCandleH = [], t4.seriesCandleM = [], t4.seriesCandleL = [], t4.seriesCandleC = [], t4.seriesRangeStart = [], t4.seriesRangeEnd = [], t4.seriesRange = [], t4.seriesPercent = [], t4.seriesGoals = [], t4.seriesX = [], t4.seriesZ = [], t4.seriesNames = [], t4.seriesTotals = [], t4.seriesLog = [], t4.seriesColors = [], t4.stackedSeriesTotals = [], t4.seriesXvalues = [], t4.seriesYvalues = [], t4.labels = [], t4.hasXaxisGroups = false, t4.groups = [], t4.barGroups = [], t4.lineGroups = [], t4.areaGroups = [], t4.hasSeriesGroups = false, t4.seriesGroups = [], t4.categoryLabels = [], t4.timescaleLabels = [], t4.noLabelsProvided = false, t4.resizeTimer = null, t4.selectionResizeTimer = null, t4.delayedElements = [], t4.pointsArray = [], t4.dataLabelsRects = [], t4.isXNumeric = false, t4.skipLastTimelinelabel = false, t4.skipFirstTimelinelabel = false, t4.isDataXYZ = false, t4.isMultiLineX = false, t4.isMultipleYAxis = false, t4.maxY = -Number.MAX_VALUE, t4.minY = Number.MIN_VALUE, t4.minYArr = [], t4.maxYArr = [], t4.maxX = -Number.MAX_VALUE, t4.minX = Number.MAX_VALUE, t4.initialMaxX = -Number.MAX_VALUE, t4.initialMinX = Number.MAX_VALUE, t4.maxDate = 0, t4.minDate = Number.MAX_VALUE, t4.minZ = Number.MAX_VALUE, t4.maxZ = -Number.MAX_VALUE, t4.minXDiff = Number.MAX_VALUE, t4.yAxisScale = [], t4.xAxisScale = null, t4.xAxisTicksPositions = [], t4.yLabelsCoords = [], t4.yTitleCoords = [], t4.barPadForNumericAxis = 0, t4.padHorizontal = 0, t4.xRange = 0, t4.yRange = [], t4.zRange = 0, t4.dataPoints = 0, t4.xTickAmount = 0, t4.multiAxisTickAmount = 0;
    } }, { key: "globalVars", value: function(t4) {
      return { chartID: null, cuid: null, events: { beforeMount: [], mounted: [], updated: [], clicked: [], selection: [], dataPointSelection: [], zoomed: [], scrolled: [] }, colors: [], clientX: null, clientY: null, fill: { colors: [] }, stroke: { colors: [] }, dataLabels: { style: { colors: [] } }, radarPolygons: { fill: { colors: [] } }, markers: { colors: [], size: t4.markers.size, largestSize: 0 }, animationEnded: false, isTouchDevice: "ontouchstart" in window || navigator.msMaxTouchPoints, isDirty: false, isExecCalled: false, initialConfig: null, initialSeries: [], lastXAxis: [], lastYAxis: [], columnSeries: null, labels: [], timescaleLabels: [], noLabelsProvided: false, allSeriesCollapsed: false, collapsedSeries: [], collapsedSeriesIndices: [], ancillaryCollapsedSeries: [], ancillaryCollapsedSeriesIndices: [], risingSeries: [], dataFormatXNumeric: false, capturedSeriesIndex: -1, capturedDataPointIndex: -1, selectedDataPoints: [], goldenPadding: 35, invalidLogScale: false, ignoreYAxisIndexes: [], maxValsInArrayIndex: 0, radialSize: 0, selection: void 0, zoomEnabled: "zoom" === t4.chart.toolbar.autoSelected && t4.chart.toolbar.tools.zoom && t4.chart.zoom.enabled, panEnabled: "pan" === t4.chart.toolbar.autoSelected && t4.chart.toolbar.tools.pan, selectionEnabled: "selection" === t4.chart.toolbar.autoSelected && t4.chart.toolbar.tools.selection, yaxis: null, mousedown: false, lastClientPosition: {}, visibleXRange: void 0, yValueDecimal: 0, total: 0, SVGNS: "http://www.w3.org/2000/svg", svgWidth: 0, svgHeight: 0, noData: false, locale: {}, dom: {}, memory: { methodsToExec: [] }, shouldAnimate: true, skipLastTimelinelabel: false, skipFirstTimelinelabel: false, delayedElements: [], axisCharts: true, isDataXYZ: false, isSlopeChart: t4.plotOptions.line.isSlopeChart, resized: false, resizeTimer: null, comboCharts: false, dataChanged: false, previousPaths: [], allSeriesHasEqualX: true, pointsArray: [], dataLabelsRects: [], lastDrawnDataLabelsIndexes: [], hasNullValues: false, easing: null, zoomed: false, gridWidth: 0, gridHeight: 0, rotateXLabels: false, defaultLabels: false, xLabelFormatter: void 0, yLabelFormatters: [], xaxisTooltipFormatter: void 0, ttKeyFormatter: void 0, ttVal: void 0, ttZFormatter: void 0, LINE_HEIGHT_RATIO: 1.618, xAxisLabelsHeight: 0, xAxisGroupLabelsHeight: 0, xAxisLabelsWidth: 0, yAxisLabelsWidth: 0, scaleX: 1, scaleY: 1, translateX: 0, translateY: 0, translateYAxisX: [], yAxisWidths: [], translateXAxisY: 0, translateXAxisX: 0, tooltip: null, niceScaleAllowedMagMsd: [[1, 1, 2, 5, 5, 5, 10, 10, 10, 10, 10], [1, 1, 2, 5, 5, 5, 10, 10, 10, 10, 10]], niceScaleDefaultTicks: [1, 2, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 12, 12, 12, 12, 12, 12, 12, 12, 12, 24], seriesYAxisMap: [], seriesYAxisReverseMap: [] };
    } }, { key: "init", value: function(t4) {
      var e3 = this.globalVars(t4);
      return this.initGlobalVars(e3), e3.initialConfig = x2.extend({}, t4), e3.initialSeries = x2.clone(t4.series), e3.lastXAxis = x2.clone(e3.initialConfig.xaxis), e3.lastYAxis = x2.clone(e3.initialConfig.yaxis), e3;
    } }]), t3;
  }(), R2 = function() {
    function t3(e3) {
      a2(this, t3), this.opts = e3;
    }
    return r(t3, [{ key: "init", value: function() {
      var t4 = new Y2(this.opts).init({ responsiveOverride: false });
      return { config: t4, globals: new F2().init(t4) };
    } }]), t3;
  }(), H4 = function() {
    function t3(e3) {
      a2(this, t3), this.ctx = e3, this.w = e3.w, this.opts = null, this.seriesIndex = 0;
    }
    return r(t3, [{ key: "clippedImgArea", value: function(t4) {
      var e3 = this.w, i2 = e3.config, a3 = parseInt(e3.globals.gridWidth, 10), s3 = parseInt(e3.globals.gridHeight, 10), r2 = a3 > s3 ? a3 : s3, o3 = t4.image, n3 = 0, l3 = 0;
      void 0 === t4.width && void 0 === t4.height ? void 0 !== i2.fill.image.width && void 0 !== i2.fill.image.height ? (n3 = i2.fill.image.width + 1, l3 = i2.fill.image.height) : (n3 = r2 + 1, l3 = r2) : (n3 = t4.width, l3 = t4.height);
      var h3 = document.createElementNS(e3.globals.SVGNS, "pattern");
      m2.setAttrs(h3, { id: t4.patternID, patternUnits: t4.patternUnits ? t4.patternUnits : "userSpaceOnUse", width: n3 + "px", height: l3 + "px" });
      var c3 = document.createElementNS(e3.globals.SVGNS, "image");
      h3.appendChild(c3), c3.setAttributeNS(window.SVG.xlink, "href", o3), m2.setAttrs(c3, { x: 0, y: 0, preserveAspectRatio: "none", width: n3 + "px", height: l3 + "px" }), c3.style.opacity = t4.opacity, e3.globals.dom.elDefs.node.appendChild(h3);
    } }, { key: "getSeriesIndex", value: function(t4) {
      var e3 = this.w, i2 = e3.config.chart.type;
      return ("bar" === i2 || "rangeBar" === i2) && e3.config.plotOptions.bar.distributed || "heatmap" === i2 || "treemap" === i2 ? this.seriesIndex = t4.seriesNumber : this.seriesIndex = t4.seriesNumber % e3.globals.series.length, this.seriesIndex;
    } }, { key: "fillPath", value: function(t4) {
      var e3 = this.w;
      this.opts = t4;
      var i2, a3, s3, r2 = this.w.config;
      this.seriesIndex = this.getSeriesIndex(t4);
      var o3 = this.getFillColors()[this.seriesIndex];
      void 0 !== e3.globals.seriesColors[this.seriesIndex] && (o3 = e3.globals.seriesColors[this.seriesIndex]), "function" == typeof o3 && (o3 = o3({ seriesIndex: this.seriesIndex, dataPointIndex: t4.dataPointIndex, value: t4.value, w: e3 }));
      var n3 = t4.fillType ? t4.fillType : this.getFillType(this.seriesIndex), l3 = Array.isArray(r2.fill.opacity) ? r2.fill.opacity[this.seriesIndex] : r2.fill.opacity;
      t4.color && (o3 = t4.color), o3 || (o3 = "#fff", console.warn("undefined color - ApexCharts"));
      var h3 = o3;
      if (-1 === o3.indexOf("rgb") ? o3.length < 9 && (h3 = x2.hexToRgba(o3, l3)) : o3.indexOf("rgba") > -1 && (l3 = x2.getOpacityFromRGBA(o3)), t4.opacity && (l3 = t4.opacity), "pattern" === n3 && (a3 = this.handlePatternFill({ fillConfig: t4.fillConfig, patternFill: a3, fillColor: o3, fillOpacity: l3, defaultColor: h3 })), "gradient" === n3 && (s3 = this.handleGradientFill({ fillConfig: t4.fillConfig, fillColor: o3, fillOpacity: l3, i: this.seriesIndex })), "image" === n3) {
        var c3 = r2.fill.image.src, d3 = t4.patternID ? t4.patternID : "";
        this.clippedImgArea({ opacity: l3, image: Array.isArray(c3) ? t4.seriesNumber < c3.length ? c3[t4.seriesNumber] : c3[0] : c3, width: t4.width ? t4.width : void 0, height: t4.height ? t4.height : void 0, patternUnits: t4.patternUnits, patternID: "pattern".concat(e3.globals.cuid).concat(t4.seriesNumber + 1).concat(d3) }), i2 = "url(#pattern".concat(e3.globals.cuid).concat(t4.seriesNumber + 1).concat(d3, ")");
      } else i2 = "gradient" === n3 ? s3 : "pattern" === n3 ? a3 : h3;
      return t4.solid && (i2 = h3), i2;
    } }, { key: "getFillType", value: function(t4) {
      var e3 = this.w;
      return Array.isArray(e3.config.fill.type) ? e3.config.fill.type[t4] : e3.config.fill.type;
    } }, { key: "getFillColors", value: function() {
      var t4 = this.w, e3 = t4.config, i2 = this.opts, a3 = [];
      return t4.globals.comboCharts ? "line" === t4.config.series[this.seriesIndex].type ? Array.isArray(t4.globals.stroke.colors) ? a3 = t4.globals.stroke.colors : a3.push(t4.globals.stroke.colors) : Array.isArray(t4.globals.fill.colors) ? a3 = t4.globals.fill.colors : a3.push(t4.globals.fill.colors) : "line" === e3.chart.type ? Array.isArray(t4.globals.stroke.colors) ? a3 = t4.globals.stroke.colors : a3.push(t4.globals.stroke.colors) : Array.isArray(t4.globals.fill.colors) ? a3 = t4.globals.fill.colors : a3.push(t4.globals.fill.colors), void 0 !== i2.fillColors && (a3 = [], Array.isArray(i2.fillColors) ? a3 = i2.fillColors.slice() : a3.push(i2.fillColors)), a3;
    } }, { key: "handlePatternFill", value: function(t4) {
      var e3 = t4.fillConfig, i2 = t4.patternFill, a3 = t4.fillColor, s3 = t4.fillOpacity, r2 = t4.defaultColor, o3 = this.w.config.fill;
      e3 && (o3 = e3);
      var n3 = this.opts, l3 = new m2(this.ctx), h3 = Array.isArray(o3.pattern.strokeWidth) ? o3.pattern.strokeWidth[this.seriesIndex] : o3.pattern.strokeWidth, c3 = a3;
      Array.isArray(o3.pattern.style) ? i2 = void 0 !== o3.pattern.style[n3.seriesNumber] ? l3.drawPattern(o3.pattern.style[n3.seriesNumber], o3.pattern.width, o3.pattern.height, c3, h3, s3) : r2 : i2 = l3.drawPattern(o3.pattern.style, o3.pattern.width, o3.pattern.height, c3, h3, s3);
      return i2;
    } }, { key: "handleGradientFill", value: function(t4) {
      var i2 = t4.fillColor, a3 = t4.fillOpacity, s3 = t4.fillConfig, r2 = t4.i, o3 = this.w.config.fill;
      s3 && (o3 = e2(e2({}, o3), s3));
      var n3, l3 = this.opts, h3 = new m2(this.ctx), c3 = new x2(), d3 = o3.gradient.type, g3 = i2, u3 = void 0 === o3.gradient.opacityFrom ? a3 : Array.isArray(o3.gradient.opacityFrom) ? o3.gradient.opacityFrom[r2] : o3.gradient.opacityFrom;
      g3.indexOf("rgba") > -1 && (u3 = x2.getOpacityFromRGBA(g3));
      var p3 = void 0 === o3.gradient.opacityTo ? a3 : Array.isArray(o3.gradient.opacityTo) ? o3.gradient.opacityTo[r2] : o3.gradient.opacityTo;
      if (void 0 === o3.gradient.gradientToColors || 0 === o3.gradient.gradientToColors.length) n3 = "dark" === o3.gradient.shade ? c3.shadeColor(-1 * parseFloat(o3.gradient.shadeIntensity), i2.indexOf("rgb") > -1 ? x2.rgb2hex(i2) : i2) : c3.shadeColor(parseFloat(o3.gradient.shadeIntensity), i2.indexOf("rgb") > -1 ? x2.rgb2hex(i2) : i2);
      else if (o3.gradient.gradientToColors[l3.seriesNumber]) {
        var f3 = o3.gradient.gradientToColors[l3.seriesNumber];
        n3 = f3, f3.indexOf("rgba") > -1 && (p3 = x2.getOpacityFromRGBA(f3));
      } else n3 = i2;
      if (o3.gradient.gradientFrom && (g3 = o3.gradient.gradientFrom), o3.gradient.gradientTo && (n3 = o3.gradient.gradientTo), o3.gradient.inverseColors) {
        var b3 = g3;
        g3 = n3, n3 = b3;
      }
      return g3.indexOf("rgb") > -1 && (g3 = x2.rgb2hex(g3)), n3.indexOf("rgb") > -1 && (n3 = x2.rgb2hex(n3)), h3.drawGradient(d3, g3, n3, u3, p3, l3.size, o3.gradient.stops, o3.gradient.colorStops, r2);
    } }]), t3;
  }(), D2 = function() {
    function t3(e3, i2) {
      a2(this, t3), this.ctx = e3, this.w = e3.w;
    }
    return r(t3, [{ key: "setGlobalMarkerSize", value: function() {
      var t4 = this.w;
      if (t4.globals.markers.size = Array.isArray(t4.config.markers.size) ? t4.config.markers.size : [t4.config.markers.size], t4.globals.markers.size.length > 0) {
        if (t4.globals.markers.size.length < t4.globals.series.length + 1) for (var e3 = 0; e3 <= t4.globals.series.length; e3++) void 0 === t4.globals.markers.size[e3] && t4.globals.markers.size.push(t4.globals.markers.size[0]);
      } else t4.globals.markers.size = t4.config.series.map(function(e4) {
        return t4.config.markers.size;
      });
    } }, { key: "plotChartMarkers", value: function(t4, e3, i2, a3) {
      var s3, r2 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], o3 = this.w, n3 = e3, l3 = t4, h3 = null, c3 = new m2(this.ctx), d3 = o3.config.markers.discrete && o3.config.markers.discrete.length;
      if ((o3.globals.markers.size[e3] > 0 || r2 || d3) && (h3 = c3.group({ class: r2 || d3 ? "" : "apexcharts-series-markers" })).attr("clip-path", "url(#gridRectMarkerMask".concat(o3.globals.cuid, ")")), Array.isArray(l3.x)) for (var g3 = 0; g3 < l3.x.length; g3++) {
        var u3 = i2;
        1 === i2 && 0 === g3 && (u3 = 0), 1 === i2 && 1 === g3 && (u3 = 1);
        var p3 = "apexcharts-marker";
        if ("line" !== o3.config.chart.type && "area" !== o3.config.chart.type || o3.globals.comboCharts || o3.config.tooltip.intersect || (p3 += " no-pointer-events"), (Array.isArray(o3.config.markers.size) ? o3.globals.markers.size[e3] > 0 : o3.config.markers.size > 0) || r2 || d3) {
          x2.isNumber(l3.y[g3]) ? p3 += " w".concat(x2.randomId()) : p3 = "apexcharts-nullpoint";
          var f3 = this.getMarkerConfig({ cssClass: p3, seriesIndex: e3, dataPointIndex: u3 });
          o3.config.series[n3].data[u3] && (o3.config.series[n3].data[u3].fillColor && (f3.pointFillColor = o3.config.series[n3].data[u3].fillColor), o3.config.series[n3].data[u3].strokeColor && (f3.pointStrokeColor = o3.config.series[n3].data[u3].strokeColor)), a3 && (f3.pSize = a3), (l3.x[g3] < -o3.globals.markers.largestSize || l3.x[g3] > o3.globals.gridWidth + o3.globals.markers.largestSize || l3.y[g3] < -o3.globals.markers.largestSize || l3.y[g3] > o3.globals.gridHeight + o3.globals.markers.largestSize) && (f3.pSize = 0), (s3 = c3.drawMarker(l3.x[g3], l3.y[g3], f3)).attr("rel", u3), s3.attr("j", u3), s3.attr("index", e3), s3.node.setAttribute("default-marker-size", f3.pSize), new v2(this.ctx).setSelectionFilter(s3, e3, u3), this.addEvents(s3), h3 && h3.add(s3);
        } else void 0 === o3.globals.pointsArray[e3] && (o3.globals.pointsArray[e3] = []), o3.globals.pointsArray[e3].push([l3.x[g3], l3.y[g3]]);
      }
      return h3;
    } }, { key: "getMarkerConfig", value: function(t4) {
      var e3 = t4.cssClass, i2 = t4.seriesIndex, a3 = t4.dataPointIndex, s3 = void 0 === a3 ? null : a3, r2 = t4.finishRadius, o3 = void 0 === r2 ? null : r2, n3 = this.w, l3 = this.getMarkerStyle(i2), h3 = n3.globals.markers.size[i2], c3 = n3.config.markers;
      return null !== s3 && c3.discrete.length && c3.discrete.map(function(t5) {
        t5.seriesIndex === i2 && t5.dataPointIndex === s3 && (l3.pointStrokeColor = t5.strokeColor, l3.pointFillColor = t5.fillColor, h3 = t5.size, l3.pointShape = t5.shape);
      }), { pSize: null === o3 ? h3 : o3, pRadius: c3.radius, width: Array.isArray(c3.width) ? c3.width[i2] : c3.width, height: Array.isArray(c3.height) ? c3.height[i2] : c3.height, pointStrokeWidth: Array.isArray(c3.strokeWidth) ? c3.strokeWidth[i2] : c3.strokeWidth, pointStrokeColor: l3.pointStrokeColor, pointFillColor: l3.pointFillColor, shape: l3.pointShape || (Array.isArray(c3.shape) ? c3.shape[i2] : c3.shape), class: e3, pointStrokeOpacity: Array.isArray(c3.strokeOpacity) ? c3.strokeOpacity[i2] : c3.strokeOpacity, pointStrokeDashArray: Array.isArray(c3.strokeDashArray) ? c3.strokeDashArray[i2] : c3.strokeDashArray, pointFillOpacity: Array.isArray(c3.fillOpacity) ? c3.fillOpacity[i2] : c3.fillOpacity, seriesIndex: i2 };
    } }, { key: "addEvents", value: function(t4) {
      var e3 = this.w, i2 = new m2(this.ctx);
      t4.node.addEventListener("mouseenter", i2.pathMouseEnter.bind(this.ctx, t4)), t4.node.addEventListener("mouseleave", i2.pathMouseLeave.bind(this.ctx, t4)), t4.node.addEventListener("mousedown", i2.pathMouseDown.bind(this.ctx, t4)), t4.node.addEventListener("click", e3.config.markers.onClick), t4.node.addEventListener("dblclick", e3.config.markers.onDblClick), t4.node.addEventListener("touchstart", i2.pathMouseDown.bind(this.ctx, t4), { passive: true });
    } }, { key: "getMarkerStyle", value: function(t4) {
      var e3 = this.w, i2 = e3.globals.markers.colors, a3 = e3.config.markers.strokeColor || e3.config.markers.strokeColors;
      return { pointStrokeColor: Array.isArray(a3) ? a3[t4] : a3, pointFillColor: Array.isArray(i2) ? i2[t4] : i2 };
    } }]), t3;
  }(), O2 = function() {
    function t3(e3) {
      a2(this, t3), this.ctx = e3, this.w = e3.w, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled;
    }
    return r(t3, [{ key: "draw", value: function(t4, e3, i2) {
      var a3 = this.w, s3 = new m2(this.ctx), r2 = i2.realIndex, o3 = i2.pointsPos, n3 = i2.zRatio, l3 = i2.elParent, h3 = s3.group({ class: "apexcharts-series-markers apexcharts-series-".concat(a3.config.chart.type) });
      if (h3.attr("clip-path", "url(#gridRectMarkerMask".concat(a3.globals.cuid, ")")), Array.isArray(o3.x)) for (var c3 = 0; c3 < o3.x.length; c3++) {
        var d3 = e3 + 1, g3 = true;
        0 === e3 && 0 === c3 && (d3 = 0), 0 === e3 && 1 === c3 && (d3 = 1);
        var u3 = 0, p3 = a3.globals.markers.size[r2];
        if (n3 !== 1 / 0) {
          var f3 = a3.config.plotOptions.bubble;
          p3 = a3.globals.seriesZ[r2][d3], f3.zScaling && (p3 /= n3), f3.minBubbleRadius && p3 < f3.minBubbleRadius && (p3 = f3.minBubbleRadius), f3.maxBubbleRadius && p3 > f3.maxBubbleRadius && (p3 = f3.maxBubbleRadius);
        }
        a3.config.chart.animations.enabled || (u3 = p3);
        var x3 = o3.x[c3], b3 = o3.y[c3];
        if (u3 = u3 || 0, null !== b3 && void 0 !== a3.globals.series[r2][d3] || (g3 = false), g3) {
          var v3 = this.drawPoint(x3, b3, u3, p3, r2, d3, e3);
          h3.add(v3);
        }
        l3.add(h3);
      }
    } }, { key: "drawPoint", value: function(t4, e3, i2, a3, s3, r2, o3) {
      var n3 = this.w, l3 = s3, h3 = new b2(this.ctx), c3 = new v2(this.ctx), d3 = new H4(this.ctx), g3 = new D2(this.ctx), u3 = new m2(this.ctx), p3 = g3.getMarkerConfig({ cssClass: "apexcharts-marker", seriesIndex: l3, dataPointIndex: r2, finishRadius: "bubble" === n3.config.chart.type || n3.globals.comboCharts && n3.config.series[s3] && "bubble" === n3.config.series[s3].type ? a3 : null });
      a3 = p3.pSize;
      var f3, x3 = d3.fillPath({ seriesNumber: s3, dataPointIndex: r2, color: p3.pointFillColor, patternUnits: "objectBoundingBox", value: n3.globals.series[s3][o3] });
      if ("circle" === p3.shape ? f3 = u3.drawCircle(i2) : "square" !== p3.shape && "rect" !== p3.shape || (f3 = u3.drawRect(0, 0, p3.width - p3.pointStrokeWidth / 2, p3.height - p3.pointStrokeWidth / 2, p3.pRadius)), n3.config.series[l3].data[r2] && n3.config.series[l3].data[r2].fillColor && (x3 = n3.config.series[l3].data[r2].fillColor), f3.attr({ x: t4 - p3.width / 2 - p3.pointStrokeWidth / 2, y: e3 - p3.height / 2 - p3.pointStrokeWidth / 2, cx: t4, cy: e3, fill: x3, "fill-opacity": p3.pointFillOpacity, stroke: p3.pointStrokeColor, r: a3, "stroke-width": p3.pointStrokeWidth, "stroke-dasharray": p3.pointStrokeDashArray, "stroke-opacity": p3.pointStrokeOpacity }), n3.config.chart.dropShadow.enabled) {
        var y3 = n3.config.chart.dropShadow;
        c3.dropShadow(f3, y3, s3);
      }
      if (!this.initialAnim || n3.globals.dataChanged || n3.globals.resized) n3.globals.animationEnded = true;
      else {
        var w3 = n3.config.chart.animations.speed;
        h3.animateMarker(f3, 0, "circle" === p3.shape ? a3 : { width: p3.width, height: p3.height }, w3, n3.globals.easing, function() {
          window.setTimeout(function() {
            h3.animationCompleted(f3);
          }, 100);
        });
      }
      if (n3.globals.dataChanged && "circle" === p3.shape) if (this.dynamicAnim) {
        var k3, A3, S3, C3, L3 = n3.config.chart.animations.dynamicAnimation.speed;
        null != (C3 = n3.globals.previousPaths[s3] && n3.globals.previousPaths[s3][o3]) && (k3 = C3.x, A3 = C3.y, S3 = void 0 !== C3.r ? C3.r : a3);
        for (var P3 = 0; P3 < n3.globals.collapsedSeries.length; P3++) n3.globals.collapsedSeries[P3].index === s3 && (L3 = 1, a3 = 0);
        0 === t4 && 0 === e3 && (a3 = 0), h3.animateCircle(f3, { cx: k3, cy: A3, r: S3 }, { cx: t4, cy: e3, r: a3 }, L3, n3.globals.easing);
      } else f3.attr({ r: a3 });
      return f3.attr({ rel: r2, j: r2, index: s3, "default-marker-size": a3 }), c3.setSelectionFilter(f3, s3, r2), g3.addEvents(f3), f3.node.classList.add("apexcharts-marker"), f3;
    } }, { key: "centerTextInBubble", value: function(t4) {
      var e3 = this.w;
      return { y: t4 += parseInt(e3.config.dataLabels.style.fontSize, 10) / 4 };
    } }]), t3;
  }(), N2 = function() {
    function t3(e3) {
      a2(this, t3), this.ctx = e3, this.w = e3.w;
    }
    return r(t3, [{ key: "dataLabelsCorrection", value: function(t4, e3, i2, a3, s3, r2, o3) {
      var n3 = this.w, l3 = false, h3 = new m2(this.ctx).getTextRects(i2, o3), c3 = h3.width, d3 = h3.height;
      e3 < 0 && (e3 = 0), e3 > n3.globals.gridHeight + d3 && (e3 = n3.globals.gridHeight + d3 / 2), void 0 === n3.globals.dataLabelsRects[a3] && (n3.globals.dataLabelsRects[a3] = []), n3.globals.dataLabelsRects[a3].push({ x: t4, y: e3, width: c3, height: d3 });
      var g3 = n3.globals.dataLabelsRects[a3].length - 2, u3 = void 0 !== n3.globals.lastDrawnDataLabelsIndexes[a3] ? n3.globals.lastDrawnDataLabelsIndexes[a3][n3.globals.lastDrawnDataLabelsIndexes[a3].length - 1] : 0;
      if (void 0 !== n3.globals.dataLabelsRects[a3][g3]) {
        var p3 = n3.globals.dataLabelsRects[a3][u3];
        (t4 > p3.x + p3.width || e3 > p3.y + p3.height || e3 + d3 < p3.y || t4 + c3 < p3.x) && (l3 = true);
      }
      return (0 === s3 || r2) && (l3 = true), { x: t4, y: e3, textRects: h3, drawnextLabel: l3 };
    } }, { key: "drawDataLabel", value: function(t4) {
      var e3 = this, i2 = t4.type, a3 = t4.pos, s3 = t4.i, r2 = t4.j, o3 = t4.isRangeStart, n3 = t4.strokeWidth, l3 = void 0 === n3 ? 2 : n3, h3 = this.w, c3 = new m2(this.ctx), d3 = h3.config.dataLabels, g3 = 0, u3 = 0, p3 = r2, f3 = null;
      if (-1 !== h3.globals.collapsedSeriesIndices.indexOf(s3) || !d3.enabled || !Array.isArray(a3.x)) return f3;
      f3 = c3.group({ class: "apexcharts-data-labels" });
      for (var x3 = 0; x3 < a3.x.length; x3++) if (g3 = a3.x[x3] + d3.offsetX, u3 = a3.y[x3] + d3.offsetY + l3, !isNaN(g3)) {
        1 === r2 && 0 === x3 && (p3 = 0), 1 === r2 && 1 === x3 && (p3 = 1);
        var b3 = h3.globals.series[s3][p3];
        "rangeArea" === i2 && (b3 = o3 ? h3.globals.seriesRangeStart[s3][p3] : h3.globals.seriesRangeEnd[s3][p3]);
        var v3 = "", y3 = function(t5) {
          return h3.config.dataLabels.formatter(t5, { ctx: e3.ctx, seriesIndex: s3, dataPointIndex: p3, w: h3 });
        };
        if ("bubble" === h3.config.chart.type) v3 = y3(b3 = h3.globals.seriesZ[s3][p3]), u3 = a3.y[x3], u3 = new O2(this.ctx).centerTextInBubble(u3, s3, p3).y;
        else void 0 !== b3 && (v3 = y3(b3));
        var w3 = h3.config.dataLabels.textAnchor;
        h3.globals.isSlopeChart && (w3 = 0 === p3 ? "end" : p3 === h3.config.series[s3].data.length - 1 ? "start" : "middle"), this.plotDataLabelsText({ x: g3, y: u3, text: v3, i: s3, j: p3, parent: f3, offsetCorrection: true, dataLabelsConfig: h3.config.dataLabels, textAnchor: w3 });
      }
      return f3;
    } }, { key: "plotDataLabelsText", value: function(t4) {
      var e3 = this.w, i2 = new m2(this.ctx), a3 = t4.x, s3 = t4.y, r2 = t4.i, o3 = t4.j, n3 = t4.text, l3 = t4.textAnchor, h3 = t4.fontSize, c3 = t4.parent, d3 = t4.dataLabelsConfig, g3 = t4.color, u3 = t4.alwaysDrawDataLabel, p3 = t4.offsetCorrection, f3 = t4.className, x3 = null;
      if (Array.isArray(e3.config.dataLabels.enabledOnSeries) && e3.config.dataLabels.enabledOnSeries.indexOf(r2) < 0) return x3;
      var b3 = { x: a3, y: s3, drawnextLabel: true, textRects: null };
      p3 && (b3 = this.dataLabelsCorrection(a3, s3, n3, r2, o3, u3, parseInt(d3.style.fontSize, 10))), e3.globals.zoomed || (a3 = b3.x, s3 = b3.y), b3.textRects && (a3 < -20 - b3.textRects.width || a3 > e3.globals.gridWidth + b3.textRects.width + 30) && (n3 = "");
      var y3 = e3.globals.dataLabels.style.colors[r2];
      (("bar" === e3.config.chart.type || "rangeBar" === e3.config.chart.type) && e3.config.plotOptions.bar.distributed || e3.config.dataLabels.distributed) && (y3 = e3.globals.dataLabels.style.colors[o3]), "function" == typeof y3 && (y3 = y3({ series: e3.globals.series, seriesIndex: r2, dataPointIndex: o3, w: e3 })), g3 && (y3 = g3);
      var w3 = d3.offsetX, k3 = d3.offsetY;
      if ("bar" !== e3.config.chart.type && "rangeBar" !== e3.config.chart.type || (w3 = 0, k3 = 0), e3.globals.isSlopeChart && (0 !== o3 && (w3 = -2 * d3.offsetX + 5), 0 !== o3 && o3 !== e3.config.series[r2].data.length - 1 && (w3 = 0)), b3.drawnextLabel) {
        if ((x3 = i2.drawText({ width: 100, height: parseInt(d3.style.fontSize, 10), x: a3 + w3, y: s3 + k3, foreColor: y3, textAnchor: l3 || d3.textAnchor, text: n3, fontSize: h3 || d3.style.fontSize, fontFamily: d3.style.fontFamily, fontWeight: d3.style.fontWeight || "normal" })).attr({ class: f3 || "apexcharts-datalabel", cx: a3, cy: s3 }), d3.dropShadow.enabled) {
          var A3 = d3.dropShadow;
          new v2(this.ctx).dropShadow(x3, A3);
        }
        c3.add(x3), void 0 === e3.globals.lastDrawnDataLabelsIndexes[r2] && (e3.globals.lastDrawnDataLabelsIndexes[r2] = []), e3.globals.lastDrawnDataLabelsIndexes[r2].push(o3);
      }
      return x3;
    } }, { key: "addBackgroundToDataLabel", value: function(t4, e3) {
      var i2 = this.w, a3 = i2.config.dataLabels.background, s3 = a3.padding, r2 = a3.padding / 2, o3 = e3.width, n3 = e3.height, l3 = new m2(this.ctx).drawRect(e3.x - s3, e3.y - r2 / 2, o3 + 2 * s3, n3 + r2, a3.borderRadius, "transparent" === i2.config.chart.background ? "#fff" : i2.config.chart.background, a3.opacity, a3.borderWidth, a3.borderColor);
      a3.dropShadow.enabled && new v2(this.ctx).dropShadow(l3, a3.dropShadow);
      return l3;
    } }, { key: "dataLabelsBackground", value: function() {
      var t4 = this.w;
      if ("bubble" !== t4.config.chart.type) for (var e3 = t4.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels text"), i2 = 0; i2 < e3.length; i2++) {
        var a3 = e3[i2], s3 = a3.getBBox(), r2 = null;
        if (s3.width && s3.height && (r2 = this.addBackgroundToDataLabel(a3, s3)), r2) {
          a3.parentNode.insertBefore(r2.node, a3);
          var o3 = a3.getAttribute("fill");
          t4.config.chart.animations.enabled && !t4.globals.resized && !t4.globals.dataChanged ? r2.animate().attr({ fill: o3 }) : r2.attr({ fill: o3 }), a3.setAttribute("fill", t4.config.dataLabels.background.foreColor);
        }
      }
    } }, { key: "bringForward", value: function() {
      for (var t4 = this.w, e3 = t4.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels"), i2 = t4.globals.dom.baseEl.querySelector(".apexcharts-plot-series:last-child"), a3 = 0; a3 < e3.length; a3++) i2 && i2.insertBefore(e3[a3], i2.nextSibling);
    } }]), t3;
  }(), W2 = function() {
    function t3(e3) {
      a2(this, t3), this.ctx = e3, this.w = e3.w, this.legendInactiveClass = "legend-mouseover-inactive";
    }
    return r(t3, [{ key: "getAllSeriesEls", value: function() {
      return this.w.globals.dom.baseEl.getElementsByClassName("apexcharts-series");
    } }, { key: "getSeriesByName", value: function(t4) {
      return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner .apexcharts-series[seriesName='".concat(x2.escapeString(t4), "']"));
    } }, { key: "isSeriesHidden", value: function(t4) {
      var e3 = this.getSeriesByName(t4), i2 = parseInt(e3.getAttribute("data:realIndex"), 10);
      return { isHidden: e3.classList.contains("apexcharts-series-collapsed"), realIndex: i2 };
    } }, { key: "addCollapsedClassToSeries", value: function(t4, e3) {
      var i2 = this.w;
      function a3(i3) {
        for (var a4 = 0; a4 < i3.length; a4++) i3[a4].index === e3 && t4.node.classList.add("apexcharts-series-collapsed");
      }
      a3(i2.globals.collapsedSeries), a3(i2.globals.ancillaryCollapsedSeries);
    } }, { key: "toggleSeries", value: function(t4) {
      var e3 = this.isSeriesHidden(t4);
      return this.ctx.legend.legendHelpers.toggleDataSeries(e3.realIndex, e3.isHidden), e3.isHidden;
    } }, { key: "showSeries", value: function(t4) {
      var e3 = this.isSeriesHidden(t4);
      e3.isHidden && this.ctx.legend.legendHelpers.toggleDataSeries(e3.realIndex, true);
    } }, { key: "hideSeries", value: function(t4) {
      var e3 = this.isSeriesHidden(t4);
      e3.isHidden || this.ctx.legend.legendHelpers.toggleDataSeries(e3.realIndex, false);
    } }, { key: "resetSeries", value: function() {
      var t4 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], e3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], a3 = this.w, s3 = x2.clone(a3.globals.initialSeries);
      a3.globals.previousPaths = [], i2 ? (a3.globals.collapsedSeries = [], a3.globals.ancillaryCollapsedSeries = [], a3.globals.collapsedSeriesIndices = [], a3.globals.ancillaryCollapsedSeriesIndices = []) : s3 = this.emptyCollapsedSeries(s3), a3.config.series = s3, t4 && (e3 && (a3.globals.zoomed = false, this.ctx.updateHelpers.revertDefaultAxisMinMax()), this.ctx.updateHelpers._updateSeries(s3, a3.config.chart.animations.dynamicAnimation.enabled));
    } }, { key: "emptyCollapsedSeries", value: function(t4) {
      for (var e3 = this.w, i2 = 0; i2 < t4.length; i2++) e3.globals.collapsedSeriesIndices.indexOf(i2) > -1 && (t4[i2].data = []);
      return t4;
    } }, { key: "toggleSeriesOnHover", value: function(t4, e3) {
      var i2 = this.w;
      e3 || (e3 = t4.target);
      var a3 = i2.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels, .apexcharts-yaxis");
      if ("mousemove" === t4.type) {
        var s3 = parseInt(e3.getAttribute("rel"), 10) - 1, r2 = null, o3 = null, n3 = null;
        if (i2.globals.axisCharts || "radialBar" === i2.config.chart.type) if (i2.globals.axisCharts) {
          r2 = i2.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(s3, "']")), o3 = i2.globals.dom.baseEl.querySelector(".apexcharts-datalabels[data\\:realIndex='".concat(s3, "']"));
          var l3 = i2.globals.seriesYAxisReverseMap[s3];
          n3 = i2.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(l3, "']"));
        } else r2 = i2.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(s3 + 1, "']"));
        else r2 = i2.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(s3 + 1, "'] path"));
        for (var h3 = 0; h3 < a3.length; h3++) a3[h3].classList.add(this.legendInactiveClass);
        null !== r2 && (i2.globals.axisCharts || r2.parentNode.classList.remove(this.legendInactiveClass), r2.classList.remove(this.legendInactiveClass), null !== o3 && o3.classList.remove(this.legendInactiveClass), null !== n3 && n3.classList.remove(this.legendInactiveClass));
      } else if ("mouseout" === t4.type) for (var c3 = 0; c3 < a3.length; c3++) a3[c3].classList.remove(this.legendInactiveClass);
    } }, { key: "highlightRangeInSeries", value: function(t4, e3) {
      var i2 = this, a3 = this.w, s3 = a3.globals.dom.baseEl.getElementsByClassName("apexcharts-heatmap-rect"), r2 = function(t5) {
        for (var e4 = 0; e4 < s3.length; e4++) s3[e4].classList[t5](i2.legendInactiveClass);
      };
      if ("mousemove" === t4.type) {
        var o3 = parseInt(e3.getAttribute("rel"), 10) - 1;
        r2("add"), function(t5) {
          for (var e4 = 0; e4 < s3.length; e4++) {
            var a4 = parseInt(s3[e4].getAttribute("val"), 10);
            a4 >= t5.from && a4 <= t5.to && s3[e4].classList.remove(i2.legendInactiveClass);
          }
        }(a3.config.plotOptions.heatmap.colorScale.ranges[o3]);
      } else "mouseout" === t4.type && r2("remove");
    } }, { key: "getActiveConfigSeriesIndex", value: function() {
      var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "asc", e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], i2 = this.w, a3 = 0;
      if (i2.config.series.length > 1) {
        for (var s3 = i2.config.series.map(function(t5, a4) {
          return t5.data && t5.data.length > 0 && -1 === i2.globals.collapsedSeriesIndices.indexOf(a4) && (!i2.globals.comboCharts || 0 === e3.length || e3.length && e3.indexOf(i2.config.series[a4].type) > -1) ? a4 : -1;
        }), r2 = "asc" === t4 ? 0 : s3.length - 1; "asc" === t4 ? r2 < s3.length : r2 >= 0; "asc" === t4 ? r2++ : r2--) if (-1 !== s3[r2]) {
          a3 = s3[r2];
          break;
        }
      }
      return a3;
    } }, { key: "getBarSeriesIndices", value: function() {
      return this.w.globals.comboCharts ? this.w.config.series.map(function(t4, e3) {
        return "bar" === t4.type || "column" === t4.type ? e3 : -1;
      }).filter(function(t4) {
        return -1 !== t4;
      }) : this.w.config.series.map(function(t4, e3) {
        return e3;
      });
    } }, { key: "getPreviousPaths", value: function() {
      var t4 = this.w;
      function e3(e4, i3, a4) {
        for (var s4 = e4[i3].childNodes, r2 = { type: a4, paths: [], realIndex: e4[i3].getAttribute("data:realIndex") }, o3 = 0; o3 < s4.length; o3++) if (s4[o3].hasAttribute("pathTo")) {
          var n3 = s4[o3].getAttribute("pathTo");
          r2.paths.push({ d: n3 });
        }
        t4.globals.previousPaths.push(r2);
      }
      t4.globals.previousPaths = [];
      ["line", "area", "bar", "rangebar", "rangeArea", "candlestick", "radar"].forEach(function(i3) {
        for (var a4, s4 = (a4 = i3, t4.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(a4, "-series .apexcharts-series"))), r2 = 0; r2 < s4.length; r2++) e3(s4, r2, i3);
      }), this.handlePrevBubbleScatterPaths("bubble"), this.handlePrevBubbleScatterPaths("scatter");
      var i2 = t4.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t4.config.chart.type, " .apexcharts-series"));
      if (i2.length > 0) for (var a3 = function(e4) {
        for (var i3 = t4.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t4.config.chart.type, " .apexcharts-series[data\\:realIndex='").concat(e4, "'] rect")), a4 = [], s4 = function(t5) {
          var e5 = function(e6) {
            return i3[t5].getAttribute(e6);
          }, s5 = { x: parseFloat(e5("x")), y: parseFloat(e5("y")), width: parseFloat(e5("width")), height: parseFloat(e5("height")) };
          a4.push({ rect: s5, color: i3[t5].getAttribute("color") });
        }, r2 = 0; r2 < i3.length; r2++) s4(r2);
        t4.globals.previousPaths.push(a4);
      }, s3 = 0; s3 < i2.length; s3++) a3(s3);
      t4.globals.axisCharts || (t4.globals.previousPaths = t4.globals.series);
    } }, { key: "handlePrevBubbleScatterPaths", value: function(t4) {
      var e3 = this.w, i2 = e3.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t4, "-series .apexcharts-series"));
      if (i2.length > 0) for (var a3 = 0; a3 < i2.length; a3++) {
        for (var s3 = e3.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t4, "-series .apexcharts-series[data\\:realIndex='").concat(a3, "'] circle")), r2 = [], o3 = 0; o3 < s3.length; o3++) r2.push({ x: s3[o3].getAttribute("cx"), y: s3[o3].getAttribute("cy"), r: s3[o3].getAttribute("r") });
        e3.globals.previousPaths.push(r2);
      }
    } }, { key: "clearPreviousPaths", value: function() {
      var t4 = this.w;
      t4.globals.previousPaths = [], t4.globals.allSeriesCollapsed = false;
    } }, { key: "handleNoData", value: function() {
      var t4 = this.w, e3 = t4.config.noData, i2 = new m2(this.ctx), a3 = t4.globals.svgWidth / 2, s3 = t4.globals.svgHeight / 2, r2 = "middle";
      if (t4.globals.noData = true, t4.globals.animationEnded = true, "left" === e3.align ? (a3 = 10, r2 = "start") : "right" === e3.align && (a3 = t4.globals.svgWidth - 10, r2 = "end"), "top" === e3.verticalAlign ? s3 = 50 : "bottom" === e3.verticalAlign && (s3 = t4.globals.svgHeight - 50), a3 += e3.offsetX, s3 = s3 + parseInt(e3.style.fontSize, 10) + 2 + e3.offsetY, void 0 !== e3.text && "" !== e3.text) {
        var o3 = i2.drawText({ x: a3, y: s3, text: e3.text, textAnchor: r2, fontSize: e3.style.fontSize, fontFamily: e3.style.fontFamily, foreColor: e3.style.color, opacity: 1, class: "apexcharts-text-nodata" });
        t4.globals.dom.Paper.add(o3);
      }
    } }, { key: "setNullSeriesToZeroValues", value: function(t4) {
      for (var e3 = this.w, i2 = 0; i2 < t4.length; i2++) if (0 === t4[i2].length) for (var a3 = 0; a3 < t4[e3.globals.maxValsInArrayIndex].length; a3++) t4[i2].push(0);
      return t4;
    } }, { key: "hasAllSeriesEqualX", value: function() {
      for (var t4 = true, e3 = this.w, i2 = this.filteredSeriesX(), a3 = 0; a3 < i2.length - 1; a3++) if (i2[a3][0] !== i2[a3 + 1][0]) {
        t4 = false;
        break;
      }
      return e3.globals.allSeriesHasEqualX = t4, t4;
    } }, { key: "filteredSeriesX", value: function() {
      var t4 = this.w.globals.seriesX.map(function(t5) {
        return t5.length > 0 ? t5 : [];
      });
      return t4;
    } }]), t3;
  }(), B3 = function() {
    function t3(e3) {
      a2(this, t3), this.ctx = e3, this.w = e3.w, this.twoDSeries = [], this.threeDSeries = [], this.twoDSeriesX = [], this.seriesGoals = [], this.coreUtils = new y2(this.ctx);
    }
    return r(t3, [{ key: "isMultiFormat", value: function() {
      return this.isFormatXY() || this.isFormat2DArray();
    } }, { key: "isFormatXY", value: function() {
      var t4 = this.w.config.series.slice(), e3 = new W2(this.ctx);
      if (this.activeSeriesIndex = e3.getActiveConfigSeriesIndex(), void 0 !== t4[this.activeSeriesIndex].data && t4[this.activeSeriesIndex].data.length > 0 && null !== t4[this.activeSeriesIndex].data[0] && void 0 !== t4[this.activeSeriesIndex].data[0].x && null !== t4[this.activeSeriesIndex].data[0]) return true;
    } }, { key: "isFormat2DArray", value: function() {
      var t4 = this.w.config.series.slice(), e3 = new W2(this.ctx);
      if (this.activeSeriesIndex = e3.getActiveConfigSeriesIndex(), void 0 !== t4[this.activeSeriesIndex].data && t4[this.activeSeriesIndex].data.length > 0 && void 0 !== t4[this.activeSeriesIndex].data[0] && null !== t4[this.activeSeriesIndex].data[0] && t4[this.activeSeriesIndex].data[0].constructor === Array) return true;
    } }, { key: "handleFormat2DArray", value: function(t4, e3) {
      for (var i2 = this.w.config, a3 = this.w.globals, s3 = "boxPlot" === i2.chart.type || "boxPlot" === i2.series[e3].type, r2 = 0; r2 < t4[e3].data.length; r2++) if (void 0 !== t4[e3].data[r2][1] && (Array.isArray(t4[e3].data[r2][1]) && 4 === t4[e3].data[r2][1].length && !s3 ? this.twoDSeries.push(x2.parseNumber(t4[e3].data[r2][1][3])) : t4[e3].data[r2].length >= 5 ? this.twoDSeries.push(x2.parseNumber(t4[e3].data[r2][4])) : this.twoDSeries.push(x2.parseNumber(t4[e3].data[r2][1])), a3.dataFormatXNumeric = true), "datetime" === i2.xaxis.type) {
        var o3 = new Date(t4[e3].data[r2][0]);
        o3 = new Date(o3).getTime(), this.twoDSeriesX.push(o3);
      } else this.twoDSeriesX.push(t4[e3].data[r2][0]);
      for (var n3 = 0; n3 < t4[e3].data.length; n3++) void 0 !== t4[e3].data[n3][2] && (this.threeDSeries.push(t4[e3].data[n3][2]), a3.isDataXYZ = true);
    } }, { key: "handleFormatXY", value: function(t4, e3) {
      var i2 = this.w.config, a3 = this.w.globals, s3 = new A2(this.ctx), r2 = e3;
      a3.collapsedSeriesIndices.indexOf(e3) > -1 && (r2 = this.activeSeriesIndex);
      for (var o3 = 0; o3 < t4[e3].data.length; o3++) void 0 !== t4[e3].data[o3].y && (Array.isArray(t4[e3].data[o3].y) ? this.twoDSeries.push(x2.parseNumber(t4[e3].data[o3].y[t4[e3].data[o3].y.length - 1])) : this.twoDSeries.push(x2.parseNumber(t4[e3].data[o3].y))), void 0 !== t4[e3].data[o3].goals && Array.isArray(t4[e3].data[o3].goals) ? (void 0 === this.seriesGoals[e3] && (this.seriesGoals[e3] = []), this.seriesGoals[e3].push(t4[e3].data[o3].goals)) : (void 0 === this.seriesGoals[e3] && (this.seriesGoals[e3] = []), this.seriesGoals[e3].push(null));
      for (var n3 = 0; n3 < t4[r2].data.length; n3++) {
        var l3 = "string" == typeof t4[r2].data[n3].x, h3 = Array.isArray(t4[r2].data[n3].x), c3 = !h3 && !!s3.isValidDate(t4[r2].data[n3].x);
        if (l3 || c3) if (l3 || i2.xaxis.convertedCatToNumeric) {
          var d3 = a3.isBarHorizontal && a3.isRangeData;
          "datetime" !== i2.xaxis.type || d3 ? (this.fallbackToCategory = true, this.twoDSeriesX.push(t4[r2].data[n3].x), isNaN(t4[r2].data[n3].x) || "category" === this.w.config.xaxis.type || "string" == typeof t4[r2].data[n3].x || (a3.isXNumeric = true)) : this.twoDSeriesX.push(s3.parseDate(t4[r2].data[n3].x));
        } else "datetime" === i2.xaxis.type ? this.twoDSeriesX.push(s3.parseDate(t4[r2].data[n3].x.toString())) : (a3.dataFormatXNumeric = true, a3.isXNumeric = true, this.twoDSeriesX.push(parseFloat(t4[r2].data[n3].x)));
        else h3 ? (this.fallbackToCategory = true, this.twoDSeriesX.push(t4[r2].data[n3].x)) : (a3.isXNumeric = true, a3.dataFormatXNumeric = true, this.twoDSeriesX.push(t4[r2].data[n3].x));
      }
      if (t4[e3].data[0] && void 0 !== t4[e3].data[0].z) {
        for (var g3 = 0; g3 < t4[e3].data.length; g3++) this.threeDSeries.push(t4[e3].data[g3].z);
        a3.isDataXYZ = true;
      }
    } }, { key: "handleRangeData", value: function(t4, e3) {
      var i2 = this.w.globals, a3 = {};
      return this.isFormat2DArray() ? a3 = this.handleRangeDataFormat("array", t4, e3) : this.isFormatXY() && (a3 = this.handleRangeDataFormat("xy", t4, e3)), i2.seriesRangeStart.push(void 0 === a3.start ? [] : a3.start), i2.seriesRangeEnd.push(void 0 === a3.end ? [] : a3.end), i2.seriesRange.push(a3.rangeUniques), i2.seriesRange.forEach(function(t5, e4) {
        t5 && t5.forEach(function(t6, e5) {
          t6.y.forEach(function(e6, i3) {
            for (var a4 = 0; a4 < t6.y.length; a4++) if (i3 !== a4) {
              var s3 = e6.y1, r2 = e6.y2, o3 = t6.y[a4].y1;
              s3 <= t6.y[a4].y2 && o3 <= r2 && (t6.overlaps.indexOf(e6.rangeName) < 0 && t6.overlaps.push(e6.rangeName), t6.overlaps.indexOf(t6.y[a4].rangeName) < 0 && t6.overlaps.push(t6.y[a4].rangeName));
            }
          });
        });
      }), a3;
    } }, { key: "handleCandleStickBoxData", value: function(t4, e3) {
      var i2 = this.w.globals, a3 = {};
      return this.isFormat2DArray() ? a3 = this.handleCandleStickBoxDataFormat("array", t4, e3) : this.isFormatXY() && (a3 = this.handleCandleStickBoxDataFormat("xy", t4, e3)), i2.seriesCandleO[e3] = a3.o, i2.seriesCandleH[e3] = a3.h, i2.seriesCandleM[e3] = a3.m, i2.seriesCandleL[e3] = a3.l, i2.seriesCandleC[e3] = a3.c, a3;
    } }, { key: "handleRangeDataFormat", value: function(t4, e3, i2) {
      var a3 = [], s3 = [], r2 = e3[i2].data.filter(function(t5, e4, i3) {
        return e4 === i3.findIndex(function(e5) {
          return e5.x === t5.x;
        });
      }).map(function(t5, e4) {
        return { x: t5.x, overlaps: [], y: [] };
      });
      if ("array" === t4) for (var o3 = 0; o3 < e3[i2].data.length; o3++) Array.isArray(e3[i2].data[o3]) ? (a3.push(e3[i2].data[o3][1][0]), s3.push(e3[i2].data[o3][1][1])) : (a3.push(e3[i2].data[o3]), s3.push(e3[i2].data[o3]));
      else if ("xy" === t4) for (var n3 = function(t5) {
        var o4 = Array.isArray(e3[i2].data[t5].y), n4 = x2.randomId(), l4 = e3[i2].data[t5].x, h3 = { y1: o4 ? e3[i2].data[t5].y[0] : e3[i2].data[t5].y, y2: o4 ? e3[i2].data[t5].y[1] : e3[i2].data[t5].y, rangeName: n4 };
        e3[i2].data[t5].rangeName = n4;
        var c3 = r2.findIndex(function(t6) {
          return t6.x === l4;
        });
        r2[c3].y.push(h3), a3.push(h3.y1), s3.push(h3.y2);
      }, l3 = 0; l3 < e3[i2].data.length; l3++) n3(l3);
      return { start: a3, end: s3, rangeUniques: r2 };
    } }, { key: "handleCandleStickBoxDataFormat", value: function(t4, e3, i2) {
      var a3 = this.w, s3 = "boxPlot" === a3.config.chart.type || "boxPlot" === a3.config.series[i2].type, r2 = [], o3 = [], n3 = [], l3 = [], h3 = [];
      if ("array" === t4) if (s3 && 6 === e3[i2].data[0].length || !s3 && 5 === e3[i2].data[0].length) for (var c3 = 0; c3 < e3[i2].data.length; c3++) r2.push(e3[i2].data[c3][1]), o3.push(e3[i2].data[c3][2]), s3 ? (n3.push(e3[i2].data[c3][3]), l3.push(e3[i2].data[c3][4]), h3.push(e3[i2].data[c3][5])) : (l3.push(e3[i2].data[c3][3]), h3.push(e3[i2].data[c3][4]));
      else for (var d3 = 0; d3 < e3[i2].data.length; d3++) Array.isArray(e3[i2].data[d3][1]) && (r2.push(e3[i2].data[d3][1][0]), o3.push(e3[i2].data[d3][1][1]), s3 ? (n3.push(e3[i2].data[d3][1][2]), l3.push(e3[i2].data[d3][1][3]), h3.push(e3[i2].data[d3][1][4])) : (l3.push(e3[i2].data[d3][1][2]), h3.push(e3[i2].data[d3][1][3])));
      else if ("xy" === t4) for (var g3 = 0; g3 < e3[i2].data.length; g3++) Array.isArray(e3[i2].data[g3].y) && (r2.push(e3[i2].data[g3].y[0]), o3.push(e3[i2].data[g3].y[1]), s3 ? (n3.push(e3[i2].data[g3].y[2]), l3.push(e3[i2].data[g3].y[3]), h3.push(e3[i2].data[g3].y[4])) : (l3.push(e3[i2].data[g3].y[2]), h3.push(e3[i2].data[g3].y[3])));
      return { o: r2, h: o3, m: n3, l: l3, c: h3 };
    } }, { key: "parseDataAxisCharts", value: function(t4) {
      var e3 = this, i2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.ctx, a3 = this.w.config, s3 = this.w.globals, r2 = new A2(i2), o3 = a3.labels.length > 0 ? a3.labels.slice() : a3.xaxis.categories.slice();
      s3.isRangeBar = "rangeBar" === a3.chart.type && s3.isBarHorizontal, s3.hasXaxisGroups = "category" === a3.xaxis.type && a3.xaxis.group.groups.length > 0, s3.hasXaxisGroups && (s3.groups = a3.xaxis.group.groups), t4.forEach(function(t5, e4) {
        void 0 !== t5.name ? s3.seriesNames.push(t5.name) : s3.seriesNames.push("series-" + parseInt(e4 + 1, 10));
      }), this.coreUtils.setSeriesYAxisMappings();
      var n3 = [], l3 = u2(new Set(a3.series.map(function(t5) {
        return t5.group;
      })));
      a3.series.forEach(function(t5, e4) {
        var i3 = l3.indexOf(t5.group);
        n3[i3] || (n3[i3] = []), n3[i3].push(s3.seriesNames[e4]);
      }), s3.seriesGroups = n3;
      for (var h3 = function() {
        for (var t5 = 0; t5 < o3.length; t5++) if ("string" == typeof o3[t5]) {
          if (!r2.isValidDate(o3[t5])) throw new Error("You have provided invalid Date format. Please provide a valid JavaScript Date");
          e3.twoDSeriesX.push(r2.parseDate(o3[t5]));
        } else e3.twoDSeriesX.push(o3[t5]);
      }, c3 = 0; c3 < t4.length; c3++) {
        if (this.twoDSeries = [], this.twoDSeriesX = [], this.threeDSeries = [], void 0 === t4[c3].data) return void console.error("It is a possibility that you may have not included 'data' property in series.");
        if ("rangeBar" !== a3.chart.type && "rangeArea" !== a3.chart.type && "rangeBar" !== t4[c3].type && "rangeArea" !== t4[c3].type || (s3.isRangeData = true, "rangeBar" !== a3.chart.type && "rangeArea" !== a3.chart.type || this.handleRangeData(t4, c3)), this.isMultiFormat()) this.isFormat2DArray() ? this.handleFormat2DArray(t4, c3) : this.isFormatXY() && this.handleFormatXY(t4, c3), "candlestick" !== a3.chart.type && "candlestick" !== t4[c3].type && "boxPlot" !== a3.chart.type && "boxPlot" !== t4[c3].type || this.handleCandleStickBoxData(t4, c3), s3.series.push(this.twoDSeries), s3.labels.push(this.twoDSeriesX), s3.seriesX.push(this.twoDSeriesX), s3.seriesGoals = this.seriesGoals, c3 !== this.activeSeriesIndex || this.fallbackToCategory || (s3.isXNumeric = true);
        else {
          "datetime" === a3.xaxis.type ? (s3.isXNumeric = true, h3(), s3.seriesX.push(this.twoDSeriesX)) : "numeric" === a3.xaxis.type && (s3.isXNumeric = true, o3.length > 0 && (this.twoDSeriesX = o3, s3.seriesX.push(this.twoDSeriesX))), s3.labels.push(this.twoDSeriesX);
          var d3 = t4[c3].data.map(function(t5) {
            return x2.parseNumber(t5);
          });
          s3.series.push(d3);
        }
        s3.seriesZ.push(this.threeDSeries), void 0 !== t4[c3].color ? s3.seriesColors.push(t4[c3].color) : s3.seriesColors.push(void 0);
      }
      return this.w;
    } }, { key: "parseDataNonAxisCharts", value: function(t4) {
      var e3 = this.w.globals, i2 = this.w.config;
      e3.series = t4.slice(), e3.seriesNames = i2.labels.slice();
      for (var a3 = 0; a3 < e3.series.length; a3++) void 0 === e3.seriesNames[a3] && e3.seriesNames.push("series-" + (a3 + 1));
      return this.w;
    } }, { key: "handleExternalLabelsData", value: function(t4) {
      var e3 = this.w.config, i2 = this.w.globals;
      if (e3.xaxis.categories.length > 0) i2.labels = e3.xaxis.categories;
      else if (e3.labels.length > 0) i2.labels = e3.labels.slice();
      else if (this.fallbackToCategory) {
        if (i2.labels = i2.labels[0], i2.seriesRange.length && (i2.seriesRange.map(function(t5) {
          t5.forEach(function(t6) {
            i2.labels.indexOf(t6.x) < 0 && t6.x && i2.labels.push(t6.x);
          });
        }), i2.labels = Array.from(new Set(i2.labels.map(JSON.stringify)), JSON.parse)), e3.xaxis.convertedCatToNumeric) new E2(e3).convertCatToNumericXaxis(e3, this.ctx, i2.seriesX[0]), this._generateExternalLabels(t4);
      } else this._generateExternalLabels(t4);
    } }, { key: "_generateExternalLabels", value: function(t4) {
      var e3 = this.w.globals, i2 = this.w.config, a3 = [];
      if (e3.axisCharts) {
        if (e3.series.length > 0) if (this.isFormatXY()) for (var s3 = i2.series.map(function(t5, e4) {
          return t5.data.filter(function(t6, e5, i3) {
            return i3.findIndex(function(e6) {
              return e6.x === t6.x;
            }) === e5;
          });
        }), r2 = s3.reduce(function(t5, e4, i3, a4) {
          return a4[t5].length > e4.length ? t5 : i3;
        }, 0), o3 = 0; o3 < s3[r2].length; o3++) a3.push(o3 + 1);
        else for (var n3 = 0; n3 < e3.series[e3.maxValsInArrayIndex].length; n3++) a3.push(n3 + 1);
        e3.seriesX = [];
        for (var l3 = 0; l3 < t4.length; l3++) e3.seriesX.push(a3);
        this.w.globals.isBarHorizontal || (e3.isXNumeric = true);
      }
      if (0 === a3.length) {
        a3 = e3.axisCharts ? [] : e3.series.map(function(t5, e4) {
          return e4 + 1;
        });
        for (var h3 = 0; h3 < t4.length; h3++) e3.seriesX.push(a3);
      }
      e3.labels = a3, i2.xaxis.convertedCatToNumeric && (e3.categoryLabels = a3.map(function(t5) {
        return i2.xaxis.labels.formatter(t5);
      })), e3.noLabelsProvided = true;
    } }, { key: "parseData", value: function(t4) {
      var e3 = this.w, i2 = e3.config, a3 = e3.globals;
      if (this.excludeCollapsedSeriesInYAxis(), this.fallbackToCategory = false, this.ctx.core.resetGlobals(), this.ctx.core.isMultipleY(), a3.axisCharts ? (this.parseDataAxisCharts(t4), this.coreUtils.getLargestSeries()) : this.parseDataNonAxisCharts(t4), i2.chart.stacked) {
        var s3 = new W2(this.ctx);
        a3.series = s3.setNullSeriesToZeroValues(a3.series);
      }
      this.coreUtils.getSeriesTotals(), a3.axisCharts && (a3.stackedSeriesTotals = this.coreUtils.getStackedSeriesTotals(), a3.stackedSeriesTotalsByGroups = this.coreUtils.getStackedSeriesTotalsByGroups()), this.coreUtils.getPercentSeries(), a3.dataFormatXNumeric || a3.isXNumeric && ("numeric" !== i2.xaxis.type || 0 !== i2.labels.length || 0 !== i2.xaxis.categories.length) || this.handleExternalLabelsData(t4);
      for (var r2 = this.coreUtils.getCategoryLabels(a3.labels), o3 = 0; o3 < r2.length; o3++) if (Array.isArray(r2[o3])) {
        a3.isMultiLineX = true;
        break;
      }
    } }, { key: "excludeCollapsedSeriesInYAxis", value: function() {
      var t4 = this.w, e3 = [];
      t4.globals.seriesYAxisMap.forEach(function(i2, a3) {
        var s3 = 0;
        i2.forEach(function(e4) {
          -1 !== t4.globals.collapsedSeriesIndices.indexOf(e4) && s3++;
        }), s3 > 0 && s3 == i2.length && e3.push(a3);
      }), t4.globals.ignoreYAxisIndexes = e3.map(function(t5) {
        return t5;
      });
    } }]), t3;
  }(), G2 = function() {
    function t3(e3) {
      a2(this, t3), this.ctx = e3, this.w = e3.w;
    }
    return r(t3, [{ key: "scaleSvgNode", value: function(t4, e3) {
      var i2 = parseFloat(t4.getAttributeNS(null, "width")), a3 = parseFloat(t4.getAttributeNS(null, "height"));
      t4.setAttributeNS(null, "width", i2 * e3), t4.setAttributeNS(null, "height", a3 * e3), t4.setAttributeNS(null, "viewBox", "0 0 " + i2 + " " + a3);
    } }, { key: "fixSvgStringForIe11", value: function(t4) {
      if (!x2.isIE11()) return t4.replace(/&nbsp;/g, "&#160;");
      var e3 = 0, i2 = t4.replace(/xmlns="http:\/\/www.w3.org\/2000\/svg"/g, function(t5) {
        return 2 === ++e3 ? 'xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.dev"' : t5;
      });
      return i2 = (i2 = i2.replace(/xmlns:NS\d+=""/g, "")).replace(/NS\d+:(\w+:\w+=")/g, "$1");
    } }, { key: "getSvgString", value: function(t4) {
      null == t4 && (t4 = 1);
      var e3 = this.w.globals.dom.Paper.svg();
      if (1 !== t4) {
        var i2 = this.w.globals.dom.Paper.node.cloneNode(true);
        this.scaleSvgNode(i2, t4), e3 = new XMLSerializer().serializeToString(i2);
      }
      return this.fixSvgStringForIe11(e3);
    } }, { key: "cleanup", value: function() {
      var t4 = this.w, e3 = t4.globals.dom.baseEl.getElementsByClassName("apexcharts-xcrosshairs"), i2 = t4.globals.dom.baseEl.getElementsByClassName("apexcharts-ycrosshairs"), a3 = t4.globals.dom.baseEl.querySelectorAll(".apexcharts-zoom-rect, .apexcharts-selection-rect");
      Array.prototype.forEach.call(a3, function(t5) {
        t5.setAttribute("width", 0);
      }), e3 && e3[0] && (e3[0].setAttribute("x", -500), e3[0].setAttribute("x1", -500), e3[0].setAttribute("x2", -500)), i2 && i2[0] && (i2[0].setAttribute("y", -100), i2[0].setAttribute("y1", -100), i2[0].setAttribute("y2", -100));
    } }, { key: "svgUrl", value: function() {
      this.cleanup();
      var t4 = this.getSvgString(), e3 = new Blob([t4], { type: "image/svg+xml;charset=utf-8" });
      return URL.createObjectURL(e3);
    } }, { key: "dataURI", value: function(t4) {
      var e3 = this;
      return new Promise(function(i2) {
        var a3 = e3.w, s3 = t4 ? t4.scale || t4.width / a3.globals.svgWidth : 1;
        e3.cleanup();
        var r2 = document.createElement("canvas");
        r2.width = a3.globals.svgWidth * s3, r2.height = parseInt(a3.globals.dom.elWrap.style.height, 10) * s3;
        var o3 = "transparent" === a3.config.chart.background ? "#fff" : a3.config.chart.background, n3 = r2.getContext("2d");
        n3.fillStyle = o3, n3.fillRect(0, 0, r2.width * s3, r2.height * s3);
        var l3 = e3.getSvgString(s3);
        if (window.canvg && x2.isIE11()) {
          var h3 = window.canvg.Canvg.fromString(n3, l3, { ignoreClear: true, ignoreDimensions: true });
          h3.start();
          var c3 = r2.msToBlob();
          h3.stop(), i2({ blob: c3 });
        } else {
          var d3 = "data:image/svg+xml," + encodeURIComponent(l3), g3 = new Image();
          g3.crossOrigin = "anonymous", g3.onload = function() {
            if (n3.drawImage(g3, 0, 0), r2.msToBlob) {
              var t5 = r2.msToBlob();
              i2({ blob: t5 });
            } else {
              var e4 = r2.toDataURL("image/png");
              i2({ imgURI: e4 });
            }
          }, g3.src = d3;
        }
      });
    } }, { key: "exportToSVG", value: function() {
      this.triggerDownload(this.svgUrl(), this.w.config.chart.toolbar.export.svg.filename, ".svg");
    } }, { key: "exportToPng", value: function() {
      var t4 = this;
      this.dataURI().then(function(e3) {
        var i2 = e3.imgURI, a3 = e3.blob;
        a3 ? navigator.msSaveOrOpenBlob(a3, t4.w.globals.chartID + ".png") : t4.triggerDownload(i2, t4.w.config.chart.toolbar.export.png.filename, ".png");
      });
    } }, { key: "exportToCSV", value: function(t4) {
      var e3 = this, i2 = t4.series, a3 = t4.fileName, s3 = t4.columnDelimiter, r2 = void 0 === s3 ? "," : s3, o3 = t4.lineDelimiter, n3 = void 0 === o3 ? "\n" : o3, l3 = this.w;
      i2 || (i2 = l3.config.series);
      var h3, c3, d3 = [], g3 = [], p3 = "", f3 = l3.globals.series.map(function(t5, e4) {
        return -1 === l3.globals.collapsedSeriesIndices.indexOf(e4) ? t5 : [];
      }), b3 = function(t5) {
        return "datetime" === l3.config.xaxis.type && String(t5).length >= 10;
      }, v3 = Math.max.apply(Math, u2(i2.map(function(t5) {
        return t5.data ? t5.data.length : 0;
      }))), m3 = new B3(this.ctx), y3 = new C2(this.ctx), w3 = function(t5) {
        var i3 = "";
        if (l3.globals.axisCharts) {
          if ("category" === l3.config.xaxis.type || l3.config.xaxis.convertedCatToNumeric) if (l3.globals.isBarHorizontal) {
            var a4 = l3.globals.yLabelFormatters[0], s4 = new W2(e3.ctx).getActiveConfigSeriesIndex();
            i3 = a4(l3.globals.labels[t5], { seriesIndex: s4, dataPointIndex: t5, w: l3 });
          } else i3 = y3.getLabel(l3.globals.labels, l3.globals.timescaleLabels, 0, t5).text;
          "datetime" === l3.config.xaxis.type && (l3.config.xaxis.categories.length ? i3 = l3.config.xaxis.categories[t5] : l3.config.labels.length && (i3 = l3.config.labels[t5]));
        } else i3 = l3.config.labels[t5];
        return null === i3 ? "nullvalue" : (Array.isArray(i3) && (i3 = i3.join(" ")), x2.isNumber(i3) ? i3 : i3.split(r2).join(""));
      }, k3 = function(t5, e4) {
        if (d3.length && 0 === e4 && g3.push(d3.join(r2)), t5.data) {
          t5.data = t5.data.length && t5.data || u2(Array(v3)).map(function() {
            return "";
          });
          for (var a4 = 0; a4 < t5.data.length; a4++) {
            d3 = [];
            var s4 = w3(a4);
            if ("nullvalue" !== s4) {
              if (s4 || (m3.isFormatXY() ? s4 = i2[e4].data[a4].x : m3.isFormat2DArray() && (s4 = i2[e4].data[a4] ? i2[e4].data[a4][0] : "")), 0 === e4) {
                d3.push(b3(s4) ? l3.config.chart.toolbar.export.csv.dateFormatter(s4) : x2.isNumber(s4) ? s4 : s4.split(r2).join(""));
                for (var o4 = 0; o4 < l3.globals.series.length; o4++) {
                  var n4;
                  if (m3.isFormatXY()) d3.push(null === (n4 = i2[o4].data[a4]) || void 0 === n4 ? void 0 : n4.y);
                  else d3.push(f3[o4][a4]);
                }
              }
              ("candlestick" === l3.config.chart.type || t5.type && "candlestick" === t5.type) && (d3.pop(), d3.push(l3.globals.seriesCandleO[e4][a4]), d3.push(l3.globals.seriesCandleH[e4][a4]), d3.push(l3.globals.seriesCandleL[e4][a4]), d3.push(l3.globals.seriesCandleC[e4][a4])), ("boxPlot" === l3.config.chart.type || t5.type && "boxPlot" === t5.type) && (d3.pop(), d3.push(l3.globals.seriesCandleO[e4][a4]), d3.push(l3.globals.seriesCandleH[e4][a4]), d3.push(l3.globals.seriesCandleM[e4][a4]), d3.push(l3.globals.seriesCandleL[e4][a4]), d3.push(l3.globals.seriesCandleC[e4][a4])), "rangeBar" === l3.config.chart.type && (d3.pop(), d3.push(l3.globals.seriesRangeStart[e4][a4]), d3.push(l3.globals.seriesRangeEnd[e4][a4])), d3.length && g3.push(d3.join(r2));
            }
          }
        }
      };
      d3.push(l3.config.chart.toolbar.export.csv.headerCategory), "boxPlot" === l3.config.chart.type ? (d3.push("minimum"), d3.push("q1"), d3.push("median"), d3.push("q3"), d3.push("maximum")) : "candlestick" === l3.config.chart.type ? (d3.push("open"), d3.push("high"), d3.push("low"), d3.push("close")) : "rangeBar" === l3.config.chart.type ? (d3.push("minimum"), d3.push("maximum")) : i2.map(function(t5, e4) {
        var i3 = (t5.name ? t5.name : "series-".concat(e4)) + "";
        l3.globals.axisCharts && d3.push(i3.split(r2).join("") ? i3.split(r2).join("") : "series-".concat(e4));
      }), l3.globals.axisCharts || (d3.push(l3.config.chart.toolbar.export.csv.headerValue), g3.push(d3.join(r2))), l3.globals.allSeriesHasEqualX || !l3.globals.axisCharts || l3.config.xaxis.categories.length || l3.config.labels.length ? i2.map(function(t5, e4) {
        l3.globals.axisCharts ? k3(t5, e4) : ((d3 = []).push(l3.globals.labels[e4].split(r2).join("")), d3.push(f3[e4]), g3.push(d3.join(r2)));
      }) : (h3 = /* @__PURE__ */ new Set(), c3 = {}, i2.forEach(function(t5, e4) {
        null == t5 || t5.data.forEach(function(t6) {
          var a4, s4;
          if (m3.isFormatXY()) a4 = t6.x, s4 = t6.y;
          else {
            if (!m3.isFormat2DArray()) return;
            a4 = t6[0], s4 = t6[1];
          }
          c3[a4] || (c3[a4] = Array(i2.length).fill("")), c3[a4][e4] = s4, h3.add(a4);
        });
      }), d3.length && g3.push(d3.join(r2)), Array.from(h3).sort().forEach(function(t5) {
        g3.push([b3(t5) && "datetime" === l3.config.xaxis.type ? l3.config.chart.toolbar.export.csv.dateFormatter(t5) : x2.isNumber(t5) ? t5 : t5.split(r2).join(""), c3[t5].join(r2)]);
      })), p3 += g3.join(n3), this.triggerDownload("data:text/csv; charset=utf-8," + encodeURIComponent("\uFEFF" + p3), a3 || l3.config.chart.toolbar.export.csv.filename, ".csv");
    } }, { key: "triggerDownload", value: function(t4, e3, i2) {
      var a3 = document.createElement("a");
      a3.href = t4, a3.download = (e3 || this.w.globals.chartID) + i2, document.body.appendChild(a3), a3.click(), document.body.removeChild(a3);
    } }]), t3;
  }(), V2 = function() {
    function t3(e3, i2) {
      a2(this, t3), this.ctx = e3, this.elgrid = i2, this.w = e3.w;
      var s3 = this.w;
      this.axesUtils = new C2(e3), this.xaxisLabels = s3.globals.labels.slice(), s3.globals.timescaleLabels.length > 0 && !s3.globals.isBarHorizontal && (this.xaxisLabels = s3.globals.timescaleLabels.slice()), s3.config.xaxis.overwriteCategories && (this.xaxisLabels = s3.config.xaxis.overwriteCategories), this.drawnLabels = [], this.drawnLabelsRects = [], "top" === s3.config.xaxis.position ? this.offY = 0 : this.offY = s3.globals.gridHeight, this.offY = this.offY + s3.config.xaxis.axisBorder.offsetY, this.isCategoryBarHorizontal = "bar" === s3.config.chart.type && s3.config.plotOptions.bar.horizontal, this.xaxisFontSize = s3.config.xaxis.labels.style.fontSize, this.xaxisFontFamily = s3.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = s3.config.xaxis.labels.style.colors, this.xaxisBorderWidth = s3.config.xaxis.axisBorder.width, this.isCategoryBarHorizontal && (this.xaxisBorderWidth = s3.config.yaxis[0].axisBorder.width.toString()), this.xaxisBorderWidth.indexOf("%") > -1 ? this.xaxisBorderWidth = s3.globals.gridWidth * parseInt(this.xaxisBorderWidth, 10) / 100 : this.xaxisBorderWidth = parseInt(this.xaxisBorderWidth, 10), this.xaxisBorderHeight = s3.config.xaxis.axisBorder.height, this.yaxis = s3.config.yaxis[0];
    }
    return r(t3, [{ key: "drawXaxis", value: function() {
      var t4 = this.w, e3 = new m2(this.ctx), i2 = e3.group({ class: "apexcharts-xaxis", transform: "translate(".concat(t4.config.xaxis.offsetX, ", ").concat(t4.config.xaxis.offsetY, ")") }), a3 = e3.group({ class: "apexcharts-xaxis-texts-g", transform: "translate(".concat(t4.globals.translateXAxisX, ", ").concat(t4.globals.translateXAxisY, ")") });
      i2.add(a3);
      for (var s3 = [], r2 = 0; r2 < this.xaxisLabels.length; r2++) s3.push(this.xaxisLabels[r2]);
      if (this.drawXAxisLabelAndGroup(true, e3, a3, s3, t4.globals.isXNumeric, function(t5, e4) {
        return e4;
      }), t4.globals.hasXaxisGroups) {
        var o3 = t4.globals.groups;
        s3 = [];
        for (var n3 = 0; n3 < o3.length; n3++) s3.push(o3[n3].title);
        var l3 = {};
        t4.config.xaxis.group.style && (l3.xaxisFontSize = t4.config.xaxis.group.style.fontSize, l3.xaxisFontFamily = t4.config.xaxis.group.style.fontFamily, l3.xaxisForeColors = t4.config.xaxis.group.style.colors, l3.fontWeight = t4.config.xaxis.group.style.fontWeight, l3.cssClass = t4.config.xaxis.group.style.cssClass), this.drawXAxisLabelAndGroup(false, e3, a3, s3, false, function(t5, e4) {
          return o3[t5].cols * e4;
        }, l3);
      }
      if (void 0 !== t4.config.xaxis.title.text) {
        var h3 = e3.group({ class: "apexcharts-xaxis-title" }), c3 = e3.drawText({ x: t4.globals.gridWidth / 2 + t4.config.xaxis.title.offsetX, y: this.offY + parseFloat(this.xaxisFontSize) + ("bottom" === t4.config.xaxis.position ? t4.globals.xAxisLabelsHeight : -t4.globals.xAxisLabelsHeight - 10) + t4.config.xaxis.title.offsetY, text: t4.config.xaxis.title.text, textAnchor: "middle", fontSize: t4.config.xaxis.title.style.fontSize, fontFamily: t4.config.xaxis.title.style.fontFamily, fontWeight: t4.config.xaxis.title.style.fontWeight, foreColor: t4.config.xaxis.title.style.color, cssClass: "apexcharts-xaxis-title-text " + t4.config.xaxis.title.style.cssClass });
        h3.add(c3), i2.add(h3);
      }
      if (t4.config.xaxis.axisBorder.show) {
        var d3 = t4.globals.barPadForNumericAxis, g3 = e3.drawLine(t4.globals.padHorizontal + t4.config.xaxis.axisBorder.offsetX - d3, this.offY, this.xaxisBorderWidth + d3, this.offY, t4.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight);
        this.elgrid && this.elgrid.elGridBorders && t4.config.grid.show ? this.elgrid.elGridBorders.add(g3) : i2.add(g3);
      }
      return i2;
    } }, { key: "drawXAxisLabelAndGroup", value: function(t4, e3, i2, a3, s3, r2) {
      var o3, n3 = this, l3 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : {}, h3 = [], c3 = [], d3 = this.w, g3 = l3.xaxisFontSize || this.xaxisFontSize, u3 = l3.xaxisFontFamily || this.xaxisFontFamily, p3 = l3.xaxisForeColors || this.xaxisForeColors, f3 = l3.fontWeight || d3.config.xaxis.labels.style.fontWeight, x3 = l3.cssClass || d3.config.xaxis.labels.style.cssClass, b3 = d3.globals.padHorizontal, v3 = a3.length, m3 = "category" === d3.config.xaxis.type ? d3.globals.dataPoints : v3;
      if (0 === m3 && v3 > m3 && (m3 = v3), s3) {
        var y3 = m3 > 1 ? m3 - 1 : m3;
        o3 = d3.globals.gridWidth / Math.min(y3, v3 - 1), b3 = b3 + r2(0, o3) / 2 + d3.config.xaxis.labels.offsetX;
      } else o3 = d3.globals.gridWidth / m3, b3 = b3 + r2(0, o3) + d3.config.xaxis.labels.offsetX;
      for (var w3 = function(s4) {
        var l4 = b3 - r2(s4, o3) / 2 + d3.config.xaxis.labels.offsetX;
        0 === s4 && 1 === v3 && o3 / 2 === b3 && 1 === m3 && (l4 = d3.globals.gridWidth / 2);
        var y4 = n3.axesUtils.getLabel(a3, d3.globals.timescaleLabels, l4, s4, h3, g3, t4), w4 = 28;
        d3.globals.rotateXLabels && t4 && (w4 = 22), d3.config.xaxis.title.text && "top" === d3.config.xaxis.position && (w4 += parseFloat(d3.config.xaxis.title.style.fontSize) + 2), t4 || (w4 = w4 + parseFloat(g3) + (d3.globals.xAxisLabelsHeight - d3.globals.xAxisGroupLabelsHeight) + (d3.globals.rotateXLabels ? 10 : 0)), y4 = void 0 !== d3.config.xaxis.tickAmount && "dataPoints" !== d3.config.xaxis.tickAmount && "datetime" !== d3.config.xaxis.type ? n3.axesUtils.checkLabelBasedOnTickamount(s4, y4, v3) : n3.axesUtils.checkForOverflowingLabels(s4, y4, v3, h3, c3);
        if (d3.config.xaxis.labels.show) {
          var k4 = e3.drawText({ x: y4.x, y: n3.offY + d3.config.xaxis.labels.offsetY + w4 - ("top" === d3.config.xaxis.position ? d3.globals.xAxisHeight + d3.config.xaxis.axisTicks.height - 2 : 0), text: y4.text, textAnchor: "middle", fontWeight: y4.isBold ? 600 : f3, fontSize: g3, fontFamily: u3, foreColor: Array.isArray(p3) ? t4 && d3.config.xaxis.convertedCatToNumeric ? p3[d3.globals.minX + s4 - 1] : p3[s4] : p3, isPlainText: false, cssClass: (t4 ? "apexcharts-xaxis-label " : "apexcharts-xaxis-group-label ") + x3 });
          if (i2.add(k4), k4.on("click", function(t5) {
            if ("function" == typeof d3.config.chart.events.xAxisLabelClick) {
              var e4 = Object.assign({}, d3, { labelIndex: s4 });
              d3.config.chart.events.xAxisLabelClick(t5, n3.ctx, e4);
            }
          }), t4) {
            var A3 = document.createElementNS(d3.globals.SVGNS, "title");
            A3.textContent = Array.isArray(y4.text) ? y4.text.join(" ") : y4.text, k4.node.appendChild(A3), "" !== y4.text && (h3.push(y4.text), c3.push(y4));
          }
        }
        s4 < v3 - 1 && (b3 += r2(s4 + 1, o3));
      }, k3 = 0; k3 <= v3 - 1; k3++) w3(k3);
    } }, { key: "drawXaxisInversed", value: function(t4) {
      var e3, i2, a3 = this, s3 = this.w, r2 = new m2(this.ctx), o3 = s3.config.yaxis[0].opposite ? s3.globals.translateYAxisX[t4] : 0, n3 = r2.group({ class: "apexcharts-yaxis apexcharts-xaxis-inversed", rel: t4 }), l3 = r2.group({ class: "apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g", transform: "translate(" + o3 + ", 0)" });
      n3.add(l3);
      var h3 = [];
      if (s3.config.yaxis[t4].show) for (var c3 = 0; c3 < this.xaxisLabels.length; c3++) h3.push(this.xaxisLabels[c3]);
      e3 = s3.globals.gridHeight / h3.length, i2 = -e3 / 2.2;
      var d3 = s3.globals.yLabelFormatters[0], g3 = s3.config.yaxis[0].labels;
      if (g3.show) for (var u3 = function(o4) {
        var n4 = void 0 === h3[o4] ? "" : h3[o4];
        n4 = d3(n4, { seriesIndex: t4, dataPointIndex: o4, w: s3 });
        var c4 = a3.axesUtils.getYAxisForeColor(g3.style.colors, t4), u4 = 0;
        Array.isArray(n4) && (u4 = n4.length / 2 * parseInt(g3.style.fontSize, 10));
        var p4 = g3.offsetX - 15, f4 = "end";
        a3.yaxis.opposite && (f4 = "start"), "left" === s3.config.yaxis[0].labels.align ? (p4 = g3.offsetX, f4 = "start") : "center" === s3.config.yaxis[0].labels.align ? (p4 = g3.offsetX, f4 = "middle") : "right" === s3.config.yaxis[0].labels.align && (f4 = "end");
        var x4 = r2.drawText({ x: p4, y: i2 + e3 + g3.offsetY - u4, text: n4, textAnchor: f4, foreColor: Array.isArray(c4) ? c4[o4] : c4, fontSize: g3.style.fontSize, fontFamily: g3.style.fontFamily, fontWeight: g3.style.fontWeight, isPlainText: false, cssClass: "apexcharts-yaxis-label " + g3.style.cssClass, maxWidth: g3.maxWidth });
        l3.add(x4), x4.on("click", function(t5) {
          if ("function" == typeof s3.config.chart.events.xAxisLabelClick) {
            var e4 = Object.assign({}, s3, { labelIndex: o4 });
            s3.config.chart.events.xAxisLabelClick(t5, a3.ctx, e4);
          }
        });
        var b4 = document.createElementNS(s3.globals.SVGNS, "title");
        if (b4.textContent = Array.isArray(n4) ? n4.join(" ") : n4, x4.node.appendChild(b4), 0 !== s3.config.yaxis[t4].labels.rotate) {
          var v4 = r2.rotateAroundCenter(x4.node);
          x4.node.setAttribute("transform", "rotate(".concat(s3.config.yaxis[t4].labels.rotate, " 0 ").concat(v4.y, ")"));
        }
        i2 += e3;
      }, p3 = 0; p3 <= h3.length - 1; p3++) u3(p3);
      if (void 0 !== s3.config.yaxis[0].title.text) {
        var f3 = r2.group({ class: "apexcharts-yaxis-title apexcharts-xaxis-title-inversed", transform: "translate(" + o3 + ", 0)" }), x3 = r2.drawText({ x: s3.config.yaxis[0].title.offsetX, y: s3.globals.gridHeight / 2 + s3.config.yaxis[0].title.offsetY, text: s3.config.yaxis[0].title.text, textAnchor: "middle", foreColor: s3.config.yaxis[0].title.style.color, fontSize: s3.config.yaxis[0].title.style.fontSize, fontWeight: s3.config.yaxis[0].title.style.fontWeight, fontFamily: s3.config.yaxis[0].title.style.fontFamily, cssClass: "apexcharts-yaxis-title-text " + s3.config.yaxis[0].title.style.cssClass });
        f3.add(x3), n3.add(f3);
      }
      var b3 = 0;
      this.isCategoryBarHorizontal && s3.config.yaxis[0].opposite && (b3 = s3.globals.gridWidth);
      var v3 = s3.config.xaxis.axisBorder;
      if (v3.show) {
        var y3 = r2.drawLine(s3.globals.padHorizontal + v3.offsetX + b3, 1 + v3.offsetY, s3.globals.padHorizontal + v3.offsetX + b3, s3.globals.gridHeight + v3.offsetY, v3.color, 0);
        this.elgrid && this.elgrid.elGridBorders && s3.config.grid.show ? this.elgrid.elGridBorders.add(y3) : n3.add(y3);
      }
      return s3.config.yaxis[0].axisTicks.show && this.axesUtils.drawYAxisTicks(b3, h3.length, s3.config.yaxis[0].axisBorder, s3.config.yaxis[0].axisTicks, 0, e3, n3), n3;
    } }, { key: "drawXaxisTicks", value: function(t4, e3, i2) {
      var a3 = this.w, s3 = t4;
      if (!(t4 < 0 || t4 - 2 > a3.globals.gridWidth)) {
        var r2 = this.offY + a3.config.xaxis.axisTicks.offsetY;
        if (e3 = e3 + r2 + a3.config.xaxis.axisTicks.height, "top" === a3.config.xaxis.position && (e3 = r2 - a3.config.xaxis.axisTicks.height), a3.config.xaxis.axisTicks.show) {
          var o3 = new m2(this.ctx).drawLine(t4 + a3.config.xaxis.axisTicks.offsetX, r2 + a3.config.xaxis.offsetY, s3 + a3.config.xaxis.axisTicks.offsetX, e3 + a3.config.xaxis.offsetY, a3.config.xaxis.axisTicks.color);
          i2.add(o3), o3.node.classList.add("apexcharts-xaxis-tick");
        }
      }
    } }, { key: "getXAxisTicksPositions", value: function() {
      var t4 = this.w, e3 = [], i2 = this.xaxisLabels.length, a3 = t4.globals.padHorizontal;
      if (t4.globals.timescaleLabels.length > 0) for (var s3 = 0; s3 < i2; s3++) a3 = this.xaxisLabels[s3].position, e3.push(a3);
      else for (var r2 = i2, o3 = 0; o3 < r2; o3++) {
        var n3 = r2;
        t4.globals.isXNumeric && "bar" !== t4.config.chart.type && (n3 -= 1), a3 += t4.globals.gridWidth / n3, e3.push(a3);
      }
      return e3;
    } }, { key: "xAxisLabelCorrections", value: function() {
      var t4 = this.w, e3 = new m2(this.ctx), i2 = t4.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g"), a3 = t4.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-texts-g text:not(.apexcharts-xaxis-group-label)"), s3 = t4.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-inversed text"), r2 = t4.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-inversed-texts-g text tspan");
      if (t4.globals.rotateXLabels || t4.config.xaxis.labels.rotateAlways) for (var o3 = 0; o3 < a3.length; o3++) {
        var n3 = e3.rotateAroundCenter(a3[o3]);
        n3.y = n3.y - 1, n3.x = n3.x + 1, a3[o3].setAttribute("transform", "rotate(".concat(t4.config.xaxis.labels.rotate, " ").concat(n3.x, " ").concat(n3.y, ")")), a3[o3].setAttribute("text-anchor", "end");
        i2.setAttribute("transform", "translate(0, ".concat(-10, ")"));
        var l3 = a3[o3].childNodes;
        t4.config.xaxis.labels.trim && Array.prototype.forEach.call(l3, function(i3) {
          e3.placeTextWithEllipsis(i3, i3.textContent, t4.globals.xAxisLabelsHeight - ("bottom" === t4.config.legend.position ? 20 : 10));
        });
      }
      else !function() {
        for (var i3 = t4.globals.gridWidth / (t4.globals.labels.length + 1), s4 = 0; s4 < a3.length; s4++) {
          var r3 = a3[s4].childNodes;
          t4.config.xaxis.labels.trim && "datetime" !== t4.config.xaxis.type && Array.prototype.forEach.call(r3, function(t5) {
            e3.placeTextWithEllipsis(t5, t5.textContent, i3);
          });
        }
      }();
      if (s3.length > 0) {
        var h3 = s3[s3.length - 1].getBBox(), c3 = s3[0].getBBox();
        h3.x < -20 && s3[s3.length - 1].parentNode.removeChild(s3[s3.length - 1]), c3.x + c3.width > t4.globals.gridWidth && !t4.globals.isBarHorizontal && s3[0].parentNode.removeChild(s3[0]);
        for (var d3 = 0; d3 < r2.length; d3++) e3.placeTextWithEllipsis(r2[d3], r2[d3].textContent, t4.config.yaxis[0].labels.maxWidth - (t4.config.yaxis[0].title.text ? 2 * parseFloat(t4.config.yaxis[0].title.style.fontSize) : 0) - 15);
      }
    } }]), t3;
  }(), j2 = function() {
    function t3(e3) {
      a2(this, t3), this.ctx = e3, this.w = e3.w;
      var i2 = this.w;
      this.xaxisLabels = i2.globals.labels.slice(), this.axesUtils = new C2(e3), this.isRangeBar = i2.globals.seriesRange.length && i2.globals.isBarHorizontal, i2.globals.timescaleLabels.length > 0 && (this.xaxisLabels = i2.globals.timescaleLabels.slice());
    }
    return r(t3, [{ key: "drawGridArea", value: function() {
      var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, e3 = this.w, i2 = new m2(this.ctx);
      null === t4 && (t4 = i2.group({ class: "apexcharts-grid" }));
      var a3 = i2.drawLine(e3.globals.padHorizontal, 1, e3.globals.padHorizontal, e3.globals.gridHeight, "transparent"), s3 = i2.drawLine(e3.globals.padHorizontal, e3.globals.gridHeight, e3.globals.gridWidth, e3.globals.gridHeight, "transparent");
      return t4.add(s3), t4.add(a3), t4;
    } }, { key: "drawGrid", value: function() {
      var t4 = null;
      return this.w.globals.axisCharts && (t4 = this.renderGrid(), this.drawGridArea(t4.el)), t4;
    } }, { key: "createGridMask", value: function() {
      var t4 = this.w, e3 = t4.globals, i2 = new m2(this.ctx), a3 = Array.isArray(t4.config.stroke.width) ? 0 : t4.config.stroke.width;
      if (Array.isArray(t4.config.stroke.width)) {
        var s3 = 0;
        t4.config.stroke.width.forEach(function(t5) {
          s3 = Math.max(s3, t5);
        }), a3 = s3;
      }
      e3.dom.elGridRectMask = document.createElementNS(e3.SVGNS, "clipPath"), e3.dom.elGridRectMask.setAttribute("id", "gridRectMask".concat(e3.cuid)), e3.dom.elGridRectMarkerMask = document.createElementNS(e3.SVGNS, "clipPath"), e3.dom.elGridRectMarkerMask.setAttribute("id", "gridRectMarkerMask".concat(e3.cuid)), e3.dom.elForecastMask = document.createElementNS(e3.SVGNS, "clipPath"), e3.dom.elForecastMask.setAttribute("id", "forecastMask".concat(e3.cuid)), e3.dom.elNonForecastMask = document.createElementNS(e3.SVGNS, "clipPath"), e3.dom.elNonForecastMask.setAttribute("id", "nonForecastMask".concat(e3.cuid));
      var r2 = t4.config.chart.type, o3 = 0, n3 = 0;
      ("bar" === r2 || "rangeBar" === r2 || "candlestick" === r2 || "boxPlot" === r2 || t4.globals.comboBarCount > 0) && t4.globals.isXNumeric && !t4.globals.isBarHorizontal && (o3 = t4.config.grid.padding.left, n3 = t4.config.grid.padding.right, e3.barPadForNumericAxis > o3 && (o3 = e3.barPadForNumericAxis, n3 = e3.barPadForNumericAxis)), e3.dom.elGridRect = i2.drawRect(-a3 / 2 - o3 - 2, -a3 / 2 - 2, e3.gridWidth + a3 + n3 + o3 + 4, e3.gridHeight + a3 + 4, 0, "#fff");
      var l3 = t4.globals.markers.largestSize + 1;
      e3.dom.elGridRectMarker = i2.drawRect(2 * -l3, 2 * -l3, e3.gridWidth + 4 * l3, e3.gridHeight + 4 * l3, 0, "#fff"), e3.dom.elGridRectMask.appendChild(e3.dom.elGridRect.node), e3.dom.elGridRectMarkerMask.appendChild(e3.dom.elGridRectMarker.node);
      var h3 = e3.dom.baseEl.querySelector("defs");
      h3.appendChild(e3.dom.elGridRectMask), h3.appendChild(e3.dom.elForecastMask), h3.appendChild(e3.dom.elNonForecastMask), h3.appendChild(e3.dom.elGridRectMarkerMask);
    } }, { key: "_drawGridLines", value: function(t4) {
      var e3 = t4.i, i2 = t4.x1, a3 = t4.y1, s3 = t4.x2, r2 = t4.y2, o3 = t4.xCount, n3 = t4.parent, l3 = this.w;
      if (!(0 === e3 && l3.globals.skipFirstTimelinelabel || e3 === o3 - 1 && l3.globals.skipLastTimelinelabel && !l3.config.xaxis.labels.formatter || "radar" === l3.config.chart.type)) {
        l3.config.grid.xaxis.lines.show && this._drawGridLine({ i: e3, x1: i2, y1: a3, x2: s3, y2: r2, xCount: o3, parent: n3 });
        var h3 = 0;
        if (l3.globals.hasXaxisGroups && "between" === l3.config.xaxis.tickPlacement) {
          var c3 = l3.globals.groups;
          if (c3) {
            for (var d3 = 0, g3 = 0; d3 < e3 && g3 < c3.length; g3++) d3 += c3[g3].cols;
            d3 === e3 && (h3 = 0.6 * l3.globals.xAxisLabelsHeight);
          }
        }
        new V2(this.ctx).drawXaxisTicks(i2, h3, l3.globals.dom.elGraphical);
      }
    } }, { key: "_drawGridLine", value: function(t4) {
      var e3 = t4.i, i2 = t4.x1, a3 = t4.y1, s3 = t4.x2, r2 = t4.y2, o3 = t4.xCount, n3 = t4.parent, l3 = this.w, h3 = false, c3 = n3.node.classList.contains("apexcharts-gridlines-horizontal"), d3 = l3.config.grid.strokeDashArray, g3 = l3.globals.barPadForNumericAxis;
      (0 === a3 && 0 === r2 || 0 === i2 && 0 === s3) && (h3 = true), a3 === l3.globals.gridHeight && r2 === l3.globals.gridHeight && (h3 = true), !l3.globals.isBarHorizontal || 0 !== e3 && e3 !== o3 - 1 || (h3 = true);
      var u3 = new m2(this).drawLine(i2 - (c3 ? g3 : 0), a3, s3 + (c3 ? g3 : 0), r2, l3.config.grid.borderColor, d3);
      u3.node.classList.add("apexcharts-gridline"), h3 && l3.config.grid.show ? this.elGridBorders.add(u3) : n3.add(u3);
    } }, { key: "_drawGridBandRect", value: function(t4) {
      var e3 = t4.c, i2 = t4.x1, a3 = t4.y1, s3 = t4.x2, r2 = t4.y2, o3 = t4.type, n3 = this.w, l3 = new m2(this.ctx), h3 = n3.globals.barPadForNumericAxis;
      if ("column" !== o3 || "datetime" !== n3.config.xaxis.type) {
        var c3 = n3.config.grid[o3].colors[e3], d3 = l3.drawRect(i2 - ("row" === o3 ? h3 : 0), a3, s3 + ("row" === o3 ? 2 * h3 : 0), r2, 0, c3, n3.config.grid[o3].opacity);
        this.elg.add(d3), d3.attr("clip-path", "url(#gridRectMask".concat(n3.globals.cuid, ")")), d3.node.classList.add("apexcharts-grid-".concat(o3));
      }
    } }, { key: "_drawXYLines", value: function(t4) {
      var e3 = this, i2 = t4.xCount, a3 = t4.tickAmount, s3 = this.w;
      if (s3.config.grid.xaxis.lines.show || s3.config.xaxis.axisTicks.show) {
        var r2, o3 = s3.globals.padHorizontal, n3 = s3.globals.gridHeight;
        s3.globals.timescaleLabels.length ? function(t5) {
          for (var a4 = t5.xC, s4 = t5.x1, r3 = t5.y1, o4 = t5.x2, n4 = t5.y2, l4 = 0; l4 < a4; l4++) s4 = e3.xaxisLabels[l4].position, o4 = e3.xaxisLabels[l4].position, e3._drawGridLines({ i: l4, x1: s4, y1: r3, x2: o4, y2: n4, xCount: i2, parent: e3.elgridLinesV });
        }({ xC: i2, x1: o3, y1: 0, x2: r2, y2: n3 }) : (s3.globals.isXNumeric && (i2 = s3.globals.xAxisScale.result.length), function(t5) {
          for (var a4 = t5.xC, r3 = t5.x1, o4 = t5.y1, n4 = t5.x2, l4 = t5.y2, h4 = 0; h4 < a4 + (s3.globals.isXNumeric ? 0 : 1); h4++) 0 === h4 && 1 === a4 && 1 === s3.globals.dataPoints && (n4 = r3 = s3.globals.gridWidth / 2), e3._drawGridLines({ i: h4, x1: r3, y1: o4, x2: n4, y2: l4, xCount: i2, parent: e3.elgridLinesV }), n4 = r3 += s3.globals.gridWidth / (s3.globals.isXNumeric ? a4 - 1 : a4);
        }({ xC: i2, x1: o3, y1: 0, x2: r2, y2: n3 }));
      }
      if (s3.config.grid.yaxis.lines.show) {
        var l3 = 0, h3 = 0, c3 = s3.globals.gridWidth, d3 = a3 + 1;
        this.isRangeBar && (d3 = s3.globals.labels.length);
        for (var g3 = 0; g3 < d3 + (this.isRangeBar ? 1 : 0); g3++) this._drawGridLine({ i: g3, xCount: d3 + (this.isRangeBar ? 1 : 0), x1: 0, y1: l3, x2: c3, y2: h3, parent: this.elgridLinesH }), h3 = l3 += s3.globals.gridHeight / (this.isRangeBar ? d3 : a3);
      }
    } }, { key: "_drawInvertedXYLines", value: function(t4) {
      var e3 = t4.xCount, i2 = this.w;
      if (i2.config.grid.xaxis.lines.show || i2.config.xaxis.axisTicks.show) for (var a3, s3 = i2.globals.padHorizontal, r2 = i2.globals.gridHeight, o3 = 0; o3 < e3 + 1; o3++) {
        i2.config.grid.xaxis.lines.show && this._drawGridLine({ i: o3, xCount: e3 + 1, x1: s3, y1: 0, x2: a3, y2: r2, parent: this.elgridLinesV }), new V2(this.ctx).drawXaxisTicks(s3, 0, i2.globals.dom.elGraphical), a3 = s3 += i2.globals.gridWidth / e3;
      }
      if (i2.config.grid.yaxis.lines.show) for (var n3 = 0, l3 = 0, h3 = i2.globals.gridWidth, c3 = 0; c3 < i2.globals.dataPoints + 1; c3++) this._drawGridLine({ i: c3, xCount: i2.globals.dataPoints + 1, x1: 0, y1: n3, x2: h3, y2: l3, parent: this.elgridLinesH }), l3 = n3 += i2.globals.gridHeight / i2.globals.dataPoints;
    } }, { key: "renderGrid", value: function() {
      var t4 = this.w, e3 = t4.globals, i2 = new m2(this.ctx);
      this.elg = i2.group({ class: "apexcharts-grid" }), this.elgridLinesH = i2.group({ class: "apexcharts-gridlines-horizontal" }), this.elgridLinesV = i2.group({ class: "apexcharts-gridlines-vertical" }), this.elGridBorders = i2.group({ class: "apexcharts-grid-borders" }), this.elg.add(this.elgridLinesH), this.elg.add(this.elgridLinesV), t4.config.grid.show || (this.elgridLinesV.hide(), this.elgridLinesH.hide(), this.elGridBorders.hide());
      for (var a3 = 0; a3 < e3.seriesYAxisMap.length && -1 !== e3.ignoreYAxisIndexes.indexOf(a3); ) a3++;
      a3 === e3.seriesYAxisMap.length && (a3 = 0);
      var s3, r2 = e3.yAxisScale[a3].result.length - 1;
      if (!e3.isBarHorizontal || this.isRangeBar) {
        var o3, n3, l3;
        if (s3 = this.xaxisLabels.length, this.isRangeBar) r2 = e3.labels.length, t4.config.xaxis.tickAmount && t4.config.xaxis.labels.formatter && (s3 = t4.config.xaxis.tickAmount), (null === (o3 = e3.yAxisScale) || void 0 === o3 || null === (n3 = o3[a3]) || void 0 === n3 || null === (l3 = n3.result) || void 0 === l3 ? void 0 : l3.length) > 0 && "datetime" !== t4.config.xaxis.type && (s3 = e3.yAxisScale[a3].result.length - 1);
        this._drawXYLines({ xCount: s3, tickAmount: r2 });
      } else s3 = r2, r2 = e3.xTickAmount, this._drawInvertedXYLines({ xCount: s3, tickAmount: r2 });
      return this.drawGridBands(s3, r2), { el: this.elg, elGridBorders: this.elGridBorders, xAxisTickWidth: e3.gridWidth / s3 };
    } }, { key: "drawGridBands", value: function(t4, e3) {
      var i2 = this.w;
      if (void 0 !== i2.config.grid.row.colors && i2.config.grid.row.colors.length > 0) for (var a3 = 0, s3 = i2.globals.gridHeight / e3, r2 = i2.globals.gridWidth, o3 = 0, n3 = 0; o3 < e3; o3++, n3++) n3 >= i2.config.grid.row.colors.length && (n3 = 0), this._drawGridBandRect({ c: n3, x1: 0, y1: a3, x2: r2, y2: s3, type: "row" }), a3 += i2.globals.gridHeight / e3;
      if (void 0 !== i2.config.grid.column.colors && i2.config.grid.column.colors.length > 0) for (var l3 = i2.globals.isBarHorizontal || "on" !== i2.config.xaxis.tickPlacement || "category" !== i2.config.xaxis.type && !i2.config.xaxis.convertedCatToNumeric ? t4 : t4 - 1, h3 = i2.globals.padHorizontal, c3 = i2.globals.padHorizontal + i2.globals.gridWidth / l3, d3 = i2.globals.gridHeight, g3 = 0, u3 = 0; g3 < t4; g3++, u3++) u3 >= i2.config.grid.column.colors.length && (u3 = 0), this._drawGridBandRect({ c: u3, x1: h3, y1: 0, x2: c3, y2: d3, type: "column" }), h3 += i2.globals.gridWidth / l3;
    } }]), t3;
  }(), _2 = function() {
    function t3(e3) {
      a2(this, t3), this.ctx = e3, this.w = e3.w;
    }
    return r(t3, [{ key: "niceScale", value: function(t4, e3) {
      var i2, a3, s3, r2, o3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, n3 = 1e-11, l3 = this.w, h3 = l3.globals;
      h3.isBarHorizontal ? (i2 = l3.config.xaxis, a3 = Math.max((h3.svgWidth - 100) / 25, 2)) : (i2 = l3.config.yaxis[o3], a3 = Math.max((h3.svgHeight - 100) / 15, 2)), s3 = void 0 !== i2.min && null !== i2.min, r2 = void 0 !== i2.max && null !== i2.min;
      var c3 = void 0 !== i2.stepSize && null !== i2.stepSize, d3 = void 0 !== i2.tickAmount && null !== i2.tickAmount, g3 = d3 ? i2.tickAmount : i2.forceNiceScale ? h3.niceScaleDefaultTicks[Math.min(Math.round(a3 / 2), h3.niceScaleDefaultTicks.length - 1)] : 10;
      if (h3.isMultipleYAxis && !d3 && h3.multiAxisTickAmount > 0 && (g3 = h3.multiAxisTickAmount, d3 = true), g3 = "dataPoints" === g3 ? h3.dataPoints - 1 : Math.abs(Math.round(g3)), (t4 === Number.MIN_VALUE && 0 === e3 || !x2.isNumber(t4) && !x2.isNumber(e3) || t4 === Number.MIN_VALUE && e3 === -Number.MAX_VALUE) && (t4 = x2.isNumber(i2.min) ? i2.min : 0, e3 = x2.isNumber(i2.max) ? i2.max : t4 + g3, h3.allSeriesCollapsed = false), t4 > e3) {
        console.warn("axis.min cannot be greater than axis.max: swapping min and max");
        var u3 = e3;
        e3 = t4, t4 = u3;
      } else t4 === e3 && (t4 = 0 === t4 ? 0 : t4 - 1, e3 = 0 === e3 ? 2 : e3 + 1);
      var p3 = [];
      g3 < 1 && (g3 = 1);
      var f3 = g3, b3 = Math.abs(e3 - t4);
      if (i2.forceNiceScale) {
        !s3 && t4 > 0 && t4 / b3 < 0.15 && (t4 = 0, s3 = true), !r2 && e3 < 0 && -e3 / b3 < 0.15 && (e3 = 0, r2 = true), b3 = Math.abs(e3 - t4);
      }
      var v3 = b3 / f3, m3 = v3, y3 = Math.floor(Math.log10(m3)), w3 = Math.pow(10, y3), k3 = Math.ceil(m3 / w3);
      if (v3 = m3 = (k3 = h3.niceScaleAllowedMagMsd[0 === h3.yValueDecimal ? 0 : 1][k3]) * w3, h3.isBarHorizontal && i2.stepSize && "datetime" !== i2.type ? (v3 = i2.stepSize, c3 = true) : c3 && (v3 = i2.stepSize), c3 && i2.forceNiceScale) {
        var A3 = Math.floor(Math.log10(v3));
        v3 *= Math.pow(10, y3 - A3);
      }
      if (s3 && r2) {
        var S3 = b3 / f3;
        if (d3) if (c3) if (0 != x2.mod(b3, v3)) {
          var C3 = x2.getGCD(v3, S3);
          v3 = S3 / C3 < 10 ? C3 : S3;
        } else 0 == x2.mod(v3, S3) ? v3 = S3 : (S3 = v3, d3 = false);
        else v3 = S3;
        else if (c3) 0 == x2.mod(b3, v3) ? S3 = v3 : v3 = S3;
        else if (0 == x2.mod(b3, v3)) S3 = v3;
        else {
          S3 = b3 / (f3 = Math.ceil(b3 / v3));
          var L3 = x2.getGCD(b3, v3);
          b3 / L3 < a3 && (S3 = L3), v3 = S3;
        }
        f3 = Math.round(b3 / v3);
      } else {
        if (s3 || r2) {
          if (r2) if (d3) t4 = e3 - v3 * f3;
          else {
            var P3 = t4;
            t4 = v3 * Math.floor(t4 / v3), Math.abs(e3 - t4) / x2.getGCD(b3, v3) > a3 && (t4 = e3 - v3 * g3, t4 += v3 * Math.floor((P3 - t4) / v3));
          }
          else if (s3) if (d3) e3 = t4 + v3 * f3;
          else {
            var M3 = e3;
            e3 = v3 * Math.ceil(e3 / v3), Math.abs(e3 - t4) / x2.getGCD(b3, v3) > a3 && (e3 = t4 + v3 * g3, e3 += v3 * Math.ceil((M3 - e3) / v3));
          }
        } else if (d3) {
          var I3 = v3 / (e3 - t4 > e3 ? 1 : 2), T3 = I3 * Math.floor(t4 / I3);
          Math.abs(T3 - t4) <= I3 / 2 ? e3 = (t4 = T3) + v3 * f3 : t4 = (e3 = I3 * Math.ceil(e3 / I3)) - v3 * f3;
        } else t4 = v3 * Math.floor(t4 / v3), e3 = v3 * Math.ceil(e3 / v3);
        b3 = Math.abs(e3 - t4), v3 = x2.getGCD(b3, v3), f3 = Math.round(b3 / v3);
      }
      if (d3 || s3 || r2 || (f3 = Math.ceil((b3 - n3) / (v3 + n3))) > 16 && x2.getPrimeFactors(f3).length < 2 && f3++, !d3 && i2.forceNiceScale && 0 === h3.yValueDecimal && f3 > b3 && (f3 = b3, v3 = Math.round(b3 / f3)), f3 > a3 && (!d3 && !c3 || i2.forceNiceScale)) {
        var z3 = x2.getPrimeFactors(f3), X3 = z3.length - 1, E3 = f3;
        t: for (var Y3 = 0; Y3 < X3; Y3++) for (var F3 = 0; F3 <= X3 - Y3; F3++) {
          for (var R3 = Math.min(F3 + Y3, X3), H5 = E3, D3 = 1, O3 = F3; O3 <= R3; O3++) D3 *= z3[O3];
          if ((H5 /= D3) < a3) {
            E3 = H5;
            break t;
          }
        }
        v3 = E3 === f3 ? b3 : b3 / E3, f3 = Math.round(b3 / v3);
      }
      h3.isMultipleYAxis && 0 == h3.multiAxisTickAmount && h3.ignoreYAxisIndexes.indexOf(o3) < 0 && (h3.multiAxisTickAmount = f3);
      var N3 = t4 - v3, W3 = v3 * n3;
      do {
        N3 += v3, p3.push(x2.stripNumber(N3, 7));
      } while (e3 - N3 > W3);
      return { result: p3, niceMin: p3[0], niceMax: p3[p3.length - 1] };
    } }, { key: "linearScale", value: function(t4, e3) {
      var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10, a3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, s3 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : void 0, r2 = Math.abs(e3 - t4);
      "dataPoints" === (i2 = this._adjustTicksForSmallRange(i2, a3, r2)) && (i2 = this.w.globals.dataPoints - 1), s3 || (s3 = r2 / i2), i2 === Number.MAX_VALUE && (i2 = 5, s3 = 1);
      for (var o3 = [], n3 = t4; i2 >= 0; ) o3.push(n3), n3 += s3, i2 -= 1;
      return { result: o3, niceMin: o3[0], niceMax: o3[o3.length - 1] };
    } }, { key: "logarithmicScaleNice", value: function(t4, e3, i2) {
      e3 <= 0 && (e3 = Math.max(t4, i2)), t4 <= 0 && (t4 = Math.min(e3, i2));
      for (var a3 = [], s3 = Math.ceil(Math.log(e3) / Math.log(i2) + 1), r2 = Math.floor(Math.log(t4) / Math.log(i2)); r2 < s3; r2++) a3.push(Math.pow(i2, r2));
      return { result: a3, niceMin: a3[0], niceMax: a3[a3.length - 1] };
    } }, { key: "logarithmicScale", value: function(t4, e3, i2) {
      e3 <= 0 && (e3 = Math.max(t4, i2)), t4 <= 0 && (t4 = Math.min(e3, i2));
      for (var a3 = [], s3 = Math.log(e3) / Math.log(i2), r2 = Math.log(t4) / Math.log(i2), o3 = s3 - r2, n3 = Math.round(o3), l3 = o3 / n3, h3 = 0, c3 = r2; h3 < n3; h3++, c3 += l3) a3.push(Math.pow(i2, c3));
      return a3.push(Math.pow(i2, s3)), { result: a3, niceMin: t4, niceMax: e3 };
    } }, { key: "_adjustTicksForSmallRange", value: function(t4, e3, i2) {
      var a3 = t4;
      if (void 0 !== e3 && this.w.config.yaxis[e3].labels.formatter && void 0 === this.w.config.yaxis[e3].tickAmount) {
        var s3 = Number(this.w.config.yaxis[e3].labels.formatter(1));
        x2.isNumber(s3) && 0 === this.w.globals.yValueDecimal && (a3 = Math.ceil(i2));
      }
      return a3 < t4 ? a3 : t4;
    } }, { key: "setYScaleForIndex", value: function(t4, e3, i2) {
      var a3 = this.w.globals, s3 = this.w.config, r2 = a3.isBarHorizontal ? s3.xaxis : s3.yaxis[t4];
      void 0 === a3.yAxisScale[t4] && (a3.yAxisScale[t4] = []);
      var o3 = Math.abs(i2 - e3);
      r2.logarithmic && o3 <= 5 && (a3.invalidLogScale = true), r2.logarithmic && o3 > 5 ? (a3.allSeriesCollapsed = false, a3.yAxisScale[t4] = r2.forceNiceScale ? this.logarithmicScaleNice(e3, i2, r2.logBase) : this.logarithmicScale(e3, i2, r2.logBase)) : i2 !== -Number.MAX_VALUE && x2.isNumber(i2) && e3 !== Number.MAX_VALUE && x2.isNumber(e3) ? (a3.allSeriesCollapsed = false, a3.yAxisScale[t4] = this.niceScale(e3, i2, t4)) : a3.yAxisScale[t4] = this.niceScale(Number.MIN_VALUE, 0, t4);
    } }, { key: "setXScale", value: function(t4, e3) {
      var i2 = this.w, a3 = i2.globals, s3 = Math.abs(e3 - t4);
      return e3 !== -Number.MAX_VALUE && x2.isNumber(e3) ? a3.xAxisScale = this.linearScale(t4, e3, i2.config.xaxis.tickAmount ? i2.config.xaxis.tickAmount : s3 < 10 && s3 > 1 ? s3 + 1 : 10, 0, i2.config.xaxis.stepSize) : a3.xAxisScale = this.linearScale(0, 10, 10), a3.xAxisScale;
    } }, { key: "setSeriesYAxisMappings", value: function() {
      var t4 = this.w.globals, e3 = this.w.config, i2 = [], a3 = [], s3 = [], r2 = t4.series.length > e3.yaxis.length || e3.yaxis.some(function(t5) {
        return Array.isArray(t5.seriesName);
      });
      e3.series.forEach(function(t5, e4) {
        s3.push(e4), a3.push(null);
      }), e3.yaxis.forEach(function(t5, e4) {
        i2[e4] = [];
      });
      var o3 = [];
      e3.yaxis.forEach(function(t5, a4) {
        var n4 = false;
        if (t5.seriesName) {
          var l4 = [];
          Array.isArray(t5.seriesName) ? l4 = t5.seriesName : l4.push(t5.seriesName), l4.forEach(function(t6) {
            e3.series.forEach(function(e4, o4) {
              if (e4.name === t6) {
                var l5 = o4;
                a4 === o4 || r2 ? !r2 || s3.indexOf(o4) > -1 ? i2[a4].push([a4, o4]) : console.warn("Series '" + e4.name + "' referenced more than once in what looks like the new style. That is, when using either seriesName: [], or when there are more series than yaxes.") : (i2[o4].push([o4, a4]), l5 = a4), n4 = true, -1 !== (l5 = s3.indexOf(l5)) && s3.splice(l5, 1);
              }
            });
          });
        }
        n4 || o3.push(a4);
      }), i2 = i2.map(function(t5, e4) {
        var i3 = [];
        return t5.forEach(function(t6) {
          a3[t6[1]] = t6[0], i3.push(t6[1]);
        }), i3;
      });
      for (var n3 = e3.yaxis.length - 1, l3 = 0; l3 < o3.length && (n3 = o3[l3], i2[n3] = [], s3); l3++) {
        var h3 = s3[0];
        s3.shift(), i2[n3].push(h3), a3[h3] = n3;
      }
      s3.forEach(function(t5) {
        i2[n3].push(t5), a3[t5] = n3;
      }), t4.seriesYAxisMap = i2.map(function(t5) {
        return t5;
      }), t4.seriesYAxisReverseMap = a3.map(function(t5) {
        return t5;
      });
    } }, { key: "scaleMultipleYAxes", value: function() {
      var t4 = this, e3 = this.w.config, i2 = this.w.globals;
      this.setSeriesYAxisMappings();
      var a3 = i2.seriesYAxisMap, s3 = i2.minYArr, r2 = i2.maxYArr;
      i2.allSeriesCollapsed = true, i2.barGroups = [], a3.forEach(function(a4, o3) {
        var n3 = [];
        a4.forEach(function(t5) {
          var i3 = e3.series[t5].group;
          n3.indexOf(i3) < 0 && n3.push(i3);
        }), a4.length > 0 ? function() {
          var l3, h3, c3 = Number.MAX_VALUE, d3 = -Number.MAX_VALUE, g3 = c3, u3 = d3;
          if (e3.chart.stacked) !function() {
            var t5 = i2.seriesX[a4[0]], s4 = [], r3 = [], p4 = [];
            n3.forEach(function() {
              s4.push(t5.map(function() {
                return Number.MIN_VALUE;
              })), r3.push(t5.map(function() {
                return Number.MIN_VALUE;
              })), p4.push(t5.map(function() {
                return Number.MIN_VALUE;
              }));
            });
            for (var f4 = function(t6) {
              !l3 && e3.series[a4[t6]].type && (l3 = e3.series[a4[t6]].type);
              var c4 = a4[t6];
              h3 = e3.series[c4].group ? e3.series[c4].group : "axis-".concat(o3), !(i2.collapsedSeriesIndices.indexOf(c4) < 0 && i2.ancillaryCollapsedSeriesIndices.indexOf(c4) < 0) || (i2.allSeriesCollapsed = false, n3.forEach(function(t7, a5) {
                if (e3.series[c4].group === t7) for (var o4 = 0; o4 < i2.series[c4].length; o4++) {
                  var n4 = i2.series[c4][o4];
                  n4 >= 0 ? r3[a5][o4] += n4 : p4[a5][o4] += n4, s4[a5][o4] += n4, g3 = Math.min(g3, n4), u3 = Math.max(u3, n4);
                }
              })), "bar" !== l3 && "column" !== l3 || i2.barGroups.push(h3);
            }, x3 = 0; x3 < a4.length; x3++) f4(x3);
            l3 || (l3 = e3.chart.type), "bar" === l3 || "column" === l3 ? n3.forEach(function(t6, e4) {
              c3 = Math.min(c3, Math.min.apply(null, p4[e4])), d3 = Math.max(d3, Math.max.apply(null, r3[e4]));
            }) : (n3.forEach(function(t6, e4) {
              g3 = Math.min(g3, Math.min.apply(null, s4[e4])), u3 = Math.max(u3, Math.max.apply(null, s4[e4]));
            }), c3 = g3, d3 = u3), c3 === Number.MIN_VALUE && d3 === Number.MIN_VALUE && (d3 = -Number.MAX_VALUE);
          }();
          else for (var p3 = 0; p3 < a4.length; p3++) {
            var f3 = a4[p3];
            c3 = Math.min(c3, s3[f3]), d3 = Math.max(d3, r2[f3]), !(i2.collapsedSeriesIndices.indexOf(f3) < 0 && i2.ancillaryCollapsedSeriesIndices.indexOf(f3) < 0) || (i2.allSeriesCollapsed = false);
          }
          void 0 !== e3.yaxis[o3].min && (c3 = "function" == typeof e3.yaxis[o3].min ? e3.yaxis[o3].min(c3) : e3.yaxis[o3].min), void 0 !== e3.yaxis[o3].max && (d3 = "function" == typeof e3.yaxis[o3].max ? e3.yaxis[o3].max(d3) : e3.yaxis[o3].max), i2.barGroups = i2.barGroups.filter(function(t5, e4, i3) {
            return i3.indexOf(t5) === e4;
          }), t4.setYScaleForIndex(o3, c3, d3), a4.forEach(function(t5) {
            s3[t5] = i2.yAxisScale[o3].niceMin, r2[t5] = i2.yAxisScale[o3].niceMax;
          });
        }() : t4.setYScaleForIndex(o3, 0, -Number.MAX_VALUE);
      });
    } }]), t3;
  }(), U2 = function() {
    function t3(e3) {
      a2(this, t3), this.ctx = e3, this.w = e3.w, this.scales = new _2(e3);
    }
    return r(t3, [{ key: "init", value: function() {
      this.setYRange(), this.setXRange(), this.setZRange();
    } }, { key: "getMinYMaxY", value: function(t4) {
      var e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -Number.MAX_VALUE, a3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, s3 = this.w.config, r2 = this.w.globals, o3 = -Number.MAX_VALUE, n3 = Number.MIN_VALUE;
      null === a3 && (a3 = t4 + 1);
      var l3 = 0, h3 = 0, c3 = void 0;
      if (r2.seriesX.length >= a3) {
        var d3, g3;
        l3 = 0, h3 = (c3 = u2(new Set((d3 = []).concat.apply(d3, u2(r2.seriesX.slice(t4, a3)))))).length - 1;
        var p3 = null === (g3 = r2.brushSource) || void 0 === g3 ? void 0 : g3.w.config.chart.brush;
        if (s3.chart.zoom.enabled && s3.chart.zoom.autoScaleYaxis || null != p3 && p3.enabled && null != p3 && p3.autoScaleYaxis) {
          if (s3.xaxis.min) for (l3 = 0; l3 < h3 && c3[l3] < s3.xaxis.min; l3++) ;
          if (s3.xaxis.max) for (; h3 > l3 && c3[h3] > s3.xaxis.max; h3--) ;
        }
      }
      var f3 = r2.series, b3 = f3, v3 = f3;
      "candlestick" === s3.chart.type ? (b3 = r2.seriesCandleL, v3 = r2.seriesCandleH) : "boxPlot" === s3.chart.type ? (b3 = r2.seriesCandleO, v3 = r2.seriesCandleC) : r2.isRangeData && (b3 = r2.seriesRangeStart, v3 = r2.seriesRangeEnd);
      for (var m3 = t4; m3 < a3; m3++) {
        r2.dataPoints = Math.max(r2.dataPoints, f3[m3].length);
        var y3 = s3.series[m3].type;
        r2.categoryLabels.length && (r2.dataPoints = r2.categoryLabels.filter(function(t5) {
          return void 0 !== t5;
        }).length), r2.labels.length && "datetime" !== s3.xaxis.type && 0 !== r2.series.reduce(function(t5, e4) {
          return t5 + e4.length;
        }, 0) && (r2.dataPoints = Math.max(r2.dataPoints, r2.labels.length)), c3 || (l3 = 0, h3 = r2.series[m3].length);
        for (var w3 = l3; w3 <= h3 && w3 < r2.series[m3].length; w3++) {
          var k3 = f3[m3][w3];
          if (null !== k3 && x2.isNumber(k3)) {
            switch (void 0 !== v3[m3][w3] && (o3 = Math.max(o3, v3[m3][w3]), e3 = Math.min(e3, v3[m3][w3])), void 0 !== b3[m3][w3] && (e3 = Math.min(e3, b3[m3][w3]), i2 = Math.max(i2, b3[m3][w3])), y3) {
              case "candlestick":
                void 0 !== r2.seriesCandleC[m3][w3] && (o3 = Math.max(o3, r2.seriesCandleH[m3][w3]), e3 = Math.min(e3, r2.seriesCandleL[m3][w3]));
                break;
              case "boxPlot":
                void 0 !== r2.seriesCandleC[m3][w3] && (o3 = Math.max(o3, r2.seriesCandleC[m3][w3]), e3 = Math.min(e3, r2.seriesCandleO[m3][w3]));
            }
            y3 && "candlestick" !== y3 && "boxPlot" !== y3 && "rangeArea" !== y3 && "rangeBar" !== y3 && (o3 = Math.max(o3, r2.series[m3][w3]), e3 = Math.min(e3, r2.series[m3][w3])), i2 = o3, r2.seriesGoals[m3] && r2.seriesGoals[m3][w3] && Array.isArray(r2.seriesGoals[m3][w3]) && r2.seriesGoals[m3][w3].forEach(function(t5) {
              n3 !== Number.MIN_VALUE && (n3 = Math.min(n3, t5.value), e3 = n3), o3 = Math.max(o3, t5.value), i2 = o3;
            }), x2.isFloat(k3) && (k3 = x2.noExponents(k3), r2.yValueDecimal = Math.max(r2.yValueDecimal, k3.toString().split(".")[1].length)), n3 > b3[m3][w3] && b3[m3][w3] < 0 && (n3 = b3[m3][w3]);
          } else r2.hasNullValues = true;
        }
        "bar" !== y3 && "column" !== y3 || (n3 < 0 && o3 < 0 && (o3 = 0, i2 = Math.max(i2, 0)), n3 === Number.MIN_VALUE && (n3 = 0, e3 = Math.min(e3, 0)));
      }
      return "rangeBar" === s3.chart.type && r2.seriesRangeStart.length && r2.isBarHorizontal && (n3 = e3), "bar" === s3.chart.type && (n3 < 0 && o3 < 0 && (o3 = 0), n3 === Number.MIN_VALUE && (n3 = 0)), { minY: n3, maxY: o3, lowestY: e3, highestY: i2 };
    } }, { key: "setYRange", value: function() {
      var t4 = this.w.globals, e3 = this.w.config;
      t4.maxY = -Number.MAX_VALUE, t4.minY = Number.MIN_VALUE;
      var i2, a3 = Number.MAX_VALUE;
      if (t4.isMultipleYAxis) {
        a3 = Number.MAX_VALUE;
        for (var s3 = 0; s3 < t4.series.length; s3++) i2 = this.getMinYMaxY(s3), t4.minYArr[s3] = i2.lowestY, t4.maxYArr[s3] = i2.highestY, a3 = Math.min(a3, i2.lowestY);
      }
      if (i2 = this.getMinYMaxY(0, a3, null, t4.series.length), "bar" === e3.chart.type ? (t4.minY = i2.minY, t4.maxY = i2.maxY) : (t4.minY = i2.lowestY, t4.maxY = i2.highestY), a3 = i2.lowestY, e3.chart.stacked && this._setStackedMinMax(), "line" === e3.chart.type || "area" === e3.chart.type || "scatter" === e3.chart.type || "candlestick" === e3.chart.type || "boxPlot" === e3.chart.type || "rangeBar" === e3.chart.type && !t4.isBarHorizontal ? t4.minY === Number.MIN_VALUE && a3 !== -Number.MAX_VALUE && a3 !== t4.maxY && (t4.minY = a3) : t4.minY = i2.minY, e3.yaxis.forEach(function(e4, i3) {
        void 0 !== e4.max && ("number" == typeof e4.max ? t4.maxYArr[i3] = e4.max : "function" == typeof e4.max && (t4.maxYArr[i3] = e4.max(t4.isMultipleYAxis ? t4.maxYArr[i3] : t4.maxY)), t4.maxY = t4.maxYArr[i3]), void 0 !== e4.min && ("number" == typeof e4.min ? t4.minYArr[i3] = e4.min : "function" == typeof e4.min && (t4.minYArr[i3] = e4.min(t4.isMultipleYAxis ? t4.minYArr[i3] === Number.MIN_VALUE ? 0 : t4.minYArr[i3] : t4.minY)), t4.minY = t4.minYArr[i3]);
      }), t4.isBarHorizontal) {
        ["min", "max"].forEach(function(i3) {
          void 0 !== e3.xaxis[i3] && "number" == typeof e3.xaxis[i3] && ("min" === i3 ? t4.minY = e3.xaxis[i3] : t4.maxY = e3.xaxis[i3]);
        });
      }
      return t4.isMultipleYAxis ? (this.scales.scaleMultipleYAxes(), t4.minY = a3) : (this.scales.setYScaleForIndex(0, t4.minY, t4.maxY), t4.minY = t4.yAxisScale[0].niceMin, t4.maxY = t4.yAxisScale[0].niceMax, t4.minYArr[0] = t4.minY, t4.maxYArr[0] = t4.maxY), t4.barGroups = [], t4.lineGroups = [], t4.areaGroups = [], e3.series.forEach(function(i3) {
        switch (i3.type || e3.chart.type) {
          case "bar":
          case "column":
            t4.barGroups.push(i3.group);
            break;
          case "line":
            t4.lineGroups.push(i3.group);
            break;
          case "area":
            t4.areaGroups.push(i3.group);
        }
      }), t4.barGroups = t4.barGroups.filter(function(t5, e4, i3) {
        return i3.indexOf(t5) === e4;
      }), t4.lineGroups = t4.lineGroups.filter(function(t5, e4, i3) {
        return i3.indexOf(t5) === e4;
      }), t4.areaGroups = t4.areaGroups.filter(function(t5, e4, i3) {
        return i3.indexOf(t5) === e4;
      }), { minY: t4.minY, maxY: t4.maxY, minYArr: t4.minYArr, maxYArr: t4.maxYArr, yAxisScale: t4.yAxisScale };
    } }, { key: "setXRange", value: function() {
      var t4 = this.w.globals, e3 = this.w.config, i2 = "numeric" === e3.xaxis.type || "datetime" === e3.xaxis.type || "category" === e3.xaxis.type && !t4.noLabelsProvided || t4.noLabelsProvided || t4.isXNumeric;
      if (t4.isXNumeric && function() {
        for (var e4 = 0; e4 < t4.series.length; e4++) if (t4.labels[e4]) for (var i3 = 0; i3 < t4.labels[e4].length; i3++) null !== t4.labels[e4][i3] && x2.isNumber(t4.labels[e4][i3]) && (t4.maxX = Math.max(t4.maxX, t4.labels[e4][i3]), t4.initialMaxX = Math.max(t4.maxX, t4.labels[e4][i3]), t4.minX = Math.min(t4.minX, t4.labels[e4][i3]), t4.initialMinX = Math.min(t4.minX, t4.labels[e4][i3]));
      }(), t4.noLabelsProvided && 0 === e3.xaxis.categories.length && (t4.maxX = t4.labels[t4.labels.length - 1], t4.initialMaxX = t4.labels[t4.labels.length - 1], t4.minX = 1, t4.initialMinX = 1), t4.isXNumeric || t4.noLabelsProvided || t4.dataFormatXNumeric) {
        var a3;
        if (void 0 === e3.xaxis.tickAmount ? (a3 = Math.round(t4.svgWidth / 150), "numeric" === e3.xaxis.type && t4.dataPoints < 30 && (a3 = t4.dataPoints - 1), a3 > t4.dataPoints && 0 !== t4.dataPoints && (a3 = t4.dataPoints - 1)) : "dataPoints" === e3.xaxis.tickAmount ? (t4.series.length > 1 && (a3 = t4.series[t4.maxValsInArrayIndex].length - 1), t4.isXNumeric && (a3 = t4.maxX - t4.minX - 1)) : a3 = e3.xaxis.tickAmount, t4.xTickAmount = a3, void 0 !== e3.xaxis.max && "number" == typeof e3.xaxis.max && (t4.maxX = e3.xaxis.max), void 0 !== e3.xaxis.min && "number" == typeof e3.xaxis.min && (t4.minX = e3.xaxis.min), void 0 !== e3.xaxis.range && (t4.minX = t4.maxX - e3.xaxis.range), t4.minX !== Number.MAX_VALUE && t4.maxX !== -Number.MAX_VALUE) if (e3.xaxis.convertedCatToNumeric && !t4.dataFormatXNumeric) {
          for (var s3 = [], r2 = t4.minX - 1; r2 < t4.maxX; r2++) s3.push(r2 + 1);
          t4.xAxisScale = { result: s3, niceMin: s3[0], niceMax: s3[s3.length - 1] };
        } else t4.xAxisScale = this.scales.setXScale(t4.minX, t4.maxX);
        else t4.xAxisScale = this.scales.linearScale(0, a3, a3, 0, e3.xaxis.stepSize), t4.noLabelsProvided && t4.labels.length > 0 && (t4.xAxisScale = this.scales.linearScale(1, t4.labels.length, a3 - 1, 0, e3.xaxis.stepSize), t4.seriesX = t4.labels.slice());
        i2 && (t4.labels = t4.xAxisScale.result.slice());
      }
      return t4.isBarHorizontal && t4.labels.length && (t4.xTickAmount = t4.labels.length), this._handleSingleDataPoint(), this._getMinXDiff(), { minX: t4.minX, maxX: t4.maxX };
    } }, { key: "setZRange", value: function() {
      var t4 = this.w.globals;
      if (t4.isDataXYZ) {
        for (var e3 = 0; e3 < t4.series.length; e3++) if (void 0 !== t4.seriesZ[e3]) for (var i2 = 0; i2 < t4.seriesZ[e3].length; i2++) null !== t4.seriesZ[e3][i2] && x2.isNumber(t4.seriesZ[e3][i2]) && (t4.maxZ = Math.max(t4.maxZ, t4.seriesZ[e3][i2]), t4.minZ = Math.min(t4.minZ, t4.seriesZ[e3][i2]));
      }
    } }, { key: "_handleSingleDataPoint", value: function() {
      var t4 = this.w.globals, e3 = this.w.config;
      if (t4.minX === t4.maxX) {
        var i2 = new A2(this.ctx);
        if ("datetime" === e3.xaxis.type) {
          var a3 = i2.getDate(t4.minX);
          e3.xaxis.labels.datetimeUTC ? a3.setUTCDate(a3.getUTCDate() - 2) : a3.setDate(a3.getDate() - 2), t4.minX = new Date(a3).getTime();
          var s3 = i2.getDate(t4.maxX);
          e3.xaxis.labels.datetimeUTC ? s3.setUTCDate(s3.getUTCDate() + 2) : s3.setDate(s3.getDate() + 2), t4.maxX = new Date(s3).getTime();
        } else ("numeric" === e3.xaxis.type || "category" === e3.xaxis.type && !t4.noLabelsProvided) && (t4.minX = t4.minX - 2, t4.initialMinX = t4.minX, t4.maxX = t4.maxX + 2, t4.initialMaxX = t4.maxX);
      }
    } }, { key: "_getMinXDiff", value: function() {
      var t4 = this.w.globals;
      t4.isXNumeric && t4.seriesX.forEach(function(e3, i2) {
        1 === e3.length && e3.push(t4.seriesX[t4.maxValsInArrayIndex][t4.seriesX[t4.maxValsInArrayIndex].length - 1]);
        var a3 = e3.slice();
        a3.sort(function(t5, e4) {
          return t5 - e4;
        }), a3.forEach(function(e4, i3) {
          if (i3 > 0) {
            var s3 = e4 - a3[i3 - 1];
            s3 > 0 && (t4.minXDiff = Math.min(s3, t4.minXDiff));
          }
        }), 1 !== t4.dataPoints && t4.minXDiff !== Number.MAX_VALUE || (t4.minXDiff = 0.5);
      });
    } }, { key: "_setStackedMinMax", value: function() {
      var t4 = this, e3 = this.w.globals;
      if (e3.series.length) {
        var i2 = e3.seriesGroups;
        i2.length || (i2 = [this.w.globals.seriesNames.map(function(t5) {
          return t5;
        })]);
        var a3 = {}, s3 = {};
        i2.forEach(function(i3) {
          a3[i3] = [], s3[i3] = [], t4.w.config.series.map(function(t5, a4) {
            return i3.indexOf(e3.seriesNames[a4]) > -1 ? a4 : null;
          }).filter(function(t5) {
            return null !== t5;
          }).forEach(function(r2) {
            for (var o3 = 0; o3 < e3.series[e3.maxValsInArrayIndex].length; o3++) {
              var n3, l3, h3, c3;
              void 0 === a3[i3][o3] && (a3[i3][o3] = 0, s3[i3][o3] = 0), (t4.w.config.chart.stacked && !e3.comboCharts || t4.w.config.chart.stacked && e3.comboCharts && (!t4.w.config.chart.stackOnlyBar || "bar" === (null === (n3 = t4.w.config.series) || void 0 === n3 || null === (l3 = n3[r2]) || void 0 === l3 ? void 0 : l3.type) || "column" === (null === (h3 = t4.w.config.series) || void 0 === h3 || null === (c3 = h3[r2]) || void 0 === c3 ? void 0 : c3.type))) && null !== e3.series[r2][o3] && x2.isNumber(e3.series[r2][o3]) && (e3.series[r2][o3] > 0 ? a3[i3][o3] += parseFloat(e3.series[r2][o3]) + 1e-4 : s3[i3][o3] += parseFloat(e3.series[r2][o3]));
            }
          });
        }), Object.entries(a3).forEach(function(t5) {
          var i3 = g2(t5, 1)[0];
          a3[i3].forEach(function(t6, r2) {
            e3.maxY = Math.max(e3.maxY, a3[i3][r2]), e3.minY = Math.min(e3.minY, s3[i3][r2]);
          });
        });
      }
    } }]), t3;
  }(), q2 = function() {
    function t3(e3, i2) {
      a2(this, t3), this.ctx = e3, this.elgrid = i2, this.w = e3.w;
      var s3 = this.w;
      this.xaxisFontSize = s3.config.xaxis.labels.style.fontSize, this.axisFontFamily = s3.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = s3.config.xaxis.labels.style.colors, this.isCategoryBarHorizontal = "bar" === s3.config.chart.type && s3.config.plotOptions.bar.horizontal, this.xAxisoffX = 0, "bottom" === s3.config.xaxis.position && (this.xAxisoffX = s3.globals.gridHeight), this.drawnLabels = [], this.axesUtils = new C2(e3);
    }
    return r(t3, [{ key: "drawYaxis", value: function(t4) {
      var e3 = this, i2 = this.w, a3 = new m2(this.ctx), s3 = i2.config.yaxis[t4].labels.style, r2 = s3.fontSize, o3 = s3.fontFamily, n3 = s3.fontWeight, l3 = a3.group({ class: "apexcharts-yaxis", rel: t4, transform: "translate(" + i2.globals.translateYAxisX[t4] + ", 0)" });
      if (this.axesUtils.isYAxisHidden(t4)) return l3;
      var h3 = a3.group({ class: "apexcharts-yaxis-texts-g" });
      l3.add(h3);
      var c3 = i2.globals.yAxisScale[t4].result.length - 1, d3 = i2.globals.gridHeight / c3, g3 = i2.globals.yLabelFormatters[t4], u3 = i2.globals.yAxisScale[t4].result.slice();
      u3 = this.axesUtils.checkForReversedLabels(t4, u3);
      var p3 = "";
      if (i2.config.yaxis[t4].labels.show) {
        var f3 = i2.globals.translateY + i2.config.yaxis[t4].labels.offsetY;
        i2.globals.isBarHorizontal ? f3 = 0 : "heatmap" === i2.config.chart.type && (f3 -= d3 / 2), f3 += parseInt(i2.config.yaxis[t4].labels.style.fontSize, 10) / 3;
        for (var x3 = function(l4) {
          var x4 = u3[l4];
          x4 = g3(x4, l4, i2);
          var b4 = i2.config.yaxis[t4].labels.padding;
          i2.config.yaxis[t4].opposite && 0 !== i2.config.yaxis.length && (b4 *= -1);
          var v4 = "end";
          i2.config.yaxis[t4].opposite && (v4 = "start"), "left" === i2.config.yaxis[t4].labels.align ? v4 = "start" : "center" === i2.config.yaxis[t4].labels.align ? v4 = "middle" : "right" === i2.config.yaxis[t4].labels.align && (v4 = "end");
          var m3 = e3.axesUtils.getYAxisForeColor(s3.colors, t4), y4 = a3.drawText({ x: b4, y: f3, text: x4, textAnchor: v4, fontSize: r2, fontFamily: o3, fontWeight: n3, maxWidth: i2.config.yaxis[t4].labels.maxWidth, foreColor: Array.isArray(m3) ? m3[l4] : m3, isPlainText: false, cssClass: "apexcharts-yaxis-label " + s3.cssClass });
          l4 === c3 && (p3 = y4), h3.add(y4);
          var w4 = document.createElementNS(i2.globals.SVGNS, "title");
          if (w4.textContent = Array.isArray(x4) ? x4.join(" ") : x4, y4.node.appendChild(w4), 0 !== i2.config.yaxis[t4].labels.rotate) {
            var k4 = a3.rotateAroundCenter(p3.node), A4 = a3.rotateAroundCenter(y4.node);
            y4.node.setAttribute("transform", "rotate(".concat(i2.config.yaxis[t4].labels.rotate, " ").concat(k4.x, " ").concat(A4.y, ")"));
          }
          f3 += d3;
        }, b3 = c3; b3 >= 0; b3--) x3(b3);
      }
      if (void 0 !== i2.config.yaxis[t4].title.text) {
        var v3 = a3.group({ class: "apexcharts-yaxis-title" }), y3 = 0;
        i2.config.yaxis[t4].opposite && (y3 = i2.globals.translateYAxisX[t4]);
        var w3 = a3.drawText({ x: y3, y: i2.globals.gridHeight / 2 + i2.globals.translateY + i2.config.yaxis[t4].title.offsetY, text: i2.config.yaxis[t4].title.text, textAnchor: "end", foreColor: i2.config.yaxis[t4].title.style.color, fontSize: i2.config.yaxis[t4].title.style.fontSize, fontWeight: i2.config.yaxis[t4].title.style.fontWeight, fontFamily: i2.config.yaxis[t4].title.style.fontFamily, cssClass: "apexcharts-yaxis-title-text " + i2.config.yaxis[t4].title.style.cssClass });
        v3.add(w3), l3.add(v3);
      }
      var k3 = i2.config.yaxis[t4].axisBorder, A3 = 31 + k3.offsetX;
      if (i2.config.yaxis[t4].opposite && (A3 = -31 - k3.offsetX), k3.show) {
        var S3 = a3.drawLine(A3, i2.globals.translateY + k3.offsetY - 2, A3, i2.globals.gridHeight + i2.globals.translateY + k3.offsetY + 2, k3.color, 0, k3.width);
        l3.add(S3);
      }
      return i2.config.yaxis[t4].axisTicks.show && this.axesUtils.drawYAxisTicks(A3, c3, k3, i2.config.yaxis[t4].axisTicks, t4, d3, l3), l3;
    } }, { key: "drawYaxisInversed", value: function(t4) {
      var e3 = this.w, i2 = new m2(this.ctx), a3 = i2.group({ class: "apexcharts-xaxis apexcharts-yaxis-inversed" }), s3 = i2.group({ class: "apexcharts-xaxis-texts-g", transform: "translate(".concat(e3.globals.translateXAxisX, ", ").concat(e3.globals.translateXAxisY, ")") });
      a3.add(s3);
      var r2 = e3.globals.yAxisScale[t4].result.length - 1, o3 = e3.globals.gridWidth / r2 + 0.1, n3 = o3 + e3.config.xaxis.labels.offsetX, l3 = e3.globals.xLabelFormatter, h3 = e3.globals.yAxisScale[t4].result.slice(), c3 = e3.globals.timescaleLabels;
      c3.length > 0 && (this.xaxisLabels = c3.slice(), r2 = (h3 = c3.slice()).length), h3 = this.axesUtils.checkForReversedLabels(t4, h3);
      var d3 = c3.length;
      if (e3.config.xaxis.labels.show) for (var g3 = d3 ? 0 : r2; d3 ? g3 < d3 : g3 >= 0; d3 ? g3++ : g3--) {
        var u3 = h3[g3];
        u3 = l3(u3, g3, e3);
        var p3 = e3.globals.gridWidth + e3.globals.padHorizontal - (n3 - o3 + e3.config.xaxis.labels.offsetX);
        if (c3.length) {
          var f3 = this.axesUtils.getLabel(h3, c3, p3, g3, this.drawnLabels, this.xaxisFontSize);
          p3 = f3.x, u3 = f3.text, this.drawnLabels.push(f3.text), 0 === g3 && e3.globals.skipFirstTimelinelabel && (u3 = ""), g3 === h3.length - 1 && e3.globals.skipLastTimelinelabel && (u3 = "");
        }
        var x3 = i2.drawText({ x: p3, y: this.xAxisoffX + e3.config.xaxis.labels.offsetY + 30 - ("top" === e3.config.xaxis.position ? e3.globals.xAxisHeight + e3.config.xaxis.axisTicks.height - 2 : 0), text: u3, textAnchor: "middle", foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[t4] : this.xaxisForeColors, fontSize: this.xaxisFontSize, fontFamily: this.xaxisFontFamily, fontWeight: e3.config.xaxis.labels.style.fontWeight, isPlainText: false, cssClass: "apexcharts-xaxis-label " + e3.config.xaxis.labels.style.cssClass });
        s3.add(x3), x3.tspan(u3);
        var b3 = document.createElementNS(e3.globals.SVGNS, "title");
        b3.textContent = u3, x3.node.appendChild(b3), n3 += o3;
      }
      return this.inversedYAxisTitleText(a3), this.inversedYAxisBorder(a3), a3;
    } }, { key: "inversedYAxisBorder", value: function(t4) {
      var e3 = this.w, i2 = new m2(this.ctx), a3 = e3.config.xaxis.axisBorder;
      if (a3.show) {
        var s3 = 0;
        "bar" === e3.config.chart.type && e3.globals.isXNumeric && (s3 -= 15);
        var r2 = i2.drawLine(e3.globals.padHorizontal + s3 + a3.offsetX, this.xAxisoffX, e3.globals.gridWidth, this.xAxisoffX, a3.color, 0, a3.height);
        this.elgrid && this.elgrid.elGridBorders && e3.config.grid.show ? this.elgrid.elGridBorders.add(r2) : t4.add(r2);
      }
    } }, { key: "inversedYAxisTitleText", value: function(t4) {
      var e3 = this.w, i2 = new m2(this.ctx);
      if (void 0 !== e3.config.xaxis.title.text) {
        var a3 = i2.group({ class: "apexcharts-xaxis-title apexcharts-yaxis-title-inversed" }), s3 = i2.drawText({ x: e3.globals.gridWidth / 2 + e3.config.xaxis.title.offsetX, y: this.xAxisoffX + parseFloat(this.xaxisFontSize) + parseFloat(e3.config.xaxis.title.style.fontSize) + e3.config.xaxis.title.offsetY + 20, text: e3.config.xaxis.title.text, textAnchor: "middle", fontSize: e3.config.xaxis.title.style.fontSize, fontFamily: e3.config.xaxis.title.style.fontFamily, fontWeight: e3.config.xaxis.title.style.fontWeight, foreColor: e3.config.xaxis.title.style.color, cssClass: "apexcharts-xaxis-title-text " + e3.config.xaxis.title.style.cssClass });
        a3.add(s3), t4.add(a3);
      }
    } }, { key: "yAxisTitleRotate", value: function(t4, e3) {
      var i2 = this.w, a3 = new m2(this.ctx), s3 = { width: 0, height: 0 }, r2 = { width: 0, height: 0 }, o3 = i2.globals.dom.baseEl.querySelector(" .apexcharts-yaxis[rel='".concat(t4, "'] .apexcharts-yaxis-texts-g"));
      null !== o3 && (s3 = o3.getBoundingClientRect());
      var n3 = i2.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(t4, "'] .apexcharts-yaxis-title text"));
      if (null !== n3 && (r2 = n3.getBoundingClientRect()), null !== n3) {
        var l3 = this.xPaddingForYAxisTitle(t4, s3, r2, e3);
        n3.setAttribute("x", l3.xPos - (e3 ? 10 : 0));
      }
      if (null !== n3) {
        var h3 = a3.rotateAroundCenter(n3);
        n3.setAttribute("transform", "rotate(".concat(e3 ? -1 * i2.config.yaxis[t4].title.rotate : i2.config.yaxis[t4].title.rotate, " ").concat(h3.x, " ").concat(h3.y, ")"));
      }
    } }, { key: "xPaddingForYAxisTitle", value: function(t4, e3, i2, a3) {
      var s3 = this.w, r2 = 0, o3 = 0, n3 = 10;
      return void 0 === s3.config.yaxis[t4].title.text || t4 < 0 ? { xPos: o3, padd: 0 } : (a3 ? (o3 = e3.width + s3.config.yaxis[t4].title.offsetX + i2.width / 2 + n3 / 2, 0 === (r2 += 1) && (o3 -= n3 / 2)) : (o3 = -1 * e3.width + s3.config.yaxis[t4].title.offsetX + n3 / 2 + i2.width / 2, s3.globals.isBarHorizontal && (n3 = 25, o3 = -1 * e3.width - s3.config.yaxis[t4].title.offsetX - n3)), { xPos: o3, padd: n3 });
    } }, { key: "setYAxisXPosition", value: function(t4, e3) {
      var i2 = this.w, a3 = 0, s3 = 0, r2 = 18, o3 = 1;
      i2.config.yaxis.length > 1 && (this.multipleYs = true), i2.config.yaxis.map(function(n3, l3) {
        var h3 = i2.globals.ignoreYAxisIndexes.indexOf(l3) > -1 || !n3.show || n3.floating || 0 === t4[l3].width, c3 = t4[l3].width + e3[l3].width;
        n3.opposite ? i2.globals.isBarHorizontal ? (s3 = i2.globals.gridWidth + i2.globals.translateX - 1, i2.globals.translateYAxisX[l3] = s3 - n3.labels.offsetX) : (s3 = i2.globals.gridWidth + i2.globals.translateX + o3, h3 || (o3 = o3 + c3 + 20), i2.globals.translateYAxisX[l3] = s3 - n3.labels.offsetX + 20) : (a3 = i2.globals.translateX - r2, h3 || (r2 = r2 + c3 + 20), i2.globals.translateYAxisX[l3] = a3 + n3.labels.offsetX);
      });
    } }, { key: "setYAxisTextAlignments", value: function() {
      var t4 = this.w, e3 = t4.globals.dom.baseEl.getElementsByClassName("apexcharts-yaxis");
      (e3 = x2.listToArray(e3)).forEach(function(e4, i2) {
        var a3 = t4.config.yaxis[i2];
        if (a3 && !a3.floating && void 0 !== a3.labels.align) {
          var s3 = t4.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(i2, "'] .apexcharts-yaxis-texts-g")), r2 = t4.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(i2, "'] .apexcharts-yaxis-label"));
          r2 = x2.listToArray(r2);
          var o3 = s3.getBoundingClientRect();
          "left" === a3.labels.align ? (r2.forEach(function(t5, e5) {
            t5.setAttribute("text-anchor", "start");
          }), a3.opposite || s3.setAttribute("transform", "translate(-".concat(o3.width, ", 0)"))) : "center" === a3.labels.align ? (r2.forEach(function(t5, e5) {
            t5.setAttribute("text-anchor", "middle");
          }), s3.setAttribute("transform", "translate(".concat(o3.width / 2 * (a3.opposite ? 1 : -1), ", 0)"))) : "right" === a3.labels.align && (r2.forEach(function(t5, e5) {
            t5.setAttribute("text-anchor", "end");
          }), a3.opposite && s3.setAttribute("transform", "translate(".concat(o3.width, ", 0)")));
        }
      });
    } }]), t3;
  }(), Z2 = function() {
    function t3(e3) {
      a2(this, t3), this.ctx = e3, this.w = e3.w, this.documentEvent = x2.bind(this.documentEvent, this);
    }
    return r(t3, [{ key: "addEventListener", value: function(t4, e3) {
      var i2 = this.w;
      i2.globals.events.hasOwnProperty(t4) ? i2.globals.events[t4].push(e3) : i2.globals.events[t4] = [e3];
    } }, { key: "removeEventListener", value: function(t4, e3) {
      var i2 = this.w;
      if (i2.globals.events.hasOwnProperty(t4)) {
        var a3 = i2.globals.events[t4].indexOf(e3);
        -1 !== a3 && i2.globals.events[t4].splice(a3, 1);
      }
    } }, { key: "fireEvent", value: function(t4, e3) {
      var i2 = this.w;
      if (i2.globals.events.hasOwnProperty(t4)) {
        e3 && e3.length || (e3 = []);
        for (var a3 = i2.globals.events[t4], s3 = a3.length, r2 = 0; r2 < s3; r2++) a3[r2].apply(null, e3);
      }
    } }, { key: "setupEventHandlers", value: function() {
      var t4 = this, e3 = this.w, i2 = this.ctx, a3 = e3.globals.dom.baseEl.querySelector(e3.globals.chartClass);
      this.ctx.eventList.forEach(function(t5) {
        a3.addEventListener(t5, function(t6) {
          var a4 = Object.assign({}, e3, { seriesIndex: e3.globals.axisCharts ? e3.globals.capturedSeriesIndex : 0, dataPointIndex: e3.globals.capturedDataPointIndex });
          "mousemove" === t6.type || "touchmove" === t6.type ? "function" == typeof e3.config.chart.events.mouseMove && e3.config.chart.events.mouseMove(t6, i2, a4) : "mouseleave" === t6.type || "touchleave" === t6.type ? "function" == typeof e3.config.chart.events.mouseLeave && e3.config.chart.events.mouseLeave(t6, i2, a4) : ("mouseup" === t6.type && 1 === t6.which || "touchend" === t6.type) && ("function" == typeof e3.config.chart.events.click && e3.config.chart.events.click(t6, i2, a4), i2.ctx.events.fireEvent("click", [t6, i2, a4]));
        }, { capture: false, passive: true });
      }), this.ctx.eventList.forEach(function(i3) {
        e3.globals.dom.baseEl.addEventListener(i3, t4.documentEvent, { passive: true });
      }), this.ctx.core.setupBrushHandler();
    } }, { key: "documentEvent", value: function(t4) {
      var e3 = this.w, i2 = t4.target.className;
      if ("click" === t4.type) {
        var a3 = e3.globals.dom.baseEl.querySelector(".apexcharts-menu");
        a3 && a3.classList.contains("apexcharts-menu-open") && "apexcharts-menu-icon" !== i2 && a3.classList.remove("apexcharts-menu-open");
      }
      e3.globals.clientX = "touchmove" === t4.type ? t4.touches[0].clientX : t4.clientX, e3.globals.clientY = "touchmove" === t4.type ? t4.touches[0].clientY : t4.clientY;
    } }]), t3;
  }(), $2 = function() {
    function t3(e3) {
      a2(this, t3), this.ctx = e3, this.w = e3.w;
    }
    return r(t3, [{ key: "setCurrentLocaleValues", value: function(t4) {
      var e3 = this.w.config.chart.locales;
      window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0 && (e3 = this.w.config.chart.locales.concat(window.Apex.chart.locales));
      var i2 = e3.filter(function(e4) {
        return e4.name === t4;
      })[0];
      if (!i2) throw new Error("Wrong locale name provided. Please make sure you set the correct locale name in options");
      var a3 = x2.extend(M2, i2);
      this.w.globals.locale = a3.options;
    } }]), t3;
  }(), J2 = function() {
    function t3(e3) {
      a2(this, t3), this.ctx = e3, this.w = e3.w;
    }
    return r(t3, [{ key: "drawAxis", value: function(t4, e3) {
      var i2, a3, s3 = this, r2 = this.w.globals, o3 = this.w.config, n3 = new V2(this.ctx, e3), l3 = new q2(this.ctx, e3);
      r2.axisCharts && "radar" !== t4 && (r2.isBarHorizontal ? (a3 = l3.drawYaxisInversed(0), i2 = n3.drawXaxisInversed(0), r2.dom.elGraphical.add(i2), r2.dom.elGraphical.add(a3)) : (i2 = n3.drawXaxis(), r2.dom.elGraphical.add(i2), o3.yaxis.map(function(t5, e4) {
        if (-1 === r2.ignoreYAxisIndexes.indexOf(e4) && (a3 = l3.drawYaxis(e4), r2.dom.Paper.add(a3), "back" === s3.w.config.grid.position)) {
          var i3 = r2.dom.Paper.children()[1];
          i3.remove(), r2.dom.Paper.add(i3);
        }
      })));
    } }]), t3;
  }(), Q2 = function() {
    function t3(e3) {
      a2(this, t3), this.ctx = e3, this.w = e3.w;
    }
    return r(t3, [{ key: "drawXCrosshairs", value: function() {
      var t4 = this.w, e3 = new m2(this.ctx), i2 = new v2(this.ctx), a3 = t4.config.xaxis.crosshairs.fill.gradient, s3 = t4.config.xaxis.crosshairs.dropShadow, r2 = t4.config.xaxis.crosshairs.fill.type, o3 = a3.colorFrom, n3 = a3.colorTo, l3 = a3.opacityFrom, h3 = a3.opacityTo, c3 = a3.stops, d3 = s3.enabled, g3 = s3.left, u3 = s3.top, p3 = s3.blur, f3 = s3.color, b3 = s3.opacity, y3 = t4.config.xaxis.crosshairs.fill.color;
      if (t4.config.xaxis.crosshairs.show) {
        "gradient" === r2 && (y3 = e3.drawGradient("vertical", o3, n3, l3, h3, null, c3, null));
        var w3 = e3.drawRect();
        1 === t4.config.xaxis.crosshairs.width && (w3 = e3.drawLine());
        var k3 = t4.globals.gridHeight;
        (!x2.isNumber(k3) || k3 < 0) && (k3 = 0);
        var A3 = t4.config.xaxis.crosshairs.width;
        (!x2.isNumber(A3) || A3 < 0) && (A3 = 0), w3.attr({ class: "apexcharts-xcrosshairs", x: 0, y: 0, y2: k3, width: A3, height: k3, fill: y3, filter: "none", "fill-opacity": t4.config.xaxis.crosshairs.opacity, stroke: t4.config.xaxis.crosshairs.stroke.color, "stroke-width": t4.config.xaxis.crosshairs.stroke.width, "stroke-dasharray": t4.config.xaxis.crosshairs.stroke.dashArray }), d3 && (w3 = i2.dropShadow(w3, { left: g3, top: u3, blur: p3, color: f3, opacity: b3 })), t4.globals.dom.elGraphical.add(w3);
      }
    } }, { key: "drawYCrosshairs", value: function() {
      var t4 = this.w, e3 = new m2(this.ctx), i2 = t4.config.yaxis[0].crosshairs, a3 = t4.globals.barPadForNumericAxis;
      if (t4.config.yaxis[0].crosshairs.show) {
        var s3 = e3.drawLine(-a3, 0, t4.globals.gridWidth + a3, 0, i2.stroke.color, i2.stroke.dashArray, i2.stroke.width);
        s3.attr({ class: "apexcharts-ycrosshairs" }), t4.globals.dom.elGraphical.add(s3);
      }
      var r2 = e3.drawLine(-a3, 0, t4.globals.gridWidth + a3, 0, i2.stroke.color, 0, 0);
      r2.attr({ class: "apexcharts-ycrosshairs-hidden" }), t4.globals.dom.elGraphical.add(r2);
    } }]), t3;
  }(), K2 = function() {
    function t3(e3) {
      a2(this, t3), this.ctx = e3, this.w = e3.w;
    }
    return r(t3, [{ key: "checkResponsiveConfig", value: function(t4) {
      var e3 = this, i2 = this.w, a3 = i2.config;
      if (0 !== a3.responsive.length) {
        var s3 = a3.responsive.slice();
        s3.sort(function(t5, e4) {
          return t5.breakpoint > e4.breakpoint ? 1 : e4.breakpoint > t5.breakpoint ? -1 : 0;
        }).reverse();
        var r2 = new Y2({}), o3 = function() {
          var t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, a4 = s3[0].breakpoint, o4 = window.innerWidth > 0 ? window.innerWidth : screen.width;
          if (o4 > a4) {
            var n4 = x2.clone(i2.globals.initialConfig);
            n4.series = x2.clone(i2.config.series);
            var l3 = y2.extendArrayProps(r2, n4, i2);
            t5 = x2.extend(l3, t5), t5 = x2.extend(i2.config, t5), e3.overrideResponsiveOptions(t5);
          } else for (var h3 = 0; h3 < s3.length; h3++) o4 < s3[h3].breakpoint && (t5 = y2.extendArrayProps(r2, s3[h3].options, i2), t5 = x2.extend(i2.config, t5), e3.overrideResponsiveOptions(t5));
        };
        if (t4) {
          var n3 = y2.extendArrayProps(r2, t4, i2);
          n3 = x2.extend(i2.config, n3), o3(n3 = x2.extend(n3, t4));
        } else o3({});
      }
    } }, { key: "overrideResponsiveOptions", value: function(t4) {
      var e3 = new Y2(t4).init({ responsiveOverride: true });
      this.w.config = e3;
    } }]), t3;
  }(), tt2 = function() {
    function t3(e3) {
      a2(this, t3), this.ctx = e3, this.colors = [], this.w = e3.w;
      var i2 = this.w;
      this.isColorFn = false, this.isHeatmapDistributed = "treemap" === i2.config.chart.type && i2.config.plotOptions.treemap.distributed || "heatmap" === i2.config.chart.type && i2.config.plotOptions.heatmap.distributed, this.isBarDistributed = i2.config.plotOptions.bar.distributed && ("bar" === i2.config.chart.type || "rangeBar" === i2.config.chart.type);
    }
    return r(t3, [{ key: "init", value: function() {
      this.setDefaultColors();
    } }, { key: "setDefaultColors", value: function() {
      var t4, e3 = this, i2 = this.w, a3 = new x2();
      if (i2.globals.dom.elWrap.classList.add("apexcharts-theme-".concat(i2.config.theme.mode)), void 0 === i2.config.colors || 0 === (null === (t4 = i2.config.colors) || void 0 === t4 ? void 0 : t4.length) ? i2.globals.colors = this.predefined() : (i2.globals.colors = i2.config.colors, Array.isArray(i2.config.colors) && i2.config.colors.length > 0 && "function" == typeof i2.config.colors[0] && (i2.globals.colors = i2.config.series.map(function(t5, a4) {
        var s4 = i2.config.colors[a4];
        return s4 || (s4 = i2.config.colors[0]), "function" == typeof s4 ? (e3.isColorFn = true, s4({ value: i2.globals.axisCharts ? i2.globals.series[a4][0] ? i2.globals.series[a4][0] : 0 : i2.globals.series[a4], seriesIndex: a4, dataPointIndex: a4, w: i2 })) : s4;
      }))), i2.globals.seriesColors.map(function(t5, e4) {
        t5 && (i2.globals.colors[e4] = t5);
      }), i2.config.theme.monochrome.enabled) {
        var s3 = [], r2 = i2.globals.series.length;
        (this.isBarDistributed || this.isHeatmapDistributed) && (r2 = i2.globals.series[0].length * i2.globals.series.length);
        for (var o3 = i2.config.theme.monochrome.color, n3 = 1 / (r2 / i2.config.theme.monochrome.shadeIntensity), l3 = i2.config.theme.monochrome.shadeTo, h3 = 0, c3 = 0; c3 < r2; c3++) {
          var d3 = void 0;
          "dark" === l3 ? (d3 = a3.shadeColor(-1 * h3, o3), h3 += n3) : (d3 = a3.shadeColor(h3, o3), h3 += n3), s3.push(d3);
        }
        i2.globals.colors = s3.slice();
      }
      var g3 = i2.globals.colors.slice();
      this.pushExtraColors(i2.globals.colors);
      ["fill", "stroke"].forEach(function(t5) {
        void 0 === i2.config[t5].colors ? i2.globals[t5].colors = e3.isColorFn ? i2.config.colors : g3 : i2.globals[t5].colors = i2.config[t5].colors.slice(), e3.pushExtraColors(i2.globals[t5].colors);
      }), void 0 === i2.config.dataLabels.style.colors ? i2.globals.dataLabels.style.colors = g3 : i2.globals.dataLabels.style.colors = i2.config.dataLabels.style.colors.slice(), this.pushExtraColors(i2.globals.dataLabels.style.colors, 50), void 0 === i2.config.plotOptions.radar.polygons.fill.colors ? i2.globals.radarPolygons.fill.colors = ["dark" === i2.config.theme.mode ? "#424242" : "none"] : i2.globals.radarPolygons.fill.colors = i2.config.plotOptions.radar.polygons.fill.colors.slice(), this.pushExtraColors(i2.globals.radarPolygons.fill.colors, 20), void 0 === i2.config.markers.colors ? i2.globals.markers.colors = g3 : i2.globals.markers.colors = i2.config.markers.colors.slice(), this.pushExtraColors(i2.globals.markers.colors);
    } }, { key: "pushExtraColors", value: function(t4, e3) {
      var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a3 = this.w, s3 = e3 || a3.globals.series.length;
      if (null === i2 && (i2 = this.isBarDistributed || this.isHeatmapDistributed || "heatmap" === a3.config.chart.type && a3.config.plotOptions.heatmap.colorScale.inverse), i2 && a3.globals.series.length && (s3 = a3.globals.series[a3.globals.maxValsInArrayIndex].length * a3.globals.series.length), t4.length < s3) for (var r2 = s3 - t4.length, o3 = 0; o3 < r2; o3++) t4.push(t4[o3]);
    } }, { key: "updateThemeOptions", value: function(t4) {
      t4.chart = t4.chart || {}, t4.tooltip = t4.tooltip || {};
      var e3 = t4.theme.mode, i2 = "dark" === e3 ? "#424242" : "light" === e3 ? "#fff" : t4.chart.background || "#fff", a3 = "dark" === e3 ? "palette4" : "light" === e3 ? "palette1" : t4.theme.palette || "palette1", s3 = "dark" === e3 ? "#f6f7f8" : "light" === e3 ? "#373d3f" : t4.chart.foreColor || "#373d3f";
      return t4.tooltip.theme = e3 || "light", t4.chart.foreColor = s3, t4.chart.background = i2, t4.theme.palette = a3, t4;
    } }, { key: "predefined", value: function() {
      switch (this.w.config.theme.palette) {
        case "palette1":
        default:
          this.colors = ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"];
          break;
        case "palette2":
          this.colors = ["#3f51b5", "#03a9f4", "#4caf50", "#f9ce1d", "#FF9800"];
          break;
        case "palette3":
          this.colors = ["#33b2df", "#546E7A", "#d4526e", "#13d8aa", "#A5978B"];
          break;
        case "palette4":
          this.colors = ["#4ecdc4", "#c7f464", "#81D4FA", "#fd6a6a", "#546E7A"];
          break;
        case "palette5":
          this.colors = ["#2b908f", "#f9a3a4", "#90ee7e", "#fa4443", "#69d2e7"];
          break;
        case "palette6":
          this.colors = ["#449DD1", "#F86624", "#EA3546", "#662E9B", "#C5D86D"];
          break;
        case "palette7":
          this.colors = ["#D7263D", "#1B998B", "#2E294E", "#F46036", "#E2C044"];
          break;
        case "palette8":
          this.colors = ["#662E9B", "#F86624", "#F9C80E", "#EA3546", "#43BCCD"];
          break;
        case "palette9":
          this.colors = ["#5C4742", "#A5978B", "#8D5B4C", "#5A2A27", "#C4BBAF"];
          break;
        case "palette10":
          this.colors = ["#A300D6", "#7D02EB", "#5653FE", "#2983FF", "#00B1F2"];
      }
      return this.colors;
    } }]), t3;
  }(), et2 = function() {
    function t3(e3) {
      a2(this, t3), this.ctx = e3, this.w = e3.w;
    }
    return r(t3, [{ key: "draw", value: function() {
      this.drawTitleSubtitle("title"), this.drawTitleSubtitle("subtitle");
    } }, { key: "drawTitleSubtitle", value: function(t4) {
      var e3 = this.w, i2 = "title" === t4 ? e3.config.title : e3.config.subtitle, a3 = e3.globals.svgWidth / 2, s3 = i2.offsetY, r2 = "middle";
      if ("left" === i2.align ? (a3 = 10, r2 = "start") : "right" === i2.align && (a3 = e3.globals.svgWidth - 10, r2 = "end"), a3 += i2.offsetX, s3 = s3 + parseInt(i2.style.fontSize, 10) + i2.margin / 2, void 0 !== i2.text) {
        var o3 = new m2(this.ctx).drawText({ x: a3, y: s3, text: i2.text, textAnchor: r2, fontSize: i2.style.fontSize, fontFamily: i2.style.fontFamily, fontWeight: i2.style.fontWeight, foreColor: i2.style.color, opacity: 1 });
        o3.node.setAttribute("class", "apexcharts-".concat(t4, "-text")), e3.globals.dom.Paper.add(o3);
      }
    } }]), t3;
  }(), it2 = function() {
    function t3(e3) {
      a2(this, t3), this.w = e3.w, this.dCtx = e3;
    }
    return r(t3, [{ key: "getTitleSubtitleCoords", value: function(t4) {
      var e3 = this.w, i2 = 0, a3 = 0, s3 = "title" === t4 ? e3.config.title.floating : e3.config.subtitle.floating, r2 = e3.globals.dom.baseEl.querySelector(".apexcharts-".concat(t4, "-text"));
      if (null !== r2 && !s3) {
        var o3 = r2.getBoundingClientRect();
        i2 = o3.width, a3 = e3.globals.axisCharts ? o3.height + 5 : o3.height;
      }
      return { width: i2, height: a3 };
    } }, { key: "getLegendsRect", value: function() {
      var t4 = this.w, e3 = t4.globals.dom.elLegendWrap;
      t4.config.legend.height || "top" !== t4.config.legend.position && "bottom" !== t4.config.legend.position || (e3.style.maxHeight = t4.globals.svgHeight / 2 + "px");
      var i2 = Object.assign({}, x2.getBoundingClientRect(e3));
      return null !== e3 && !t4.config.legend.floating && t4.config.legend.show ? this.dCtx.lgRect = { x: i2.x, y: i2.y, height: i2.height, width: 0 === i2.height ? 0 : i2.width } : this.dCtx.lgRect = { x: 0, y: 0, height: 0, width: 0 }, "left" !== t4.config.legend.position && "right" !== t4.config.legend.position || 1.5 * this.dCtx.lgRect.width > t4.globals.svgWidth && (this.dCtx.lgRect.width = t4.globals.svgWidth / 1.5), this.dCtx.lgRect;
    } }, { key: "getDatalabelsRect", value: function() {
      var t4 = this, e3 = this.w, i2 = [];
      e3.config.series.forEach(function(s4, r3) {
        s4.data.forEach(function(s5, o4) {
          var n3;
          n3 = e3.globals.series[r3][o4], a3 = e3.config.dataLabels.formatter(n3, { ctx: t4.dCtx.ctx, seriesIndex: r3, dataPointIndex: o4, w: e3 }), i2.push(a3);
        });
      });
      var a3 = x2.getLargestStringFromArr(i2), s3 = new m2(this.dCtx.ctx), r2 = e3.config.dataLabels.style, o3 = s3.getTextRects(a3, parseInt(r2.fontSize), r2.fontFamily);
      return { width: 1.05 * o3.width, height: o3.height };
    } }, { key: "getLargestStringFromMultiArr", value: function(t4, e3) {
      var i2 = t4;
      if (this.w.globals.isMultiLineX) {
        var a3 = e3.map(function(t5, e4) {
          return Array.isArray(t5) ? t5.length : 1;
        }), s3 = Math.max.apply(Math, u2(a3));
        i2 = e3[a3.indexOf(s3)];
      }
      return i2;
    } }]), t3;
  }(), at2 = function() {
    function t3(e3) {
      a2(this, t3), this.w = e3.w, this.dCtx = e3;
    }
    return r(t3, [{ key: "getxAxisLabelsCoords", value: function() {
      var t4, e3 = this.w, i2 = e3.globals.labels.slice();
      if (e3.config.xaxis.convertedCatToNumeric && 0 === i2.length && (i2 = e3.globals.categoryLabels), e3.globals.timescaleLabels.length > 0) {
        var a3 = this.getxAxisTimeScaleLabelsCoords();
        t4 = { width: a3.width, height: a3.height }, e3.globals.rotateXLabels = false;
      } else {
        this.dCtx.lgWidthForSideLegends = "left" !== e3.config.legend.position && "right" !== e3.config.legend.position || e3.config.legend.floating ? 0 : this.dCtx.lgRect.width;
        var s3 = e3.globals.xLabelFormatter, r2 = x2.getLargestStringFromArr(i2), o3 = this.dCtx.dimHelpers.getLargestStringFromMultiArr(r2, i2);
        e3.globals.isBarHorizontal && (o3 = r2 = e3.globals.yAxisScale[0].result.reduce(function(t5, e4) {
          return t5.length > e4.length ? t5 : e4;
        }, 0));
        var n3 = new S2(this.dCtx.ctx), l3 = r2;
        r2 = n3.xLabelFormat(s3, r2, l3, { i: void 0, dateFormatter: new A2(this.dCtx.ctx).formatDate, w: e3 }), o3 = n3.xLabelFormat(s3, o3, l3, { i: void 0, dateFormatter: new A2(this.dCtx.ctx).formatDate, w: e3 }), (e3.config.xaxis.convertedCatToNumeric && void 0 === r2 || "" === String(r2).trim()) && (o3 = r2 = "1");
        var h3 = new m2(this.dCtx.ctx), c3 = h3.getTextRects(r2, e3.config.xaxis.labels.style.fontSize), d3 = c3;
        if (r2 !== o3 && (d3 = h3.getTextRects(o3, e3.config.xaxis.labels.style.fontSize)), (t4 = { width: c3.width >= d3.width ? c3.width : d3.width, height: c3.height >= d3.height ? c3.height : d3.height }).width * i2.length > e3.globals.svgWidth - this.dCtx.lgWidthForSideLegends - this.dCtx.yAxisWidth - this.dCtx.gridPad.left - this.dCtx.gridPad.right && 0 !== e3.config.xaxis.labels.rotate || e3.config.xaxis.labels.rotateAlways) {
          if (!e3.globals.isBarHorizontal) {
            e3.globals.rotateXLabels = true;
            var g3 = function(t5) {
              return h3.getTextRects(t5, e3.config.xaxis.labels.style.fontSize, e3.config.xaxis.labels.style.fontFamily, "rotate(".concat(e3.config.xaxis.labels.rotate, " 0 0)"), false);
            };
            c3 = g3(r2), r2 !== o3 && (d3 = g3(o3)), t4.height = (c3.height > d3.height ? c3.height : d3.height) / 1.5, t4.width = c3.width > d3.width ? c3.width : d3.width;
          }
        } else e3.globals.rotateXLabels = false;
      }
      return e3.config.xaxis.labels.show || (t4 = { width: 0, height: 0 }), { width: t4.width, height: t4.height };
    } }, { key: "getxAxisGroupLabelsCoords", value: function() {
      var t4, e3 = this.w;
      if (!e3.globals.hasXaxisGroups) return { width: 0, height: 0 };
      var i2, a3 = (null === (t4 = e3.config.xaxis.group.style) || void 0 === t4 ? void 0 : t4.fontSize) || e3.config.xaxis.labels.style.fontSize, s3 = e3.globals.groups.map(function(t5) {
        return t5.title;
      }), r2 = x2.getLargestStringFromArr(s3), o3 = this.dCtx.dimHelpers.getLargestStringFromMultiArr(r2, s3), n3 = new m2(this.dCtx.ctx), l3 = n3.getTextRects(r2, a3), h3 = l3;
      return r2 !== o3 && (h3 = n3.getTextRects(o3, a3)), i2 = { width: l3.width >= h3.width ? l3.width : h3.width, height: l3.height >= h3.height ? l3.height : h3.height }, e3.config.xaxis.labels.show || (i2 = { width: 0, height: 0 }), { width: i2.width, height: i2.height };
    } }, { key: "getxAxisTitleCoords", value: function() {
      var t4 = this.w, e3 = 0, i2 = 0;
      if (void 0 !== t4.config.xaxis.title.text) {
        var a3 = new m2(this.dCtx.ctx).getTextRects(t4.config.xaxis.title.text, t4.config.xaxis.title.style.fontSize);
        e3 = a3.width, i2 = a3.height;
      }
      return { width: e3, height: i2 };
    } }, { key: "getxAxisTimeScaleLabelsCoords", value: function() {
      var t4, e3 = this.w;
      this.dCtx.timescaleLabels = e3.globals.timescaleLabels.slice();
      var i2 = this.dCtx.timescaleLabels.map(function(t5) {
        return t5.value;
      }), a3 = i2.reduce(function(t5, e4) {
        return void 0 === t5 ? (console.error("You have possibly supplied invalid Date format. Please supply a valid JavaScript Date"), 0) : t5.length > e4.length ? t5 : e4;
      }, 0);
      return 1.05 * (t4 = new m2(this.dCtx.ctx).getTextRects(a3, e3.config.xaxis.labels.style.fontSize)).width * i2.length > e3.globals.gridWidth && 0 !== e3.config.xaxis.labels.rotate && (e3.globals.overlappingXLabels = true), t4;
    } }, { key: "additionalPaddingXLabels", value: function(t4) {
      var e3 = this, i2 = this.w, a3 = i2.globals, s3 = i2.config, r2 = s3.xaxis.type, o3 = t4.width;
      a3.skipLastTimelinelabel = false, a3.skipFirstTimelinelabel = false;
      var n3 = i2.config.yaxis[0].opposite && i2.globals.isBarHorizontal, l3 = function(t5, n4) {
        s3.yaxis.length > 1 && function(t6) {
          return -1 !== a3.collapsedSeriesIndices.indexOf(t6);
        }(n4) || function(t6) {
          if (e3.dCtx.timescaleLabels && e3.dCtx.timescaleLabels.length) {
            var n5 = e3.dCtx.timescaleLabels[0], l4 = e3.dCtx.timescaleLabels[e3.dCtx.timescaleLabels.length - 1].position + o3 / 1.75 - e3.dCtx.yAxisWidthRight, h3 = n5.position - o3 / 1.75 + e3.dCtx.yAxisWidthLeft, c3 = "right" === i2.config.legend.position && e3.dCtx.lgRect.width > 0 ? e3.dCtx.lgRect.width : 0;
            l4 > a3.svgWidth - a3.translateX - c3 && (a3.skipLastTimelinelabel = true), h3 < -(t6.show && !t6.floating || "bar" !== s3.chart.type && "candlestick" !== s3.chart.type && "rangeBar" !== s3.chart.type && "boxPlot" !== s3.chart.type ? 10 : o3 / 1.75) && (a3.skipFirstTimelinelabel = true);
          } else "datetime" === r2 ? e3.dCtx.gridPad.right < o3 && !a3.rotateXLabels && (a3.skipLastTimelinelabel = true) : "datetime" !== r2 && e3.dCtx.gridPad.right < o3 / 2 - e3.dCtx.yAxisWidthRight && !a3.rotateXLabels && !i2.config.xaxis.labels.trim && ("between" !== i2.config.xaxis.tickPlacement || i2.globals.isBarHorizontal) && (e3.dCtx.xPadRight = o3 / 2 + 1);
        }(t5);
      };
      s3.yaxis.forEach(function(t5, i3) {
        n3 ? (e3.dCtx.gridPad.left < o3 && (e3.dCtx.xPadLeft = o3 / 2 + 1), e3.dCtx.xPadRight = o3 / 2 + 1) : l3(t5, i3);
      });
    } }]), t3;
  }(), st2 = function() {
    function t3(e3) {
      a2(this, t3), this.w = e3.w, this.dCtx = e3;
    }
    return r(t3, [{ key: "getyAxisLabelsCoords", value: function() {
      var t4 = this, e3 = this.w, i2 = [], a3 = 10, s3 = new C2(this.dCtx.ctx);
      return e3.config.yaxis.map(function(r2, o3) {
        var n3 = { seriesIndex: o3, dataPointIndex: -1, w: e3 }, l3 = e3.globals.yAxisScale[o3], h3 = 0;
        if (!s3.isYAxisHidden(o3) && r2.labels.show && void 0 !== r2.labels.minWidth && (h3 = r2.labels.minWidth), !s3.isYAxisHidden(o3) && r2.labels.show && l3.result.length) {
          var c3 = e3.globals.yLabelFormatters[o3], d3 = l3.niceMin === Number.MIN_VALUE ? 0 : l3.niceMin, g3 = l3.result.reduce(function(t5, e4) {
            var i3, a4;
            return (null === (i3 = String(c3(t5, n3))) || void 0 === i3 ? void 0 : i3.length) > (null === (a4 = String(c3(e4, n3))) || void 0 === a4 ? void 0 : a4.length) ? t5 : e4;
          }, d3), u3 = g3 = c3(g3, n3);
          if (void 0 !== g3 && 0 !== g3.length || (g3 = l3.niceMax), e3.globals.isBarHorizontal) {
            a3 = 0;
            var p3 = e3.globals.labels.slice();
            g3 = x2.getLargestStringFromArr(p3), g3 = c3(g3, { seriesIndex: o3, dataPointIndex: -1, w: e3 }), u3 = t4.dCtx.dimHelpers.getLargestStringFromMultiArr(g3, p3);
          }
          var f3 = new m2(t4.dCtx.ctx), b3 = "rotate(".concat(r2.labels.rotate, " 0 0)"), v3 = f3.getTextRects(g3, r2.labels.style.fontSize, r2.labels.style.fontFamily, b3, false), y3 = v3;
          g3 !== u3 && (y3 = f3.getTextRects(u3, r2.labels.style.fontSize, r2.labels.style.fontFamily, b3, false)), i2.push({ width: (h3 > y3.width || h3 > v3.width ? h3 : y3.width > v3.width ? y3.width : v3.width) + a3, height: y3.height > v3.height ? y3.height : v3.height });
        } else i2.push({ width: 0, height: 0 });
      }), i2;
    } }, { key: "getyAxisTitleCoords", value: function() {
      var t4 = this, e3 = this.w, i2 = [];
      return e3.config.yaxis.map(function(e4, a3) {
        if (e4.show && void 0 !== e4.title.text) {
          var s3 = new m2(t4.dCtx.ctx), r2 = "rotate(".concat(e4.title.rotate, " 0 0)"), o3 = s3.getTextRects(e4.title.text, e4.title.style.fontSize, e4.title.style.fontFamily, r2, false);
          i2.push({ width: o3.width, height: o3.height });
        } else i2.push({ width: 0, height: 0 });
      }), i2;
    } }, { key: "getTotalYAxisWidth", value: function() {
      var t4 = this.w, e3 = 0, i2 = 0, a3 = 0, s3 = t4.globals.yAxisScale.length > 1 ? 10 : 0, r2 = new C2(this.dCtx.ctx), o3 = function(o4, n3) {
        var l3 = t4.config.yaxis[n3].floating, h3 = 0;
        o4.width > 0 && !l3 ? (h3 = o4.width + s3, function(e4) {
          return t4.globals.ignoreYAxisIndexes.indexOf(e4) > -1;
        }(n3) && (h3 = h3 - o4.width - s3)) : h3 = l3 || r2.isYAxisHidden(n3) ? 0 : 5, t4.config.yaxis[n3].opposite ? a3 += h3 : i2 += h3, e3 += h3;
      };
      return t4.globals.yLabelsCoords.map(function(t5, e4) {
        o3(t5, e4);
      }), t4.globals.yTitleCoords.map(function(t5, e4) {
        o3(t5, e4);
      }), t4.globals.isBarHorizontal && !t4.config.yaxis[0].floating && (e3 = t4.globals.yLabelsCoords[0].width + t4.globals.yTitleCoords[0].width + 15), this.dCtx.yAxisWidthLeft = i2, this.dCtx.yAxisWidthRight = a3, e3;
    } }]), t3;
  }(), rt2 = function() {
    function t3(e3) {
      a2(this, t3), this.w = e3.w, this.dCtx = e3;
    }
    return r(t3, [{ key: "gridPadForColumnsInNumericAxis", value: function(t4) {
      var e3 = this.w, i2 = e3.config, a3 = e3.globals;
      if (a3.noData || a3.collapsedSeries.length + a3.ancillaryCollapsedSeries.length === i2.series.length) return 0;
      var s3 = function(t5) {
        return "bar" === t5 || "rangeBar" === t5 || "candlestick" === t5 || "boxPlot" === t5;
      }, r2 = i2.chart.type, o3 = 0, n3 = s3(r2) ? i2.series.length : 1;
      a3.comboBarCount > 0 && (n3 = a3.comboBarCount), a3.collapsedSeries.forEach(function(t5) {
        s3(t5.type) && (n3 -= 1);
      }), i2.chart.stacked && (n3 = 1);
      var l3 = s3(r2) || a3.comboBarCount > 0, h3 = Math.abs(a3.initialMaxX - a3.initialMinX);
      if (l3 && a3.isXNumeric && !a3.isBarHorizontal && n3 > 0 && 0 !== h3) {
        var c3, d3;
        h3 <= 3 && (h3 = a3.dataPoints), c3 = h3 / t4, a3.minXDiff && a3.minXDiff / c3 > 0 && (d3 = a3.minXDiff / c3), d3 > t4 / 2 && (d3 /= 2), (o3 = d3 * parseInt(i2.plotOptions.bar.columnWidth, 10) / 100) < 1 && (o3 = 1), a3.barPadForNumericAxis = o3;
      }
      return o3;
    } }, { key: "gridPadFortitleSubtitle", value: function() {
      var t4 = this, e3 = this.w, i2 = e3.globals, a3 = this.dCtx.isSparkline || !e3.globals.axisCharts ? 0 : 10;
      ["title", "subtitle"].forEach(function(i3) {
        void 0 !== e3.config[i3].text ? a3 += e3.config[i3].margin : a3 += t4.dCtx.isSparkline || !e3.globals.axisCharts ? 0 : 5;
      }), !e3.config.legend.show || "bottom" !== e3.config.legend.position || e3.config.legend.floating || e3.globals.axisCharts || (a3 += 10);
      var s3 = this.dCtx.dimHelpers.getTitleSubtitleCoords("title"), r2 = this.dCtx.dimHelpers.getTitleSubtitleCoords("subtitle");
      i2.gridHeight = i2.gridHeight - s3.height - r2.height - a3, i2.translateY = i2.translateY + s3.height + r2.height + a3;
    } }, { key: "setGridXPosForDualYAxis", value: function(t4, e3) {
      var i2 = this.w, a3 = new C2(this.dCtx.ctx);
      i2.config.yaxis.map(function(s3, r2) {
        -1 !== i2.globals.ignoreYAxisIndexes.indexOf(r2) || s3.floating || a3.isYAxisHidden(r2) || (s3.opposite && (i2.globals.translateX = i2.globals.translateX - (e3[r2].width + t4[r2].width) - parseInt(i2.config.yaxis[r2].labels.style.fontSize, 10) / 1.2 - 12), i2.globals.translateX < 2 && (i2.globals.translateX = 2));
      });
    } }]), t3;
  }(), ot2 = function() {
    function t3(e3) {
      a2(this, t3), this.ctx = e3, this.w = e3.w, this.lgRect = {}, this.yAxisWidth = 0, this.yAxisWidthLeft = 0, this.yAxisWidthRight = 0, this.xAxisHeight = 0, this.isSparkline = this.w.config.chart.sparkline.enabled, this.dimHelpers = new it2(this), this.dimYAxis = new st2(this), this.dimXAxis = new at2(this), this.dimGrid = new rt2(this), this.lgWidthForSideLegends = 0, this.gridPad = this.w.config.grid.padding, this.xPadRight = 0, this.xPadLeft = 0;
    }
    return r(t3, [{ key: "plotCoords", value: function() {
      var t4 = this, e3 = this.w, i2 = e3.globals;
      this.lgRect = this.dimHelpers.getLegendsRect(), this.datalabelsCoords = { width: 0, height: 0 };
      var a3 = Array.isArray(e3.config.stroke.width) ? Math.max.apply(Math, u2(e3.config.stroke.width)) : e3.config.stroke.width;
      this.isSparkline && ((e3.config.markers.discrete.length > 0 || e3.config.markers.size > 0) && Object.entries(this.gridPad).forEach(function(e4) {
        var i3 = g2(e4, 2), a4 = i3[0], s4 = i3[1];
        t4.gridPad[a4] = Math.max(s4, t4.w.globals.markers.largestSize / 1.5);
      }), this.gridPad.top = Math.max(a3 / 2, this.gridPad.top), this.gridPad.bottom = Math.max(a3 / 2, this.gridPad.bottom)), i2.axisCharts ? this.setDimensionsForAxisCharts() : this.setDimensionsForNonAxisCharts(), this.dimGrid.gridPadFortitleSubtitle(), i2.gridHeight = i2.gridHeight - this.gridPad.top - this.gridPad.bottom, i2.gridWidth = i2.gridWidth - this.gridPad.left - this.gridPad.right - this.xPadRight - this.xPadLeft;
      var s3 = this.dimGrid.gridPadForColumnsInNumericAxis(i2.gridWidth);
      i2.gridWidth = i2.gridWidth - 2 * s3, i2.translateX = i2.translateX + this.gridPad.left + this.xPadLeft + (s3 > 0 ? s3 : 0), i2.translateY = i2.translateY + this.gridPad.top;
    } }, { key: "setDimensionsForAxisCharts", value: function() {
      var t4 = this, e3 = this.w, i2 = e3.globals, a3 = this.dimYAxis.getyAxisLabelsCoords(), s3 = this.dimYAxis.getyAxisTitleCoords();
      i2.isSlopeChart && (this.datalabelsCoords = this.dimHelpers.getDatalabelsRect()), e3.globals.yLabelsCoords = [], e3.globals.yTitleCoords = [], e3.config.yaxis.map(function(t5, i3) {
        e3.globals.yLabelsCoords.push({ width: a3[i3].width, index: i3 }), e3.globals.yTitleCoords.push({ width: s3[i3].width, index: i3 });
      }), this.yAxisWidth = this.dimYAxis.getTotalYAxisWidth();
      var r2 = this.dimXAxis.getxAxisLabelsCoords(), o3 = this.dimXAxis.getxAxisGroupLabelsCoords(), n3 = this.dimXAxis.getxAxisTitleCoords();
      this.conditionalChecksForAxisCoords(r2, n3, o3), i2.translateXAxisY = e3.globals.rotateXLabels ? this.xAxisHeight / 8 : -4, i2.translateXAxisX = e3.globals.rotateXLabels && e3.globals.isXNumeric && e3.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0, e3.globals.isBarHorizontal && (i2.rotateXLabels = false, i2.translateXAxisY = parseInt(e3.config.xaxis.labels.style.fontSize, 10) / 1.5 * -1), i2.translateXAxisY = i2.translateXAxisY + e3.config.xaxis.labels.offsetY, i2.translateXAxisX = i2.translateXAxisX + e3.config.xaxis.labels.offsetX;
      var l3 = this.yAxisWidth, h3 = this.xAxisHeight;
      i2.xAxisLabelsHeight = this.xAxisHeight - n3.height, i2.xAxisGroupLabelsHeight = i2.xAxisLabelsHeight - r2.height, i2.xAxisLabelsWidth = this.xAxisWidth, i2.xAxisHeight = this.xAxisHeight;
      var c3 = 10;
      ("radar" === e3.config.chart.type || this.isSparkline) && (l3 = 0, h3 = i2.goldenPadding), this.isSparkline && (this.lgRect = { height: 0, width: 0 }), (this.isSparkline || "treemap" === e3.config.chart.type) && (l3 = 0, h3 = 0, c3 = 0), this.isSparkline || this.dimXAxis.additionalPaddingXLabels(r2);
      var d3 = function() {
        i2.translateX = l3 + t4.datalabelsCoords.width, i2.gridHeight = i2.svgHeight - t4.lgRect.height - h3 - (t4.isSparkline || "treemap" === e3.config.chart.type ? 0 : e3.globals.rotateXLabels ? 10 : 15), i2.gridWidth = i2.svgWidth - l3 - 2 * t4.datalabelsCoords.width;
      };
      switch ("top" === e3.config.xaxis.position && (c3 = i2.xAxisHeight - e3.config.xaxis.axisTicks.height - 5), e3.config.legend.position) {
        case "bottom":
          i2.translateY = c3, d3();
          break;
        case "top":
          i2.translateY = this.lgRect.height + c3, d3();
          break;
        case "left":
          i2.translateY = c3, i2.translateX = this.lgRect.width + l3 + this.datalabelsCoords.width, i2.gridHeight = i2.svgHeight - h3 - 12, i2.gridWidth = i2.svgWidth - this.lgRect.width - l3 - 2 * this.datalabelsCoords.width;
          break;
        case "right":
          i2.translateY = c3, i2.translateX = l3 + this.datalabelsCoords.width, i2.gridHeight = i2.svgHeight - h3 - 12, i2.gridWidth = i2.svgWidth - this.lgRect.width - l3 - 2 * this.datalabelsCoords.width - 5;
          break;
        default:
          throw new Error("Legend position not supported");
      }
      this.dimGrid.setGridXPosForDualYAxis(s3, a3), new q2(this.ctx).setYAxisXPosition(a3, s3);
    } }, { key: "setDimensionsForNonAxisCharts", value: function() {
      var t4 = this.w, e3 = t4.globals, i2 = t4.config, a3 = 0;
      t4.config.legend.show && !t4.config.legend.floating && (a3 = 20);
      var s3 = "pie" === i2.chart.type || "polarArea" === i2.chart.type || "donut" === i2.chart.type ? "pie" : "radialBar", r2 = i2.plotOptions[s3].offsetY, o3 = i2.plotOptions[s3].offsetX;
      if (!i2.legend.show || i2.legend.floating) return e3.gridHeight = e3.svgHeight - i2.grid.padding.left + i2.grid.padding.right, e3.gridWidth = Math.min(e3.svgWidth, e3.gridHeight), e3.translateY = r2, void (e3.translateX = o3 + (e3.svgWidth - e3.gridWidth) / 2);
      switch (i2.legend.position) {
        case "bottom":
          e3.gridHeight = e3.svgHeight - this.lgRect.height - e3.goldenPadding, e3.gridWidth = e3.svgWidth, e3.translateY = r2 - 10, e3.translateX = o3 + (e3.svgWidth - e3.gridWidth) / 2;
          break;
        case "top":
          e3.gridHeight = e3.svgHeight - this.lgRect.height - e3.goldenPadding, e3.gridWidth = e3.svgWidth, e3.translateY = this.lgRect.height + r2 + 10, e3.translateX = o3 + (e3.svgWidth - e3.gridWidth) / 2;
          break;
        case "left":
          e3.gridWidth = e3.svgWidth - this.lgRect.width - a3, e3.gridHeight = "auto" !== i2.chart.height ? e3.svgHeight : e3.gridWidth, e3.translateY = r2, e3.translateX = o3 + this.lgRect.width + a3;
          break;
        case "right":
          e3.gridWidth = e3.svgWidth - this.lgRect.width - a3 - 5, e3.gridHeight = "auto" !== i2.chart.height ? e3.svgHeight : e3.gridWidth, e3.translateY = r2, e3.translateX = o3 + 10;
          break;
        default:
          throw new Error("Legend position not supported");
      }
    } }, { key: "conditionalChecksForAxisCoords", value: function(t4, e3, i2) {
      var a3 = this.w, s3 = a3.globals.hasXaxisGroups ? 2 : 1, r2 = i2.height + t4.height + e3.height, o3 = a3.globals.isMultiLineX ? 1.2 : a3.globals.LINE_HEIGHT_RATIO, n3 = a3.globals.rotateXLabels ? 22 : 10, l3 = a3.globals.rotateXLabels && "bottom" === a3.config.legend.position ? 10 : 0;
      this.xAxisHeight = r2 * o3 + s3 * n3 + l3, this.xAxisWidth = t4.width, this.xAxisHeight - e3.height > a3.config.xaxis.labels.maxHeight && (this.xAxisHeight = a3.config.xaxis.labels.maxHeight), a3.config.xaxis.labels.minHeight && this.xAxisHeight < a3.config.xaxis.labels.minHeight && (this.xAxisHeight = a3.config.xaxis.labels.minHeight), a3.config.xaxis.floating && (this.xAxisHeight = 0);
      var h3 = 0, c3 = 0;
      a3.config.yaxis.forEach(function(t5) {
        h3 += t5.labels.minWidth, c3 += t5.labels.maxWidth;
      }), this.yAxisWidth < h3 && (this.yAxisWidth = h3), this.yAxisWidth > c3 && (this.yAxisWidth = c3);
    } }]), t3;
  }(), nt2 = function() {
    function t3(e3) {
      a2(this, t3), this.w = e3.w, this.lgCtx = e3;
    }
    return r(t3, [{ key: "getLegendStyles", value: function() {
      var t4, e3, i2, a3 = document.createElement("style");
      a3.setAttribute("type", "text/css");
      var s3 = (null === (t4 = this.lgCtx.ctx) || void 0 === t4 || null === (e3 = t4.opts) || void 0 === e3 || null === (i2 = e3.chart) || void 0 === i2 ? void 0 : i2.nonce) || this.w.config.chart.nonce;
      s3 && a3.setAttribute("nonce", s3);
      var r2 = document.createTextNode("\n      .apexcharts-legend {\n        display: flex;\n        overflow: auto;\n        padding: 0 10px;\n      }\n      .apexcharts-legend.apx-legend-position-bottom, .apexcharts-legend.apx-legend-position-top {\n        flex-wrap: wrap\n      }\n      .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\n        flex-direction: column;\n        bottom: 0;\n      }\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-left, .apexcharts-legend.apx-legend-position-top.apexcharts-align-left, .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\n        justify-content: flex-start;\n      }\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-center, .apexcharts-legend.apx-legend-position-top.apexcharts-align-center {\n        justify-content: center;\n      }\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-right, .apexcharts-legend.apx-legend-position-top.apexcharts-align-right {\n        justify-content: flex-end;\n      }\n      .apexcharts-legend-series {\n        cursor: pointer;\n        line-height: normal;\n      }\n      .apexcharts-legend.apx-legend-position-bottom .apexcharts-legend-series, .apexcharts-legend.apx-legend-position-top .apexcharts-legend-series{\n        display: flex;\n        align-items: center;\n      }\n      .apexcharts-legend-text {\n        position: relative;\n        font-size: 14px;\n      }\n      .apexcharts-legend-text *, .apexcharts-legend-marker * {\n        pointer-events: none;\n      }\n      .apexcharts-legend-marker {\n        position: relative;\n        display: inline-block;\n        cursor: pointer;\n        margin-right: 3px;\n        border-style: solid;\n      }\n\n      .apexcharts-legend.apexcharts-align-right .apexcharts-legend-series, .apexcharts-legend.apexcharts-align-left .apexcharts-legend-series{\n        display: inline-block;\n      }\n      .apexcharts-legend-series.apexcharts-no-click {\n        cursor: auto;\n      }\n      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {\n        display: none !important;\n      }\n      .apexcharts-inactive-legend {\n        opacity: 0.45;\n      }");
      return a3.appendChild(r2), a3;
    } }, { key: "getLegendBBox", value: function() {
      var t4 = this.w.globals.dom.baseEl.querySelector(".apexcharts-legend").getBoundingClientRect(), e3 = t4.width;
      return { clwh: t4.height, clww: e3 };
    } }, { key: "appendToForeignObject", value: function() {
      this.w.globals.dom.elLegendForeign.appendChild(this.getLegendStyles());
    } }, { key: "toggleDataSeries", value: function(t4, e3) {
      var i2 = this, a3 = this.w;
      if (a3.globals.axisCharts || "radialBar" === a3.config.chart.type) {
        a3.globals.resized = true;
        var s3 = null, r2 = null;
        if (a3.globals.risingSeries = [], a3.globals.axisCharts ? (s3 = a3.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(t4, "']")), r2 = parseInt(s3.getAttribute("data:realIndex"), 10)) : (s3 = a3.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(t4 + 1, "']")), r2 = parseInt(s3.getAttribute("rel"), 10) - 1), e3) [{ cs: a3.globals.collapsedSeries, csi: a3.globals.collapsedSeriesIndices }, { cs: a3.globals.ancillaryCollapsedSeries, csi: a3.globals.ancillaryCollapsedSeriesIndices }].forEach(function(t5) {
          i2.riseCollapsedSeries(t5.cs, t5.csi, r2);
        });
        else this.hideSeries({ seriesEl: s3, realIndex: r2 });
      } else {
        var o3 = a3.globals.dom.Paper.select(" .apexcharts-series[rel='".concat(t4 + 1, "'] path")), n3 = a3.config.chart.type;
        if ("pie" === n3 || "polarArea" === n3 || "donut" === n3) {
          var l3 = a3.config.plotOptions.pie.donut.labels;
          new m2(this.lgCtx.ctx).pathMouseDown(o3.members[0], null), this.lgCtx.ctx.pie.printDataLabelsInner(o3.members[0].node, l3);
        }
        o3.fire("click");
      }
    } }, { key: "hideSeries", value: function(t4) {
      var e3 = t4.seriesEl, i2 = t4.realIndex, a3 = this.w, s3 = a3.globals, r2 = x2.clone(a3.config.series);
      if (s3.axisCharts) {
        var o3 = a3.config.yaxis[s3.seriesYAxisReverseMap[i2]];
        if (o3 && o3.show && o3.showAlways) s3.ancillaryCollapsedSeriesIndices.indexOf(i2) < 0 && (s3.ancillaryCollapsedSeries.push({ index: i2, data: r2[i2].data.slice(), type: e3.parentNode.className.baseVal.split("-")[1] }), s3.ancillaryCollapsedSeriesIndices.push(i2));
        else if (s3.collapsedSeriesIndices.indexOf(i2) < 0) {
          s3.collapsedSeries.push({ index: i2, data: r2[i2].data.slice(), type: e3.parentNode.className.baseVal.split("-")[1] }), s3.collapsedSeriesIndices.push(i2);
          var n3 = s3.risingSeries.indexOf(i2);
          s3.risingSeries.splice(n3, 1);
        }
      } else s3.collapsedSeries.push({ index: i2, data: r2[i2] }), s3.collapsedSeriesIndices.push(i2);
      for (var l3 = e3.childNodes, h3 = 0; h3 < l3.length; h3++) l3[h3].classList.contains("apexcharts-series-markers-wrap") && (l3[h3].classList.contains("apexcharts-hide") ? l3[h3].classList.remove("apexcharts-hide") : l3[h3].classList.add("apexcharts-hide"));
      s3.allSeriesCollapsed = s3.collapsedSeries.length + s3.ancillaryCollapsedSeries.length === a3.config.series.length, r2 = this._getSeriesBasedOnCollapsedState(r2), this.lgCtx.ctx.updateHelpers._updateSeries(r2, a3.config.chart.animations.dynamicAnimation.enabled);
    } }, { key: "riseCollapsedSeries", value: function(t4, e3, i2) {
      var a3 = this.w, s3 = x2.clone(a3.config.series);
      if (t4.length > 0) {
        for (var r2 = 0; r2 < t4.length; r2++) t4[r2].index === i2 && (a3.globals.axisCharts ? (s3[i2].data = t4[r2].data.slice(), t4.splice(r2, 1), e3.splice(r2, 1), a3.globals.risingSeries.push(i2)) : (s3[i2] = t4[r2].data, t4.splice(r2, 1), e3.splice(r2, 1), a3.globals.risingSeries.push(i2)));
        s3 = this._getSeriesBasedOnCollapsedState(s3), this.lgCtx.ctx.updateHelpers._updateSeries(s3, a3.config.chart.animations.dynamicAnimation.enabled);
      }
    } }, { key: "_getSeriesBasedOnCollapsedState", value: function(t4) {
      var e3 = this.w, i2 = 0;
      return e3.globals.axisCharts ? t4.forEach(function(a3, s3) {
        e3.globals.collapsedSeriesIndices.indexOf(s3) < 0 && e3.globals.ancillaryCollapsedSeriesIndices.indexOf(s3) < 0 || (t4[s3].data = [], i2++);
      }) : t4.forEach(function(a3, s3) {
        !e3.globals.collapsedSeriesIndices.indexOf(s3) < 0 && (t4[s3] = 0, i2++);
      }), e3.globals.allSeriesCollapsed = i2 === t4.length, t4;
    } }]), t3;
  }(), lt2 = function() {
    function t3(e3) {
      a2(this, t3), this.ctx = e3, this.w = e3.w, this.onLegendClick = this.onLegendClick.bind(this), this.onLegendHovered = this.onLegendHovered.bind(this), this.isBarsDistributed = "bar" === this.w.config.chart.type && this.w.config.plotOptions.bar.distributed && 1 === this.w.config.series.length, this.legendHelpers = new nt2(this);
    }
    return r(t3, [{ key: "init", value: function() {
      var t4 = this.w, e3 = t4.globals, i2 = t4.config;
      if ((i2.legend.showForSingleSeries && 1 === e3.series.length || this.isBarsDistributed || e3.series.length > 1 || !e3.axisCharts) && i2.legend.show) {
        for (; e3.dom.elLegendWrap.firstChild; ) e3.dom.elLegendWrap.removeChild(e3.dom.elLegendWrap.firstChild);
        this.drawLegends(), x2.isIE11() ? document.getElementsByTagName("head")[0].appendChild(this.legendHelpers.getLegendStyles()) : this.legendHelpers.appendToForeignObject(), "bottom" === i2.legend.position || "top" === i2.legend.position ? this.legendAlignHorizontal() : "right" !== i2.legend.position && "left" !== i2.legend.position || this.legendAlignVertical();
      }
    } }, { key: "drawLegends", value: function() {
      var t4 = this, e3 = this.w, i2 = e3.config.legend.fontFamily, a3 = e3.globals.seriesNames, s3 = e3.globals.colors.slice();
      if ("heatmap" === e3.config.chart.type) {
        var r2 = e3.config.plotOptions.heatmap.colorScale.ranges;
        a3 = r2.map(function(t5) {
          return t5.name ? t5.name : t5.from + " - " + t5.to;
        }), s3 = r2.map(function(t5) {
          return t5.color;
        });
      } else this.isBarsDistributed && (a3 = e3.globals.labels.slice());
      e3.config.legend.customLegendItems.length && (a3 = e3.config.legend.customLegendItems);
      for (var o3 = e3.globals.legendFormatter, n3 = e3.config.legend.inverseOrder, l3 = n3 ? a3.length - 1 : 0; n3 ? l3 >= 0 : l3 <= a3.length - 1; n3 ? l3-- : l3++) {
        var h3, c3 = o3(a3[l3], { seriesIndex: l3, w: e3 }), d3 = false, g3 = false;
        if (e3.globals.collapsedSeries.length > 0) for (var u3 = 0; u3 < e3.globals.collapsedSeries.length; u3++) e3.globals.collapsedSeries[u3].index === l3 && (d3 = true);
        if (e3.globals.ancillaryCollapsedSeriesIndices.length > 0) for (var p3 = 0; p3 < e3.globals.ancillaryCollapsedSeriesIndices.length; p3++) e3.globals.ancillaryCollapsedSeriesIndices[p3] === l3 && (g3 = true);
        var f3 = document.createElement("span");
        f3.classList.add("apexcharts-legend-marker");
        var b3 = e3.config.legend.markers.offsetX, v3 = e3.config.legend.markers.offsetY, w3 = e3.config.legend.markers.height, k3 = e3.config.legend.markers.width, A3 = e3.config.legend.markers.strokeWidth, S3 = e3.config.legend.markers.strokeColor, C3 = e3.config.legend.markers.radius, L3 = f3.style;
        L3.background = s3[l3], L3.color = s3[l3], L3.setProperty("background", s3[l3], "important"), e3.config.legend.markers.fillColors && e3.config.legend.markers.fillColors[l3] && (L3.background = e3.config.legend.markers.fillColors[l3]), void 0 !== e3.globals.seriesColors[l3] && (L3.background = e3.globals.seriesColors[l3], L3.color = e3.globals.seriesColors[l3]), L3.height = Array.isArray(w3) ? parseFloat(w3[l3]) + "px" : parseFloat(w3) + "px", L3.width = Array.isArray(k3) ? parseFloat(k3[l3]) + "px" : parseFloat(k3) + "px", L3.left = (Array.isArray(b3) ? parseFloat(b3[l3]) : parseFloat(b3)) + "px", L3.top = (Array.isArray(v3) ? parseFloat(v3[l3]) : parseFloat(v3)) + "px", L3.borderWidth = Array.isArray(A3) ? A3[l3] : A3, L3.borderColor = Array.isArray(S3) ? S3[l3] : S3, L3.borderRadius = Array.isArray(C3) ? parseFloat(C3[l3]) + "px" : parseFloat(C3) + "px", e3.config.legend.markers.customHTML && (Array.isArray(e3.config.legend.markers.customHTML) ? e3.config.legend.markers.customHTML[l3] && (f3.innerHTML = e3.config.legend.markers.customHTML[l3]()) : f3.innerHTML = e3.config.legend.markers.customHTML()), m2.setAttrs(f3, { rel: l3 + 1, "data:collapsed": d3 || g3 }), (d3 || g3) && f3.classList.add("apexcharts-inactive-legend");
        var P3 = document.createElement("div"), M3 = document.createElement("span");
        M3.classList.add("apexcharts-legend-text"), M3.innerHTML = Array.isArray(c3) ? c3.join(" ") : c3;
        var I3 = e3.config.legend.labels.useSeriesColors ? e3.globals.colors[l3] : Array.isArray(e3.config.legend.labels.colors) ? null === (h3 = e3.config.legend.labels.colors) || void 0 === h3 ? void 0 : h3[l3] : e3.config.legend.labels.colors;
        I3 || (I3 = e3.config.chart.foreColor), M3.style.color = I3, M3.style.fontSize = parseFloat(e3.config.legend.fontSize) + "px", M3.style.fontWeight = e3.config.legend.fontWeight, M3.style.fontFamily = i2 || e3.config.chart.fontFamily, m2.setAttrs(M3, { rel: l3 + 1, i: l3, "data:default-text": encodeURIComponent(c3), "data:collapsed": d3 || g3 }), P3.appendChild(f3), P3.appendChild(M3);
        var T3 = new y2(this.ctx);
        if (!e3.config.legend.showForZeroSeries) 0 === T3.getSeriesTotalByIndex(l3) && T3.seriesHaveSameValues(l3) && !T3.isSeriesNull(l3) && -1 === e3.globals.collapsedSeriesIndices.indexOf(l3) && -1 === e3.globals.ancillaryCollapsedSeriesIndices.indexOf(l3) && P3.classList.add("apexcharts-hidden-zero-series");
        e3.config.legend.showForNullSeries || T3.isSeriesNull(l3) && -1 === e3.globals.collapsedSeriesIndices.indexOf(l3) && -1 === e3.globals.ancillaryCollapsedSeriesIndices.indexOf(l3) && P3.classList.add("apexcharts-hidden-null-series"), e3.globals.dom.elLegendWrap.appendChild(P3), e3.globals.dom.elLegendWrap.classList.add("apexcharts-align-".concat(e3.config.legend.horizontalAlign)), e3.globals.dom.elLegendWrap.classList.add("apx-legend-position-" + e3.config.legend.position), P3.classList.add("apexcharts-legend-series"), P3.style.margin = "".concat(e3.config.legend.itemMargin.vertical, "px ").concat(e3.config.legend.itemMargin.horizontal, "px"), e3.globals.dom.elLegendWrap.style.width = e3.config.legend.width ? e3.config.legend.width + "px" : "", e3.globals.dom.elLegendWrap.style.height = e3.config.legend.height ? e3.config.legend.height + "px" : "", m2.setAttrs(P3, { rel: l3 + 1, seriesName: x2.escapeString(a3[l3]), "data:collapsed": d3 || g3 }), (d3 || g3) && P3.classList.add("apexcharts-inactive-legend"), e3.config.legend.onItemClick.toggleDataSeries || P3.classList.add("apexcharts-no-click");
      }
      e3.globals.dom.elWrap.addEventListener("click", t4.onLegendClick, true), e3.config.legend.onItemHover.highlightDataSeries && 0 === e3.config.legend.customLegendItems.length && (e3.globals.dom.elWrap.addEventListener("mousemove", t4.onLegendHovered, true), e3.globals.dom.elWrap.addEventListener("mouseout", t4.onLegendHovered, true));
    } }, { key: "setLegendWrapXY", value: function(t4, e3) {
      var i2 = this.w, a3 = i2.globals.dom.elLegendWrap, s3 = a3.getBoundingClientRect(), r2 = 0, o3 = 0;
      if ("bottom" === i2.config.legend.position) o3 += i2.globals.svgHeight - s3.height / 2;
      else if ("top" === i2.config.legend.position) {
        var n3 = new ot2(this.ctx), l3 = n3.dimHelpers.getTitleSubtitleCoords("title").height, h3 = n3.dimHelpers.getTitleSubtitleCoords("subtitle").height;
        o3 = o3 + (l3 > 0 ? l3 - 10 : 0) + (h3 > 0 ? h3 - 10 : 0);
      }
      a3.style.position = "absolute", r2 = r2 + t4 + i2.config.legend.offsetX, o3 = o3 + e3 + i2.config.legend.offsetY, a3.style.left = r2 + "px", a3.style.top = o3 + "px", "bottom" === i2.config.legend.position ? (a3.style.top = "auto", a3.style.bottom = 5 - i2.config.legend.offsetY + "px") : "right" === i2.config.legend.position && (a3.style.left = "auto", a3.style.right = 25 + i2.config.legend.offsetX + "px");
      ["width", "height"].forEach(function(t5) {
        a3.style[t5] && (a3.style[t5] = parseInt(i2.config.legend[t5], 10) + "px");
      });
    } }, { key: "legendAlignHorizontal", value: function() {
      var t4 = this.w;
      t4.globals.dom.elLegendWrap.style.right = 0;
      var e3 = this.legendHelpers.getLegendBBox(), i2 = new ot2(this.ctx), a3 = i2.dimHelpers.getTitleSubtitleCoords("title"), s3 = i2.dimHelpers.getTitleSubtitleCoords("subtitle"), r2 = 0;
      "bottom" === t4.config.legend.position ? r2 = -e3.clwh / 1.8 : "top" === t4.config.legend.position && (r2 = a3.height + s3.height + t4.config.title.margin + t4.config.subtitle.margin - 10), this.setLegendWrapXY(20, r2);
    } }, { key: "legendAlignVertical", value: function() {
      var t4 = this.w, e3 = this.legendHelpers.getLegendBBox(), i2 = 0;
      "left" === t4.config.legend.position && (i2 = 20), "right" === t4.config.legend.position && (i2 = t4.globals.svgWidth - e3.clww - 10), this.setLegendWrapXY(i2, 20);
    } }, { key: "onLegendHovered", value: function(t4) {
      var e3 = this.w, i2 = t4.target.classList.contains("apexcharts-legend-series") || t4.target.classList.contains("apexcharts-legend-text") || t4.target.classList.contains("apexcharts-legend-marker");
      if ("heatmap" === e3.config.chart.type || this.isBarsDistributed) {
        if (i2) {
          var a3 = parseInt(t4.target.getAttribute("rel"), 10) - 1;
          this.ctx.events.fireEvent("legendHover", [this.ctx, a3, this.w]), new W2(this.ctx).highlightRangeInSeries(t4, t4.target);
        }
      } else !t4.target.classList.contains("apexcharts-inactive-legend") && i2 && new W2(this.ctx).toggleSeriesOnHover(t4, t4.target);
    } }, { key: "onLegendClick", value: function(t4) {
      var e3 = this.w;
      if (!e3.config.legend.customLegendItems.length && (t4.target.classList.contains("apexcharts-legend-series") || t4.target.classList.contains("apexcharts-legend-text") || t4.target.classList.contains("apexcharts-legend-marker"))) {
        var i2 = parseInt(t4.target.getAttribute("rel"), 10) - 1, a3 = "true" === t4.target.getAttribute("data:collapsed"), s3 = this.w.config.chart.events.legendClick;
        "function" == typeof s3 && s3(this.ctx, i2, this.w), this.ctx.events.fireEvent("legendClick", [this.ctx, i2, this.w]);
        var r2 = this.w.config.legend.markers.onClick;
        "function" == typeof r2 && t4.target.classList.contains("apexcharts-legend-marker") && (r2(this.ctx, i2, this.w), this.ctx.events.fireEvent("legendMarkerClick", [this.ctx, i2, this.w])), "treemap" !== e3.config.chart.type && "heatmap" !== e3.config.chart.type && !this.isBarsDistributed && e3.config.legend.onItemClick.toggleDataSeries && this.legendHelpers.toggleDataSeries(i2, a3);
      }
    } }]), t3;
  }(), ht2 = function() {
    function t3(e3) {
      a2(this, t3), this.ctx = e3, this.w = e3.w;
      var i2 = this.w;
      this.ev = this.w.config.chart.events, this.selectedClass = "apexcharts-selected", this.localeValues = this.w.globals.locale.toolbar, this.minX = i2.globals.minX, this.maxX = i2.globals.maxX;
    }
    return r(t3, [{ key: "createToolbar", value: function() {
      var t4 = this, e3 = this.w, i2 = function() {
        return document.createElement("div");
      }, a3 = i2();
      if (a3.setAttribute("class", "apexcharts-toolbar"), a3.style.top = e3.config.chart.toolbar.offsetY + "px", a3.style.right = 3 - e3.config.chart.toolbar.offsetX + "px", e3.globals.dom.elWrap.appendChild(a3), this.elZoom = i2(), this.elZoomIn = i2(), this.elZoomOut = i2(), this.elPan = i2(), this.elSelection = i2(), this.elZoomReset = i2(), this.elMenuIcon = i2(), this.elMenu = i2(), this.elCustomIcons = [], this.t = e3.config.chart.toolbar.tools, Array.isArray(this.t.customIcons)) for (var s3 = 0; s3 < this.t.customIcons.length; s3++) this.elCustomIcons.push(i2());
      var r2 = [], o3 = function(i3, a4, s4) {
        var o4 = i3.toLowerCase();
        t4.t[o4] && e3.config.chart.zoom.enabled && r2.push({ el: a4, icon: "string" == typeof t4.t[o4] ? t4.t[o4] : s4, title: t4.localeValues[i3], class: "apexcharts-".concat(o4, "-icon") });
      };
      o3("zoomIn", this.elZoomIn, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n'), o3("zoomOut", this.elZoomOut, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n');
      var n3 = function(i3) {
        t4.t[i3] && e3.config.chart[i3].enabled && r2.push({ el: "zoom" === i3 ? t4.elZoom : t4.elSelection, icon: "string" == typeof t4.t[i3] ? t4.t[i3] : "zoom" === i3 ? '<svg xmlns="http://www.w3.org/2000/svg" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>\n    <path d="M0 0h24v24H0V0z" fill="none"/>\n    <path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"/>\n</svg>' : '<svg fill="#6E8192" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z"/>\n</svg>', title: t4.localeValues["zoom" === i3 ? "selectionZoom" : "selection"], class: e3.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-".concat(i3, "-icon") });
      };
      n3("zoom"), n3("selection"), this.t.pan && e3.config.chart.zoom.enabled && r2.push({ el: this.elPan, icon: "string" == typeof this.t.pan ? this.t.pan : '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <defs>\n        <path d="M0 0h24v24H0z" id="a"/>\n    </defs>\n    <clipPath id="b">\n        <use overflow="visible" xlink:href="#a"/>\n    </clipPath>\n    <path clip-path="url(#b)" d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"/>\n</svg>', title: this.localeValues.pan, class: e3.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-pan-icon" }), o3("reset", this.elZoomReset, '<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>\n    <path d="M0 0h24v24H0z" fill="none"/>\n</svg>'), this.t.download && r2.push({ el: this.elMenuIcon, icon: "string" == typeof this.t.download ? this.t.download : '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>', title: this.localeValues.menu, class: "apexcharts-menu-icon" });
      for (var l3 = 0; l3 < this.elCustomIcons.length; l3++) r2.push({ el: this.elCustomIcons[l3], icon: this.t.customIcons[l3].icon, title: this.t.customIcons[l3].title, index: this.t.customIcons[l3].index, class: "apexcharts-toolbar-custom-icon " + this.t.customIcons[l3].class });
      r2.forEach(function(t5, e4) {
        t5.index && x2.moveIndexInArray(r2, e4, t5.index);
      });
      for (var h3 = 0; h3 < r2.length; h3++) m2.setAttrs(r2[h3].el, { class: r2[h3].class, title: r2[h3].title }), r2[h3].el.innerHTML = r2[h3].icon, a3.appendChild(r2[h3].el);
      this._createHamburgerMenu(a3), e3.globals.zoomEnabled ? this.elZoom.classList.add(this.selectedClass) : e3.globals.panEnabled ? this.elPan.classList.add(this.selectedClass) : e3.globals.selectionEnabled && this.elSelection.classList.add(this.selectedClass), this.addToolbarEventListeners();
    } }, { key: "_createHamburgerMenu", value: function(t4) {
      this.elMenuItems = [], t4.appendChild(this.elMenu), m2.setAttrs(this.elMenu, { class: "apexcharts-menu" });
      for (var e3 = [{ name: "exportSVG", title: this.localeValues.exportToSVG }, { name: "exportPNG", title: this.localeValues.exportToPNG }, { name: "exportCSV", title: this.localeValues.exportToCSV }], i2 = 0; i2 < e3.length; i2++) this.elMenuItems.push(document.createElement("div")), this.elMenuItems[i2].innerHTML = e3[i2].title, m2.setAttrs(this.elMenuItems[i2], { class: "apexcharts-menu-item ".concat(e3[i2].name), title: e3[i2].title }), this.elMenu.appendChild(this.elMenuItems[i2]);
    } }, { key: "addToolbarEventListeners", value: function() {
      var t4 = this;
      this.elZoomReset.addEventListener("click", this.handleZoomReset.bind(this)), this.elSelection.addEventListener("click", this.toggleZoomSelection.bind(this, "selection")), this.elZoom.addEventListener("click", this.toggleZoomSelection.bind(this, "zoom")), this.elZoomIn.addEventListener("click", this.handleZoomIn.bind(this)), this.elZoomOut.addEventListener("click", this.handleZoomOut.bind(this)), this.elPan.addEventListener("click", this.togglePanning.bind(this)), this.elMenuIcon.addEventListener("click", this.toggleMenu.bind(this)), this.elMenuItems.forEach(function(e4) {
        e4.classList.contains("exportSVG") ? e4.addEventListener("click", t4.handleDownload.bind(t4, "svg")) : e4.classList.contains("exportPNG") ? e4.addEventListener("click", t4.handleDownload.bind(t4, "png")) : e4.classList.contains("exportCSV") && e4.addEventListener("click", t4.handleDownload.bind(t4, "csv"));
      });
      for (var e3 = 0; e3 < this.t.customIcons.length; e3++) this.elCustomIcons[e3].addEventListener("click", this.t.customIcons[e3].click.bind(this, this.ctx, this.ctx.w));
    } }, { key: "toggleZoomSelection", value: function(t4) {
      this.ctx.getSyncedCharts().forEach(function(e3) {
        e3.ctx.toolbar.toggleOtherControls();
        var i2 = "selection" === t4 ? e3.ctx.toolbar.elSelection : e3.ctx.toolbar.elZoom, a3 = "selection" === t4 ? "selectionEnabled" : "zoomEnabled";
        e3.w.globals[a3] = !e3.w.globals[a3], i2.classList.contains(e3.ctx.toolbar.selectedClass) ? i2.classList.remove(e3.ctx.toolbar.selectedClass) : i2.classList.add(e3.ctx.toolbar.selectedClass);
      });
    } }, { key: "getToolbarIconsReference", value: function() {
      var t4 = this.w;
      this.elZoom || (this.elZoom = t4.globals.dom.baseEl.querySelector(".apexcharts-zoom-icon")), this.elPan || (this.elPan = t4.globals.dom.baseEl.querySelector(".apexcharts-pan-icon")), this.elSelection || (this.elSelection = t4.globals.dom.baseEl.querySelector(".apexcharts-selection-icon"));
    } }, { key: "enableZoomPanFromToolbar", value: function(t4) {
      this.toggleOtherControls(), "pan" === t4 ? this.w.globals.panEnabled = true : this.w.globals.zoomEnabled = true;
      var e3 = "pan" === t4 ? this.elPan : this.elZoom, i2 = "pan" === t4 ? this.elZoom : this.elPan;
      e3 && e3.classList.add(this.selectedClass), i2 && i2.classList.remove(this.selectedClass);
    } }, { key: "togglePanning", value: function() {
      this.ctx.getSyncedCharts().forEach(function(t4) {
        t4.ctx.toolbar.toggleOtherControls(), t4.w.globals.panEnabled = !t4.w.globals.panEnabled, t4.ctx.toolbar.elPan.classList.contains(t4.ctx.toolbar.selectedClass) ? t4.ctx.toolbar.elPan.classList.remove(t4.ctx.toolbar.selectedClass) : t4.ctx.toolbar.elPan.classList.add(t4.ctx.toolbar.selectedClass);
      });
    } }, { key: "toggleOtherControls", value: function() {
      var t4 = this, e3 = this.w;
      e3.globals.panEnabled = false, e3.globals.zoomEnabled = false, e3.globals.selectionEnabled = false, this.getToolbarIconsReference(), [this.elPan, this.elSelection, this.elZoom].forEach(function(e4) {
        e4 && e4.classList.remove(t4.selectedClass);
      });
    } }, { key: "handleZoomIn", value: function() {
      var t4 = this.w;
      t4.globals.isRangeBar && (this.minX = t4.globals.minY, this.maxX = t4.globals.maxY);
      var e3 = (this.minX + this.maxX) / 2, i2 = (this.minX + e3) / 2, a3 = (this.maxX + e3) / 2, s3 = this._getNewMinXMaxX(i2, a3);
      t4.globals.disableZoomIn || this.zoomUpdateOptions(s3.minX, s3.maxX);
    } }, { key: "handleZoomOut", value: function() {
      var t4 = this.w;
      if (t4.globals.isRangeBar && (this.minX = t4.globals.minY, this.maxX = t4.globals.maxY), !("datetime" === t4.config.xaxis.type && new Date(this.minX).getUTCFullYear() < 1e3)) {
        var e3 = (this.minX + this.maxX) / 2, i2 = this.minX - (e3 - this.minX), a3 = this.maxX - (e3 - this.maxX), s3 = this._getNewMinXMaxX(i2, a3);
        t4.globals.disableZoomOut || this.zoomUpdateOptions(s3.minX, s3.maxX);
      }
    } }, { key: "_getNewMinXMaxX", value: function(t4, e3) {
      var i2 = this.w.config.xaxis.convertedCatToNumeric;
      return { minX: i2 ? Math.floor(t4) : t4, maxX: i2 ? Math.floor(e3) : e3 };
    } }, { key: "zoomUpdateOptions", value: function(t4, e3) {
      var i2 = this.w;
      if (void 0 !== t4 || void 0 !== e3) {
        if (!(i2.config.xaxis.convertedCatToNumeric && (t4 < 1 && (t4 = 1, e3 = i2.globals.dataPoints), e3 - t4 < 2))) {
          var a3 = { min: t4, max: e3 }, s3 = this.getBeforeZoomRange(a3);
          s3 && (a3 = s3.xaxis);
          var r2 = { xaxis: a3 }, o3 = x2.clone(i2.globals.initialConfig.yaxis);
          i2.config.chart.group || (r2.yaxis = o3), this.w.globals.zoomed = true, this.ctx.updateHelpers._updateOptions(r2, false, this.w.config.chart.animations.dynamicAnimation.enabled), this.zoomCallback(a3, o3);
        }
      } else this.handleZoomReset();
    } }, { key: "zoomCallback", value: function(t4, e3) {
      "function" == typeof this.ev.zoomed && this.ev.zoomed(this.ctx, { xaxis: t4, yaxis: e3 });
    } }, { key: "getBeforeZoomRange", value: function(t4, e3) {
      var i2 = null;
      return "function" == typeof this.ev.beforeZoom && (i2 = this.ev.beforeZoom(this, { xaxis: t4, yaxis: e3 })), i2;
    } }, { key: "toggleMenu", value: function() {
      var t4 = this;
      window.setTimeout(function() {
        t4.elMenu.classList.contains("apexcharts-menu-open") ? t4.elMenu.classList.remove("apexcharts-menu-open") : t4.elMenu.classList.add("apexcharts-menu-open");
      }, 0);
    } }, { key: "handleDownload", value: function(t4) {
      var e3 = this.w, i2 = new G2(this.ctx);
      switch (t4) {
        case "svg":
          i2.exportToSVG(this.ctx);
          break;
        case "png":
          i2.exportToPng(this.ctx);
          break;
        case "csv":
          i2.exportToCSV({ series: e3.config.series, columnDelimiter: e3.config.chart.toolbar.export.csv.columnDelimiter });
      }
    } }, { key: "handleZoomReset", value: function(t4) {
      this.ctx.getSyncedCharts().forEach(function(t5) {
        var e3 = t5.w;
        if (e3.globals.lastXAxis.min = e3.globals.initialConfig.xaxis.min, e3.globals.lastXAxis.max = e3.globals.initialConfig.xaxis.max, t5.updateHelpers.revertDefaultAxisMinMax(), "function" == typeof e3.config.chart.events.beforeResetZoom) {
          var i2 = e3.config.chart.events.beforeResetZoom(t5, e3);
          i2 && t5.updateHelpers.revertDefaultAxisMinMax(i2);
        }
        "function" == typeof e3.config.chart.events.zoomed && t5.ctx.toolbar.zoomCallback({ min: e3.config.xaxis.min, max: e3.config.xaxis.max }), e3.globals.zoomed = false;
        var a3 = t5.ctx.series.emptyCollapsedSeries(x2.clone(e3.globals.initialSeries));
        t5.updateHelpers._updateSeries(a3, e3.config.chart.animations.dynamicAnimation.enabled);
      });
    } }, { key: "destroy", value: function() {
      this.elZoom = null, this.elZoomIn = null, this.elZoomOut = null, this.elPan = null, this.elSelection = null, this.elZoomReset = null, this.elMenuIcon = null;
    } }]), t3;
  }(), ct2 = function(t3) {
    n2(i2, ht2);
    var e3 = d2(i2);
    function i2(t4) {
      var s3;
      return a2(this, i2), (s3 = e3.call(this, t4)).ctx = t4, s3.w = t4.w, s3.dragged = false, s3.graphics = new m2(s3.ctx), s3.eventList = ["mousedown", "mouseleave", "mousemove", "touchstart", "touchmove", "mouseup", "touchend"], s3.clientX = 0, s3.clientY = 0, s3.startX = 0, s3.endX = 0, s3.dragX = 0, s3.startY = 0, s3.endY = 0, s3.dragY = 0, s3.moveDirection = "none", s3;
    }
    return r(i2, [{ key: "init", value: function(t4) {
      var e4 = this, i3 = t4.xyRatios, a3 = this.w, s3 = this;
      this.xyRatios = i3, this.zoomRect = this.graphics.drawRect(0, 0, 0, 0), this.selectionRect = this.graphics.drawRect(0, 0, 0, 0), this.gridRect = a3.globals.dom.baseEl.querySelector(".apexcharts-grid"), this.zoomRect.node.classList.add("apexcharts-zoom-rect"), this.selectionRect.node.classList.add("apexcharts-selection-rect"), a3.globals.dom.elGraphical.add(this.zoomRect), a3.globals.dom.elGraphical.add(this.selectionRect), "x" === a3.config.chart.selection.type ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, minY: 0, maxX: a3.globals.gridWidth, maxY: a3.globals.gridHeight }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : "y" === a3.config.chart.selection.type ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, maxX: a3.globals.gridWidth }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : this.slDraggableRect = this.selectionRect.draggable().on("dragmove", this.selectionDragging.bind(this, "dragging")), this.preselectedSelection(), this.hoverArea = a3.globals.dom.baseEl.querySelector("".concat(a3.globals.chartClass, " .apexcharts-svg")), this.hoverArea.classList.add("apexcharts-zoomable"), this.eventList.forEach(function(t5) {
        e4.hoverArea.addEventListener(t5, s3.svgMouseEvents.bind(s3, i3), { capture: false, passive: true });
      });
    } }, { key: "destroy", value: function() {
      this.slDraggableRect && (this.slDraggableRect.draggable(false), this.slDraggableRect.off(), this.selectionRect.off()), this.selectionRect = null, this.zoomRect = null, this.gridRect = null;
    } }, { key: "svgMouseEvents", value: function(t4, e4) {
      var i3 = this.w, a3 = this, s3 = this.ctx.toolbar, r2 = i3.globals.zoomEnabled ? i3.config.chart.zoom.type : i3.config.chart.selection.type, o3 = i3.config.chart.toolbar.autoSelected;
      if (e4.shiftKey ? (this.shiftWasPressed = true, s3.enableZoomPanFromToolbar("pan" === o3 ? "zoom" : "pan")) : this.shiftWasPressed && (s3.enableZoomPanFromToolbar(o3), this.shiftWasPressed = false), e4.target) {
        var n3, l3 = e4.target.classList;
        if (e4.target.parentNode && null !== e4.target.parentNode && (n3 = e4.target.parentNode.classList), !(l3.contains("apexcharts-selection-rect") || l3.contains("apexcharts-legend-marker") || l3.contains("apexcharts-legend-text") || n3 && n3.contains("apexcharts-toolbar"))) {
          if (a3.clientX = "touchmove" === e4.type || "touchstart" === e4.type ? e4.touches[0].clientX : "touchend" === e4.type ? e4.changedTouches[0].clientX : e4.clientX, a3.clientY = "touchmove" === e4.type || "touchstart" === e4.type ? e4.touches[0].clientY : "touchend" === e4.type ? e4.changedTouches[0].clientY : e4.clientY, "mousedown" === e4.type && 1 === e4.which) {
            var h3 = a3.gridRect.getBoundingClientRect();
            a3.startX = a3.clientX - h3.left, a3.startY = a3.clientY - h3.top, a3.dragged = false, a3.w.globals.mousedown = true;
          }
          if (("mousemove" === e4.type && 1 === e4.which || "touchmove" === e4.type) && (a3.dragged = true, i3.globals.panEnabled ? (i3.globals.selection = null, a3.w.globals.mousedown && a3.panDragging({ context: a3, zoomtype: r2, xyRatios: t4 })) : (a3.w.globals.mousedown && i3.globals.zoomEnabled || a3.w.globals.mousedown && i3.globals.selectionEnabled) && (a3.selection = a3.selectionDrawing({ context: a3, zoomtype: r2 }))), "mouseup" === e4.type || "touchend" === e4.type || "mouseleave" === e4.type) {
            var c3 = a3.gridRect.getBoundingClientRect();
            a3.w.globals.mousedown && (a3.endX = a3.clientX - c3.left, a3.endY = a3.clientY - c3.top, a3.dragX = Math.abs(a3.endX - a3.startX), a3.dragY = Math.abs(a3.endY - a3.startY), (i3.globals.zoomEnabled || i3.globals.selectionEnabled) && a3.selectionDrawn({ context: a3, zoomtype: r2 }), i3.globals.panEnabled && i3.config.xaxis.convertedCatToNumeric && a3.delayedPanScrolled()), i3.globals.zoomEnabled && a3.hideSelectionRect(this.selectionRect), a3.dragged = false, a3.w.globals.mousedown = false;
          }
          this.makeSelectionRectDraggable();
        }
      }
    } }, { key: "makeSelectionRectDraggable", value: function() {
      var t4 = this.w;
      if (this.selectionRect) {
        var e4 = this.selectionRect.node.getBoundingClientRect();
        e4.width > 0 && e4.height > 0 && this.slDraggableRect.selectize({ points: "l, r", pointSize: 8, pointType: "rect" }).resize({ constraint: { minX: 0, minY: 0, maxX: t4.globals.gridWidth, maxY: t4.globals.gridHeight } }).on("resizing", this.selectionDragging.bind(this, "resizing"));
      }
    } }, { key: "preselectedSelection", value: function() {
      var t4 = this.w, e4 = this.xyRatios;
      if (!t4.globals.zoomEnabled) {
        if (void 0 !== t4.globals.selection && null !== t4.globals.selection) this.drawSelectionRect(t4.globals.selection);
        else if (void 0 !== t4.config.chart.selection.xaxis.min && void 0 !== t4.config.chart.selection.xaxis.max) {
          var i3 = (t4.config.chart.selection.xaxis.min - t4.globals.minX) / e4.xRatio, a3 = t4.globals.gridWidth - (t4.globals.maxX - t4.config.chart.selection.xaxis.max) / e4.xRatio - i3;
          t4.globals.isRangeBar && (i3 = (t4.config.chart.selection.xaxis.min - t4.globals.yAxisScale[0].niceMin) / e4.invertedYRatio, a3 = (t4.config.chart.selection.xaxis.max - t4.config.chart.selection.xaxis.min) / e4.invertedYRatio);
          var s3 = { x: i3, y: 0, width: a3, height: t4.globals.gridHeight, translateX: 0, translateY: 0, selectionEnabled: true };
          this.drawSelectionRect(s3), this.makeSelectionRectDraggable(), "function" == typeof t4.config.chart.events.selection && t4.config.chart.events.selection(this.ctx, { xaxis: { min: t4.config.chart.selection.xaxis.min, max: t4.config.chart.selection.xaxis.max }, yaxis: {} });
        }
      }
    } }, { key: "drawSelectionRect", value: function(t4) {
      var e4 = t4.x, i3 = t4.y, a3 = t4.width, s3 = t4.height, r2 = t4.translateX, o3 = void 0 === r2 ? 0 : r2, n3 = t4.translateY, l3 = void 0 === n3 ? 0 : n3, h3 = this.w, c3 = this.zoomRect, d3 = this.selectionRect;
      if (this.dragged || null !== h3.globals.selection) {
        var g3 = { transform: "translate(" + o3 + ", " + l3 + ")" };
        h3.globals.zoomEnabled && this.dragged && (a3 < 0 && (a3 = 1), c3.attr({ x: e4, y: i3, width: a3, height: s3, fill: h3.config.chart.zoom.zoomedArea.fill.color, "fill-opacity": h3.config.chart.zoom.zoomedArea.fill.opacity, stroke: h3.config.chart.zoom.zoomedArea.stroke.color, "stroke-width": h3.config.chart.zoom.zoomedArea.stroke.width, "stroke-opacity": h3.config.chart.zoom.zoomedArea.stroke.opacity }), m2.setAttrs(c3.node, g3)), h3.globals.selectionEnabled && (d3.attr({ x: e4, y: i3, width: a3 > 0 ? a3 : 0, height: s3 > 0 ? s3 : 0, fill: h3.config.chart.selection.fill.color, "fill-opacity": h3.config.chart.selection.fill.opacity, stroke: h3.config.chart.selection.stroke.color, "stroke-width": h3.config.chart.selection.stroke.width, "stroke-dasharray": h3.config.chart.selection.stroke.dashArray, "stroke-opacity": h3.config.chart.selection.stroke.opacity }), m2.setAttrs(d3.node, g3));
      }
    } }, { key: "hideSelectionRect", value: function(t4) {
      t4 && t4.attr({ x: 0, y: 0, width: 0, height: 0 });
    } }, { key: "selectionDrawing", value: function(t4) {
      var e4 = t4.context, i3 = t4.zoomtype, a3 = this.w, s3 = e4, r2 = this.gridRect.getBoundingClientRect(), o3 = s3.startX - 1, n3 = s3.startY, l3 = false, h3 = false, c3 = s3.clientX - r2.left - o3, d3 = s3.clientY - r2.top - n3, g3 = {};
      return Math.abs(c3 + o3) > a3.globals.gridWidth ? c3 = a3.globals.gridWidth - o3 : s3.clientX - r2.left < 0 && (c3 = o3), o3 > s3.clientX - r2.left && (l3 = true, c3 = Math.abs(c3)), n3 > s3.clientY - r2.top && (h3 = true, d3 = Math.abs(d3)), g3 = "x" === i3 ? { x: l3 ? o3 - c3 : o3, y: 0, width: c3, height: a3.globals.gridHeight } : "y" === i3 ? { x: 0, y: h3 ? n3 - d3 : n3, width: a3.globals.gridWidth, height: d3 } : { x: l3 ? o3 - c3 : o3, y: h3 ? n3 - d3 : n3, width: c3, height: d3 }, s3.drawSelectionRect(g3), s3.selectionDragging("resizing"), g3;
    } }, { key: "selectionDragging", value: function(t4, e4) {
      var i3 = this, a3 = this.w, s3 = this.xyRatios, r2 = this.selectionRect, o3 = 0;
      "resizing" === t4 && (o3 = 30);
      var n3 = function(t5) {
        return parseFloat(r2.node.getAttribute(t5));
      }, l3 = { x: n3("x"), y: n3("y"), width: n3("width"), height: n3("height") };
      a3.globals.selection = l3, "function" == typeof a3.config.chart.events.selection && a3.globals.selectionEnabled && (clearTimeout(this.w.globals.selectionResizeTimer), this.w.globals.selectionResizeTimer = window.setTimeout(function() {
        var t5, e5, o4, n4, l4 = i3.gridRect.getBoundingClientRect(), h3 = r2.node.getBoundingClientRect();
        a3.globals.isRangeBar ? (t5 = a3.globals.yAxisScale[0].niceMin + (h3.left - l4.left) * s3.invertedYRatio, e5 = a3.globals.yAxisScale[0].niceMin + (h3.right - l4.left) * s3.invertedYRatio, o4 = 0, n4 = 1) : (t5 = a3.globals.xAxisScale.niceMin + (h3.left - l4.left) * s3.xRatio, e5 = a3.globals.xAxisScale.niceMin + (h3.right - l4.left) * s3.xRatio, o4 = a3.globals.yAxisScale[0].niceMin + (l4.bottom - h3.bottom) * s3.yRatio[0], n4 = a3.globals.yAxisScale[0].niceMax - (h3.top - l4.top) * s3.yRatio[0]);
        var c3 = { xaxis: { min: t5, max: e5 }, yaxis: { min: o4, max: n4 } };
        a3.config.chart.events.selection(i3.ctx, c3), a3.config.chart.brush.enabled && void 0 !== a3.config.chart.events.brushScrolled && a3.config.chart.events.brushScrolled(i3.ctx, c3);
      }, o3));
    } }, { key: "selectionDrawn", value: function(t4) {
      var e4 = t4.context, i3 = t4.zoomtype, a3 = this.w, s3 = e4, r2 = this.xyRatios, o3 = this.ctx.toolbar;
      if (s3.startX > s3.endX) {
        var n3 = s3.startX;
        s3.startX = s3.endX, s3.endX = n3;
      }
      if (s3.startY > s3.endY) {
        var l3 = s3.startY;
        s3.startY = s3.endY, s3.endY = l3;
      }
      var h3 = void 0, c3 = void 0;
      a3.globals.isRangeBar ? (h3 = a3.globals.yAxisScale[0].niceMin + s3.startX * r2.invertedYRatio, c3 = a3.globals.yAxisScale[0].niceMin + s3.endX * r2.invertedYRatio) : (h3 = a3.globals.xAxisScale.niceMin + s3.startX * r2.xRatio, c3 = a3.globals.xAxisScale.niceMin + s3.endX * r2.xRatio);
      var d3 = [], g3 = [];
      if (a3.config.yaxis.forEach(function(t5, e5) {
        if (a3.globals.seriesYAxisMap[e5].length > 0) {
          var i4 = a3.globals.seriesYAxisMap[e5][0];
          d3.push(a3.globals.yAxisScale[e5].niceMax - r2.yRatio[i4] * s3.startY), g3.push(a3.globals.yAxisScale[e5].niceMax - r2.yRatio[i4] * s3.endY);
        }
      }), s3.dragged && (s3.dragX > 10 || s3.dragY > 10) && h3 !== c3) {
        if (a3.globals.zoomEnabled) {
          var u3 = x2.clone(a3.globals.initialConfig.yaxis), p3 = x2.clone(a3.globals.initialConfig.xaxis);
          if (a3.globals.zoomed = true, a3.config.xaxis.convertedCatToNumeric && (h3 = Math.floor(h3), c3 = Math.floor(c3), h3 < 1 && (h3 = 1, c3 = a3.globals.dataPoints), c3 - h3 < 2 && (c3 = h3 + 1)), "xy" !== i3 && "x" !== i3 || (p3 = { min: h3, max: c3 }), "xy" !== i3 && "y" !== i3 || u3.forEach(function(t5, e5) {
            u3[e5].min = g3[e5], u3[e5].max = d3[e5];
          }), o3) {
            var f3 = o3.getBeforeZoomRange(p3, u3);
            f3 && (p3 = f3.xaxis ? f3.xaxis : p3, u3 = f3.yaxis ? f3.yaxis : u3);
          }
          var b3 = { xaxis: p3 };
          a3.config.chart.group || (b3.yaxis = u3), s3.ctx.updateHelpers._updateOptions(b3, false, s3.w.config.chart.animations.dynamicAnimation.enabled), "function" == typeof a3.config.chart.events.zoomed && o3.zoomCallback(p3, u3);
        } else if (a3.globals.selectionEnabled) {
          var v3, m3 = null;
          v3 = { min: h3, max: c3 }, "xy" !== i3 && "y" !== i3 || (m3 = x2.clone(a3.config.yaxis)).forEach(function(t5, e5) {
            m3[e5].min = g3[e5], m3[e5].max = d3[e5];
          }), a3.globals.selection = s3.selection, "function" == typeof a3.config.chart.events.selection && a3.config.chart.events.selection(s3.ctx, { xaxis: v3, yaxis: m3 });
        }
      }
    } }, { key: "panDragging", value: function(t4) {
      var e4 = t4.context, i3 = this.w, a3 = e4;
      if (void 0 !== i3.globals.lastClientPosition.x) {
        var s3 = i3.globals.lastClientPosition.x - a3.clientX, r2 = i3.globals.lastClientPosition.y - a3.clientY;
        Math.abs(s3) > Math.abs(r2) && s3 > 0 ? this.moveDirection = "left" : Math.abs(s3) > Math.abs(r2) && s3 < 0 ? this.moveDirection = "right" : Math.abs(r2) > Math.abs(s3) && r2 > 0 ? this.moveDirection = "up" : Math.abs(r2) > Math.abs(s3) && r2 < 0 && (this.moveDirection = "down");
      }
      i3.globals.lastClientPosition = { x: a3.clientX, y: a3.clientY };
      var o3 = i3.globals.isRangeBar ? i3.globals.minY : i3.globals.minX, n3 = i3.globals.isRangeBar ? i3.globals.maxY : i3.globals.maxX;
      i3.config.xaxis.convertedCatToNumeric || a3.panScrolled(o3, n3);
    } }, { key: "delayedPanScrolled", value: function() {
      var t4 = this.w, e4 = t4.globals.minX, i3 = t4.globals.maxX, a3 = (t4.globals.maxX - t4.globals.minX) / 2;
      "left" === this.moveDirection ? (e4 = t4.globals.minX + a3, i3 = t4.globals.maxX + a3) : "right" === this.moveDirection && (e4 = t4.globals.minX - a3, i3 = t4.globals.maxX - a3), e4 = Math.floor(e4), i3 = Math.floor(i3), this.updateScrolledChart({ xaxis: { min: e4, max: i3 } }, e4, i3);
    } }, { key: "panScrolled", value: function(t4, e4) {
      var i3 = this.w, a3 = this.xyRatios, s3 = x2.clone(i3.globals.initialConfig.yaxis), r2 = a3.xRatio, o3 = i3.globals.minX, n3 = i3.globals.maxX;
      i3.globals.isRangeBar && (r2 = a3.invertedYRatio, o3 = i3.globals.minY, n3 = i3.globals.maxY), "left" === this.moveDirection ? (t4 = o3 + i3.globals.gridWidth / 15 * r2, e4 = n3 + i3.globals.gridWidth / 15 * r2) : "right" === this.moveDirection && (t4 = o3 - i3.globals.gridWidth / 15 * r2, e4 = n3 - i3.globals.gridWidth / 15 * r2), i3.globals.isRangeBar || (t4 < i3.globals.initialMinX || e4 > i3.globals.initialMaxX) && (t4 = o3, e4 = n3);
      var l3 = { xaxis: { min: t4, max: e4 } };
      i3.config.chart.group || (l3.yaxis = s3), this.updateScrolledChart(l3, t4, e4);
    } }, { key: "updateScrolledChart", value: function(t4, e4, i3) {
      var a3 = this.w;
      this.ctx.updateHelpers._updateOptions(t4, false, false), "function" == typeof a3.config.chart.events.scrolled && a3.config.chart.events.scrolled(this.ctx, { xaxis: { min: e4, max: i3 } });
    } }]), i2;
  }(), dt2 = function() {
    function t3(e3) {
      a2(this, t3), this.w = e3.w, this.ttCtx = e3, this.ctx = e3.ctx;
    }
    return r(t3, [{ key: "getNearestValues", value: function(t4) {
      var e3 = t4.hoverArea, i2 = t4.elGrid, a3 = t4.clientX, s3 = t4.clientY, r2 = this.w, o3 = i2.getBoundingClientRect(), n3 = o3.width, l3 = o3.height, h3 = n3 / (r2.globals.dataPoints - 1), c3 = l3 / r2.globals.dataPoints, d3 = this.hasBars();
      !r2.globals.comboCharts && !d3 || r2.config.xaxis.convertedCatToNumeric || (h3 = n3 / r2.globals.dataPoints);
      var g3 = a3 - o3.left - r2.globals.barPadForNumericAxis, u3 = s3 - o3.top;
      g3 < 0 || u3 < 0 || g3 > n3 || u3 > l3 ? (e3.classList.remove("hovering-zoom"), e3.classList.remove("hovering-pan")) : r2.globals.zoomEnabled ? (e3.classList.remove("hovering-pan"), e3.classList.add("hovering-zoom")) : r2.globals.panEnabled && (e3.classList.remove("hovering-zoom"), e3.classList.add("hovering-pan"));
      var p3 = Math.round(g3 / h3), f3 = Math.floor(u3 / c3);
      d3 && !r2.config.xaxis.convertedCatToNumeric && (p3 = Math.ceil(g3 / h3), p3 -= 1);
      var b3 = null, v3 = null, m3 = r2.globals.seriesXvalues.map(function(t5) {
        return t5.filter(function(t6) {
          return x2.isNumber(t6);
        });
      }), y3 = r2.globals.seriesYvalues.map(function(t5) {
        return t5.filter(function(t6) {
          return x2.isNumber(t6);
        });
      });
      if (r2.globals.isXNumeric) {
        var w3 = this.ttCtx.getElGrid().getBoundingClientRect(), k3 = g3 * (w3.width / n3), A3 = u3 * (w3.height / l3);
        b3 = (v3 = this.closestInMultiArray(k3, A3, m3, y3)).index, p3 = v3.j, null !== b3 && (m3 = r2.globals.seriesXvalues[b3], p3 = (v3 = this.closestInArray(k3, m3)).index);
      }
      return r2.globals.capturedSeriesIndex = null === b3 ? -1 : b3, (!p3 || p3 < 1) && (p3 = 0), r2.globals.isBarHorizontal ? r2.globals.capturedDataPointIndex = f3 : r2.globals.capturedDataPointIndex = p3, { capturedSeries: b3, j: r2.globals.isBarHorizontal ? f3 : p3, hoverX: g3, hoverY: u3 };
    } }, { key: "closestInMultiArray", value: function(t4, e3, i2, a3) {
      var s3 = this.w, r2 = 0, o3 = null, n3 = -1;
      s3.globals.series.length > 1 ? r2 = this.getFirstActiveXArray(i2) : o3 = 0;
      var l3 = i2[r2][0], h3 = Math.abs(t4 - l3);
      if (i2.forEach(function(e4) {
        e4.forEach(function(e5, i3) {
          var a4 = Math.abs(t4 - e5);
          a4 <= h3 && (h3 = a4, n3 = i3);
        });
      }), -1 !== n3) {
        var c3 = a3[r2][n3], d3 = Math.abs(e3 - c3);
        o3 = r2, a3.forEach(function(t5, i3) {
          var a4 = Math.abs(e3 - t5[n3]);
          a4 <= d3 && (d3 = a4, o3 = i3);
        });
      }
      return { index: o3, j: n3 };
    } }, { key: "getFirstActiveXArray", value: function(t4) {
      for (var e3 = this.w, i2 = 0, a3 = t4.map(function(t5, e4) {
        return t5.length > 0 ? e4 : -1;
      }), s3 = 0; s3 < a3.length; s3++) if (-1 !== a3[s3] && -1 === e3.globals.collapsedSeriesIndices.indexOf(s3) && -1 === e3.globals.ancillaryCollapsedSeriesIndices.indexOf(s3)) {
        i2 = a3[s3];
        break;
      }
      return i2;
    } }, { key: "closestInArray", value: function(t4, e3) {
      for (var i2 = e3[0], a3 = null, s3 = Math.abs(t4 - i2), r2 = 0; r2 < e3.length; r2++) {
        var o3 = Math.abs(t4 - e3[r2]);
        o3 < s3 && (s3 = o3, a3 = r2);
      }
      return { index: a3 };
    } }, { key: "isXoverlap", value: function(t4) {
      var e3 = [], i2 = this.w.globals.seriesX.filter(function(t5) {
        return void 0 !== t5[0];
      });
      if (i2.length > 0) for (var a3 = 0; a3 < i2.length - 1; a3++) void 0 !== i2[a3][t4] && void 0 !== i2[a3 + 1][t4] && i2[a3][t4] !== i2[a3 + 1][t4] && e3.push("unEqual");
      return 0 === e3.length;
    } }, { key: "isInitialSeriesSameLen", value: function() {
      for (var t4 = true, e3 = this.w.globals.initialSeries, i2 = 0; i2 < e3.length - 1; i2++) if (e3[i2].data.length !== e3[i2 + 1].data.length) {
        t4 = false;
        break;
      }
      return t4;
    } }, { key: "getBarsHeight", value: function(t4) {
      return u2(t4).reduce(function(t5, e3) {
        return t5 + e3.getBBox().height;
      }, 0);
    } }, { key: "getElMarkers", value: function(t4) {
      return "number" == typeof t4 ? this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:realIndex='".concat(t4, "'] .apexcharts-series-markers-wrap > *")) : this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap > *");
    } }, { key: "getAllMarkers", value: function() {
      var t4 = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap");
      (t4 = u2(t4)).sort(function(t5, e4) {
        var i2 = Number(t5.getAttribute("data:realIndex")), a3 = Number(e4.getAttribute("data:realIndex"));
        return a3 < i2 ? 1 : a3 > i2 ? -1 : 0;
      });
      var e3 = [];
      return t4.forEach(function(t5) {
        e3.push(t5.querySelector(".apexcharts-marker"));
      }), e3;
    } }, { key: "hasMarkers", value: function(t4) {
      return this.getElMarkers(t4).length > 0;
    } }, { key: "getElBars", value: function() {
      return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-boxPlot-series, .apexcharts-rangebar-series");
    } }, { key: "hasBars", value: function() {
      return this.getElBars().length > 0;
    } }, { key: "getHoverMarkerSize", value: function(t4) {
      var e3 = this.w, i2 = e3.config.markers.hover.size;
      return void 0 === i2 && (i2 = e3.globals.markers.size[t4] + e3.config.markers.hover.sizeOffset), i2;
    } }, { key: "toggleAllTooltipSeriesGroups", value: function(t4) {
      var e3 = this.w, i2 = this.ttCtx;
      0 === i2.allTooltipSeriesGroups.length && (i2.allTooltipSeriesGroups = e3.globals.dom.baseEl.querySelectorAll(".apexcharts-tooltip-series-group"));
      for (var a3 = i2.allTooltipSeriesGroups, s3 = 0; s3 < a3.length; s3++) "enable" === t4 ? (a3[s3].classList.add("apexcharts-active"), a3[s3].style.display = e3.config.tooltip.items.display) : (a3[s3].classList.remove("apexcharts-active"), a3[s3].style.display = "none");
    } }]), t3;
  }(), gt2 = function() {
    function t3(e3) {
      a2(this, t3), this.w = e3.w, this.ctx = e3.ctx, this.ttCtx = e3, this.tooltipUtil = new dt2(e3);
    }
    return r(t3, [{ key: "drawSeriesTexts", value: function(t4) {
      var e3 = t4.shared, i2 = void 0 === e3 || e3, a3 = t4.ttItems, s3 = t4.i, r2 = void 0 === s3 ? 0 : s3, o3 = t4.j, n3 = void 0 === o3 ? null : o3, l3 = t4.y1, h3 = t4.y2, c3 = t4.e, d3 = this.w;
      void 0 !== d3.config.tooltip.custom ? this.handleCustomTooltip({ i: r2, j: n3, y1: l3, y2: h3, w: d3 }) : this.toggleActiveInactiveSeries(i2);
      var g3 = this.getValuesToPrint({ i: r2, j: n3 });
      this.printLabels({ i: r2, j: n3, values: g3, ttItems: a3, shared: i2, e: c3 });
      var u3 = this.ttCtx.getElTooltip();
      this.ttCtx.tooltipRect.ttWidth = u3.getBoundingClientRect().width, this.ttCtx.tooltipRect.ttHeight = u3.getBoundingClientRect().height;
    } }, { key: "printLabels", value: function(t4) {
      var i2, a3 = this, s3 = t4.i, r2 = t4.j, o3 = t4.values, n3 = t4.ttItems, l3 = t4.shared, h3 = t4.e, c3 = this.w, d3 = [], g3 = function(t5) {
        return c3.globals.seriesGoals[t5] && c3.globals.seriesGoals[t5][r2] && Array.isArray(c3.globals.seriesGoals[t5][r2]);
      }, u3 = o3.xVal, p3 = o3.zVal, f3 = o3.xAxisTTVal, x3 = "", b3 = c3.globals.colors[s3];
      null !== r2 && c3.config.plotOptions.bar.distributed && (b3 = c3.globals.colors[r2]);
      for (var v3 = function(t5, o4) {
        var v4 = a3.getFormatters(s3);
        x3 = a3.getSeriesName({ fn: v4.yLbTitleFormatter, index: s3, seriesIndex: s3, j: r2 }), "treemap" === c3.config.chart.type && (x3 = v4.yLbTitleFormatter(String(c3.config.series[s3].data[r2].x), { series: c3.globals.series, seriesIndex: s3, dataPointIndex: r2, w: c3 }));
        var m4 = c3.config.tooltip.inverseOrder ? o4 : t5;
        if (c3.globals.axisCharts) {
          var y4 = function(t6) {
            var e3, i3, a4, s4;
            return c3.globals.isRangeData ? v4.yLbFormatter(null === (e3 = c3.globals.seriesRangeStart) || void 0 === e3 || null === (i3 = e3[t6]) || void 0 === i3 ? void 0 : i3[r2], { series: c3.globals.seriesRangeStart, seriesIndex: t6, dataPointIndex: r2, w: c3 }) + " - " + v4.yLbFormatter(null === (a4 = c3.globals.seriesRangeEnd) || void 0 === a4 || null === (s4 = a4[t6]) || void 0 === s4 ? void 0 : s4[r2], { series: c3.globals.seriesRangeEnd, seriesIndex: t6, dataPointIndex: r2, w: c3 }) : v4.yLbFormatter(c3.globals.series[t6][r2], { series: c3.globals.series, seriesIndex: t6, dataPointIndex: r2, w: c3 });
          };
          if (l3) v4 = a3.getFormatters(m4), x3 = a3.getSeriesName({ fn: v4.yLbTitleFormatter, index: m4, seriesIndex: s3, j: r2 }), b3 = c3.globals.colors[m4], i2 = y4(m4), g3(m4) && (d3 = c3.globals.seriesGoals[m4][r2].map(function(t6) {
            return { attrs: t6, val: v4.yLbFormatter(t6.value, { seriesIndex: m4, dataPointIndex: r2, w: c3 }) };
          }));
          else {
            var w3, k3 = null == h3 || null === (w3 = h3.target) || void 0 === w3 ? void 0 : w3.getAttribute("fill");
            k3 && (b3 = -1 !== k3.indexOf("url") ? document.querySelector(k3.substr(4).slice(0, -1)).childNodes[0].getAttribute("stroke") : k3), i2 = y4(s3), g3(s3) && Array.isArray(c3.globals.seriesGoals[s3][r2]) && (d3 = c3.globals.seriesGoals[s3][r2].map(function(t6) {
              return { attrs: t6, val: v4.yLbFormatter(t6.value, { seriesIndex: s3, dataPointIndex: r2, w: c3 }) };
            }));
          }
        }
        null === r2 && (i2 = v4.yLbFormatter(c3.globals.series[s3], e2(e2({}, c3), {}, { seriesIndex: s3, dataPointIndex: s3 }))), a3.DOMHandling({ i: s3, t: m4, j: r2, ttItems: n3, values: { val: i2, goalVals: d3, xVal: u3, xAxisTTVal: f3, zVal: p3 }, seriesName: x3, shared: l3, pColor: b3 });
      }, m3 = 0, y3 = c3.globals.series.length - 1; m3 < c3.globals.series.length; m3++, y3--) v3(m3, y3);
    } }, { key: "getFormatters", value: function(t4) {
      var e3, i2 = this.w, a3 = i2.globals.yLabelFormatters[t4];
      return void 0 !== i2.globals.ttVal ? Array.isArray(i2.globals.ttVal) ? (a3 = i2.globals.ttVal[t4] && i2.globals.ttVal[t4].formatter, e3 = i2.globals.ttVal[t4] && i2.globals.ttVal[t4].title && i2.globals.ttVal[t4].title.formatter) : (a3 = i2.globals.ttVal.formatter, "function" == typeof i2.globals.ttVal.title.formatter && (e3 = i2.globals.ttVal.title.formatter)) : e3 = i2.config.tooltip.y.title.formatter, "function" != typeof a3 && (a3 = i2.globals.yLabelFormatters[0] ? i2.globals.yLabelFormatters[0] : function(t5) {
        return t5;
      }), "function" != typeof e3 && (e3 = function(t5) {
        return t5;
      }), { yLbFormatter: a3, yLbTitleFormatter: e3 };
    } }, { key: "getSeriesName", value: function(t4) {
      var e3 = t4.fn, i2 = t4.index, a3 = t4.seriesIndex, s3 = t4.j, r2 = this.w;
      return e3(String(r2.globals.seriesNames[i2]), { series: r2.globals.series, seriesIndex: a3, dataPointIndex: s3, w: r2 });
    } }, { key: "DOMHandling", value: function(t4) {
      t4.i;
      var e3 = t4.t, i2 = t4.j, a3 = t4.ttItems, s3 = t4.values, r2 = t4.seriesName, o3 = t4.shared, n3 = t4.pColor, l3 = this.w, h3 = this.ttCtx, c3 = s3.val, d3 = s3.goalVals, g3 = s3.xVal, u3 = s3.xAxisTTVal, p3 = s3.zVal, f3 = null;
      f3 = a3[e3].children, l3.config.tooltip.fillSeriesColor && (a3[e3].style.backgroundColor = n3, f3[0].style.display = "none"), h3.showTooltipTitle && (null === h3.tooltipTitle && (h3.tooltipTitle = l3.globals.dom.baseEl.querySelector(".apexcharts-tooltip-title")), h3.tooltipTitle.innerHTML = g3), h3.isXAxisTooltipEnabled && (h3.xaxisTooltipText.innerHTML = "" !== u3 ? u3 : g3);
      var x3 = a3[e3].querySelector(".apexcharts-tooltip-text-y-label");
      x3 && (x3.innerHTML = r2 || "");
      var b3 = a3[e3].querySelector(".apexcharts-tooltip-text-y-value");
      b3 && (b3.innerHTML = void 0 !== c3 ? c3 : ""), f3[0] && f3[0].classList.contains("apexcharts-tooltip-marker") && (l3.config.tooltip.marker.fillColors && Array.isArray(l3.config.tooltip.marker.fillColors) && (n3 = l3.config.tooltip.marker.fillColors[e3]), f3[0].style.backgroundColor = n3), l3.config.tooltip.marker.show || (f3[0].style.display = "none");
      var v3 = a3[e3].querySelector(".apexcharts-tooltip-text-goals-label"), m3 = a3[e3].querySelector(".apexcharts-tooltip-text-goals-value");
      if (d3.length && l3.globals.seriesGoals[e3]) {
        var y3 = function() {
          var t5 = "<div >", e4 = "<div>";
          d3.forEach(function(i3, a4) {
            t5 += ' <div style="display: flex"><span class="apexcharts-tooltip-marker" style="background-color: '.concat(i3.attrs.strokeColor, '; height: 3px; border-radius: 0; top: 5px;"></span> ').concat(i3.attrs.name, "</div>"), e4 += "<div>".concat(i3.val, "</div>");
          }), v3.innerHTML = t5 + "</div>", m3.innerHTML = e4 + "</div>";
        };
        o3 ? l3.globals.seriesGoals[e3][i2] && Array.isArray(l3.globals.seriesGoals[e3][i2]) ? y3() : (v3.innerHTML = "", m3.innerHTML = "") : y3();
      } else v3.innerHTML = "", m3.innerHTML = "";
      null !== p3 && (a3[e3].querySelector(".apexcharts-tooltip-text-z-label").innerHTML = l3.config.tooltip.z.title, a3[e3].querySelector(".apexcharts-tooltip-text-z-value").innerHTML = void 0 !== p3 ? p3 : "");
      if (o3 && f3[0]) {
        if (l3.config.tooltip.hideEmptySeries) {
          var w3 = a3[e3].querySelector(".apexcharts-tooltip-marker"), k3 = a3[e3].querySelector(".apexcharts-tooltip-text");
          0 == parseFloat(c3) ? (w3.style.display = "none", k3.style.display = "none") : (w3.style.display = "block", k3.style.display = "block");
        }
        null == c3 || l3.globals.ancillaryCollapsedSeriesIndices.indexOf(e3) > -1 || l3.globals.collapsedSeriesIndices.indexOf(e3) > -1 ? f3[0].parentNode.style.display = "none" : f3[0].parentNode.style.display = l3.config.tooltip.items.display;
      }
    } }, { key: "toggleActiveInactiveSeries", value: function(t4) {
      var e3 = this.w;
      if (t4) this.tooltipUtil.toggleAllTooltipSeriesGroups("enable");
      else {
        this.tooltipUtil.toggleAllTooltipSeriesGroups("disable");
        var i2 = e3.globals.dom.baseEl.querySelector(".apexcharts-tooltip-series-group");
        i2 && (i2.classList.add("apexcharts-active"), i2.style.display = e3.config.tooltip.items.display);
      }
    } }, { key: "getValuesToPrint", value: function(t4) {
      var e3 = t4.i, i2 = t4.j, a3 = this.w, s3 = this.ctx.series.filteredSeriesX(), r2 = "", o3 = "", n3 = null, l3 = null, h3 = { series: a3.globals.series, seriesIndex: e3, dataPointIndex: i2, w: a3 }, c3 = a3.globals.ttZFormatter;
      null === i2 ? l3 = a3.globals.series[e3] : a3.globals.isXNumeric && "treemap" !== a3.config.chart.type ? (r2 = s3[e3][i2], 0 === s3[e3].length && (r2 = s3[this.tooltipUtil.getFirstActiveXArray(s3)][i2])) : r2 = void 0 !== a3.globals.labels[i2] ? a3.globals.labels[i2] : "";
      var d3 = r2;
      a3.globals.isXNumeric && "datetime" === a3.config.xaxis.type ? r2 = new S2(this.ctx).xLabelFormat(a3.globals.ttKeyFormatter, d3, d3, { i: void 0, dateFormatter: new A2(this.ctx).formatDate, w: this.w }) : r2 = a3.globals.isBarHorizontal ? a3.globals.yLabelFormatters[0](d3, h3) : a3.globals.xLabelFormatter(d3, h3);
      return void 0 !== a3.config.tooltip.x.formatter && (r2 = a3.globals.ttKeyFormatter(d3, h3)), a3.globals.seriesZ.length > 0 && a3.globals.seriesZ[e3].length > 0 && (n3 = c3(a3.globals.seriesZ[e3][i2], a3)), o3 = "function" == typeof a3.config.xaxis.tooltip.formatter ? a3.globals.xaxisTooltipFormatter(d3, h3) : r2, { val: Array.isArray(l3) ? l3.join(" ") : l3, xVal: Array.isArray(r2) ? r2.join(" ") : r2, xAxisTTVal: Array.isArray(o3) ? o3.join(" ") : o3, zVal: n3 };
    } }, { key: "handleCustomTooltip", value: function(t4) {
      var e3 = t4.i, i2 = t4.j, a3 = t4.y1, s3 = t4.y2, r2 = t4.w, o3 = this.ttCtx.getElTooltip(), n3 = r2.config.tooltip.custom;
      Array.isArray(n3) && n3[e3] && (n3 = n3[e3]), o3.innerHTML = n3({ ctx: this.ctx, series: r2.globals.series, seriesIndex: e3, dataPointIndex: i2, y1: a3, y2: s3, w: r2 });
    } }]), t3;
  }(), ut2 = function() {
    function t3(e3) {
      a2(this, t3), this.ttCtx = e3, this.ctx = e3.ctx, this.w = e3.w;
    }
    return r(t3, [{ key: "moveXCrosshairs", value: function(t4) {
      var e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, i2 = this.ttCtx, a3 = this.w, s3 = i2.getElXCrosshairs(), r2 = t4 - i2.xcrosshairsWidth / 2, o3 = a3.globals.labels.slice().length;
      if (null !== e3 && (r2 = a3.globals.gridWidth / o3 * e3), null === s3 || a3.globals.isBarHorizontal || (s3.setAttribute("x", r2), s3.setAttribute("x1", r2), s3.setAttribute("x2", r2), s3.setAttribute("y2", a3.globals.gridHeight), s3.classList.add("apexcharts-active")), r2 < 0 && (r2 = 0), r2 > a3.globals.gridWidth && (r2 = a3.globals.gridWidth), i2.isXAxisTooltipEnabled) {
        var n3 = r2;
        "tickWidth" !== a3.config.xaxis.crosshairs.width && "barWidth" !== a3.config.xaxis.crosshairs.width || (n3 = r2 + i2.xcrosshairsWidth / 2), this.moveXAxisTooltip(n3);
      }
    } }, { key: "moveYCrosshairs", value: function(t4) {
      var e3 = this.ttCtx;
      null !== e3.ycrosshairs && m2.setAttrs(e3.ycrosshairs, { y1: t4, y2: t4 }), null !== e3.ycrosshairsHidden && m2.setAttrs(e3.ycrosshairsHidden, { y1: t4, y2: t4 });
    } }, { key: "moveXAxisTooltip", value: function(t4) {
      var e3 = this.w, i2 = this.ttCtx;
      if (null !== i2.xaxisTooltip && 0 !== i2.xcrosshairsWidth) {
        i2.xaxisTooltip.classList.add("apexcharts-active");
        var a3 = i2.xaxisOffY + e3.config.xaxis.tooltip.offsetY + e3.globals.translateY + 1 + e3.config.xaxis.offsetY;
        if (t4 -= i2.xaxisTooltip.getBoundingClientRect().width / 2, !isNaN(t4)) {
          t4 += e3.globals.translateX;
          var s3;
          s3 = new m2(this.ctx).getTextRects(i2.xaxisTooltipText.innerHTML), i2.xaxisTooltipText.style.minWidth = s3.width + "px", i2.xaxisTooltip.style.left = t4 + "px", i2.xaxisTooltip.style.top = a3 + "px";
        }
      }
    } }, { key: "moveYAxisTooltip", value: function(t4) {
      var e3 = this.w, i2 = this.ttCtx;
      null === i2.yaxisTTEls && (i2.yaxisTTEls = e3.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
      var a3 = parseInt(i2.ycrosshairsHidden.getAttribute("y1"), 10), s3 = e3.globals.translateY + a3, r2 = i2.yaxisTTEls[t4].getBoundingClientRect().height, o3 = e3.globals.translateYAxisX[t4] - 2;
      e3.config.yaxis[t4].opposite && (o3 -= 26), s3 -= r2 / 2, -1 === e3.globals.ignoreYAxisIndexes.indexOf(t4) ? (i2.yaxisTTEls[t4].classList.add("apexcharts-active"), i2.yaxisTTEls[t4].style.top = s3 + "px", i2.yaxisTTEls[t4].style.left = o3 + e3.config.yaxis[t4].tooltip.offsetX + "px") : i2.yaxisTTEls[t4].classList.remove("apexcharts-active");
    } }, { key: "moveTooltip", value: function(t4, e3) {
      var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a3 = this.w, s3 = this.ttCtx, r2 = s3.getElTooltip(), o3 = s3.tooltipRect, n3 = null !== i2 ? parseFloat(i2) : 1, l3 = parseFloat(t4) + n3 + 5, h3 = parseFloat(e3) + n3 / 2;
      if (l3 > a3.globals.gridWidth / 2 && (l3 = l3 - o3.ttWidth - n3 - 10), l3 > a3.globals.gridWidth - o3.ttWidth - 10 && (l3 = a3.globals.gridWidth - o3.ttWidth), l3 < -20 && (l3 = -20), a3.config.tooltip.followCursor) {
        var c3 = s3.getElGrid().getBoundingClientRect();
        (l3 = s3.e.clientX - c3.left) > a3.globals.gridWidth / 2 && (l3 -= s3.tooltipRect.ttWidth), (h3 = s3.e.clientY + a3.globals.translateY - c3.top) > a3.globals.gridHeight / 2 && (h3 -= s3.tooltipRect.ttHeight);
      } else a3.globals.isBarHorizontal || o3.ttHeight / 2 + h3 > a3.globals.gridHeight && (h3 = a3.globals.gridHeight - o3.ttHeight + a3.globals.translateY);
      isNaN(l3) || (l3 += a3.globals.translateX, r2.style.left = l3 + "px", r2.style.top = h3 + "px");
    } }, { key: "moveMarkers", value: function(t4, e3) {
      var i2 = this.w, a3 = this.ttCtx;
      if (i2.globals.markers.size[t4] > 0) for (var s3 = i2.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(t4, "'] .apexcharts-marker")), r2 = 0; r2 < s3.length; r2++) parseInt(s3[r2].getAttribute("rel"), 10) === e3 && (a3.marker.resetPointsSize(), a3.marker.enlargeCurrentPoint(e3, s3[r2]));
      else a3.marker.resetPointsSize(), this.moveDynamicPointOnHover(e3, t4);
    } }, { key: "moveDynamicPointOnHover", value: function(t4, e3) {
      var i2, a3, s3 = this.w, r2 = this.ttCtx, o3 = s3.globals.pointsArray, n3 = r2.tooltipUtil.getHoverMarkerSize(e3), l3 = s3.config.series[e3].type;
      if (!l3 || "column" !== l3 && "candlestick" !== l3 && "boxPlot" !== l3) {
        i2 = o3[e3][t4][0], a3 = o3[e3][t4][1] ? o3[e3][t4][1] : 0;
        var h3 = s3.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(e3, "'] .apexcharts-series-markers circle"));
        h3 && a3 < s3.globals.gridHeight && a3 > 0 && (h3.setAttribute("r", n3), h3.setAttribute("cx", i2), h3.setAttribute("cy", a3)), this.moveXCrosshairs(i2), r2.fixedTooltip || this.moveTooltip(i2, a3, n3);
      }
    } }, { key: "moveDynamicPointsOnHover", value: function(t4) {
      var e3, i2 = this.ttCtx, a3 = i2.w, s3 = 0, r2 = 0, o3 = a3.globals.pointsArray;
      e3 = new W2(this.ctx).getActiveConfigSeriesIndex("asc", ["line", "area", "scatter", "bubble"]);
      var n3 = i2.tooltipUtil.getHoverMarkerSize(e3);
      o3[e3] && (s3 = o3[e3][t4][0], r2 = o3[e3][t4][1]);
      var l3 = i2.tooltipUtil.getAllMarkers();
      if (null !== l3) for (var h3 = 0; h3 < a3.globals.series.length; h3++) {
        var c3 = o3[h3];
        if (a3.globals.comboCharts && void 0 === c3 && l3.splice(h3, 0, null), c3 && c3.length) {
          var d3 = o3[h3][t4][1], g3 = void 0;
          if (l3[h3].setAttribute("cx", s3), "rangeArea" === a3.config.chart.type && !a3.globals.comboCharts) {
            var u3 = t4 + a3.globals.series[h3].length;
            g3 = o3[h3][u3][1], d3 -= Math.abs(d3 - g3) / 2;
          }
          null !== d3 && !isNaN(d3) && d3 < a3.globals.gridHeight + n3 && d3 + n3 > 0 ? (l3[h3] && l3[h3].setAttribute("r", n3), l3[h3] && l3[h3].setAttribute("cy", d3)) : l3[h3] && l3[h3].setAttribute("r", 0);
        }
      }
      this.moveXCrosshairs(s3), i2.fixedTooltip || this.moveTooltip(s3, r2 || a3.globals.gridHeight, n3);
    } }, { key: "moveStickyTooltipOverBars", value: function(t4, e3) {
      var i2 = this.w, a3 = this.ttCtx, s3 = i2.globals.columnSeries ? i2.globals.columnSeries.length : i2.globals.series.length, r2 = s3 >= 2 && s3 % 2 == 0 ? Math.floor(s3 / 2) : Math.floor(s3 / 2) + 1;
      i2.globals.isBarHorizontal && (r2 = new W2(this.ctx).getActiveConfigSeriesIndex("desc") + 1);
      var o3 = i2.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='".concat(r2, "'] path[j='").concat(t4, "'], .apexcharts-candlestick-series .apexcharts-series[rel='").concat(r2, "'] path[j='").concat(t4, "'], .apexcharts-boxPlot-series .apexcharts-series[rel='").concat(r2, "'] path[j='").concat(t4, "'], .apexcharts-rangebar-series .apexcharts-series[rel='").concat(r2, "'] path[j='").concat(t4, "']"));
      o3 || "number" != typeof e3 || (o3 = i2.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[data\\:realIndex='".concat(e3, "'] path[j='").concat(t4, "'],\n        .apexcharts-candlestick-series .apexcharts-series[data\\:realIndex='").concat(e3, "'] path[j='").concat(t4, "'],\n        .apexcharts-boxPlot-series .apexcharts-series[data\\:realIndex='").concat(e3, "'] path[j='").concat(t4, "'],\n        .apexcharts-rangebar-series .apexcharts-series[data\\:realIndex='").concat(e3, "'] path[j='").concat(t4, "']")));
      var n3 = o3 ? parseFloat(o3.getAttribute("cx")) : 0, l3 = o3 ? parseFloat(o3.getAttribute("cy")) : 0, h3 = o3 ? parseFloat(o3.getAttribute("barWidth")) : 0, c3 = a3.getElGrid().getBoundingClientRect(), d3 = o3 && (o3.classList.contains("apexcharts-candlestick-area") || o3.classList.contains("apexcharts-boxPlot-area"));
      i2.globals.isXNumeric ? (o3 && !d3 && (n3 -= s3 % 2 != 0 ? h3 / 2 : 0), o3 && d3 && i2.globals.comboCharts && (n3 -= h3 / 2)) : i2.globals.isBarHorizontal || (n3 = a3.xAxisTicksPositions[t4 - 1] + a3.dataPointsDividedWidth / 2, isNaN(n3) && (n3 = a3.xAxisTicksPositions[t4] - a3.dataPointsDividedWidth / 2)), i2.globals.isBarHorizontal ? l3 -= a3.tooltipRect.ttHeight : i2.config.tooltip.followCursor ? l3 = a3.e.clientY - c3.top - a3.tooltipRect.ttHeight / 2 : l3 + a3.tooltipRect.ttHeight + 15 > i2.globals.gridHeight && (l3 = i2.globals.gridHeight), i2.globals.isBarHorizontal || this.moveXCrosshairs(n3), a3.fixedTooltip || this.moveTooltip(n3, l3 || i2.globals.gridHeight);
    } }]), t3;
  }(), pt2 = function() {
    function t3(e3) {
      a2(this, t3), this.w = e3.w, this.ttCtx = e3, this.ctx = e3.ctx, this.tooltipPosition = new ut2(e3);
    }
    return r(t3, [{ key: "drawDynamicPoints", value: function() {
      var t4 = this.w, e3 = new m2(this.ctx), i2 = new D2(this.ctx), a3 = t4.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
      a3 = u2(a3), t4.config.chart.stacked && a3.sort(function(t5, e4) {
        return parseFloat(t5.getAttribute("data:realIndex")) - parseFloat(e4.getAttribute("data:realIndex"));
      });
      for (var s3 = 0; s3 < a3.length; s3++) {
        var r2 = a3[s3].querySelector(".apexcharts-series-markers-wrap");
        if (null !== r2) {
          var o3 = void 0, n3 = "apexcharts-marker w".concat((Math.random() + 1).toString(36).substring(4));
          "line" !== t4.config.chart.type && "area" !== t4.config.chart.type || t4.globals.comboCharts || t4.config.tooltip.intersect || (n3 += " no-pointer-events");
          var l3 = i2.getMarkerConfig({ cssClass: n3, seriesIndex: Number(r2.getAttribute("data:realIndex")) });
          (o3 = e3.drawMarker(0, 0, l3)).node.setAttribute("default-marker-size", 0);
          var h3 = document.createElementNS(t4.globals.SVGNS, "g");
          h3.classList.add("apexcharts-series-markers"), h3.appendChild(o3.node), r2.appendChild(h3);
        }
      }
    } }, { key: "enlargeCurrentPoint", value: function(t4, e3) {
      var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, s3 = this.w;
      "bubble" !== s3.config.chart.type && this.newPointSize(t4, e3);
      var r2 = e3.getAttribute("cx"), o3 = e3.getAttribute("cy");
      if (null !== i2 && null !== a3 && (r2 = i2, o3 = a3), this.tooltipPosition.moveXCrosshairs(r2), !this.fixedTooltip) {
        if ("radar" === s3.config.chart.type) {
          var n3 = this.ttCtx.getElGrid().getBoundingClientRect();
          r2 = this.ttCtx.e.clientX - n3.left;
        }
        this.tooltipPosition.moveTooltip(r2, o3, s3.config.markers.hover.size);
      }
    } }, { key: "enlargePoints", value: function(t4) {
      for (var e3 = this.w, i2 = this, a3 = this.ttCtx, s3 = t4, r2 = e3.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), o3 = e3.config.markers.hover.size, n3 = 0; n3 < r2.length; n3++) {
        var l3 = r2[n3].getAttribute("rel"), h3 = r2[n3].getAttribute("index");
        if (void 0 === o3 && (o3 = e3.globals.markers.size[h3] + e3.config.markers.hover.sizeOffset), s3 === parseInt(l3, 10)) {
          i2.newPointSize(s3, r2[n3]);
          var c3 = r2[n3].getAttribute("cx"), d3 = r2[n3].getAttribute("cy");
          i2.tooltipPosition.moveXCrosshairs(c3), a3.fixedTooltip || i2.tooltipPosition.moveTooltip(c3, d3, o3);
        } else i2.oldPointSize(r2[n3]);
      }
    } }, { key: "newPointSize", value: function(t4, e3) {
      var i2 = this.w, a3 = i2.config.markers.hover.size, s3 = 0 === t4 ? e3.parentNode.firstChild : e3.parentNode.lastChild;
      if ("0" !== s3.getAttribute("default-marker-size")) {
        var r2 = parseInt(s3.getAttribute("index"), 10);
        void 0 === a3 && (a3 = i2.globals.markers.size[r2] + i2.config.markers.hover.sizeOffset), a3 < 0 && (a3 = 0), s3.setAttribute("r", a3);
      }
    } }, { key: "oldPointSize", value: function(t4) {
      var e3 = parseFloat(t4.getAttribute("default-marker-size"));
      t4.setAttribute("r", e3);
    } }, { key: "resetPointsSize", value: function() {
      for (var t4 = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), e3 = 0; e3 < t4.length; e3++) {
        var i2 = parseFloat(t4[e3].getAttribute("default-marker-size"));
        x2.isNumber(i2) && i2 >= 0 ? t4[e3].setAttribute("r", i2) : t4[e3].setAttribute("r", 0);
      }
    } }]), t3;
  }(), ft2 = function() {
    function t3(e3) {
      a2(this, t3), this.w = e3.w;
      var i2 = this.w;
      this.ttCtx = e3, this.isVerticalGroupedRangeBar = !i2.globals.isBarHorizontal && "rangeBar" === i2.config.chart.type && i2.config.plotOptions.bar.rangeBarGroupRows;
    }
    return r(t3, [{ key: "getAttr", value: function(t4, e3) {
      return parseFloat(t4.target.getAttribute(e3));
    } }, { key: "handleHeatTreeTooltip", value: function(t4) {
      var e3 = t4.e, i2 = t4.opt, a3 = t4.x, s3 = t4.y, r2 = t4.type, o3 = this.ttCtx, n3 = this.w;
      if (e3.target.classList.contains("apexcharts-".concat(r2, "-rect"))) {
        var l3 = this.getAttr(e3, "i"), h3 = this.getAttr(e3, "j"), c3 = this.getAttr(e3, "cx"), d3 = this.getAttr(e3, "cy"), g3 = this.getAttr(e3, "width"), u3 = this.getAttr(e3, "height");
        if (o3.tooltipLabels.drawSeriesTexts({ ttItems: i2.ttItems, i: l3, j: h3, shared: false, e: e3 }), n3.globals.capturedSeriesIndex = l3, n3.globals.capturedDataPointIndex = h3, a3 = c3 + o3.tooltipRect.ttWidth / 2 + g3, s3 = d3 + o3.tooltipRect.ttHeight / 2 - u3 / 2, o3.tooltipPosition.moveXCrosshairs(c3 + g3 / 2), a3 > n3.globals.gridWidth / 2 && (a3 = c3 - o3.tooltipRect.ttWidth / 2 + g3), o3.w.config.tooltip.followCursor) {
          var p3 = n3.globals.dom.elWrap.getBoundingClientRect();
          a3 = n3.globals.clientX - p3.left - (a3 > n3.globals.gridWidth / 2 ? o3.tooltipRect.ttWidth : 0), s3 = n3.globals.clientY - p3.top - (s3 > n3.globals.gridHeight / 2 ? o3.tooltipRect.ttHeight : 0);
        }
      }
      return { x: a3, y: s3 };
    } }, { key: "handleMarkerTooltip", value: function(t4) {
      var e3, i2, a3 = t4.e, s3 = t4.opt, r2 = t4.x, o3 = t4.y, n3 = this.w, l3 = this.ttCtx;
      if (a3.target.classList.contains("apexcharts-marker")) {
        var h3 = parseInt(s3.paths.getAttribute("cx"), 10), c3 = parseInt(s3.paths.getAttribute("cy"), 10), d3 = parseFloat(s3.paths.getAttribute("val"));
        if (i2 = parseInt(s3.paths.getAttribute("rel"), 10), e3 = parseInt(s3.paths.parentNode.parentNode.parentNode.getAttribute("rel"), 10) - 1, l3.intersect) {
          var g3 = x2.findAncestor(s3.paths, "apexcharts-series");
          g3 && (e3 = parseInt(g3.getAttribute("data:realIndex"), 10));
        }
        if (l3.tooltipLabels.drawSeriesTexts({ ttItems: s3.ttItems, i: e3, j: i2, shared: !l3.showOnIntersect && n3.config.tooltip.shared, e: a3 }), "mouseup" === a3.type && l3.markerClick(a3, e3, i2), n3.globals.capturedSeriesIndex = e3, n3.globals.capturedDataPointIndex = i2, r2 = h3, o3 = c3 + n3.globals.translateY - 1.4 * l3.tooltipRect.ttHeight, l3.w.config.tooltip.followCursor) {
          var u3 = l3.getElGrid().getBoundingClientRect();
          o3 = l3.e.clientY + n3.globals.translateY - u3.top;
        }
        d3 < 0 && (o3 = c3), l3.marker.enlargeCurrentPoint(i2, s3.paths, r2, o3);
      }
      return { x: r2, y: o3 };
    } }, { key: "handleBarTooltip", value: function(t4) {
      var e3, i2, a3 = t4.e, s3 = t4.opt, r2 = this.w, o3 = this.ttCtx, n3 = o3.getElTooltip(), l3 = 0, h3 = 0, c3 = 0, d3 = this.getBarTooltipXY({ e: a3, opt: s3 });
      e3 = d3.i;
      var g3 = d3.barHeight, u3 = d3.j;
      r2.globals.capturedSeriesIndex = e3, r2.globals.capturedDataPointIndex = u3, r2.globals.isBarHorizontal && o3.tooltipUtil.hasBars() || !r2.config.tooltip.shared ? (h3 = d3.x, c3 = d3.y, i2 = Array.isArray(r2.config.stroke.width) ? r2.config.stroke.width[e3] : r2.config.stroke.width, l3 = h3) : r2.globals.comboCharts || r2.config.tooltip.shared || (l3 /= 2), isNaN(c3) && (c3 = r2.globals.svgHeight - o3.tooltipRect.ttHeight);
      var p3 = parseInt(s3.paths.parentNode.getAttribute("data:realIndex"), 10), f3 = r2.globals.isMultipleYAxis ? r2.config.yaxis[p3] && r2.config.yaxis[p3].reversed : r2.config.yaxis[0].reversed;
      if (h3 + o3.tooltipRect.ttWidth > r2.globals.gridWidth && !f3 ? h3 -= o3.tooltipRect.ttWidth : h3 < 0 && (h3 = 0), o3.w.config.tooltip.followCursor) {
        var x3 = o3.getElGrid().getBoundingClientRect();
        c3 = o3.e.clientY - x3.top;
      }
      null === o3.tooltip && (o3.tooltip = r2.globals.dom.baseEl.querySelector(".apexcharts-tooltip")), r2.config.tooltip.shared || (r2.globals.comboBarCount > 0 ? o3.tooltipPosition.moveXCrosshairs(l3 + i2 / 2) : o3.tooltipPosition.moveXCrosshairs(l3)), !o3.fixedTooltip && (!r2.config.tooltip.shared || r2.globals.isBarHorizontal && o3.tooltipUtil.hasBars()) && (f3 && (h3 -= o3.tooltipRect.ttWidth) < 0 && (h3 = 0), !f3 || r2.globals.isBarHorizontal && o3.tooltipUtil.hasBars() || (c3 = c3 + g3 - 2 * (r2.globals.series[e3][u3] < 0 ? g3 : 0)), c3 = c3 + r2.globals.translateY - o3.tooltipRect.ttHeight / 2, n3.style.left = h3 + r2.globals.translateX + "px", n3.style.top = c3 + "px");
    } }, { key: "getBarTooltipXY", value: function(t4) {
      var e3 = this, i2 = t4.e, a3 = t4.opt, s3 = this.w, r2 = null, o3 = this.ttCtx, n3 = 0, l3 = 0, h3 = 0, c3 = 0, d3 = 0, g3 = i2.target.classList;
      if (g3.contains("apexcharts-bar-area") || g3.contains("apexcharts-candlestick-area") || g3.contains("apexcharts-boxPlot-area") || g3.contains("apexcharts-rangebar-area")) {
        var u3 = i2.target, p3 = u3.getBoundingClientRect(), f3 = a3.elGrid.getBoundingClientRect(), x3 = p3.height;
        d3 = p3.height;
        var b3 = p3.width, v3 = parseInt(u3.getAttribute("cx"), 10), m3 = parseInt(u3.getAttribute("cy"), 10);
        c3 = parseFloat(u3.getAttribute("barWidth"));
        var y3 = "touchmove" === i2.type ? i2.touches[0].clientX : i2.clientX;
        r2 = parseInt(u3.getAttribute("j"), 10), n3 = parseInt(u3.parentNode.getAttribute("rel"), 10) - 1;
        var w3 = u3.getAttribute("data-range-y1"), k3 = u3.getAttribute("data-range-y2");
        s3.globals.comboCharts && (n3 = parseInt(u3.parentNode.getAttribute("data:realIndex"), 10));
        var A3 = function(t5) {
          return s3.globals.isXNumeric ? v3 - b3 / 2 : e3.isVerticalGroupedRangeBar ? v3 + b3 / 2 : v3 - o3.dataPointsDividedWidth + b3 / 2;
        }, S3 = function() {
          return m3 - o3.dataPointsDividedHeight + x3 / 2 - o3.tooltipRect.ttHeight / 2;
        };
        o3.tooltipLabels.drawSeriesTexts({ ttItems: a3.ttItems, i: n3, j: r2, y1: w3 ? parseInt(w3, 10) : null, y2: k3 ? parseInt(k3, 10) : null, shared: !o3.showOnIntersect && s3.config.tooltip.shared, e: i2 }), s3.config.tooltip.followCursor ? s3.globals.isBarHorizontal ? (l3 = y3 - f3.left + 15, h3 = S3()) : (l3 = A3(), h3 = i2.clientY - f3.top - o3.tooltipRect.ttHeight / 2 - 15) : s3.globals.isBarHorizontal ? ((l3 = v3) < o3.xyRatios.baseLineInvertedY && (l3 = v3 - o3.tooltipRect.ttWidth), h3 = S3()) : (l3 = A3(), h3 = m3);
      }
      return { x: l3, y: h3, barHeight: d3, barWidth: c3, i: n3, j: r2 };
    } }]), t3;
  }(), xt2 = function() {
    function t3(e3) {
      a2(this, t3), this.w = e3.w, this.ttCtx = e3;
    }
    return r(t3, [{ key: "drawXaxisTooltip", value: function() {
      var t4 = this.w, e3 = this.ttCtx, i2 = "bottom" === t4.config.xaxis.position;
      e3.xaxisOffY = i2 ? t4.globals.gridHeight + 1 : -t4.globals.xAxisHeight - t4.config.xaxis.axisTicks.height + 3;
      var a3 = i2 ? "apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom" : "apexcharts-xaxistooltip apexcharts-xaxistooltip-top", s3 = t4.globals.dom.elWrap;
      e3.isXAxisTooltipEnabled && (null === t4.globals.dom.baseEl.querySelector(".apexcharts-xaxistooltip") && (e3.xaxisTooltip = document.createElement("div"), e3.xaxisTooltip.setAttribute("class", a3 + " apexcharts-theme-" + t4.config.tooltip.theme), s3.appendChild(e3.xaxisTooltip), e3.xaxisTooltipText = document.createElement("div"), e3.xaxisTooltipText.classList.add("apexcharts-xaxistooltip-text"), e3.xaxisTooltipText.style.fontFamily = t4.config.xaxis.tooltip.style.fontFamily || t4.config.chart.fontFamily, e3.xaxisTooltipText.style.fontSize = t4.config.xaxis.tooltip.style.fontSize, e3.xaxisTooltip.appendChild(e3.xaxisTooltipText)));
    } }, { key: "drawYaxisTooltip", value: function() {
      for (var t4 = this.w, e3 = this.ttCtx, i2 = 0; i2 < t4.config.yaxis.length; i2++) {
        var a3 = t4.config.yaxis[i2].opposite || t4.config.yaxis[i2].crosshairs.opposite;
        e3.yaxisOffX = a3 ? t4.globals.gridWidth + 1 : 1;
        var s3 = "apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i2, a3 ? " apexcharts-yaxistooltip-right" : " apexcharts-yaxistooltip-left"), r2 = t4.globals.dom.elWrap;
        null === t4.globals.dom.baseEl.querySelector(".apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i2)) && (e3.yaxisTooltip = document.createElement("div"), e3.yaxisTooltip.setAttribute("class", s3 + " apexcharts-theme-" + t4.config.tooltip.theme), r2.appendChild(e3.yaxisTooltip), 0 === i2 && (e3.yaxisTooltipText = []), e3.yaxisTooltipText[i2] = document.createElement("div"), e3.yaxisTooltipText[i2].classList.add("apexcharts-yaxistooltip-text"), e3.yaxisTooltip.appendChild(e3.yaxisTooltipText[i2]));
      }
    } }, { key: "setXCrosshairWidth", value: function() {
      var t4 = this.w, e3 = this.ttCtx, i2 = e3.getElXCrosshairs();
      if (e3.xcrosshairsWidth = parseInt(t4.config.xaxis.crosshairs.width, 10), t4.globals.comboCharts) {
        var a3 = t4.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
        if (null !== a3 && "barWidth" === t4.config.xaxis.crosshairs.width) {
          var s3 = parseFloat(a3.getAttribute("barWidth"));
          e3.xcrosshairsWidth = s3;
        } else if ("tickWidth" === t4.config.xaxis.crosshairs.width) {
          var r2 = t4.globals.labels.length;
          e3.xcrosshairsWidth = t4.globals.gridWidth / r2;
        }
      } else if ("tickWidth" === t4.config.xaxis.crosshairs.width) {
        var o3 = t4.globals.labels.length;
        e3.xcrosshairsWidth = t4.globals.gridWidth / o3;
      } else if ("barWidth" === t4.config.xaxis.crosshairs.width) {
        var n3 = t4.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
        if (null !== n3) {
          var l3 = parseFloat(n3.getAttribute("barWidth"));
          e3.xcrosshairsWidth = l3;
        } else e3.xcrosshairsWidth = 1;
      }
      t4.globals.isBarHorizontal && (e3.xcrosshairsWidth = 0), null !== i2 && e3.xcrosshairsWidth > 0 && i2.setAttribute("width", e3.xcrosshairsWidth);
    } }, { key: "handleYCrosshair", value: function() {
      var t4 = this.w, e3 = this.ttCtx;
      e3.ycrosshairs = t4.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs"), e3.ycrosshairsHidden = t4.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs-hidden");
    } }, { key: "drawYaxisTooltipText", value: function(t4, e3, i2) {
      var a3 = this.ttCtx, s3 = this.w, r2 = s3.globals, o3 = r2.seriesYAxisMap[t4];
      if (a3.yaxisTooltips[t4] && o3.length > 0) {
        var n3 = r2.yLabelFormatters[t4], l3 = a3.getElGrid().getBoundingClientRect(), h3 = o3[0], c3 = 0;
        i2.yRatio.length > 1 && (c3 = h3);
        var d3 = (e3 - l3.top) * i2.yRatio[c3], g3 = r2.maxYArr[h3] - r2.minYArr[h3], u3 = r2.minYArr[h3] + (g3 - d3);
        s3.config.yaxis[t4].reversed && (u3 = r2.maxYArr[h3] - (g3 - d3)), a3.tooltipPosition.moveYCrosshairs(e3 - l3.top), a3.yaxisTooltipText[t4].innerHTML = n3(u3), a3.tooltipPosition.moveYAxisTooltip(t4);
      }
    } }]), t3;
  }(), bt2 = function() {
    function t3(e3) {
      a2(this, t3), this.ctx = e3, this.w = e3.w;
      var i2 = this.w;
      this.tConfig = i2.config.tooltip, this.tooltipUtil = new dt2(this), this.tooltipLabels = new gt2(this), this.tooltipPosition = new ut2(this), this.marker = new pt2(this), this.intersect = new ft2(this), this.axesTooltip = new xt2(this), this.showOnIntersect = this.tConfig.intersect, this.showTooltipTitle = this.tConfig.x.show, this.fixedTooltip = this.tConfig.fixed.enabled, this.xaxisTooltip = null, this.yaxisTTEls = null, this.isBarShared = !i2.globals.isBarHorizontal && this.tConfig.shared, this.lastHoverTime = Date.now();
    }
    return r(t3, [{ key: "getElTooltip", value: function(t4) {
      return t4 || (t4 = this), t4.w.globals.dom.baseEl ? t4.w.globals.dom.baseEl.querySelector(".apexcharts-tooltip") : null;
    } }, { key: "getElXCrosshairs", value: function() {
      return this.w.globals.dom.baseEl.querySelector(".apexcharts-xcrosshairs");
    } }, { key: "getElGrid", value: function() {
      return this.w.globals.dom.baseEl.querySelector(".apexcharts-grid");
    } }, { key: "drawTooltip", value: function(t4) {
      var e3 = this.w;
      this.xyRatios = t4, this.isXAxisTooltipEnabled = e3.config.xaxis.tooltip.enabled && e3.globals.axisCharts, this.yaxisTooltips = e3.config.yaxis.map(function(t5, i3) {
        return !!(t5.show && t5.tooltip.enabled && e3.globals.axisCharts);
      }), this.allTooltipSeriesGroups = [], e3.globals.axisCharts || (this.showTooltipTitle = false);
      var i2 = document.createElement("div");
      if (i2.classList.add("apexcharts-tooltip"), e3.config.tooltip.cssClass && i2.classList.add(e3.config.tooltip.cssClass), i2.classList.add("apexcharts-theme-".concat(this.tConfig.theme)), e3.globals.dom.elWrap.appendChild(i2), e3.globals.axisCharts) {
        this.axesTooltip.drawXaxisTooltip(), this.axesTooltip.drawYaxisTooltip(), this.axesTooltip.setXCrosshairWidth(), this.axesTooltip.handleYCrosshair();
        var a3 = new V2(this.ctx);
        this.xAxisTicksPositions = a3.getXAxisTicksPositions();
      }
      if (!e3.globals.comboCharts && !this.tConfig.intersect && "rangeBar" !== e3.config.chart.type || this.tConfig.shared || (this.showOnIntersect = true), 0 !== e3.config.markers.size && 0 !== e3.globals.markers.largestSize || this.marker.drawDynamicPoints(this), e3.globals.collapsedSeries.length !== e3.globals.series.length) {
        this.dataPointsDividedHeight = e3.globals.gridHeight / e3.globals.dataPoints, this.dataPointsDividedWidth = e3.globals.gridWidth / e3.globals.dataPoints, this.showTooltipTitle && (this.tooltipTitle = document.createElement("div"), this.tooltipTitle.classList.add("apexcharts-tooltip-title"), this.tooltipTitle.style.fontFamily = this.tConfig.style.fontFamily || e3.config.chart.fontFamily, this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize, i2.appendChild(this.tooltipTitle));
        var s3 = e3.globals.series.length;
        (e3.globals.xyCharts || e3.globals.comboCharts) && this.tConfig.shared && (s3 = this.showOnIntersect ? 1 : e3.globals.series.length), this.legendLabels = e3.globals.dom.baseEl.querySelectorAll(".apexcharts-legend-text"), this.ttItems = this.createTTElements(s3), this.addSVGEvents();
      }
    } }, { key: "createTTElements", value: function(t4) {
      for (var e3 = this, i2 = this.w, a3 = [], s3 = this.getElTooltip(), r2 = function(r3) {
        var o4 = document.createElement("div");
        o4.classList.add("apexcharts-tooltip-series-group"), o4.style.order = i2.config.tooltip.inverseOrder ? t4 - r3 : r3 + 1, e3.tConfig.shared && e3.tConfig.enabledOnSeries && Array.isArray(e3.tConfig.enabledOnSeries) && e3.tConfig.enabledOnSeries.indexOf(r3) < 0 && o4.classList.add("apexcharts-tooltip-series-group-hidden");
        var n3 = document.createElement("span");
        n3.classList.add("apexcharts-tooltip-marker"), n3.style.backgroundColor = i2.globals.colors[r3], o4.appendChild(n3);
        var l3 = document.createElement("div");
        l3.classList.add("apexcharts-tooltip-text"), l3.style.fontFamily = e3.tConfig.style.fontFamily || i2.config.chart.fontFamily, l3.style.fontSize = e3.tConfig.style.fontSize, ["y", "goals", "z"].forEach(function(t5) {
          var e4 = document.createElement("div");
          e4.classList.add("apexcharts-tooltip-".concat(t5, "-group"));
          var i3 = document.createElement("span");
          i3.classList.add("apexcharts-tooltip-text-".concat(t5, "-label")), e4.appendChild(i3);
          var a4 = document.createElement("span");
          a4.classList.add("apexcharts-tooltip-text-".concat(t5, "-value")), e4.appendChild(a4), l3.appendChild(e4);
        }), o4.appendChild(l3), s3.appendChild(o4), a3.push(o4);
      }, o3 = 0; o3 < t4; o3++) r2(o3);
      return a3;
    } }, { key: "addSVGEvents", value: function() {
      var t4 = this.w, e3 = t4.config.chart.type, i2 = this.getElTooltip(), a3 = !("bar" !== e3 && "candlestick" !== e3 && "boxPlot" !== e3 && "rangeBar" !== e3), s3 = "area" === e3 || "line" === e3 || "scatter" === e3 || "bubble" === e3 || "radar" === e3, r2 = t4.globals.dom.Paper.node, o3 = this.getElGrid();
      o3 && (this.seriesBound = o3.getBoundingClientRect());
      var n3, l3 = [], h3 = [], c3 = { hoverArea: r2, elGrid: o3, tooltipEl: i2, tooltipY: l3, tooltipX: h3, ttItems: this.ttItems };
      if (t4.globals.axisCharts && (s3 ? n3 = t4.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker") : a3 ? n3 = t4.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-boxPlot-area, .apexcharts-series .apexcharts-rangebar-area") : "heatmap" !== e3 && "treemap" !== e3 || (n3 = t4.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-heatmap, .apexcharts-series .apexcharts-treemap")), n3 && n3.length)) for (var d3 = 0; d3 < n3.length; d3++) l3.push(n3[d3].getAttribute("cy")), h3.push(n3[d3].getAttribute("cx"));
      if (t4.globals.xyCharts && !this.showOnIntersect || t4.globals.comboCharts && !this.showOnIntersect || a3 && this.tooltipUtil.hasBars() && this.tConfig.shared) this.addPathsEventListeners([r2], c3);
      else if (a3 && !t4.globals.comboCharts || s3 && this.showOnIntersect) this.addDatapointEventsListeners(c3);
      else if (!t4.globals.axisCharts || "heatmap" === e3 || "treemap" === e3) {
        var g3 = t4.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
        this.addPathsEventListeners(g3, c3);
      }
      if (this.showOnIntersect) {
        var u3 = t4.globals.dom.baseEl.querySelectorAll(".apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker");
        u3.length > 0 && this.addPathsEventListeners(u3, c3), this.tooltipUtil.hasBars() && !this.tConfig.shared && this.addDatapointEventsListeners(c3);
      }
    } }, { key: "drawFixedTooltipRect", value: function() {
      var t4 = this.w, e3 = this.getElTooltip(), i2 = e3.getBoundingClientRect(), a3 = i2.width + 10, s3 = i2.height + 10, r2 = this.tConfig.fixed.offsetX, o3 = this.tConfig.fixed.offsetY, n3 = this.tConfig.fixed.position.toLowerCase();
      return n3.indexOf("right") > -1 && (r2 = r2 + t4.globals.svgWidth - a3 + 10), n3.indexOf("bottom") > -1 && (o3 = o3 + t4.globals.svgHeight - s3 - 10), e3.style.left = r2 + "px", e3.style.top = o3 + "px", { x: r2, y: o3, ttWidth: a3, ttHeight: s3 };
    } }, { key: "addDatapointEventsListeners", value: function(t4) {
      var e3 = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-boxPlot-area, .apexcharts-rangebar-area");
      this.addPathsEventListeners(e3, t4);
    } }, { key: "addPathsEventListeners", value: function(t4, e3) {
      for (var i2 = this, a3 = function(a4) {
        var s4 = { paths: t4[a4], tooltipEl: e3.tooltipEl, tooltipY: e3.tooltipY, tooltipX: e3.tooltipX, elGrid: e3.elGrid, hoverArea: e3.hoverArea, ttItems: e3.ttItems };
        ["mousemove", "mouseup", "touchmove", "mouseout", "touchend"].map(function(e4) {
          return t4[a4].addEventListener(e4, i2.onSeriesHover.bind(i2, s4), { capture: false, passive: true });
        });
      }, s3 = 0; s3 < t4.length; s3++) a3(s3);
    } }, { key: "onSeriesHover", value: function(t4, e3) {
      var i2 = this, a3 = Date.now() - this.lastHoverTime;
      a3 >= 100 ? this.seriesHover(t4, e3) : (clearTimeout(this.seriesHoverTimeout), this.seriesHoverTimeout = setTimeout(function() {
        i2.seriesHover(t4, e3);
      }, 100 - a3));
    } }, { key: "seriesHover", value: function(t4, e3) {
      var i2 = this;
      this.lastHoverTime = Date.now();
      var a3 = [], s3 = this.w;
      s3.config.chart.group && (a3 = this.ctx.getGroupedCharts()), s3.globals.axisCharts && (s3.globals.minX === -1 / 0 && s3.globals.maxX === 1 / 0 || 0 === s3.globals.dataPoints) || (a3.length ? a3.forEach(function(a4) {
        var s4 = i2.getElTooltip(a4), r2 = { paths: t4.paths, tooltipEl: s4, tooltipY: t4.tooltipY, tooltipX: t4.tooltipX, elGrid: t4.elGrid, hoverArea: t4.hoverArea, ttItems: a4.w.globals.tooltip.ttItems };
        a4.w.globals.minX === i2.w.globals.minX && a4.w.globals.maxX === i2.w.globals.maxX && a4.w.globals.tooltip.seriesHoverByContext({ chartCtx: a4, ttCtx: a4.w.globals.tooltip, opt: r2, e: e3 });
      }) : this.seriesHoverByContext({ chartCtx: this.ctx, ttCtx: this.w.globals.tooltip, opt: t4, e: e3 }));
    } }, { key: "seriesHoverByContext", value: function(t4) {
      var e3 = t4.chartCtx, i2 = t4.ttCtx, a3 = t4.opt, s3 = t4.e, r2 = e3.w, o3 = this.getElTooltip();
      if (o3) {
        if (i2.tooltipRect = { x: 0, y: 0, ttWidth: o3.getBoundingClientRect().width, ttHeight: o3.getBoundingClientRect().height }, i2.e = s3, i2.tooltipUtil.hasBars() && !r2.globals.comboCharts && !i2.isBarShared) {
          if (this.tConfig.onDatasetHover.highlightDataSeries) new W2(e3).toggleSeriesOnHover(s3, s3.target.parentNode);
        }
        i2.fixedTooltip && i2.drawFixedTooltipRect(), r2.globals.axisCharts ? i2.axisChartsTooltips({ e: s3, opt: a3, tooltipRect: i2.tooltipRect }) : i2.nonAxisChartsTooltips({ e: s3, opt: a3, tooltipRect: i2.tooltipRect });
      }
    } }, { key: "axisChartsTooltips", value: function(t4) {
      var e3, i2, a3 = t4.e, s3 = t4.opt, r2 = this.w, o3 = s3.elGrid.getBoundingClientRect(), n3 = "touchmove" === a3.type ? a3.touches[0].clientX : a3.clientX, l3 = "touchmove" === a3.type ? a3.touches[0].clientY : a3.clientY;
      if (this.clientY = l3, this.clientX = n3, r2.globals.capturedSeriesIndex = -1, r2.globals.capturedDataPointIndex = -1, l3 < o3.top || l3 > o3.top + o3.height) this.handleMouseOut(s3);
      else {
        if (Array.isArray(this.tConfig.enabledOnSeries) && !r2.config.tooltip.shared) {
          var h3 = parseInt(s3.paths.getAttribute("index"), 10);
          if (this.tConfig.enabledOnSeries.indexOf(h3) < 0) return void this.handleMouseOut(s3);
        }
        var c3 = this.getElTooltip(), d3 = this.getElXCrosshairs(), g3 = r2.globals.xyCharts || "bar" === r2.config.chart.type && !r2.globals.isBarHorizontal && this.tooltipUtil.hasBars() && this.tConfig.shared || r2.globals.comboCharts && this.tooltipUtil.hasBars();
        if ("mousemove" === a3.type || "touchmove" === a3.type || "mouseup" === a3.type) {
          if (r2.globals.collapsedSeries.length + r2.globals.ancillaryCollapsedSeries.length === r2.globals.series.length) return;
          null !== d3 && d3.classList.add("apexcharts-active");
          var u3 = this.yaxisTooltips.filter(function(t5) {
            return true === t5;
          });
          if (null !== this.ycrosshairs && u3.length && this.ycrosshairs.classList.add("apexcharts-active"), g3 && !this.showOnIntersect) this.handleStickyTooltip(a3, n3, l3, s3);
          else if ("heatmap" === r2.config.chart.type || "treemap" === r2.config.chart.type) {
            var p3 = this.intersect.handleHeatTreeTooltip({ e: a3, opt: s3, x: e3, y: i2, type: r2.config.chart.type });
            e3 = p3.x, i2 = p3.y, c3.style.left = e3 + "px", c3.style.top = i2 + "px";
          } else this.tooltipUtil.hasBars() && this.intersect.handleBarTooltip({ e: a3, opt: s3 }), this.tooltipUtil.hasMarkers() && this.intersect.handleMarkerTooltip({ e: a3, opt: s3, x: e3, y: i2 });
          if (this.yaxisTooltips.length) for (var f3 = 0; f3 < r2.config.yaxis.length; f3++) this.axesTooltip.drawYaxisTooltipText(f3, l3, this.xyRatios);
          s3.tooltipEl.classList.add("apexcharts-active");
        } else "mouseout" !== a3.type && "touchend" !== a3.type || this.handleMouseOut(s3);
      }
    } }, { key: "nonAxisChartsTooltips", value: function(t4) {
      var e3 = t4.e, i2 = t4.opt, a3 = t4.tooltipRect, s3 = this.w, r2 = i2.paths.getAttribute("rel"), o3 = this.getElTooltip(), n3 = s3.globals.dom.elWrap.getBoundingClientRect();
      if ("mousemove" === e3.type || "touchmove" === e3.type) {
        o3.classList.add("apexcharts-active"), this.tooltipLabels.drawSeriesTexts({ ttItems: i2.ttItems, i: parseInt(r2, 10) - 1, shared: false });
        var l3 = s3.globals.clientX - n3.left - a3.ttWidth / 2, h3 = s3.globals.clientY - n3.top - a3.ttHeight - 10;
        if (o3.style.left = l3 + "px", o3.style.top = h3 + "px", s3.config.legend.tooltipHoverFormatter) {
          var c3 = r2 - 1, d3 = (0, s3.config.legend.tooltipHoverFormatter)(this.legendLabels[c3].getAttribute("data:default-text"), { seriesIndex: c3, dataPointIndex: c3, w: s3 });
          this.legendLabels[c3].innerHTML = d3;
        }
      } else "mouseout" !== e3.type && "touchend" !== e3.type || (o3.classList.remove("apexcharts-active"), s3.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(t5) {
        var e4 = t5.getAttribute("data:default-text");
        t5.innerHTML = decodeURIComponent(e4);
      }));
    } }, { key: "handleStickyTooltip", value: function(t4, e3, i2, a3) {
      var s3 = this.w, r2 = this.tooltipUtil.getNearestValues({ context: this, hoverArea: a3.hoverArea, elGrid: a3.elGrid, clientX: e3, clientY: i2 }), o3 = r2.j, n3 = r2.capturedSeries;
      s3.globals.collapsedSeriesIndices.includes(n3) && (n3 = null);
      var l3 = a3.elGrid.getBoundingClientRect();
      if (r2.hoverX < 0 || r2.hoverX > l3.width) this.handleMouseOut(a3);
      else if (null !== n3) this.handleStickyCapturedSeries(t4, n3, a3, o3);
      else if (this.tooltipUtil.isXoverlap(o3) || s3.globals.isBarHorizontal) {
        var h3 = s3.globals.series.findIndex(function(t5, e4) {
          return !s3.globals.collapsedSeriesIndices.includes(e4);
        });
        this.create(t4, this, h3, o3, a3.ttItems);
      }
    } }, { key: "handleStickyCapturedSeries", value: function(t4, e3, i2, a3) {
      var s3 = this.w;
      if (!this.tConfig.shared && null === s3.globals.series[e3][a3]) return void this.handleMouseOut(i2);
      if (void 0 !== s3.globals.series[e3][a3]) this.tConfig.shared && this.tooltipUtil.isXoverlap(a3) && this.tooltipUtil.isInitialSeriesSameLen() ? this.create(t4, this, e3, a3, i2.ttItems) : this.create(t4, this, e3, a3, i2.ttItems, false);
      else if (this.tooltipUtil.isXoverlap(a3)) {
        var r2 = s3.globals.series.findIndex(function(t5, e4) {
          return !s3.globals.collapsedSeriesIndices.includes(e4);
        });
        this.create(t4, this, r2, a3, i2.ttItems);
      }
    } }, { key: "deactivateHoverFilter", value: function() {
      for (var t4 = this.w, e3 = new m2(this.ctx), i2 = t4.globals.dom.Paper.select(".apexcharts-bar-area"), a3 = 0; a3 < i2.length; a3++) e3.pathMouseLeave(i2[a3]);
    } }, { key: "handleMouseOut", value: function(t4) {
      var e3 = this.w, i2 = this.getElXCrosshairs();
      if (t4.tooltipEl.classList.remove("apexcharts-active"), this.deactivateHoverFilter(), "bubble" !== e3.config.chart.type && this.marker.resetPointsSize(), null !== i2 && i2.classList.remove("apexcharts-active"), null !== this.ycrosshairs && this.ycrosshairs.classList.remove("apexcharts-active"), this.isXAxisTooltipEnabled && this.xaxisTooltip.classList.remove("apexcharts-active"), this.yaxisTooltips.length) {
        null === this.yaxisTTEls && (this.yaxisTTEls = e3.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
        for (var a3 = 0; a3 < this.yaxisTTEls.length; a3++) this.yaxisTTEls[a3].classList.remove("apexcharts-active");
      }
      e3.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(t5) {
        var e4 = t5.getAttribute("data:default-text");
        t5.innerHTML = decodeURIComponent(e4);
      });
    } }, { key: "markerClick", value: function(t4, e3, i2) {
      var a3 = this.w;
      "function" == typeof a3.config.chart.events.markerClick && a3.config.chart.events.markerClick(t4, this.ctx, { seriesIndex: e3, dataPointIndex: i2, w: a3 }), this.ctx.events.fireEvent("markerClick", [t4, this.ctx, { seriesIndex: e3, dataPointIndex: i2, w: a3 }]);
    } }, { key: "create", value: function(t4, i2, a3, s3, r2) {
      var o3, n3, l3, h3, c3, d3, g3, u3, p3, f3, x3, b3, v3, y3, w3, k3, A3 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null, S3 = this.w, C3 = i2;
      "mouseup" === t4.type && this.markerClick(t4, a3, s3), null === A3 && (A3 = this.tConfig.shared);
      var L3 = this.tooltipUtil.hasMarkers(a3), P3 = this.tooltipUtil.getElBars();
      if (S3.config.legend.tooltipHoverFormatter) {
        var M3 = S3.config.legend.tooltipHoverFormatter, I3 = Array.from(this.legendLabels);
        I3.forEach(function(t5) {
          var e3 = t5.getAttribute("data:default-text");
          t5.innerHTML = decodeURIComponent(e3);
        });
        for (var T3 = 0; T3 < I3.length; T3++) {
          var z3 = I3[T3], X3 = parseInt(z3.getAttribute("i"), 10), E3 = decodeURIComponent(z3.getAttribute("data:default-text")), Y3 = M3(E3, { seriesIndex: A3 ? X3 : a3, dataPointIndex: s3, w: S3 });
          if (A3) z3.innerHTML = S3.globals.collapsedSeriesIndices.indexOf(X3) < 0 ? Y3 : E3;
          else if (z3.innerHTML = X3 === a3 ? Y3 : E3, a3 === X3) break;
        }
      }
      var F3 = e2(e2({ ttItems: r2, i: a3, j: s3 }, void 0 !== (null === (o3 = S3.globals.seriesRange) || void 0 === o3 || null === (n3 = o3[a3]) || void 0 === n3 || null === (l3 = n3[s3]) || void 0 === l3 || null === (h3 = l3.y[0]) || void 0 === h3 ? void 0 : h3.y1) && { y1: null === (c3 = S3.globals.seriesRange) || void 0 === c3 || null === (d3 = c3[a3]) || void 0 === d3 || null === (g3 = d3[s3]) || void 0 === g3 || null === (u3 = g3.y[0]) || void 0 === u3 ? void 0 : u3.y1 }), void 0 !== (null === (p3 = S3.globals.seriesRange) || void 0 === p3 || null === (f3 = p3[a3]) || void 0 === f3 || null === (x3 = f3[s3]) || void 0 === x3 || null === (b3 = x3.y[0]) || void 0 === b3 ? void 0 : b3.y2) && { y2: null === (v3 = S3.globals.seriesRange) || void 0 === v3 || null === (y3 = v3[a3]) || void 0 === y3 || null === (w3 = y3[s3]) || void 0 === w3 || null === (k3 = w3.y[0]) || void 0 === k3 ? void 0 : k3.y2 });
      if (A3) {
        if (C3.tooltipLabels.drawSeriesTexts(e2(e2({}, F3), {}, { shared: !this.showOnIntersect && this.tConfig.shared })), L3) S3.globals.markers.largestSize > 0 ? C3.marker.enlargePoints(s3) : C3.tooltipPosition.moveDynamicPointsOnHover(s3);
        else if (this.tooltipUtil.hasBars() && (this.barSeriesHeight = this.tooltipUtil.getBarsHeight(P3), this.barSeriesHeight > 0)) {
          var R3 = new m2(this.ctx), H5 = S3.globals.dom.Paper.select(".apexcharts-bar-area[j='".concat(s3, "']"));
          this.deactivateHoverFilter(), this.tooltipPosition.moveStickyTooltipOverBars(s3, a3);
          for (var D3 = 0; D3 < H5.length; D3++) R3.pathMouseEnter(H5[D3]);
        }
      } else C3.tooltipLabels.drawSeriesTexts(e2({ shared: false }, F3)), this.tooltipUtil.hasBars() && C3.tooltipPosition.moveStickyTooltipOverBars(s3, a3), L3 && C3.tooltipPosition.moveMarkers(a3, s3);
    } }]), t3;
  }(), vt2 = function() {
    function t3(e3) {
      a2(this, t3), this.w = e3.w, this.barCtx = e3, this.totalFormatter = this.w.config.plotOptions.bar.dataLabels.total.formatter, this.totalFormatter || (this.totalFormatter = this.w.config.dataLabels.formatter);
    }
    return r(t3, [{ key: "handleBarDataLabels", value: function(t4) {
      var e3, i2, a3 = t4.x, s3 = t4.y, r2 = t4.y1, o3 = t4.y2, n3 = t4.i, l3 = t4.j, h3 = t4.realIndex, c3 = t4.columnGroupIndex, d3 = t4.series, g3 = t4.barHeight, u3 = t4.barWidth, p3 = t4.barXPosition, f3 = t4.barYPosition, x3 = t4.visibleSeries, b3 = t4.renderedPath, v3 = this.w, y3 = new m2(this.barCtx.ctx), w3 = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[h3] : this.barCtx.strokeWidth;
      v3.globals.isXNumeric && !v3.globals.isBarHorizontal ? (e3 = a3 + parseFloat(u3 * (x3 + 1)), i2 = s3 + parseFloat(g3 * (x3 + 1)) - w3) : (e3 = a3 + parseFloat(u3 * x3), i2 = s3 + parseFloat(g3 * x3));
      var k3, A3 = null, S3 = a3, C3 = s3, L3 = {}, P3 = v3.config.dataLabels, M3 = this.barCtx.barOptions.dataLabels, I3 = this.barCtx.barOptions.dataLabels.total;
      void 0 !== f3 && this.barCtx.isRangeBar && (i2 = f3, C3 = f3), void 0 !== p3 && this.barCtx.isVerticalGroupedRangeBar && (e3 = p3, S3 = p3);
      var T3 = P3.offsetX, z3 = P3.offsetY, X3 = { width: 0, height: 0 };
      if (v3.config.dataLabels.enabled) {
        var E3 = this.barCtx.series[n3][l3];
        X3 = y3.getTextRects(v3.globals.yLabelFormatters[0](E3), parseFloat(P3.style.fontSize));
      }
      var Y3 = { x: a3, y: s3, i: n3, j: l3, realIndex: h3, columnGroupIndex: c3, renderedPath: b3, bcx: e3, bcy: i2, barHeight: g3, barWidth: u3, textRects: X3, strokeWidth: w3, dataLabelsX: S3, dataLabelsY: C3, dataLabelsConfig: P3, barDataLabelsConfig: M3, barTotalDataLabelsConfig: I3, offX: T3, offY: z3 };
      return L3 = this.barCtx.isHorizontal ? this.calculateBarsDataLabelsPosition(Y3) : this.calculateColumnsDataLabelsPosition(Y3), b3.attr({ cy: L3.bcy, cx: L3.bcx, j: l3, val: d3[n3][l3], barHeight: g3, barWidth: u3 }), k3 = this.drawCalculatedDataLabels({ x: L3.dataLabelsX, y: L3.dataLabelsY, val: this.barCtx.isRangeBar ? [r2, o3] : d3[n3][l3], i: h3, j: l3, barWidth: u3, barHeight: g3, textRects: X3, dataLabelsConfig: P3 }), v3.config.chart.stacked && I3.enabled && (A3 = this.drawTotalDataLabels({ x: L3.totalDataLabelsX, y: L3.totalDataLabelsY, barWidth: u3, barHeight: g3, realIndex: h3, textAnchor: L3.totalDataLabelsAnchor, val: this.getStackedTotalDataLabel({ realIndex: h3, j: l3 }), dataLabelsConfig: P3, barTotalDataLabelsConfig: I3 })), { dataLabels: k3, totalDataLabels: A3 };
    } }, { key: "getStackedTotalDataLabel", value: function(t4) {
      var i2 = t4.realIndex, a3 = t4.j, s3 = this.w, r2 = this.barCtx.stackedSeriesTotals[a3];
      return this.totalFormatter && (r2 = this.totalFormatter(r2, e2(e2({}, s3), {}, { seriesIndex: i2, dataPointIndex: a3, w: s3 }))), r2;
    } }, { key: "calculateColumnsDataLabelsPosition", value: function(t4) {
      var e3, i2, a3 = this.w, s3 = t4.i, r2 = t4.j, o3 = t4.realIndex, n3 = t4.columnGroupIndex, l3 = t4.y, h3 = t4.bcx, c3 = t4.barWidth, d3 = t4.barHeight, g3 = t4.textRects, u3 = t4.dataLabelsX, p3 = t4.dataLabelsY, f3 = t4.dataLabelsConfig, x3 = t4.barDataLabelsConfig, b3 = t4.barTotalDataLabelsConfig, v3 = t4.strokeWidth, y3 = t4.offX, w3 = t4.offY, k3 = h3;
      d3 = Math.abs(d3);
      var A3 = "vertical" === a3.config.plotOptions.bar.dataLabels.orientation, S3 = this.barCtx.barHelpers.getZeroValueEncounters({ i: s3, j: r2 }).zeroEncounters;
      h3 = h3 - v3 / 2 + n3 * c3;
      var C3 = a3.globals.gridWidth / a3.globals.dataPoints;
      if (this.barCtx.isVerticalGroupedRangeBar ? u3 += c3 / 2 : (u3 = a3.globals.isXNumeric ? h3 - c3 / 2 + y3 : h3 - C3 + c3 / 2 + y3, S3 > 0 && a3.config.plotOptions.bar.hideZeroBarsWhenGrouped && (u3 -= c3 * S3)), A3) {
        u3 = u3 + g3.height / 2 - v3 / 2 - 2;
      }
      var L3 = this.barCtx.series[s3][r2] < 0, P3 = l3;
      switch (this.barCtx.isReversed && (P3 = l3 + (L3 ? d3 : -d3), l3 -= d3), x3.position) {
        case "center":
          p3 = A3 ? L3 ? P3 - d3 / 2 + w3 : P3 + d3 / 2 - w3 : L3 ? P3 - d3 / 2 + g3.height / 2 + w3 : P3 + d3 / 2 + g3.height / 2 - w3;
          break;
        case "bottom":
          p3 = A3 ? L3 ? P3 - d3 + w3 : P3 + d3 - w3 : L3 ? P3 - d3 + g3.height + v3 + w3 : P3 + d3 - g3.height / 2 + v3 - w3;
          break;
        case "top":
          p3 = A3 ? L3 ? P3 + w3 : P3 - w3 : L3 ? P3 - g3.height / 2 - w3 : P3 + g3.height + w3;
      }
      if (this.barCtx.lastActiveBarSerieIndex === o3 && b3.enabled) {
        var M3 = new m2(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({ realIndex: o3, j: r2 }), f3.fontSize);
        e3 = L3 ? P3 - M3.height / 2 - w3 - b3.offsetY + 18 : P3 + M3.height + w3 + b3.offsetY - 18;
        var I3 = a3.globals.gridWidth / a3.globals.dataPoints;
        i2 = k3 + c3 * (a3.globals.barGroups.length - 0.5) - (a3.globals.isXNumeric ? c3 : I3) + b3.offsetX;
      }
      return a3.config.chart.stacked || (p3 < 0 ? p3 = 0 + v3 : p3 + g3.height / 3 > a3.globals.gridHeight && (p3 = a3.globals.gridHeight - v3)), { bcx: h3, bcy: l3, dataLabelsX: u3, dataLabelsY: p3, totalDataLabelsX: i2, totalDataLabelsY: e3, totalDataLabelsAnchor: "middle" };
    } }, { key: "calculateBarsDataLabelsPosition", value: function(t4) {
      var e3 = this.w, i2 = t4.x, a3 = t4.i, s3 = t4.j, r2 = t4.realIndex, o3 = t4.columnGroupIndex, n3 = t4.bcy, l3 = t4.barHeight, h3 = t4.barWidth, c3 = t4.textRects, d3 = t4.dataLabelsX, g3 = t4.strokeWidth, u3 = t4.dataLabelsConfig, p3 = t4.barDataLabelsConfig, f3 = t4.barTotalDataLabelsConfig, x3 = t4.offX, b3 = t4.offY, v3 = e3.globals.gridHeight / e3.globals.dataPoints;
      h3 = Math.abs(h3);
      var y3, w3, k3 = (n3 += o3 * l3) - (this.barCtx.isRangeBar ? 0 : v3) + l3 / 2 + c3.height / 2 + b3 - 3, A3 = "start", S3 = this.barCtx.series[a3][s3] < 0, C3 = i2;
      switch (this.barCtx.isReversed && (C3 = i2 + (S3 ? -h3 : h3), i2 = e3.globals.gridWidth - h3, A3 = S3 ? "start" : "end"), p3.position) {
        case "center":
          d3 = S3 ? C3 + h3 / 2 - x3 : Math.max(c3.width / 2, C3 - h3 / 2) + x3;
          break;
        case "bottom":
          d3 = S3 ? C3 + h3 - g3 - Math.round(c3.width / 2) - x3 : C3 - h3 + g3 + Math.round(c3.width / 2) + x3;
          break;
        case "top":
          d3 = S3 ? C3 - g3 + Math.round(c3.width / 2) - x3 : C3 - g3 - Math.round(c3.width / 2) + x3;
      }
      if (this.barCtx.lastActiveBarSerieIndex === r2 && f3.enabled) {
        var L3 = new m2(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({ realIndex: r2, j: s3 }), u3.fontSize);
        S3 ? (y3 = C3 - g3 - x3 - f3.offsetX, A3 = "end") : y3 = C3 + x3 + f3.offsetX + (this.barCtx.isReversed ? -(h3 + g3) : g3), w3 = k3 - c3.height / 2 + L3.height / 2 + f3.offsetY + g3;
      }
      return e3.config.chart.stacked || (d3 < 0 ? d3 = d3 + c3.width + g3 : d3 + c3.width / 2 > e3.globals.gridWidth && (d3 = e3.globals.gridWidth - c3.width - g3)), { bcx: i2, bcy: n3, dataLabelsX: d3, dataLabelsY: k3, totalDataLabelsX: y3, totalDataLabelsY: w3, totalDataLabelsAnchor: A3 };
    } }, { key: "drawCalculatedDataLabels", value: function(t4) {
      var i2 = t4.x, a3 = t4.y, s3 = t4.val, r2 = t4.i, o3 = t4.j, n3 = t4.textRects, l3 = t4.barHeight, h3 = t4.barWidth, c3 = t4.dataLabelsConfig, d3 = this.w, g3 = "rotate(0)";
      "vertical" === d3.config.plotOptions.bar.dataLabels.orientation && (g3 = "rotate(-90, ".concat(i2, ", ").concat(a3, ")"));
      var u3 = new N2(this.barCtx.ctx), p3 = new m2(this.barCtx.ctx), f3 = c3.formatter, x3 = null, b3 = d3.globals.collapsedSeriesIndices.indexOf(r2) > -1;
      if (c3.enabled && !b3) {
        x3 = p3.group({ class: "apexcharts-data-labels", transform: g3 });
        var v3 = "";
        void 0 !== s3 && (v3 = f3(s3, e2(e2({}, d3), {}, { seriesIndex: r2, dataPointIndex: o3, w: d3 }))), !s3 && d3.config.plotOptions.bar.hideZeroBarsWhenGrouped && (v3 = "");
        var y3 = d3.globals.series[r2][o3] < 0, w3 = d3.config.plotOptions.bar.dataLabels.position;
        if ("vertical" === d3.config.plotOptions.bar.dataLabels.orientation && ("top" === w3 && (c3.textAnchor = y3 ? "end" : "start"), "center" === w3 && (c3.textAnchor = "middle"), "bottom" === w3 && (c3.textAnchor = y3 ? "end" : "start")), this.barCtx.isRangeBar && this.barCtx.barOptions.dataLabels.hideOverflowingLabels) h3 < p3.getTextRects(v3, parseFloat(c3.style.fontSize)).width && (v3 = "");
        d3.config.chart.stacked && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && (this.barCtx.isHorizontal ? n3.width / 1.6 > Math.abs(h3) && (v3 = "") : n3.height / 1.6 > Math.abs(l3) && (v3 = ""));
        var k3 = e2({}, c3);
        this.barCtx.isHorizontal && s3 < 0 && ("start" === c3.textAnchor ? k3.textAnchor = "end" : "end" === c3.textAnchor && (k3.textAnchor = "start")), u3.plotDataLabelsText({ x: i2, y: a3, text: v3, i: r2, j: o3, parent: x3, dataLabelsConfig: k3, alwaysDrawDataLabel: true, offsetCorrection: true });
      }
      return x3;
    } }, { key: "drawTotalDataLabels", value: function(t4) {
      var e3, i2 = t4.x, a3 = t4.y, s3 = t4.val, r2 = t4.barWidth, o3 = t4.barHeight, n3 = t4.realIndex, l3 = t4.textAnchor, h3 = t4.barTotalDataLabelsConfig, c3 = this.w, d3 = new m2(this.barCtx.ctx);
      return h3.enabled && void 0 !== i2 && void 0 !== a3 && this.barCtx.lastActiveBarSerieIndex === n3 && (e3 = d3.drawText({ x: i2 - (!c3.globals.isBarHorizontal && c3.globals.barGroups.length ? r2 * (c3.globals.barGroups.length - 1) / 2 : 0), y: a3 - (c3.globals.isBarHorizontal && c3.globals.barGroups.length ? o3 * (c3.globals.barGroups.length - 1) / 2 : 0), foreColor: h3.style.color, text: s3, textAnchor: l3, fontFamily: h3.style.fontFamily, fontSize: h3.style.fontSize, fontWeight: h3.style.fontWeight })), e3;
    } }]), t3;
  }(), mt2 = function() {
    function t3(e3) {
      a2(this, t3), this.w = e3.w, this.barCtx = e3;
    }
    return r(t3, [{ key: "initVariables", value: function(t4) {
      var e3 = this.w;
      this.barCtx.series = t4, this.barCtx.totalItems = 0, this.barCtx.seriesLen = 0, this.barCtx.visibleI = -1, this.barCtx.visibleItems = 1;
      for (var i2 = 0; i2 < t4.length; i2++) if (t4[i2].length > 0 && (this.barCtx.seriesLen = this.barCtx.seriesLen + 1, this.barCtx.totalItems += t4[i2].length), e3.globals.isXNumeric) for (var a3 = 0; a3 < t4[i2].length; a3++) e3.globals.seriesX[i2][a3] > e3.globals.minX && e3.globals.seriesX[i2][a3] < e3.globals.maxX && this.barCtx.visibleItems++;
      else this.barCtx.visibleItems = e3.globals.dataPoints;
      0 === this.barCtx.seriesLen && (this.barCtx.seriesLen = 1), this.barCtx.zeroSerieses = [], e3.globals.comboCharts || this.checkZeroSeries({ series: t4 });
    } }, { key: "initialPositions", value: function() {
      var t4, e3, i2, a3, s3, r2, o3, n3, l3 = this.w, h3 = l3.globals.dataPoints;
      this.barCtx.isRangeBar && (h3 = l3.globals.labels.length);
      var c3 = this.barCtx.seriesLen;
      if (l3.config.plotOptions.bar.rangeBarGroupRows && (c3 = 1), this.barCtx.isHorizontal) s3 = (i2 = l3.globals.gridHeight / h3) / c3, l3.globals.isXNumeric && (s3 = (i2 = l3.globals.gridHeight / this.barCtx.totalItems) / this.barCtx.seriesLen), s3 = s3 * parseInt(this.barCtx.barOptions.barHeight, 10) / 100, -1 === String(this.barCtx.barOptions.barHeight).indexOf("%") && (s3 = parseInt(this.barCtx.barOptions.barHeight, 10)), n3 = this.barCtx.baseLineInvertedY + l3.globals.padHorizontal + (this.barCtx.isReversed ? l3.globals.gridWidth : 0) - (this.barCtx.isReversed ? 2 * this.barCtx.baseLineInvertedY : 0), this.barCtx.isFunnel && (n3 = l3.globals.gridWidth / 2), e3 = (i2 - s3 * this.barCtx.seriesLen) / 2;
      else {
        if (a3 = l3.globals.gridWidth / this.barCtx.visibleItems, l3.config.xaxis.convertedCatToNumeric && (a3 = l3.globals.gridWidth / l3.globals.dataPoints), r2 = a3 / c3 * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100, l3.globals.isXNumeric) {
          var d3 = this.barCtx.xRatio;
          l3.globals.minXDiff && 0.5 !== l3.globals.minXDiff && l3.globals.minXDiff / d3 > 0 && (a3 = l3.globals.minXDiff / d3), (r2 = a3 / c3 * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100) < 1 && (r2 = 1);
        }
        -1 === String(this.barCtx.barOptions.columnWidth).indexOf("%") && (r2 = parseInt(this.barCtx.barOptions.columnWidth, 10)), o3 = l3.globals.gridHeight - this.barCtx.baseLineY[this.barCtx.translationsIndex] - (this.barCtx.isReversed ? l3.globals.gridHeight : 0) + (this.barCtx.isReversed ? 2 * this.barCtx.baseLineY[this.barCtx.translationsIndex] : 0), t4 = l3.globals.padHorizontal + (a3 - r2 * this.barCtx.seriesLen) / 2;
      }
      return l3.globals.barHeight = s3, l3.globals.barWidth = r2, { x: t4, y: e3, yDivision: i2, xDivision: a3, barHeight: s3, barWidth: r2, zeroH: o3, zeroW: n3 };
    } }, { key: "initializeStackedPrevVars", value: function(t4) {
      t4.w.globals.seriesGroups.forEach(function(e3) {
        t4[e3] || (t4[e3] = {}), t4[e3].prevY = [], t4[e3].prevX = [], t4[e3].prevYF = [], t4[e3].prevXF = [], t4[e3].prevYVal = [], t4[e3].prevXVal = [];
      });
    } }, { key: "initializeStackedXYVars", value: function(t4) {
      t4.w.globals.seriesGroups.forEach(function(e3) {
        t4[e3] || (t4[e3] = {}), t4[e3].xArrj = [], t4[e3].xArrjF = [], t4[e3].xArrjVal = [], t4[e3].yArrj = [], t4[e3].yArrjF = [], t4[e3].yArrjVal = [];
      });
    } }, { key: "getPathFillColor", value: function(t4, e3, i2, a3) {
      var s3, r2, o3, n3, l3 = this.w, h3 = new H4(this.barCtx.ctx), c3 = null, d3 = this.barCtx.barOptions.distributed ? i2 : e3;
      this.barCtx.barOptions.colors.ranges.length > 0 && this.barCtx.barOptions.colors.ranges.map(function(a4) {
        t4[e3][i2] >= a4.from && t4[e3][i2] <= a4.to && (c3 = a4.color);
      });
      return l3.config.series[e3].data[i2] && l3.config.series[e3].data[i2].fillColor && (c3 = l3.config.series[e3].data[i2].fillColor), h3.fillPath({ seriesNumber: this.barCtx.barOptions.distributed ? d3 : a3, dataPointIndex: i2, color: c3, value: t4[e3][i2], fillConfig: null === (s3 = l3.config.series[e3].data[i2]) || void 0 === s3 ? void 0 : s3.fill, fillType: null !== (r2 = l3.config.series[e3].data[i2]) && void 0 !== r2 && null !== (o3 = r2.fill) && void 0 !== o3 && o3.type ? null === (n3 = l3.config.series[e3].data[i2]) || void 0 === n3 ? void 0 : n3.fill.type : Array.isArray(l3.config.fill.type) ? l3.config.fill.type[e3] : l3.config.fill.type });
    } }, { key: "getStrokeWidth", value: function(t4, e3, i2) {
      var a3 = 0, s3 = this.w;
      return void 0 === this.barCtx.series[t4][e3] || null === this.barCtx.series[t4][e3] ? this.barCtx.isNullValue = true : this.barCtx.isNullValue = false, s3.config.stroke.show && (this.barCtx.isNullValue || (a3 = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[i2] : this.barCtx.strokeWidth)), a3;
    } }, { key: "shouldApplyRadius", value: function(t4) {
      var e3 = this.w, i2 = false;
      return e3.config.plotOptions.bar.borderRadius > 0 && (e3.config.chart.stacked && "last" === e3.config.plotOptions.bar.borderRadiusWhenStacked ? this.barCtx.lastActiveBarSerieIndex === t4 && (i2 = true) : i2 = true), i2;
    } }, { key: "barBackground", value: function(t4) {
      var e3 = t4.j, i2 = t4.i, a3 = t4.x1, s3 = t4.x2, r2 = t4.y1, o3 = t4.y2, n3 = t4.elSeries, l3 = this.w, h3 = new m2(this.barCtx.ctx), c3 = new W2(this.barCtx.ctx).getActiveConfigSeriesIndex();
      if (this.barCtx.barOptions.colors.backgroundBarColors.length > 0 && c3 === i2) {
        e3 >= this.barCtx.barOptions.colors.backgroundBarColors.length && (e3 %= this.barCtx.barOptions.colors.backgroundBarColors.length);
        var d3 = this.barCtx.barOptions.colors.backgroundBarColors[e3], g3 = h3.drawRect(void 0 !== a3 ? a3 : 0, void 0 !== r2 ? r2 : 0, void 0 !== s3 ? s3 : l3.globals.gridWidth, void 0 !== o3 ? o3 : l3.globals.gridHeight, this.barCtx.barOptions.colors.backgroundBarRadius, d3, this.barCtx.barOptions.colors.backgroundBarOpacity);
        n3.add(g3), g3.node.classList.add("apexcharts-backgroundBar");
      }
    } }, { key: "getColumnPaths", value: function(t4) {
      var e3, i2 = t4.barWidth, a3 = t4.barXPosition, s3 = t4.y1, r2 = t4.y2, o3 = t4.strokeWidth, n3 = t4.seriesGroup, l3 = t4.realIndex, h3 = t4.i, c3 = t4.j, d3 = t4.w, g3 = new m2(this.barCtx.ctx);
      (o3 = Array.isArray(o3) ? o3[l3] : o3) || (o3 = 0);
      var u3 = i2, p3 = a3;
      null !== (e3 = d3.config.series[l3].data[c3]) && void 0 !== e3 && e3.columnWidthOffset && (p3 = a3 - d3.config.series[l3].data[c3].columnWidthOffset / 2, u3 = i2 + d3.config.series[l3].data[c3].columnWidthOffset);
      var f3 = o3 / 2, x3 = p3 + f3, b3 = p3 + u3 - f3;
      s3 += 1e-3 - f3, r2 += 1e-3 + f3;
      var v3 = g3.move(x3, s3), y3 = g3.move(x3, s3), w3 = g3.line(b3, s3);
      if (d3.globals.previousPaths.length > 0 && (y3 = this.barCtx.getPreviousPath(l3, c3, false)), v3 = v3 + g3.line(x3, r2) + g3.line(b3, r2) + g3.line(b3, s3) + ("around" === d3.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z"), y3 = y3 + g3.line(x3, s3) + w3 + w3 + w3 + w3 + w3 + g3.line(x3, s3) + ("around" === d3.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z"), this.shouldApplyRadius(l3) && (v3 = g3.roundPathCorners(v3, d3.config.plotOptions.bar.borderRadius)), d3.config.chart.stacked) {
        var k3 = this.barCtx;
        (k3 = this.barCtx[n3]).yArrj.push(r2 - f3), k3.yArrjF.push(Math.abs(s3 - r2 + o3)), k3.yArrjVal.push(this.barCtx.series[h3][c3]);
      }
      return { pathTo: v3, pathFrom: y3 };
    } }, { key: "getBarpaths", value: function(t4) {
      var e3, i2 = t4.barYPosition, a3 = t4.barHeight, s3 = t4.x1, r2 = t4.x2, o3 = t4.strokeWidth, n3 = t4.seriesGroup, l3 = t4.realIndex, h3 = t4.i, c3 = t4.j, d3 = t4.w, g3 = new m2(this.barCtx.ctx);
      (o3 = Array.isArray(o3) ? o3[l3] : o3) || (o3 = 0);
      var u3 = i2, p3 = a3;
      null !== (e3 = d3.config.series[l3].data[c3]) && void 0 !== e3 && e3.barHeightOffset && (u3 = i2 - d3.config.series[l3].data[c3].barHeightOffset / 2, p3 = a3 + d3.config.series[l3].data[c3].barHeightOffset);
      var f3 = o3 / 2, x3 = u3 + f3, b3 = u3 + p3 - f3;
      s3 += 1e-3 - f3, r2 += 1e-3 + f3;
      var v3 = g3.move(s3, x3), y3 = g3.move(s3, x3);
      d3.globals.previousPaths.length > 0 && (y3 = this.barCtx.getPreviousPath(l3, c3, false));
      var w3 = g3.line(s3, b3);
      if (v3 = v3 + g3.line(r2, x3) + g3.line(r2, b3) + w3 + ("around" === d3.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z"), y3 = y3 + g3.line(s3, x3) + w3 + w3 + w3 + w3 + w3 + g3.line(s3, x3) + ("around" === d3.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z"), this.shouldApplyRadius(l3) && (v3 = g3.roundPathCorners(v3, d3.config.plotOptions.bar.borderRadius)), d3.config.chart.stacked) {
        var k3 = this.barCtx;
        (k3 = this.barCtx[n3]).xArrj.push(r2 + f3), k3.xArrjF.push(Math.abs(s3 - r2)), k3.xArrjVal.push(this.barCtx.series[h3][c3]);
      }
      return { pathTo: v3, pathFrom: y3 };
    } }, { key: "checkZeroSeries", value: function(t4) {
      for (var e3 = t4.series, i2 = this.w, a3 = 0; a3 < e3.length; a3++) {
        for (var s3 = 0, r2 = 0; r2 < e3[i2.globals.maxValsInArrayIndex].length; r2++) s3 += e3[a3][r2];
        0 === s3 && this.barCtx.zeroSerieses.push(a3);
      }
    } }, { key: "getXForValue", value: function(t4, e3) {
      var i2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2] ? e3 : null;
      return null != t4 && (i2 = e3 + t4 / this.barCtx.invertedYRatio - 2 * (this.barCtx.isReversed ? t4 / this.barCtx.invertedYRatio : 0)), i2;
    } }, { key: "getYForValue", value: function(t4, e3, i2) {
      var a3 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3] ? e3 : null;
      return null != t4 && (a3 = e3 - t4 / this.barCtx.yRatio[i2] + 2 * (this.barCtx.isReversed ? t4 / this.barCtx.yRatio[i2] : 0)), a3;
    } }, { key: "getGoalValues", value: function(t4, i2, a3, s3, r2, n3) {
      var l3 = this, h3 = this.w, c3 = [], d3 = function(e3, s4) {
        var r3;
        c3.push((o2(r3 = {}, t4, "x" === t4 ? l3.getXForValue(e3, i2, false) : l3.getYForValue(e3, a3, n3, false)), o2(r3, "attrs", s4), r3));
      };
      if (h3.globals.seriesGoals[s3] && h3.globals.seriesGoals[s3][r2] && Array.isArray(h3.globals.seriesGoals[s3][r2]) && h3.globals.seriesGoals[s3][r2].forEach(function(t5) {
        d3(t5.value, t5);
      }), this.barCtx.barOptions.isDumbbell && h3.globals.seriesRange.length) {
        var g3 = this.barCtx.barOptions.dumbbellColors ? this.barCtx.barOptions.dumbbellColors : h3.globals.colors, u3 = { strokeHeight: "x" === t4 ? 0 : h3.globals.markers.size[s3], strokeWidth: "x" === t4 ? h3.globals.markers.size[s3] : 0, strokeDashArray: 0, strokeLineCap: "round", strokeColor: Array.isArray(g3[s3]) ? g3[s3][0] : g3[s3] };
        d3(h3.globals.seriesRangeStart[s3][r2], u3), d3(h3.globals.seriesRangeEnd[s3][r2], e2(e2({}, u3), {}, { strokeColor: Array.isArray(g3[s3]) ? g3[s3][1] : g3[s3] }));
      }
      return c3;
    } }, { key: "drawGoalLine", value: function(t4) {
      var e3 = t4.barXPosition, i2 = t4.barYPosition, a3 = t4.goalX, s3 = t4.goalY, r2 = t4.barWidth, o3 = t4.barHeight, n3 = new m2(this.barCtx.ctx), l3 = n3.group({ className: "apexcharts-bar-goals-groups" });
      l3.node.classList.add("apexcharts-element-hidden"), this.barCtx.w.globals.delayedElements.push({ el: l3.node }), l3.attr("clip-path", "url(#gridRectMarkerMask".concat(this.barCtx.w.globals.cuid, ")"));
      var h3 = null;
      return this.barCtx.isHorizontal ? Array.isArray(a3) && a3.forEach(function(t5) {
        if (t5.x >= -1 && t5.x <= n3.w.globals.gridWidth + 1) {
          var e4 = void 0 !== t5.attrs.strokeHeight ? t5.attrs.strokeHeight : o3 / 2, a4 = i2 + e4 + o3 / 2;
          h3 = n3.drawLine(t5.x, a4 - 2 * e4, t5.x, a4, t5.attrs.strokeColor ? t5.attrs.strokeColor : void 0, t5.attrs.strokeDashArray, t5.attrs.strokeWidth ? t5.attrs.strokeWidth : 2, t5.attrs.strokeLineCap), l3.add(h3);
        }
      }) : Array.isArray(s3) && s3.forEach(function(t5) {
        if (t5.y >= -1 && t5.y <= n3.w.globals.gridHeight + 1) {
          var i3 = void 0 !== t5.attrs.strokeWidth ? t5.attrs.strokeWidth : r2 / 2, a4 = e3 + i3 + r2 / 2;
          h3 = n3.drawLine(a4 - 2 * i3, t5.y, a4, t5.y, t5.attrs.strokeColor ? t5.attrs.strokeColor : void 0, t5.attrs.strokeDashArray, t5.attrs.strokeHeight ? t5.attrs.strokeHeight : 2, t5.attrs.strokeLineCap), l3.add(h3);
        }
      }), l3;
    } }, { key: "drawBarShadow", value: function(t4) {
      var e3 = t4.prevPaths, i2 = t4.currPaths, a3 = t4.color, s3 = this.w, r2 = e3.x, o3 = e3.x1, n3 = e3.barYPosition, l3 = i2.x, h3 = i2.x1, c3 = i2.barYPosition, d3 = n3 + i2.barHeight, g3 = new m2(this.barCtx.ctx), u3 = new x2(), p3 = g3.move(o3, d3) + g3.line(r2, d3) + g3.line(l3, c3) + g3.line(h3, c3) + g3.line(o3, d3) + ("around" === s3.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z");
      return g3.drawPath({ d: p3, fill: u3.shadeColor(0.5, x2.rgb2hex(a3)), stroke: "none", strokeWidth: 0, fillOpacity: 1, classes: "apexcharts-bar-shadows" });
    } }, { key: "getZeroValueEncounters", value: function(t4) {
      var e3, i2 = t4.i, a3 = t4.j, s3 = this.w, r2 = 0, o3 = 0;
      return (s3.config.plotOptions.bar.horizontal ? s3.globals.series.map(function(t5, e4) {
        return e4;
      }) : (null === (e3 = s3.globals.columnSeries) || void 0 === e3 ? void 0 : e3.i.map(function(t5) {
        return t5;
      })) || []).forEach(function(t5) {
        var e4 = s3.globals.seriesPercent[t5][a3];
        e4 && r2++, t5 < i2 && 0 === e4 && o3++;
      }), { nonZeroColumns: r2, zeroEncounters: o3 };
    } }, { key: "getGroupIndex", value: function(t4) {
      var e3 = this.w, i2 = e3.globals.seriesGroups.findIndex(function(i3) {
        return i3.indexOf(e3.globals.seriesNames[t4]) > -1;
      }), a3 = this.barCtx.columnGroupIndices, s3 = a3.indexOf(i2);
      return s3 < 0 && (a3.push(i2), s3 = a3.length - 1), { groupIndex: i2, columnGroupIndex: s3 };
    } }]), t3;
  }(), yt2 = function() {
    function t3(e3, i2) {
      a2(this, t3), this.ctx = e3, this.w = e3.w;
      var s3 = this.w;
      this.barOptions = s3.config.plotOptions.bar, this.isHorizontal = this.barOptions.horizontal, this.strokeWidth = s3.config.stroke.width, this.isNullValue = false, this.isRangeBar = s3.globals.seriesRange.length && this.isHorizontal, this.isVerticalGroupedRangeBar = !s3.globals.isBarHorizontal && s3.globals.seriesRange.length && s3.config.plotOptions.bar.rangeBarGroupRows, this.isFunnel = this.barOptions.isFunnel, this.xyRatios = i2, null !== this.xyRatios && (this.xRatio = i2.xRatio, this.yRatio = i2.yRatio, this.invertedXRatio = i2.invertedXRatio, this.invertedYRatio = i2.invertedYRatio, this.baseLineY = i2.baseLineY, this.baseLineInvertedY = i2.baseLineInvertedY), this.yaxisIndex = 0, this.translationsIndex = 0, this.seriesLen = 0, this.pathArr = [];
      var r2 = new W2(this.ctx);
      this.lastActiveBarSerieIndex = r2.getActiveConfigSeriesIndex("desc", ["bar", "column"]), this.columnGroupIndices = [];
      var o3 = r2.getBarSeriesIndices(), n3 = new y2(this.ctx);
      this.stackedSeriesTotals = n3.getStackedSeriesTotals(this.w.config.series.map(function(t4, e4) {
        return -1 === o3.indexOf(e4) ? e4 : -1;
      }).filter(function(t4) {
        return -1 !== t4;
      })), this.barHelpers = new mt2(this);
    }
    return r(t3, [{ key: "draw", value: function(t4, i2) {
      var a3 = this.w, s3 = new m2(this.ctx), r2 = new y2(this.ctx, a3);
      t4 = r2.getLogSeries(t4), this.series = t4, this.yRatio = r2.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t4);
      var o3 = s3.group({ class: "apexcharts-bar-series apexcharts-plot-series" });
      a3.config.dataLabels.enabled && this.totalItems > this.barOptions.dataLabels.maxItems && console.warn("WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering - ApexCharts");
      for (var n3 = 0, l3 = 0; n3 < t4.length; n3++, l3++) {
        var h3, c3, d3, g3, u3 = void 0, p3 = void 0, f3 = [], b3 = [], v3 = a3.globals.comboCharts ? i2[n3] : n3, w3 = this.barHelpers.getGroupIndex(v3).columnGroupIndex, k3 = s3.group({ class: "apexcharts-series", rel: n3 + 1, seriesName: x2.escapeString(a3.globals.seriesNames[v3]), "data:realIndex": v3 });
        this.ctx.series.addCollapsedClassToSeries(k3, v3), t4[n3].length > 0 && (this.visibleI = this.visibleI + 1);
        var A3 = 0, S3 = 0;
        this.yRatio.length > 1 && (this.yaxisIndex = a3.globals.seriesYAxisReverseMap[v3], this.translationsIndex = v3);
        var C3 = this.translationsIndex;
        this.isReversed = a3.config.yaxis[this.yaxisIndex] && a3.config.yaxis[this.yaxisIndex].reversed;
        var L3 = this.barHelpers.initialPositions();
        p3 = L3.y, A3 = L3.barHeight, c3 = L3.yDivision, g3 = L3.zeroW, u3 = L3.x, S3 = L3.barWidth, h3 = L3.xDivision, d3 = L3.zeroH, this.horizontal || b3.push(u3 + S3 / 2);
        var P3 = s3.group({ class: "apexcharts-datalabels", "data:realIndex": v3 });
        a3.globals.delayedElements.push({ el: P3.node }), P3.node.classList.add("apexcharts-element-hidden");
        var M3 = s3.group({ class: "apexcharts-bar-goals-markers" }), I3 = s3.group({ class: "apexcharts-bar-shadows" });
        a3.globals.delayedElements.push({ el: I3.node }), I3.node.classList.add("apexcharts-element-hidden");
        for (var T3 = 0; T3 < t4[n3].length; T3++) {
          var z3 = this.barHelpers.getStrokeWidth(n3, T3, v3), X3 = null, E3 = { indexes: { i: n3, j: T3, realIndex: v3, translationsIndex: C3, bc: l3 }, x: u3, y: p3, strokeWidth: z3, elSeries: k3 };
          this.isHorizontal ? (X3 = this.drawBarPaths(e2(e2({}, E3), {}, { barHeight: A3, zeroW: g3, yDivision: c3 })), S3 = this.series[n3][T3] / this.invertedYRatio) : (X3 = this.drawColumnPaths(e2(e2({}, E3), {}, { xDivision: h3, barWidth: S3, zeroH: d3 })), A3 = this.series[n3][T3] / this.yRatio[C3]);
          var Y3 = this.barHelpers.getPathFillColor(t4, n3, T3, v3);
          if (this.isFunnel && this.barOptions.isFunnel3d && this.pathArr.length && T3 > 0) {
            var F3 = this.barHelpers.drawBarShadow({ color: "string" == typeof Y3 && -1 === (null == Y3 ? void 0 : Y3.indexOf("url")) ? Y3 : x2.hexToRgba(a3.globals.colors[n3]), prevPaths: this.pathArr[this.pathArr.length - 1], currPaths: X3 });
            F3 && I3.add(F3);
          }
          this.pathArr.push(X3);
          var R3 = this.barHelpers.drawGoalLine({ barXPosition: X3.barXPosition, barYPosition: X3.barYPosition, goalX: X3.goalX, goalY: X3.goalY, barHeight: A3, barWidth: S3 });
          R3 && M3.add(R3), p3 = X3.y, u3 = X3.x, T3 > 0 && b3.push(u3 + S3 / 2), f3.push(p3), this.renderSeries({ realIndex: v3, pathFill: Y3, j: T3, i: n3, columnGroupIndex: w3, pathFrom: X3.pathFrom, pathTo: X3.pathTo, strokeWidth: z3, elSeries: k3, x: u3, y: p3, series: t4, barHeight: X3.barHeight ? X3.barHeight : A3, barWidth: X3.barWidth ? X3.barWidth : S3, elDataLabelsWrap: P3, elGoalsMarkers: M3, elBarShadows: I3, visibleSeries: this.visibleI, type: "bar" });
        }
        a3.globals.seriesXvalues[v3] = b3, a3.globals.seriesYvalues[v3] = f3, o3.add(k3);
      }
      return o3;
    } }, { key: "renderSeries", value: function(t4) {
      var e3 = t4.realIndex, i2 = t4.pathFill, a3 = t4.lineFill, s3 = t4.j, r2 = t4.i, o3 = t4.columnGroupIndex, n3 = t4.pathFrom, l3 = t4.pathTo, h3 = t4.strokeWidth, c3 = t4.elSeries, d3 = t4.x, g3 = t4.y, u3 = t4.y1, p3 = t4.y2, f3 = t4.series, x3 = t4.barHeight, b3 = t4.barWidth, y3 = t4.barXPosition, w3 = t4.barYPosition, k3 = t4.elDataLabelsWrap, A3 = t4.elGoalsMarkers, S3 = t4.elBarShadows, C3 = t4.visibleSeries, L3 = t4.type, P3 = this.w, M3 = new m2(this.ctx);
      if (!a3) {
        var I3 = "function" == typeof P3.globals.stroke.colors[e3] ? function(t5) {
          var e4, i3 = P3.config.stroke.colors;
          return Array.isArray(i3) && i3.length > 0 && ((e4 = i3[t5]) || (e4 = ""), "function" == typeof e4) ? e4({ value: P3.globals.series[t5][s3], dataPointIndex: s3, w: P3 }) : e4;
        }(e3) : P3.globals.stroke.colors[e3];
        a3 = this.barOptions.distributed ? P3.globals.stroke.colors[s3] : I3;
      }
      P3.config.series[r2].data[s3] && P3.config.series[r2].data[s3].strokeColor && (a3 = P3.config.series[r2].data[s3].strokeColor), this.isNullValue && (i2 = "none");
      var T3 = s3 / P3.config.chart.animations.animateGradually.delay * (P3.config.chart.animations.speed / P3.globals.dataPoints) / 2.4, z3 = M3.renderPaths({ i: r2, j: s3, realIndex: e3, pathFrom: n3, pathTo: l3, stroke: a3, strokeWidth: h3, strokeLineCap: P3.config.stroke.lineCap, fill: i2, animationDelay: T3, initialSpeed: P3.config.chart.animations.speed, dataChangeSpeed: P3.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-".concat(L3, "-area") });
      z3.attr("clip-path", "url(#gridRectMask".concat(P3.globals.cuid, ")"));
      var X3 = P3.config.forecastDataPoints;
      X3.count > 0 && s3 >= P3.globals.dataPoints - X3.count && (z3.node.setAttribute("stroke-dasharray", X3.dashArray), z3.node.setAttribute("stroke-width", X3.strokeWidth), z3.node.setAttribute("fill-opacity", X3.fillOpacity)), void 0 !== u3 && void 0 !== p3 && (z3.attr("data-range-y1", u3), z3.attr("data-range-y2", p3)), new v2(this.ctx).setSelectionFilter(z3, e3, s3), c3.add(z3);
      var E3 = new vt2(this).handleBarDataLabels({ x: d3, y: g3, y1: u3, y2: p3, i: r2, j: s3, series: f3, realIndex: e3, columnGroupIndex: o3, barHeight: x3, barWidth: b3, barXPosition: y3, barYPosition: w3, renderedPath: z3, visibleSeries: C3 });
      return null !== E3.dataLabels && k3.add(E3.dataLabels), E3.totalDataLabels && k3.add(E3.totalDataLabels), c3.add(k3), A3 && c3.add(A3), S3 && c3.add(S3), c3;
    } }, { key: "drawBarPaths", value: function(t4) {
      var e3, i2 = t4.indexes, a3 = t4.barHeight, s3 = t4.strokeWidth, r2 = t4.zeroW, o3 = t4.x, n3 = t4.y, l3 = t4.yDivision, h3 = t4.elSeries, c3 = this.w, d3 = i2.i, g3 = i2.j;
      if (c3.globals.isXNumeric) e3 = (n3 = (c3.globals.seriesX[d3][g3] - c3.globals.minX) / this.invertedXRatio - a3) + a3 * this.visibleI;
      else if (c3.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
        var u3 = 0, p3 = 0;
        c3.globals.seriesPercent.forEach(function(t5, e4) {
          t5[g3] && u3++, e4 < d3 && 0 === t5[g3] && p3++;
        }), u3 > 0 && (a3 = this.seriesLen * a3 / u3), e3 = n3 + a3 * this.visibleI, e3 -= a3 * p3;
      } else e3 = n3 + a3 * this.visibleI;
      this.isFunnel && (r2 -= (this.barHelpers.getXForValue(this.series[d3][g3], r2) - r2) / 2), o3 = this.barHelpers.getXForValue(this.series[d3][g3], r2);
      var f3 = this.barHelpers.getBarpaths({ barYPosition: e3, barHeight: a3, x1: r2, x2: o3, strokeWidth: s3, series: this.series, realIndex: i2.realIndex, i: d3, j: g3, w: c3 });
      return c3.globals.isXNumeric || (n3 += l3), this.barHelpers.barBackground({ j: g3, i: d3, y1: e3 - a3 * this.visibleI, y2: a3 * this.seriesLen, elSeries: h3 }), { pathTo: f3.pathTo, pathFrom: f3.pathFrom, x1: r2, x: o3, y: n3, goalX: this.barHelpers.getGoalValues("x", r2, null, d3, g3), barYPosition: e3, barHeight: a3 };
    } }, { key: "drawColumnPaths", value: function(t4) {
      var e3, i2 = t4.indexes, a3 = t4.x, s3 = t4.y, r2 = t4.xDivision, o3 = t4.barWidth, n3 = t4.zeroH, l3 = t4.strokeWidth, h3 = t4.elSeries, c3 = this.w, d3 = i2.realIndex, g3 = i2.translationsIndex, u3 = i2.i, p3 = i2.j, f3 = i2.bc;
      if (c3.globals.isXNumeric) {
        var x3 = this.getBarXForNumericXAxis({ x: a3, j: p3, realIndex: d3, barWidth: o3 });
        a3 = x3.x, e3 = x3.barXPosition;
      } else if (c3.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
        var b3 = this.barHelpers.getZeroValueEncounters({ i: u3, j: p3 }), v3 = b3.nonZeroColumns, m3 = b3.zeroEncounters;
        v3 > 0 && (o3 = this.seriesLen * o3 / v3), e3 = a3 + o3 * this.visibleI, e3 -= o3 * m3;
      } else e3 = a3 + o3 * this.visibleI;
      s3 = this.barHelpers.getYForValue(this.series[u3][p3], n3, g3);
      var y3 = this.barHelpers.getColumnPaths({ barXPosition: e3, barWidth: o3, y1: n3, y2: s3, strokeWidth: l3, series: this.series, realIndex: d3, i: u3, j: p3, w: c3 });
      return c3.globals.isXNumeric || (a3 += r2), this.barHelpers.barBackground({ bc: f3, j: p3, i: u3, x1: e3 - l3 / 2 - o3 * this.visibleI, x2: o3 * this.seriesLen + l3 / 2, elSeries: h3 }), { pathTo: y3.pathTo, pathFrom: y3.pathFrom, x: a3, y: s3, goalY: this.barHelpers.getGoalValues("y", null, n3, u3, p3, g3), barXPosition: e3, barWidth: o3 };
    } }, { key: "getBarXForNumericXAxis", value: function(t4) {
      var e3 = t4.x, i2 = t4.barWidth, a3 = t4.realIndex, s3 = t4.j, r2 = this.w, o3 = a3;
      return r2.globals.seriesX[a3].length || (o3 = r2.globals.maxValsInArrayIndex), r2.globals.seriesX[o3][s3] && (e3 = (r2.globals.seriesX[o3][s3] - r2.globals.minX) / this.xRatio - i2 * this.seriesLen / 2), { barXPosition: e3 + i2 * this.visibleI, x: e3 };
    } }, { key: "getPreviousPath", value: function(t4, e3) {
      for (var i2, a3 = this.w, s3 = 0; s3 < a3.globals.previousPaths.length; s3++) {
        var r2 = a3.globals.previousPaths[s3];
        r2.paths && r2.paths.length > 0 && parseInt(r2.realIndex, 10) === parseInt(t4, 10) && void 0 !== a3.globals.previousPaths[s3].paths[e3] && (i2 = a3.globals.previousPaths[s3].paths[e3].d);
      }
      return i2;
    } }]), t3;
  }(), wt2 = function(t3) {
    n2(s3, yt2);
    var i2 = d2(s3);
    function s3() {
      return a2(this, s3), i2.apply(this, arguments);
    }
    return r(s3, [{ key: "draw", value: function(t4, i3) {
      var a3 = this, s4 = this.w;
      this.graphics = new m2(this.ctx), this.bar = new yt2(this.ctx, this.xyRatios);
      var r2 = new y2(this.ctx, s4);
      t4 = r2.getLogSeries(t4), this.yRatio = r2.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t4), "100%" === s4.config.chart.stackType && (t4 = s4.globals.comboCharts ? i3.map(function(t5) {
        return s4.globals.seriesPercent[t5];
      }) : s4.globals.seriesPercent.slice()), this.series = t4, this.barHelpers.initializeStackedPrevVars(this);
      for (var o3 = this.graphics.group({ class: "apexcharts-bar-series apexcharts-plot-series" }), n3 = 0, l3 = 0, h3 = function(r3, h4) {
        var c4 = void 0, d4 = void 0, g3 = void 0, u3 = void 0, p3 = s4.globals.comboCharts ? i3[r3] : r3, f3 = a3.barHelpers.getGroupIndex(p3), b3 = f3.groupIndex, v3 = f3.columnGroupIndex;
        a3.groupCtx = a3[s4.globals.seriesGroups[b3]];
        var m3 = [], y3 = [], w3 = 0;
        a3.yRatio.length > 1 && (a3.yaxisIndex = s4.globals.seriesYAxisReverseMap[p3][0], w3 = p3), a3.isReversed = s4.config.yaxis[a3.yaxisIndex] && s4.config.yaxis[a3.yaxisIndex].reversed;
        var k3 = a3.graphics.group({ class: "apexcharts-series", seriesName: x2.escapeString(s4.globals.seriesNames[p3]), rel: r3 + 1, "data:realIndex": p3 });
        a3.ctx.series.addCollapsedClassToSeries(k3, p3);
        var A3 = a3.graphics.group({ class: "apexcharts-datalabels", "data:realIndex": p3 }), S3 = a3.graphics.group({ class: "apexcharts-bar-goals-markers" }), C3 = 0, L3 = 0, P3 = a3.initialPositions(n3, l3, c4, d4, g3, u3, w3);
        l3 = P3.y, C3 = P3.barHeight, d4 = P3.yDivision, u3 = P3.zeroW, n3 = P3.x, L3 = P3.barWidth, c4 = P3.xDivision, g3 = P3.zeroH, s4.globals.barHeight = C3, s4.globals.barWidth = L3, a3.barHelpers.initializeStackedXYVars(a3), 1 === a3.groupCtx.prevY.length && a3.groupCtx.prevY[0].every(function(t5) {
          return isNaN(t5);
        }) && (a3.groupCtx.prevY[0] = a3.groupCtx.prevY[0].map(function() {
          return g3;
        }), a3.groupCtx.prevYF[0] = a3.groupCtx.prevYF[0].map(function() {
          return 0;
        }));
        for (var M3 = 0; M3 < s4.globals.dataPoints; M3++) {
          var I3 = a3.barHelpers.getStrokeWidth(r3, M3, p3), T3 = { indexes: { i: r3, j: M3, realIndex: p3, translationsIndex: w3, bc: h4 }, strokeWidth: I3, x: n3, y: l3, elSeries: k3, columnGroupIndex: v3, seriesGroup: s4.globals.seriesGroups[b3] }, z3 = null;
          a3.isHorizontal ? (z3 = a3.drawStackedBarPaths(e2(e2({}, T3), {}, { zeroW: u3, barHeight: C3, yDivision: d4 })), L3 = a3.series[r3][M3] / a3.invertedYRatio) : (z3 = a3.drawStackedColumnPaths(e2(e2({}, T3), {}, { xDivision: c4, barWidth: L3, zeroH: g3 })), C3 = a3.series[r3][M3] / a3.yRatio[w3]);
          var X3 = a3.barHelpers.drawGoalLine({ barXPosition: z3.barXPosition, barYPosition: z3.barYPosition, goalX: z3.goalX, goalY: z3.goalY, barHeight: C3, barWidth: L3 });
          X3 && S3.add(X3), l3 = z3.y, n3 = z3.x, m3.push(n3), y3.push(l3);
          var E3 = a3.barHelpers.getPathFillColor(t4, r3, M3, p3);
          k3 = a3.renderSeries({ realIndex: p3, pathFill: E3, j: M3, i: r3, columnGroupIndex: v3, pathFrom: z3.pathFrom, pathTo: z3.pathTo, strokeWidth: I3, elSeries: k3, x: n3, y: l3, series: t4, barHeight: C3, barWidth: L3, elDataLabelsWrap: A3, elGoalsMarkers: S3, type: "bar", visibleSeries: 0 });
        }
        s4.globals.seriesXvalues[p3] = m3, s4.globals.seriesYvalues[p3] = y3, a3.groupCtx.prevY.push(a3.groupCtx.yArrj), a3.groupCtx.prevYF.push(a3.groupCtx.yArrjF), a3.groupCtx.prevYVal.push(a3.groupCtx.yArrjVal), a3.groupCtx.prevX.push(a3.groupCtx.xArrj), a3.groupCtx.prevXF.push(a3.groupCtx.xArrjF), a3.groupCtx.prevXVal.push(a3.groupCtx.xArrjVal), o3.add(k3);
      }, c3 = 0, d3 = 0; c3 < t4.length; c3++, d3++) h3(c3, d3);
      return o3;
    } }, { key: "initialPositions", value: function(t4, e3, i3, a3, s4, r2, o3) {
      var n3, l3, h3 = this.w;
      if (this.isHorizontal) {
        a3 = h3.globals.gridHeight / h3.globals.dataPoints;
        var c3 = h3.config.plotOptions.bar.barHeight;
        n3 = -1 === String(c3).indexOf("%") ? parseInt(c3, 10) : a3 * parseInt(c3, 10) / 100, r2 = h3.globals.padHorizontal + (this.isReversed ? h3.globals.gridWidth - this.baseLineInvertedY : this.baseLineInvertedY), e3 = (a3 - n3) / 2;
      } else {
        l3 = i3 = h3.globals.gridWidth / h3.globals.dataPoints;
        var d3 = h3.config.plotOptions.bar.columnWidth;
        h3.globals.isXNumeric && h3.globals.dataPoints > 1 ? l3 = (i3 = h3.globals.minXDiff / this.xRatio) * parseInt(this.barOptions.columnWidth, 10) / 100 : -1 === String(d3).indexOf("%") ? l3 = parseInt(d3, 10) : l3 *= parseInt(d3, 10) / 100, s4 = h3.globals.gridHeight - this.baseLineY[o3] - (this.isReversed ? h3.globals.gridHeight : 0), t4 = h3.globals.padHorizontal + (i3 - l3) / 2;
      }
      var g3 = h3.globals.barGroups.length || 1;
      return { x: t4, y: e3, yDivision: a3, xDivision: i3, barHeight: n3 / g3, barWidth: l3 / g3, zeroH: s4, zeroW: r2 };
    } }, { key: "drawStackedBarPaths", value: function(t4) {
      for (var e3, i3 = t4.indexes, a3 = t4.barHeight, s4 = t4.strokeWidth, r2 = t4.zeroW, o3 = t4.x, n3 = t4.y, l3 = t4.columnGroupIndex, h3 = t4.seriesGroup, c3 = t4.yDivision, d3 = t4.elSeries, g3 = this.w, u3 = n3 + l3 * a3, p3 = i3.i, f3 = i3.j, x3 = i3.realIndex, b3 = i3.translationsIndex, v3 = 0, m3 = 0; m3 < this.groupCtx.prevXF.length; m3++) v3 += this.groupCtx.prevXF[m3][f3];
      var y3;
      if ((y3 = h3.indexOf(g3.config.series[x3].name)) > 0) {
        var w3 = r2;
        this.groupCtx.prevXVal[y3 - 1][f3] < 0 ? w3 = this.series[p3][f3] >= 0 ? this.groupCtx.prevX[y3 - 1][f3] + v3 - 2 * (this.isReversed ? v3 : 0) : this.groupCtx.prevX[y3 - 1][f3] : this.groupCtx.prevXVal[y3 - 1][f3] >= 0 && (w3 = this.series[p3][f3] >= 0 ? this.groupCtx.prevX[y3 - 1][f3] : this.groupCtx.prevX[y3 - 1][f3] - v3 + 2 * (this.isReversed ? v3 : 0)), e3 = w3;
      } else e3 = r2;
      o3 = null === this.series[p3][f3] ? e3 : e3 + this.series[p3][f3] / this.invertedYRatio - 2 * (this.isReversed ? this.series[p3][f3] / this.invertedYRatio : 0);
      var k3 = this.barHelpers.getBarpaths({ barYPosition: u3, barHeight: a3, x1: e3, x2: o3, strokeWidth: s4, series: this.series, realIndex: i3.realIndex, seriesGroup: h3, i: p3, j: f3, w: g3 });
      return this.barHelpers.barBackground({ j: f3, i: p3, y1: u3, y2: a3, elSeries: d3 }), n3 += c3, { pathTo: k3.pathTo, pathFrom: k3.pathFrom, goalX: this.barHelpers.getGoalValues("x", r2, null, p3, f3, b3), barXPosition: e3, barYPosition: u3, x: o3, y: n3 };
    } }, { key: "drawStackedColumnPaths", value: function(t4) {
      var e3 = t4.indexes, i3 = t4.x, a3 = t4.y, s4 = t4.xDivision, r2 = t4.barWidth, o3 = t4.zeroH, n3 = t4.columnGroupIndex, l3 = t4.seriesGroup, h3 = t4.elSeries, c3 = this.w, d3 = e3.i, g3 = e3.j, u3 = e3.bc, p3 = e3.realIndex, f3 = e3.translationsIndex;
      if (c3.globals.isXNumeric) {
        var x3 = c3.globals.seriesX[p3][g3];
        x3 || (x3 = 0), i3 = (x3 - c3.globals.minX) / this.xRatio - r2 / 2 * c3.globals.barGroups.length;
      }
      for (var b3, v3 = i3 + n3 * r2, m3 = 0, y3 = 0; y3 < this.groupCtx.prevYF.length; y3++) m3 += isNaN(this.groupCtx.prevYF[y3][g3]) ? 0 : this.groupCtx.prevYF[y3][g3];
      var w3 = d3;
      if (l3 && (w3 = l3.indexOf(c3.globals.seriesNames[p3])), w3 > 0 && !c3.globals.isXNumeric || w3 > 0 && c3.globals.isXNumeric && c3.globals.seriesX[p3 - 1][g3] === c3.globals.seriesX[p3][g3]) {
        var k3, A3, S3, C3 = Math.min(this.yRatio.length + 1, p3 + 1);
        if (void 0 !== this.groupCtx.prevY[w3 - 1] && this.groupCtx.prevY[w3 - 1].length) for (var L3 = 1; L3 < C3; L3++) {
          var P3;
          if (!isNaN(null === (P3 = this.groupCtx.prevY[w3 - L3]) || void 0 === P3 ? void 0 : P3[g3])) {
            S3 = this.groupCtx.prevY[w3 - L3][g3];
            break;
          }
        }
        for (var M3 = 1; M3 < C3; M3++) {
          var I3, T3;
          if ((null === (I3 = this.groupCtx.prevYVal[w3 - M3]) || void 0 === I3 ? void 0 : I3[g3]) < 0) {
            A3 = this.series[d3][g3] >= 0 ? S3 - m3 + 2 * (this.isReversed ? m3 : 0) : S3;
            break;
          }
          if ((null === (T3 = this.groupCtx.prevYVal[w3 - M3]) || void 0 === T3 ? void 0 : T3[g3]) >= 0) {
            A3 = this.series[d3][g3] >= 0 ? S3 : S3 + m3 - 2 * (this.isReversed ? m3 : 0);
            break;
          }
        }
        void 0 === A3 && (A3 = c3.globals.gridHeight), b3 = null !== (k3 = this.groupCtx.prevYF[0]) && void 0 !== k3 && k3.every(function(t5) {
          return 0 === t5;
        }) && this.groupCtx.prevYF.slice(1, w3).every(function(t5) {
          return t5.every(function(t6) {
            return isNaN(t6);
          });
        }) ? o3 : A3;
      } else b3 = o3;
      a3 = this.series[d3][g3] ? b3 - this.series[d3][g3] / this.yRatio[f3] + 2 * (this.isReversed ? this.series[d3][g3] / this.yRatio[f3] : 0) : b3;
      var z3 = this.barHelpers.getColumnPaths({ barXPosition: v3, barWidth: r2, y1: b3, y2: a3, yRatio: this.yRatio[f3], strokeWidth: this.strokeWidth, series: this.series, seriesGroup: l3, realIndex: e3.realIndex, i: d3, j: g3, w: c3 });
      return this.barHelpers.barBackground({ bc: u3, j: g3, i: d3, x1: v3, x2: r2, elSeries: h3 }), { pathTo: z3.pathTo, pathFrom: z3.pathFrom, goalY: this.barHelpers.getGoalValues("y", null, o3, d3, g3), barXPosition: v3, x: c3.globals.isXNumeric ? i3 : i3 + s4, y: a3 };
    } }]), s3;
  }(), kt2 = function(t3) {
    n2(s3, yt2);
    var i2 = d2(s3);
    function s3() {
      return a2(this, s3), i2.apply(this, arguments);
    }
    return r(s3, [{ key: "draw", value: function(t4, i3, a3) {
      var s4 = this, r2 = this.w, o3 = new m2(this.ctx), n3 = r2.globals.comboCharts ? i3 : r2.config.chart.type, l3 = new H4(this.ctx);
      this.candlestickOptions = this.w.config.plotOptions.candlestick, this.boxOptions = this.w.config.plotOptions.boxPlot, this.isHorizontal = r2.config.plotOptions.bar.horizontal;
      var h3 = new y2(this.ctx, r2);
      t4 = h3.getLogSeries(t4), this.series = t4, this.yRatio = h3.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t4);
      for (var c3 = o3.group({ class: "apexcharts-".concat(n3, "-series apexcharts-plot-series") }), d3 = function(i4) {
        s4.isBoxPlot = "boxPlot" === r2.config.chart.type || "boxPlot" === r2.config.series[i4].type;
        var n4, h4, d4, g4, u3 = void 0, p3 = void 0, f3 = [], b3 = [], v3 = r2.globals.comboCharts ? a3[i4] : i4, m3 = s4.barHelpers.getGroupIndex(v3).columnGroupIndex, y3 = o3.group({ class: "apexcharts-series", seriesName: x2.escapeString(r2.globals.seriesNames[v3]), rel: i4 + 1, "data:realIndex": v3 });
        s4.ctx.series.addCollapsedClassToSeries(y3, v3), t4[i4].length > 0 && (s4.visibleI = s4.visibleI + 1);
        var w3, k3, A3 = 0;
        s4.yRatio.length > 1 && (s4.yaxisIndex = r2.globals.seriesYAxisReverseMap[v3][0], A3 = v3);
        var S3 = s4.barHelpers.initialPositions();
        p3 = S3.y, w3 = S3.barHeight, h4 = S3.yDivision, g4 = S3.zeroW, u3 = S3.x, k3 = S3.barWidth, n4 = S3.xDivision, d4 = S3.zeroH, b3.push(u3 + k3 / 2);
        for (var C3 = o3.group({ class: "apexcharts-datalabels", "data:realIndex": v3 }), L3 = function(a4) {
          var o4 = s4.barHelpers.getStrokeWidth(i4, a4, v3), c4 = null, x3 = { indexes: { i: i4, j: a4, realIndex: v3, translationsIndex: A3 }, x: u3, y: p3, strokeWidth: o4, elSeries: y3 };
          c4 = s4.isHorizontal ? s4.drawHorizontalBoxPaths(e2(e2({}, x3), {}, { yDivision: h4, barHeight: w3, zeroW: g4 })) : s4.drawVerticalBoxPaths(e2(e2({}, x3), {}, { xDivision: n4, barWidth: k3, zeroH: d4 })), p3 = c4.y, u3 = c4.x, a4 > 0 && b3.push(u3 + k3 / 2), f3.push(p3), c4.pathTo.forEach(function(e3, n5) {
            var h5 = !s4.isBoxPlot && s4.candlestickOptions.wick.useFillColor ? c4.color[n5] : r2.globals.stroke.colors[i4], d5 = l3.fillPath({ seriesNumber: v3, dataPointIndex: a4, color: c4.color[n5], value: t4[i4][a4] });
            s4.renderSeries({ realIndex: v3, pathFill: d5, lineFill: h5, j: a4, i: i4, pathFrom: c4.pathFrom, pathTo: e3, strokeWidth: o4, elSeries: y3, x: u3, y: p3, series: t4, columnGroupIndex: m3, barHeight: w3, barWidth: k3, elDataLabelsWrap: C3, visibleSeries: s4.visibleI, type: r2.config.chart.type });
          });
        }, P3 = 0; P3 < r2.globals.dataPoints; P3++) L3(P3);
        r2.globals.seriesXvalues[v3] = b3, r2.globals.seriesYvalues[v3] = f3, c3.add(y3);
      }, g3 = 0; g3 < t4.length; g3++) d3(g3);
      return c3;
    } }, { key: "drawVerticalBoxPaths", value: function(t4) {
      var e3 = t4.indexes, i3 = t4.x;
      t4.y;
      var a3 = t4.xDivision, s4 = t4.barWidth, r2 = t4.zeroH, o3 = t4.strokeWidth, n3 = this.w, l3 = new m2(this.ctx), h3 = e3.i, c3 = e3.j, d3 = true, g3 = n3.config.plotOptions.candlestick.colors.upward, u3 = n3.config.plotOptions.candlestick.colors.downward, p3 = "";
      this.isBoxPlot && (p3 = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
      var f3 = this.yRatio[e3.translationsIndex], x3 = e3.realIndex, b3 = this.getOHLCValue(x3, c3), v3 = r2, y3 = r2;
      b3.o > b3.c && (d3 = false);
      var w3 = Math.min(b3.o, b3.c), k3 = Math.max(b3.o, b3.c), A3 = b3.m;
      n3.globals.isXNumeric && (i3 = (n3.globals.seriesX[x3][c3] - n3.globals.minX) / this.xRatio - s4 / 2);
      var S3 = i3 + s4 * this.visibleI;
      void 0 === this.series[h3][c3] || null === this.series[h3][c3] ? (w3 = r2, k3 = r2) : (w3 = r2 - w3 / f3, k3 = r2 - k3 / f3, v3 = r2 - b3.h / f3, y3 = r2 - b3.l / f3, A3 = r2 - b3.m / f3);
      var C3 = l3.move(S3, r2), L3 = l3.move(S3 + s4 / 2, w3);
      return n3.globals.previousPaths.length > 0 && (L3 = this.getPreviousPath(x3, c3, true)), C3 = this.isBoxPlot ? [l3.move(S3, w3) + l3.line(S3 + s4 / 2, w3) + l3.line(S3 + s4 / 2, v3) + l3.line(S3 + s4 / 4, v3) + l3.line(S3 + s4 - s4 / 4, v3) + l3.line(S3 + s4 / 2, v3) + l3.line(S3 + s4 / 2, w3) + l3.line(S3 + s4, w3) + l3.line(S3 + s4, A3) + l3.line(S3, A3) + l3.line(S3, w3 + o3 / 2), l3.move(S3, A3) + l3.line(S3 + s4, A3) + l3.line(S3 + s4, k3) + l3.line(S3 + s4 / 2, k3) + l3.line(S3 + s4 / 2, y3) + l3.line(S3 + s4 - s4 / 4, y3) + l3.line(S3 + s4 / 4, y3) + l3.line(S3 + s4 / 2, y3) + l3.line(S3 + s4 / 2, k3) + l3.line(S3, k3) + l3.line(S3, A3) + "z"] : [l3.move(S3, k3) + l3.line(S3 + s4 / 2, k3) + l3.line(S3 + s4 / 2, v3) + l3.line(S3 + s4 / 2, k3) + l3.line(S3 + s4, k3) + l3.line(S3 + s4, w3) + l3.line(S3 + s4 / 2, w3) + l3.line(S3 + s4 / 2, y3) + l3.line(S3 + s4 / 2, w3) + l3.line(S3, w3) + l3.line(S3, k3 - o3 / 2)], L3 += l3.move(S3, w3), n3.globals.isXNumeric || (i3 += a3), { pathTo: C3, pathFrom: L3, x: i3, y: k3, barXPosition: S3, color: this.isBoxPlot ? p3 : d3 ? [g3] : [u3] };
    } }, { key: "drawHorizontalBoxPaths", value: function(t4) {
      var e3 = t4.indexes;
      t4.x;
      var i3 = t4.y, a3 = t4.yDivision, s4 = t4.barHeight, r2 = t4.zeroW, o3 = t4.strokeWidth, n3 = this.w, l3 = new m2(this.ctx), h3 = e3.i, c3 = e3.j, d3 = this.boxOptions.colors.lower;
      this.isBoxPlot && (d3 = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
      var g3 = this.invertedYRatio, u3 = e3.realIndex, p3 = this.getOHLCValue(u3, c3), f3 = r2, x3 = r2, b3 = Math.min(p3.o, p3.c), v3 = Math.max(p3.o, p3.c), y3 = p3.m;
      n3.globals.isXNumeric && (i3 = (n3.globals.seriesX[u3][c3] - n3.globals.minX) / this.invertedXRatio - s4 / 2);
      var w3 = i3 + s4 * this.visibleI;
      void 0 === this.series[h3][c3] || null === this.series[h3][c3] ? (b3 = r2, v3 = r2) : (b3 = r2 + b3 / g3, v3 = r2 + v3 / g3, f3 = r2 + p3.h / g3, x3 = r2 + p3.l / g3, y3 = r2 + p3.m / g3);
      var k3 = l3.move(r2, w3), A3 = l3.move(b3, w3 + s4 / 2);
      return n3.globals.previousPaths.length > 0 && (A3 = this.getPreviousPath(u3, c3, true)), k3 = [l3.move(b3, w3) + l3.line(b3, w3 + s4 / 2) + l3.line(f3, w3 + s4 / 2) + l3.line(f3, w3 + s4 / 2 - s4 / 4) + l3.line(f3, w3 + s4 / 2 + s4 / 4) + l3.line(f3, w3 + s4 / 2) + l3.line(b3, w3 + s4 / 2) + l3.line(b3, w3 + s4) + l3.line(y3, w3 + s4) + l3.line(y3, w3) + l3.line(b3 + o3 / 2, w3), l3.move(y3, w3) + l3.line(y3, w3 + s4) + l3.line(v3, w3 + s4) + l3.line(v3, w3 + s4 / 2) + l3.line(x3, w3 + s4 / 2) + l3.line(x3, w3 + s4 - s4 / 4) + l3.line(x3, w3 + s4 / 4) + l3.line(x3, w3 + s4 / 2) + l3.line(v3, w3 + s4 / 2) + l3.line(v3, w3) + l3.line(y3, w3) + "z"], A3 += l3.move(b3, w3), n3.globals.isXNumeric || (i3 += a3), { pathTo: k3, pathFrom: A3, x: v3, y: i3, barYPosition: w3, color: d3 };
    } }, { key: "getOHLCValue", value: function(t4, e3) {
      var i3 = this.w;
      return { o: this.isBoxPlot ? i3.globals.seriesCandleH[t4][e3] : i3.globals.seriesCandleO[t4][e3], h: this.isBoxPlot ? i3.globals.seriesCandleO[t4][e3] : i3.globals.seriesCandleH[t4][e3], m: i3.globals.seriesCandleM[t4][e3], l: this.isBoxPlot ? i3.globals.seriesCandleC[t4][e3] : i3.globals.seriesCandleL[t4][e3], c: this.isBoxPlot ? i3.globals.seriesCandleL[t4][e3] : i3.globals.seriesCandleC[t4][e3] };
    } }]), s3;
  }(), At2 = function() {
    function t3(e3) {
      a2(this, t3), this.ctx = e3, this.w = e3.w;
    }
    return r(t3, [{ key: "checkColorRange", value: function() {
      var t4 = this.w, e3 = false, i2 = t4.config.plotOptions[t4.config.chart.type];
      return i2.colorScale.ranges.length > 0 && i2.colorScale.ranges.map(function(t5, i3) {
        t5.from <= 0 && (e3 = true);
      }), e3;
    } }, { key: "getShadeColor", value: function(t4, e3, i2, a3) {
      var s3 = this.w, r2 = 1, o3 = s3.config.plotOptions[t4].shadeIntensity, n3 = this.determineColor(t4, e3, i2);
      s3.globals.hasNegs || a3 ? r2 = s3.config.plotOptions[t4].reverseNegativeShade ? n3.percent < 0 ? n3.percent / 100 * (1.25 * o3) : (1 - n3.percent / 100) * (1.25 * o3) : n3.percent <= 0 ? 1 - (1 + n3.percent / 100) * o3 : (1 - n3.percent / 100) * o3 : (r2 = 1 - n3.percent / 100, "treemap" === t4 && (r2 = (1 - n3.percent / 100) * (1.25 * o3)));
      var l3 = n3.color, h3 = new x2();
      return s3.config.plotOptions[t4].enableShades && (l3 = "dark" === this.w.config.theme.mode ? x2.hexToRgba(h3.shadeColor(-1 * r2, n3.color), s3.config.fill.opacity) : x2.hexToRgba(h3.shadeColor(r2, n3.color), s3.config.fill.opacity)), { color: l3, colorProps: n3 };
    } }, { key: "determineColor", value: function(t4, e3, i2) {
      var a3 = this.w, s3 = a3.globals.series[e3][i2], r2 = a3.config.plotOptions[t4], o3 = r2.colorScale.inverse ? i2 : e3;
      r2.distributed && "treemap" === a3.config.chart.type && (o3 = i2);
      var n3 = a3.globals.colors[o3], l3 = null, h3 = Math.min.apply(Math, u2(a3.globals.series[e3])), c3 = Math.max.apply(Math, u2(a3.globals.series[e3]));
      r2.distributed || "heatmap" !== t4 || (h3 = a3.globals.minY, c3 = a3.globals.maxY), void 0 !== r2.colorScale.min && (h3 = r2.colorScale.min < a3.globals.minY ? r2.colorScale.min : a3.globals.minY, c3 = r2.colorScale.max > a3.globals.maxY ? r2.colorScale.max : a3.globals.maxY);
      var d3 = Math.abs(c3) + Math.abs(h3), g3 = 100 * s3 / (0 === d3 ? d3 - 1e-6 : d3);
      r2.colorScale.ranges.length > 0 && r2.colorScale.ranges.map(function(t5, e4) {
        if (s3 >= t5.from && s3 <= t5.to) {
          n3 = t5.color, l3 = t5.foreColor ? t5.foreColor : null, h3 = t5.from, c3 = t5.to;
          var i3 = Math.abs(c3) + Math.abs(h3);
          g3 = 100 * s3 / (0 === i3 ? i3 - 1e-6 : i3);
        }
      });
      return { color: n3, foreColor: l3, percent: g3 };
    } }, { key: "calculateDataLabels", value: function(t4) {
      var e3 = t4.text, i2 = t4.x, a3 = t4.y, s3 = t4.i, r2 = t4.j, o3 = t4.colorProps, n3 = t4.fontSize, l3 = this.w.config.dataLabels, h3 = new m2(this.ctx), c3 = new N2(this.ctx), d3 = null;
      if (l3.enabled) {
        d3 = h3.group({ class: "apexcharts-data-labels" });
        var g3 = l3.offsetX, u3 = l3.offsetY, p3 = i2 + g3, f3 = a3 + parseFloat(l3.style.fontSize) / 3 + u3;
        c3.plotDataLabelsText({ x: p3, y: f3, text: e3, i: s3, j: r2, color: o3.foreColor, parent: d3, fontSize: n3, dataLabelsConfig: l3 });
      }
      return d3;
    } }, { key: "addListeners", value: function(t4) {
      var e3 = new m2(this.ctx);
      t4.node.addEventListener("mouseenter", e3.pathMouseEnter.bind(this, t4)), t4.node.addEventListener("mouseleave", e3.pathMouseLeave.bind(this, t4)), t4.node.addEventListener("mousedown", e3.pathMouseDown.bind(this, t4));
    } }]), t3;
  }(), St = function() {
    function t3(e3, i2) {
      a2(this, t3), this.ctx = e3, this.w = e3.w, this.xRatio = i2.xRatio, this.yRatio = i2.yRatio, this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.helpers = new At2(e3), this.rectRadius = this.w.config.plotOptions.heatmap.radius, this.strokeWidth = this.w.config.stroke.show ? this.w.config.stroke.width : 0;
    }
    return r(t3, [{ key: "draw", value: function(t4) {
      var e3 = this.w, i2 = new m2(this.ctx), a3 = i2.group({ class: "apexcharts-heatmap" });
      a3.attr("clip-path", "url(#gridRectMask".concat(e3.globals.cuid, ")"));
      var s3 = e3.globals.gridWidth / e3.globals.dataPoints, r2 = e3.globals.gridHeight / e3.globals.series.length, o3 = 0, n3 = false;
      this.negRange = this.helpers.checkColorRange();
      var l3 = t4.slice();
      e3.config.yaxis[0].reversed && (n3 = true, l3.reverse());
      for (var h3 = n3 ? 0 : l3.length - 1; n3 ? h3 < l3.length : h3 >= 0; n3 ? h3++ : h3--) {
        var c3 = i2.group({ class: "apexcharts-series apexcharts-heatmap-series", seriesName: x2.escapeString(e3.globals.seriesNames[h3]), rel: h3 + 1, "data:realIndex": h3 });
        if (this.ctx.series.addCollapsedClassToSeries(c3, h3), e3.config.chart.dropShadow.enabled) {
          var d3 = e3.config.chart.dropShadow;
          new v2(this.ctx).dropShadow(c3, d3, h3);
        }
        for (var g3 = 0, u3 = e3.config.plotOptions.heatmap.shadeIntensity, p3 = 0; p3 < l3[h3].length; p3++) {
          var f3 = this.helpers.getShadeColor(e3.config.chart.type, h3, p3, this.negRange), b3 = f3.color, y3 = f3.colorProps;
          if ("image" === e3.config.fill.type) b3 = new H4(this.ctx).fillPath({ seriesNumber: h3, dataPointIndex: p3, opacity: e3.globals.hasNegs ? y3.percent < 0 ? 1 - (1 + y3.percent / 100) : u3 + y3.percent / 100 : y3.percent / 100, patternID: x2.randomId(), width: e3.config.fill.image.width ? e3.config.fill.image.width : s3, height: e3.config.fill.image.height ? e3.config.fill.image.height : r2 });
          var w3 = this.rectRadius, k3 = i2.drawRect(g3, o3, s3, r2, w3);
          if (k3.attr({ cx: g3, cy: o3 }), k3.node.classList.add("apexcharts-heatmap-rect"), c3.add(k3), k3.attr({ fill: b3, i: h3, index: h3, j: p3, val: t4[h3][p3], "stroke-width": this.strokeWidth, stroke: e3.config.plotOptions.heatmap.useFillColorAsStroke ? b3 : e3.globals.stroke.colors[0], color: b3 }), this.helpers.addListeners(k3), e3.config.chart.animations.enabled && !e3.globals.dataChanged) {
            var A3 = 1;
            e3.globals.resized || (A3 = e3.config.chart.animations.speed), this.animateHeatMap(k3, g3, o3, s3, r2, A3);
          }
          if (e3.globals.dataChanged) {
            var S3 = 1;
            if (this.dynamicAnim.enabled && e3.globals.shouldAnimate) {
              S3 = this.dynamicAnim.speed;
              var C3 = e3.globals.previousPaths[h3] && e3.globals.previousPaths[h3][p3] && e3.globals.previousPaths[h3][p3].color;
              C3 || (C3 = "rgba(255, 255, 255, 0)"), this.animateHeatColor(k3, x2.isColorHex(C3) ? C3 : x2.rgb2hex(C3), x2.isColorHex(b3) ? b3 : x2.rgb2hex(b3), S3);
            }
          }
          var L3 = (0, e3.config.dataLabels.formatter)(e3.globals.series[h3][p3], { value: e3.globals.series[h3][p3], seriesIndex: h3, dataPointIndex: p3, w: e3 }), P3 = this.helpers.calculateDataLabels({ text: L3, x: g3 + s3 / 2, y: o3 + r2 / 2, i: h3, j: p3, colorProps: y3, series: l3 });
          null !== P3 && c3.add(P3), g3 += s3;
        }
        o3 += r2, a3.add(c3);
      }
      var M3 = e3.globals.yAxisScale[0].result.slice();
      return e3.config.yaxis[0].reversed ? M3.unshift("") : M3.push(""), e3.globals.yAxisScale[0].result = M3, a3;
    } }, { key: "animateHeatMap", value: function(t4, e3, i2, a3, s3, r2) {
      var o3 = new b2(this.ctx);
      o3.animateRect(t4, { x: e3 + a3 / 2, y: i2 + s3 / 2, width: 0, height: 0 }, { x: e3, y: i2, width: a3, height: s3 }, r2, function() {
        o3.animationCompleted(t4);
      });
    } }, { key: "animateHeatColor", value: function(t4, e3, i2, a3) {
      t4.attr({ fill: e3 }).animate(a3).attr({ fill: i2 });
    } }]), t3;
  }(), Ct2 = function() {
    function t3(e3) {
      a2(this, t3), this.ctx = e3, this.w = e3.w;
    }
    return r(t3, [{ key: "drawYAxisTexts", value: function(t4, e3, i2, a3) {
      var s3 = this.w, r2 = s3.config.yaxis[0], o3 = s3.globals.yLabelFormatters[0];
      return new m2(this.ctx).drawText({ x: t4 + r2.labels.offsetX, y: e3 + r2.labels.offsetY, text: o3(a3, i2), textAnchor: "middle", fontSize: r2.labels.style.fontSize, fontFamily: r2.labels.style.fontFamily, foreColor: Array.isArray(r2.labels.style.colors) ? r2.labels.style.colors[i2] : r2.labels.style.colors });
    } }]), t3;
  }(), Lt2 = function() {
    function t3(e3) {
      a2(this, t3), this.ctx = e3, this.w = e3.w;
      var i2 = this.w;
      this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animBeginArr = [0], this.animDur = 0, this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels, this.lineColorArr = void 0 !== i2.globals.stroke.colors ? i2.globals.stroke.colors : i2.globals.colors, this.defaultSize = Math.min(i2.globals.gridWidth, i2.globals.gridHeight), this.centerY = this.defaultSize / 2, this.centerX = i2.globals.gridWidth / 2, "radialBar" === i2.config.chart.type ? this.fullAngle = 360 : this.fullAngle = Math.abs(i2.config.plotOptions.pie.endAngle - i2.config.plotOptions.pie.startAngle), this.initialAngle = i2.config.plotOptions.pie.startAngle % this.fullAngle, i2.globals.radialSize = this.defaultSize / 2.05 - i2.config.stroke.width - (i2.config.chart.sparkline.enabled ? 0 : i2.config.chart.dropShadow.blur), this.donutSize = i2.globals.radialSize * parseInt(i2.config.plotOptions.pie.donut.size, 10) / 100;
      var s3 = i2.config.plotOptions.pie.customScale, r2 = i2.globals.gridWidth / 2, o3 = i2.globals.gridHeight / 2;
      this.translateX = r2 - r2 * s3, this.translateY = o3 - o3 * s3, this.dataLabelsGroup = new m2(this.ctx).group({ class: "apexcharts-datalabels-group", transform: "translate(".concat(this.translateX, ", ").concat(this.translateY, ") scale(").concat(s3, ")") }), this.maxY = 0, this.sliceLabels = [], this.sliceSizes = [], this.prevSectorAngleArr = [];
    }
    return r(t3, [{ key: "draw", value: function(t4) {
      var e3 = this, i2 = this.w, a3 = new m2(this.ctx), s3 = a3.group({ class: "apexcharts-pie" });
      if (i2.globals.noData) return s3;
      for (var r2 = 0, o3 = 0; o3 < t4.length; o3++) r2 += x2.negToZero(t4[o3]);
      var n3 = [], l3 = a3.group();
      0 === r2 && (r2 = 1e-5), t4.forEach(function(t5) {
        e3.maxY = Math.max(e3.maxY, t5);
      }), i2.config.yaxis[0].max && (this.maxY = i2.config.yaxis[0].max), "back" === i2.config.grid.position && "polarArea" === this.chartType && this.drawPolarElements(s3);
      for (var h3 = 0; h3 < t4.length; h3++) {
        var c3 = this.fullAngle * x2.negToZero(t4[h3]) / r2;
        n3.push(c3), "polarArea" === this.chartType ? (n3[h3] = this.fullAngle / t4.length, this.sliceSizes.push(i2.globals.radialSize * t4[h3] / this.maxY)) : this.sliceSizes.push(i2.globals.radialSize);
      }
      if (i2.globals.dataChanged) {
        for (var d3, g3 = 0, u3 = 0; u3 < i2.globals.previousPaths.length; u3++) g3 += x2.negToZero(i2.globals.previousPaths[u3]);
        for (var p3 = 0; p3 < i2.globals.previousPaths.length; p3++) d3 = this.fullAngle * x2.negToZero(i2.globals.previousPaths[p3]) / g3, this.prevSectorAngleArr.push(d3);
      }
      if (this.donutSize < 0 && (this.donutSize = 0), "donut" === this.chartType) {
        var f3 = a3.drawCircle(this.donutSize);
        f3.attr({ cx: this.centerX, cy: this.centerY, fill: i2.config.plotOptions.pie.donut.background ? i2.config.plotOptions.pie.donut.background : "transparent" }), l3.add(f3);
      }
      var b3 = this.drawArcs(n3, t4);
      if (this.sliceLabels.forEach(function(t5) {
        b3.add(t5);
      }), l3.attr({ transform: "translate(".concat(this.translateX, ", ").concat(this.translateY, ") scale(").concat(i2.config.plotOptions.pie.customScale, ")") }), l3.add(b3), s3.add(l3), this.donutDataLabels.show) {
        var v3 = this.renderInnerDataLabels(this.dataLabelsGroup, this.donutDataLabels, { hollowSize: this.donutSize, centerX: this.centerX, centerY: this.centerY, opacity: this.donutDataLabels.show });
        s3.add(v3);
      }
      return "front" === i2.config.grid.position && "polarArea" === this.chartType && this.drawPolarElements(s3), s3;
    } }, { key: "drawArcs", value: function(t4, e3) {
      var i2 = this.w, a3 = new v2(this.ctx), s3 = new m2(this.ctx), r2 = new H4(this.ctx), o3 = s3.group({ class: "apexcharts-slices" }), n3 = this.initialAngle, l3 = this.initialAngle, h3 = this.initialAngle, c3 = this.initialAngle;
      this.strokeWidth = i2.config.stroke.show ? i2.config.stroke.width : 0;
      for (var d3 = 0; d3 < t4.length; d3++) {
        var g3 = s3.group({ class: "apexcharts-series apexcharts-pie-series", seriesName: x2.escapeString(i2.globals.seriesNames[d3]), rel: d3 + 1, "data:realIndex": d3 });
        o3.add(g3), l3 = c3, h3 = (n3 = h3) + t4[d3], c3 = l3 + this.prevSectorAngleArr[d3];
        var u3 = h3 < n3 ? this.fullAngle + h3 - n3 : h3 - n3, p3 = r2.fillPath({ seriesNumber: d3, size: this.sliceSizes[d3], value: e3[d3] }), f3 = this.getChangedPath(l3, c3), b3 = s3.drawPath({ d: f3, stroke: Array.isArray(this.lineColorArr) ? this.lineColorArr[d3] : this.lineColorArr, strokeWidth: 0, fill: p3, fillOpacity: i2.config.fill.opacity, classes: "apexcharts-pie-area apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(d3) });
        if (b3.attr({ index: 0, j: d3 }), a3.setSelectionFilter(b3, 0, d3), i2.config.chart.dropShadow.enabled) {
          var y3 = i2.config.chart.dropShadow;
          a3.dropShadow(b3, y3, d3);
        }
        this.addListeners(b3, this.donutDataLabels), m2.setAttrs(b3.node, { "data:angle": u3, "data:startAngle": n3, "data:strokeWidth": this.strokeWidth, "data:value": e3[d3] });
        var w3 = { x: 0, y: 0 };
        "pie" === this.chartType || "polarArea" === this.chartType ? w3 = x2.polarToCartesian(this.centerX, this.centerY, i2.globals.radialSize / 1.25 + i2.config.plotOptions.pie.dataLabels.offset, (n3 + u3 / 2) % this.fullAngle) : "donut" === this.chartType && (w3 = x2.polarToCartesian(this.centerX, this.centerY, (i2.globals.radialSize + this.donutSize) / 2 + i2.config.plotOptions.pie.dataLabels.offset, (n3 + u3 / 2) % this.fullAngle)), g3.add(b3);
        var k3 = 0;
        if (!this.initialAnim || i2.globals.resized || i2.globals.dataChanged ? this.animBeginArr.push(0) : (0 === (k3 = u3 / this.fullAngle * i2.config.chart.animations.speed) && (k3 = 1), this.animDur = k3 + this.animDur, this.animBeginArr.push(this.animDur)), this.dynamicAnim && i2.globals.dataChanged ? this.animatePaths(b3, { size: this.sliceSizes[d3], endAngle: h3, startAngle: n3, prevStartAngle: l3, prevEndAngle: c3, animateStartingPos: true, i: d3, animBeginArr: this.animBeginArr, shouldSetPrevPaths: true, dur: i2.config.chart.animations.dynamicAnimation.speed }) : this.animatePaths(b3, { size: this.sliceSizes[d3], endAngle: h3, startAngle: n3, i: d3, totalItems: t4.length - 1, animBeginArr: this.animBeginArr, dur: k3 }), i2.config.plotOptions.pie.expandOnClick && "polarArea" !== this.chartType && b3.node.addEventListener("mouseup", this.pieClicked.bind(this, d3)), void 0 !== i2.globals.selectedDataPoints[0] && i2.globals.selectedDataPoints[0].indexOf(d3) > -1 && this.pieClicked(d3), i2.config.dataLabels.enabled) {
          var A3 = w3.x, S3 = w3.y, C3 = 100 * u3 / this.fullAngle + "%";
          if (0 !== u3 && i2.config.plotOptions.pie.dataLabels.minAngleToShowLabel < t4[d3]) {
            var L3 = i2.config.dataLabels.formatter;
            void 0 !== L3 && (C3 = L3(i2.globals.seriesPercent[d3][0], { seriesIndex: d3, w: i2 }));
            var P3 = i2.globals.dataLabels.style.colors[d3], M3 = s3.group({ class: "apexcharts-datalabels" }), I3 = s3.drawText({ x: A3, y: S3, text: C3, textAnchor: "middle", fontSize: i2.config.dataLabels.style.fontSize, fontFamily: i2.config.dataLabels.style.fontFamily, fontWeight: i2.config.dataLabels.style.fontWeight, foreColor: P3 });
            if (M3.add(I3), i2.config.dataLabels.dropShadow.enabled) {
              var T3 = i2.config.dataLabels.dropShadow;
              a3.dropShadow(I3, T3);
            }
            I3.node.classList.add("apexcharts-pie-label"), i2.config.chart.animations.animate && false === i2.globals.resized && (I3.node.classList.add("apexcharts-pie-label-delay"), I3.node.style.animationDelay = i2.config.chart.animations.speed / 940 + "s"), this.sliceLabels.push(M3);
          }
        }
      }
      return o3;
    } }, { key: "addListeners", value: function(t4, e3) {
      var i2 = new m2(this.ctx);
      t4.node.addEventListener("mouseenter", i2.pathMouseEnter.bind(this, t4)), t4.node.addEventListener("mouseleave", i2.pathMouseLeave.bind(this, t4)), t4.node.addEventListener("mouseleave", this.revertDataLabelsInner.bind(this, t4.node, e3)), t4.node.addEventListener("mousedown", i2.pathMouseDown.bind(this, t4)), this.donutDataLabels.total.showAlways || (t4.node.addEventListener("mouseenter", this.printDataLabelsInner.bind(this, t4.node, e3)), t4.node.addEventListener("mousedown", this.printDataLabelsInner.bind(this, t4.node, e3)));
    } }, { key: "animatePaths", value: function(t4, e3) {
      var i2 = this.w, a3 = e3.endAngle < e3.startAngle ? this.fullAngle + e3.endAngle - e3.startAngle : e3.endAngle - e3.startAngle, s3 = a3, r2 = e3.startAngle, o3 = e3.startAngle;
      void 0 !== e3.prevStartAngle && void 0 !== e3.prevEndAngle && (r2 = e3.prevEndAngle, s3 = e3.prevEndAngle < e3.prevStartAngle ? this.fullAngle + e3.prevEndAngle - e3.prevStartAngle : e3.prevEndAngle - e3.prevStartAngle), e3.i === i2.config.series.length - 1 && (a3 + o3 > this.fullAngle ? e3.endAngle = e3.endAngle - (a3 + o3) : a3 + o3 < this.fullAngle && (e3.endAngle = e3.endAngle + (this.fullAngle - (a3 + o3)))), a3 === this.fullAngle && (a3 = this.fullAngle - 0.01), this.animateArc(t4, r2, o3, a3, s3, e3);
    } }, { key: "animateArc", value: function(t4, e3, i2, a3, s3, r2) {
      var o3, n3 = this, l3 = this.w, h3 = new b2(this.ctx), c3 = r2.size;
      (isNaN(e3) || isNaN(s3)) && (e3 = i2, s3 = a3, r2.dur = 0);
      var d3 = a3, g3 = i2, u3 = e3 < i2 ? this.fullAngle + e3 - i2 : e3 - i2;
      l3.globals.dataChanged && r2.shouldSetPrevPaths && r2.prevEndAngle && (o3 = n3.getPiePath({ me: n3, startAngle: r2.prevStartAngle, angle: r2.prevEndAngle < r2.prevStartAngle ? this.fullAngle + r2.prevEndAngle - r2.prevStartAngle : r2.prevEndAngle - r2.prevStartAngle, size: c3 }), t4.attr({ d: o3 })), 0 !== r2.dur ? t4.animate(r2.dur, l3.globals.easing, r2.animBeginArr[r2.i]).afterAll(function() {
        "pie" !== n3.chartType && "donut" !== n3.chartType && "polarArea" !== n3.chartType || this.animate(l3.config.chart.animations.dynamicAnimation.speed).attr({ "stroke-width": n3.strokeWidth }), r2.i === l3.config.series.length - 1 && h3.animationCompleted(t4);
      }).during(function(l4) {
        d3 = u3 + (a3 - u3) * l4, r2.animateStartingPos && (d3 = s3 + (a3 - s3) * l4, g3 = e3 - s3 + (i2 - (e3 - s3)) * l4), o3 = n3.getPiePath({ me: n3, startAngle: g3, angle: d3, size: c3 }), t4.node.setAttribute("data:pathOrig", o3), t4.attr({ d: o3 });
      }) : (o3 = n3.getPiePath({ me: n3, startAngle: g3, angle: a3, size: c3 }), r2.isTrack || (l3.globals.animationEnded = true), t4.node.setAttribute("data:pathOrig", o3), t4.attr({ d: o3, "stroke-width": n3.strokeWidth }));
    } }, { key: "pieClicked", value: function(t4) {
      var e3, i2 = this.w, a3 = this, s3 = a3.sliceSizes[t4] + (i2.config.plotOptions.pie.expandOnClick ? 4 : 0), r2 = i2.globals.dom.Paper.select(".apexcharts-".concat(a3.chartType.toLowerCase(), "-slice-").concat(t4)).members[0];
      if ("true" !== r2.attr("data:pieClicked")) {
        var o3 = i2.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area");
        Array.prototype.forEach.call(o3, function(t5) {
          t5.setAttribute("data:pieClicked", "false");
          var e4 = t5.getAttribute("data:pathOrig");
          e4 && t5.setAttribute("d", e4);
        }), i2.globals.capturedDataPointIndex = t4, r2.attr("data:pieClicked", "true");
        var n3 = parseInt(r2.attr("data:startAngle"), 10), l3 = parseInt(r2.attr("data:angle"), 10);
        e3 = a3.getPiePath({ me: a3, startAngle: n3, angle: l3, size: s3 }), 360 !== l3 && r2.plot(e3);
      } else {
        r2.attr({ "data:pieClicked": "false" }), this.revertDataLabelsInner(r2.node, this.donutDataLabels);
        var h3 = r2.attr("data:pathOrig");
        r2.attr({ d: h3 });
      }
    } }, { key: "getChangedPath", value: function(t4, e3) {
      var i2 = "";
      return this.dynamicAnim && this.w.globals.dataChanged && (i2 = this.getPiePath({ me: this, startAngle: t4, angle: e3 - t4, size: this.size })), i2;
    } }, { key: "getPiePath", value: function(t4) {
      var e3, i2 = t4.me, a3 = t4.startAngle, s3 = t4.angle, r2 = t4.size, o3 = new m2(this.ctx), n3 = a3, l3 = Math.PI * (n3 - 90) / 180, h3 = s3 + a3;
      Math.ceil(h3) >= this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle && (h3 = this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle - 0.01), Math.ceil(h3) > this.fullAngle && (h3 -= this.fullAngle);
      var c3 = Math.PI * (h3 - 90) / 180, d3 = i2.centerX + r2 * Math.cos(l3), g3 = i2.centerY + r2 * Math.sin(l3), u3 = i2.centerX + r2 * Math.cos(c3), p3 = i2.centerY + r2 * Math.sin(c3), f3 = x2.polarToCartesian(i2.centerX, i2.centerY, i2.donutSize, h3), b3 = x2.polarToCartesian(i2.centerX, i2.centerY, i2.donutSize, n3), v3 = s3 > 180 ? 1 : 0, y3 = ["M", d3, g3, "A", r2, r2, 0, v3, 1, u3, p3];
      return e3 = "donut" === i2.chartType ? [].concat(y3, ["L", f3.x, f3.y, "A", i2.donutSize, i2.donutSize, 0, v3, 0, b3.x, b3.y, "L", d3, g3, "z"]).join(" ") : "pie" === i2.chartType || "polarArea" === i2.chartType ? [].concat(y3, ["L", i2.centerX, i2.centerY, "L", d3, g3]).join(" ") : [].concat(y3).join(" "), o3.roundPathCorners(e3, 2 * this.strokeWidth);
    } }, { key: "drawPolarElements", value: function(t4) {
      var e3 = this.w, i2 = new _2(this.ctx), a3 = new m2(this.ctx), s3 = new Ct2(this.ctx), r2 = a3.group(), o3 = a3.group(), n3 = i2.niceScale(0, Math.ceil(this.maxY), 0), l3 = n3.result.reverse(), h3 = n3.result.length;
      this.maxY = n3.niceMax;
      for (var c3 = e3.globals.radialSize, d3 = c3 / (h3 - 1), g3 = 0; g3 < h3 - 1; g3++) {
        var u3 = a3.drawCircle(c3);
        if (u3.attr({ cx: this.centerX, cy: this.centerY, fill: "none", "stroke-width": e3.config.plotOptions.polarArea.rings.strokeWidth, stroke: e3.config.plotOptions.polarArea.rings.strokeColor }), e3.config.yaxis[0].show) {
          var p3 = s3.drawYAxisTexts(this.centerX, this.centerY - c3 + parseInt(e3.config.yaxis[0].labels.style.fontSize, 10) / 2, g3, l3[g3]);
          o3.add(p3);
        }
        r2.add(u3), c3 -= d3;
      }
      this.drawSpokes(t4), t4.add(r2), t4.add(o3);
    } }, { key: "renderInnerDataLabels", value: function(t4, e3, i2) {
      var a3 = this.w, s3 = new m2(this.ctx), r2 = e3.total.show;
      t4.node.innerHTML = "", t4.node.style.opacity = i2.opacity;
      var o3, n3, l3 = i2.centerX, h3 = i2.centerY;
      o3 = void 0 === e3.name.color ? a3.globals.colors[0] : e3.name.color;
      var c3 = e3.name.fontSize, d3 = e3.name.fontFamily, g3 = e3.name.fontWeight;
      n3 = void 0 === e3.value.color ? a3.config.chart.foreColor : e3.value.color;
      var u3 = e3.value.formatter, p3 = "", f3 = "";
      if (r2 ? (o3 = e3.total.color, c3 = e3.total.fontSize, d3 = e3.total.fontFamily, g3 = e3.total.fontWeight, f3 = e3.total.label, p3 = e3.total.formatter(a3)) : 1 === a3.globals.series.length && (p3 = u3(a3.globals.series[0], a3), f3 = a3.globals.seriesNames[0]), f3 && (f3 = e3.name.formatter(f3, e3.total.show, a3)), e3.name.show) {
        var x3 = s3.drawText({ x: l3, y: h3 + parseFloat(e3.name.offsetY), text: f3, textAnchor: "middle", foreColor: o3, fontSize: c3, fontWeight: g3, fontFamily: d3 });
        x3.node.classList.add("apexcharts-datalabel-label"), t4.add(x3);
      }
      if (e3.value.show) {
        var b3 = e3.name.show ? parseFloat(e3.value.offsetY) + 16 : e3.value.offsetY, v3 = s3.drawText({ x: l3, y: h3 + b3, text: p3, textAnchor: "middle", foreColor: n3, fontWeight: e3.value.fontWeight, fontSize: e3.value.fontSize, fontFamily: e3.value.fontFamily });
        v3.node.classList.add("apexcharts-datalabel-value"), t4.add(v3);
      }
      return t4;
    } }, { key: "printInnerLabels", value: function(t4, e3, i2, a3) {
      var s3, r2 = this.w;
      a3 ? s3 = void 0 === t4.name.color ? r2.globals.colors[parseInt(a3.parentNode.getAttribute("rel"), 10) - 1] : t4.name.color : r2.globals.series.length > 1 && t4.total.show && (s3 = t4.total.color);
      var o3 = r2.globals.dom.baseEl.querySelector(".apexcharts-datalabel-label"), n3 = r2.globals.dom.baseEl.querySelector(".apexcharts-datalabel-value");
      i2 = (0, t4.value.formatter)(i2, r2), a3 || "function" != typeof t4.total.formatter || (i2 = t4.total.formatter(r2));
      var l3 = e3 === t4.total.label;
      e3 = t4.name.formatter(e3, l3, r2), null !== o3 && (o3.textContent = e3), null !== n3 && (n3.textContent = i2), null !== o3 && (o3.style.fill = s3);
    } }, { key: "printDataLabelsInner", value: function(t4, e3) {
      var i2 = this.w, a3 = t4.getAttribute("data:value"), s3 = i2.globals.seriesNames[parseInt(t4.parentNode.getAttribute("rel"), 10) - 1];
      i2.globals.series.length > 1 && this.printInnerLabels(e3, s3, a3, t4);
      var r2 = i2.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group");
      null !== r2 && (r2.style.opacity = 1);
    } }, { key: "drawSpokes", value: function(t4) {
      var e3 = this, i2 = this.w, a3 = new m2(this.ctx), s3 = i2.config.plotOptions.polarArea.spokes;
      if (0 !== s3.strokeWidth) {
        for (var r2 = [], o3 = 360 / i2.globals.series.length, n3 = 0; n3 < i2.globals.series.length; n3++) r2.push(x2.polarToCartesian(this.centerX, this.centerY, i2.globals.radialSize, i2.config.plotOptions.pie.startAngle + o3 * n3));
        r2.forEach(function(i3, r3) {
          var o4 = a3.drawLine(i3.x, i3.y, e3.centerX, e3.centerY, Array.isArray(s3.connectorColors) ? s3.connectorColors[r3] : s3.connectorColors);
          t4.add(o4);
        });
      }
    } }, { key: "revertDataLabelsInner", value: function() {
      var t4 = this.w;
      if (this.donutDataLabels.show) {
        var e3 = t4.globals.dom.Paper.select(".apexcharts-datalabels-group").members[0], i2 = this.renderInnerDataLabels(e3, this.donutDataLabels, { hollowSize: this.donutSize, centerX: this.centerX, centerY: this.centerY, opacity: this.donutDataLabels.show });
        t4.globals.dom.Paper.select(".apexcharts-radialbar, .apexcharts-pie").members[0].add(i2);
      }
    } }]), t3;
  }(), Pt2 = function() {
    function t3(e3) {
      a2(this, t3), this.ctx = e3, this.w = e3.w, this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animDur = 0;
      var i2 = this.w;
      this.graphics = new m2(this.ctx), this.lineColorArr = void 0 !== i2.globals.stroke.colors ? i2.globals.stroke.colors : i2.globals.colors, this.defaultSize = i2.globals.svgHeight < i2.globals.svgWidth ? i2.globals.gridHeight + 1.5 * i2.globals.goldenPadding : i2.globals.gridWidth, this.isLog = i2.config.yaxis[0].logarithmic, this.logBase = i2.config.yaxis[0].logBase, this.coreUtils = new y2(this.ctx), this.maxValue = this.isLog ? this.coreUtils.getLogVal(this.logBase, i2.globals.maxY, 0) : i2.globals.maxY, this.minValue = this.isLog ? this.coreUtils.getLogVal(this.logBase, this.w.globals.minY, 0) : i2.globals.minY, this.polygons = i2.config.plotOptions.radar.polygons, this.strokeWidth = i2.config.stroke.show ? i2.config.stroke.width : 0, this.size = this.defaultSize / 2.1 - this.strokeWidth - i2.config.chart.dropShadow.blur, i2.config.xaxis.labels.show && (this.size = this.size - i2.globals.xAxisLabelsWidth / 1.75), void 0 !== i2.config.plotOptions.radar.size && (this.size = i2.config.plotOptions.radar.size), this.dataRadiusOfPercent = [], this.dataRadius = [], this.angleArr = [], this.yaxisLabelsTextsPos = [];
    }
    return r(t3, [{ key: "draw", value: function(t4) {
      var i2 = this, a3 = this.w, s3 = new H4(this.ctx), r2 = [], o3 = new N2(this.ctx);
      t4.length && (this.dataPointsLen = t4[a3.globals.maxValsInArrayIndex].length), this.disAngle = 2 * Math.PI / this.dataPointsLen;
      var n3 = a3.globals.gridWidth / 2, l3 = a3.globals.gridHeight / 2, h3 = n3 + a3.config.plotOptions.radar.offsetX, c3 = l3 + a3.config.plotOptions.radar.offsetY, d3 = this.graphics.group({ class: "apexcharts-radar-series apexcharts-plot-series", transform: "translate(".concat(h3 || 0, ", ").concat(c3 || 0, ")") }), g3 = [], u3 = null, p3 = null;
      if (this.yaxisLabels = this.graphics.group({ class: "apexcharts-yaxis" }), t4.forEach(function(t5, n4) {
        var l4 = t5.length === a3.globals.dataPoints, h4 = i2.graphics.group().attr({ class: "apexcharts-series", "data:longestSeries": l4, seriesName: x2.escapeString(a3.globals.seriesNames[n4]), rel: n4 + 1, "data:realIndex": n4 });
        i2.dataRadiusOfPercent[n4] = [], i2.dataRadius[n4] = [], i2.angleArr[n4] = [], t5.forEach(function(t6, e3) {
          var a4 = Math.abs(i2.maxValue - i2.minValue);
          t6 -= i2.minValue, i2.isLog && (t6 = i2.coreUtils.getLogVal(i2.logBase, t6, 0)), i2.dataRadiusOfPercent[n4][e3] = t6 / a4, i2.dataRadius[n4][e3] = i2.dataRadiusOfPercent[n4][e3] * i2.size, i2.angleArr[n4][e3] = e3 * i2.disAngle;
        }), g3 = i2.getDataPointsPos(i2.dataRadius[n4], i2.angleArr[n4]);
        var c4 = i2.createPaths(g3, { x: 0, y: 0 });
        u3 = i2.graphics.group({ class: "apexcharts-series-markers-wrap apexcharts-element-hidden" }), p3 = i2.graphics.group({ class: "apexcharts-datalabels", "data:realIndex": n4 }), a3.globals.delayedElements.push({ el: u3.node, index: n4 });
        var d4 = { i: n4, realIndex: n4, animationDelay: n4, initialSpeed: a3.config.chart.animations.speed, dataChangeSpeed: a3.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-radar", shouldClipToGrid: false, bindEventsOnPaths: false, stroke: a3.globals.stroke.colors[n4], strokeLineCap: a3.config.stroke.lineCap }, f4 = null;
        a3.globals.previousPaths.length > 0 && (f4 = i2.getPreviousPath(n4));
        for (var b3 = 0; b3 < c4.linePathsTo.length; b3++) {
          var m3 = i2.graphics.renderPaths(e2(e2({}, d4), {}, { pathFrom: null === f4 ? c4.linePathsFrom[b3] : f4, pathTo: c4.linePathsTo[b3], strokeWidth: Array.isArray(i2.strokeWidth) ? i2.strokeWidth[n4] : i2.strokeWidth, fill: "none", drawShadow: false }));
          h4.add(m3);
          var y3 = s3.fillPath({ seriesNumber: n4 }), w3 = i2.graphics.renderPaths(e2(e2({}, d4), {}, { pathFrom: null === f4 ? c4.areaPathsFrom[b3] : f4, pathTo: c4.areaPathsTo[b3], strokeWidth: 0, fill: y3, drawShadow: false }));
          if (a3.config.chart.dropShadow.enabled) {
            var k3 = new v2(i2.ctx), A3 = a3.config.chart.dropShadow;
            k3.dropShadow(w3, Object.assign({}, A3, { noUserSpaceOnUse: true }), n4);
          }
          h4.add(w3);
        }
        t5.forEach(function(t6, s4) {
          var r3 = new D2(i2.ctx).getMarkerConfig({ cssClass: "apexcharts-marker", seriesIndex: n4, dataPointIndex: s4 }), l5 = i2.graphics.drawMarker(g3[s4].x, g3[s4].y, r3);
          l5.attr("rel", s4), l5.attr("j", s4), l5.attr("index", n4), l5.node.setAttribute("default-marker-size", r3.pSize);
          var c5 = i2.graphics.group({ class: "apexcharts-series-markers" });
          c5 && c5.add(l5), u3.add(c5), h4.add(u3);
          var d5 = a3.config.dataLabels;
          if (d5.enabled) {
            var f5 = d5.formatter(a3.globals.series[n4][s4], { seriesIndex: n4, dataPointIndex: s4, w: a3 });
            o3.plotDataLabelsText({ x: g3[s4].x, y: g3[s4].y, text: f5, textAnchor: "middle", i: n4, j: n4, parent: p3, offsetCorrection: false, dataLabelsConfig: e2({}, d5) });
          }
          h4.add(p3);
        }), r2.push(h4);
      }), this.drawPolygons({ parent: d3 }), a3.config.xaxis.labels.show) {
        var f3 = this.drawXAxisTexts();
        d3.add(f3);
      }
      return r2.forEach(function(t5) {
        d3.add(t5);
      }), d3.add(this.yaxisLabels), d3;
    } }, { key: "drawPolygons", value: function(t4) {
      for (var e3 = this, i2 = this.w, a3 = t4.parent, s3 = new Ct2(this.ctx), r2 = i2.globals.yAxisScale[0].result.reverse(), o3 = r2.length, n3 = [], l3 = this.size / (o3 - 1), h3 = 0; h3 < o3; h3++) n3[h3] = l3 * h3;
      n3.reverse();
      var c3 = [], d3 = [];
      n3.forEach(function(t5, i3) {
        var a4 = x2.getPolygonPos(t5, e3.dataPointsLen), s4 = "";
        a4.forEach(function(t6, a5) {
          if (0 === i3) {
            var r3 = e3.graphics.drawLine(t6.x, t6.y, 0, 0, Array.isArray(e3.polygons.connectorColors) ? e3.polygons.connectorColors[a5] : e3.polygons.connectorColors);
            d3.push(r3);
          }
          0 === a5 && e3.yaxisLabelsTextsPos.push({ x: t6.x, y: t6.y }), s4 += t6.x + "," + t6.y + " ";
        }), c3.push(s4);
      }), c3.forEach(function(t5, s4) {
        var r3 = e3.polygons.strokeColors, o4 = e3.polygons.strokeWidth, n4 = e3.graphics.drawPolygon(t5, Array.isArray(r3) ? r3[s4] : r3, Array.isArray(o4) ? o4[s4] : o4, i2.globals.radarPolygons.fill.colors[s4]);
        a3.add(n4);
      }), d3.forEach(function(t5) {
        a3.add(t5);
      }), i2.config.yaxis[0].show && this.yaxisLabelsTextsPos.forEach(function(t5, i3) {
        var a4 = s3.drawYAxisTexts(t5.x, t5.y, i3, r2[i3]);
        e3.yaxisLabels.add(a4);
      });
    } }, { key: "drawXAxisTexts", value: function() {
      var t4 = this, i2 = this.w, a3 = i2.config.xaxis.labels, s3 = this.graphics.group({ class: "apexcharts-xaxis" }), r2 = x2.getPolygonPos(this.size, this.dataPointsLen);
      return i2.globals.labels.forEach(function(o3, n3) {
        var l3 = i2.config.xaxis.labels.formatter, h3 = new N2(t4.ctx);
        if (r2[n3]) {
          var c3 = t4.getTextPos(r2[n3], t4.size), d3 = l3(o3, { seriesIndex: -1, dataPointIndex: n3, w: i2 });
          h3.plotDataLabelsText({ x: c3.newX, y: c3.newY, text: d3, textAnchor: c3.textAnchor, i: n3, j: n3, parent: s3, className: "apexcharts-xaxis-label", color: Array.isArray(a3.style.colors) && a3.style.colors[n3] ? a3.style.colors[n3] : "#a8a8a8", dataLabelsConfig: e2({ textAnchor: c3.textAnchor, dropShadow: { enabled: false } }, a3), offsetCorrection: false }).on("click", function(e3) {
            if ("function" == typeof i2.config.chart.events.xAxisLabelClick) {
              var a4 = Object.assign({}, i2, { labelIndex: n3 });
              i2.config.chart.events.xAxisLabelClick(e3, t4.ctx, a4);
            }
          });
        }
      }), s3;
    } }, { key: "createPaths", value: function(t4, e3) {
      var i2 = this, a3 = [], s3 = [], r2 = [], o3 = [];
      if (t4.length) {
        s3 = [this.graphics.move(e3.x, e3.y)], o3 = [this.graphics.move(e3.x, e3.y)];
        var n3 = this.graphics.move(t4[0].x, t4[0].y), l3 = this.graphics.move(t4[0].x, t4[0].y);
        t4.forEach(function(e4, a4) {
          n3 += i2.graphics.line(e4.x, e4.y), l3 += i2.graphics.line(e4.x, e4.y), a4 === t4.length - 1 && (n3 += "Z", l3 += "Z");
        }), a3.push(n3), r2.push(l3);
      }
      return { linePathsFrom: s3, linePathsTo: a3, areaPathsFrom: o3, areaPathsTo: r2 };
    } }, { key: "getTextPos", value: function(t4, e3) {
      var i2 = "middle", a3 = t4.x, s3 = t4.y;
      return Math.abs(t4.x) >= 10 ? t4.x > 0 ? (i2 = "start", a3 += 10) : t4.x < 0 && (i2 = "end", a3 -= 10) : i2 = "middle", Math.abs(t4.y) >= e3 - 10 && (t4.y < 0 ? s3 -= 10 : t4.y > 0 && (s3 += 10)), { textAnchor: i2, newX: a3, newY: s3 };
    } }, { key: "getPreviousPath", value: function(t4) {
      for (var e3 = this.w, i2 = null, a3 = 0; a3 < e3.globals.previousPaths.length; a3++) {
        var s3 = e3.globals.previousPaths[a3];
        s3.paths.length > 0 && parseInt(s3.realIndex, 10) === parseInt(t4, 10) && void 0 !== e3.globals.previousPaths[a3].paths[0] && (i2 = e3.globals.previousPaths[a3].paths[0].d);
      }
      return i2;
    } }, { key: "getDataPointsPos", value: function(t4, e3) {
      var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.dataPointsLen;
      t4 = t4 || [], e3 = e3 || [];
      for (var a3 = [], s3 = 0; s3 < i2; s3++) {
        var r2 = {};
        r2.x = t4[s3] * Math.sin(e3[s3]), r2.y = -t4[s3] * Math.cos(e3[s3]), a3.push(r2);
      }
      return a3;
    } }]), t3;
  }(), Mt2 = function(t3) {
    n2(i2, Lt2);
    var e3 = d2(i2);
    function i2(t4) {
      var s3;
      a2(this, i2), (s3 = e3.call(this, t4)).ctx = t4, s3.w = t4.w, s3.animBeginArr = [0], s3.animDur = 0;
      var r2 = s3.w;
      return s3.startAngle = r2.config.plotOptions.radialBar.startAngle, s3.endAngle = r2.config.plotOptions.radialBar.endAngle, s3.totalAngle = Math.abs(r2.config.plotOptions.radialBar.endAngle - r2.config.plotOptions.radialBar.startAngle), s3.trackStartAngle = r2.config.plotOptions.radialBar.track.startAngle, s3.trackEndAngle = r2.config.plotOptions.radialBar.track.endAngle, s3.barLabels = s3.w.config.plotOptions.radialBar.barLabels, s3.donutDataLabels = s3.w.config.plotOptions.radialBar.dataLabels, s3.radialDataLabels = s3.donutDataLabels, s3.trackStartAngle || (s3.trackStartAngle = s3.startAngle), s3.trackEndAngle || (s3.trackEndAngle = s3.endAngle), 360 === s3.endAngle && (s3.endAngle = 359.99), s3.margin = parseInt(r2.config.plotOptions.radialBar.track.margin, 10), s3.onBarLabelClick = s3.onBarLabelClick.bind(c2(s3)), s3;
    }
    return r(i2, [{ key: "draw", value: function(t4) {
      var e4 = this.w, i3 = new m2(this.ctx), a3 = i3.group({ class: "apexcharts-radialbar" });
      if (e4.globals.noData) return a3;
      var s3 = i3.group(), r2 = this.defaultSize / 2, o3 = e4.globals.gridWidth / 2, n3 = this.defaultSize / 2.05;
      e4.config.chart.sparkline.enabled || (n3 = n3 - e4.config.stroke.width - e4.config.chart.dropShadow.blur);
      var l3 = e4.globals.fill.colors;
      if (e4.config.plotOptions.radialBar.track.show) {
        var h3 = this.drawTracks({ size: n3, centerX: o3, centerY: r2, colorArr: l3, series: t4 });
        s3.add(h3);
      }
      var c3 = this.drawArcs({ size: n3, centerX: o3, centerY: r2, colorArr: l3, series: t4 }), d3 = 360;
      e4.config.plotOptions.radialBar.startAngle < 0 && (d3 = this.totalAngle);
      var g3 = (360 - d3) / 360;
      if (e4.globals.radialSize = n3 - n3 * g3, this.radialDataLabels.value.show) {
        var u3 = Math.max(this.radialDataLabels.value.offsetY, this.radialDataLabels.name.offsetY);
        e4.globals.radialSize += u3 * g3;
      }
      return s3.add(c3.g), "front" === e4.config.plotOptions.radialBar.hollow.position && (c3.g.add(c3.elHollow), c3.dataLabels && c3.g.add(c3.dataLabels)), a3.add(s3), a3;
    } }, { key: "drawTracks", value: function(t4) {
      var e4 = this.w, i3 = new m2(this.ctx), a3 = i3.group({ class: "apexcharts-tracks" }), s3 = new v2(this.ctx), r2 = new H4(this.ctx), o3 = this.getStrokeWidth(t4);
      t4.size = t4.size - o3 / 2;
      for (var n3 = 0; n3 < t4.series.length; n3++) {
        var l3 = i3.group({ class: "apexcharts-radialbar-track apexcharts-track" });
        a3.add(l3), l3.attr({ rel: n3 + 1 }), t4.size = t4.size - o3 - this.margin;
        var h3 = e4.config.plotOptions.radialBar.track, c3 = r2.fillPath({ seriesNumber: 0, size: t4.size, fillColors: Array.isArray(h3.background) ? h3.background[n3] : h3.background, solid: true }), d3 = this.trackStartAngle, g3 = this.trackEndAngle;
        Math.abs(g3) + Math.abs(d3) >= 360 && (g3 = 360 - Math.abs(this.startAngle) - 0.1);
        var u3 = i3.drawPath({ d: "", stroke: c3, strokeWidth: o3 * parseInt(h3.strokeWidth, 10) / 100, fill: "none", strokeOpacity: h3.opacity, classes: "apexcharts-radialbar-area" });
        if (h3.dropShadow.enabled) {
          var p3 = h3.dropShadow;
          s3.dropShadow(u3, p3);
        }
        l3.add(u3), u3.attr("id", "apexcharts-radialbarTrack-" + n3), this.animatePaths(u3, { centerX: t4.centerX, centerY: t4.centerY, endAngle: g3, startAngle: d3, size: t4.size, i: n3, totalItems: 2, animBeginArr: 0, dur: 0, isTrack: true, easing: e4.globals.easing });
      }
      return a3;
    } }, { key: "drawArcs", value: function(t4) {
      var e4 = this.w, i3 = new m2(this.ctx), a3 = new H4(this.ctx), s3 = new v2(this.ctx), r2 = i3.group(), o3 = this.getStrokeWidth(t4);
      t4.size = t4.size - o3 / 2;
      var n3 = e4.config.plotOptions.radialBar.hollow.background, l3 = t4.size - o3 * t4.series.length - this.margin * t4.series.length - o3 * parseInt(e4.config.plotOptions.radialBar.track.strokeWidth, 10) / 100 / 2, h3 = l3 - e4.config.plotOptions.radialBar.hollow.margin;
      void 0 !== e4.config.plotOptions.radialBar.hollow.image && (n3 = this.drawHollowImage(t4, r2, l3, n3));
      var c3 = this.drawHollow({ size: h3, centerX: t4.centerX, centerY: t4.centerY, fill: n3 || "transparent" });
      if (e4.config.plotOptions.radialBar.hollow.dropShadow.enabled) {
        var d3 = e4.config.plotOptions.radialBar.hollow.dropShadow;
        s3.dropShadow(c3, d3);
      }
      var g3 = 1;
      !this.radialDataLabels.total.show && e4.globals.series.length > 1 && (g3 = 0);
      var u3 = null;
      if (this.radialDataLabels.show) {
        var p3 = e4.globals.dom.Paper.select(".apexcharts-datalabels-group").members[0];
        u3 = this.renderInnerDataLabels(p3, this.radialDataLabels, { hollowSize: l3, centerX: t4.centerX, centerY: t4.centerY, opacity: g3 });
      }
      "back" === e4.config.plotOptions.radialBar.hollow.position && (r2.add(c3), u3 && r2.add(u3));
      var f3 = false;
      e4.config.plotOptions.radialBar.inverseOrder && (f3 = true);
      for (var b3 = f3 ? t4.series.length - 1 : 0; f3 ? b3 >= 0 : b3 < t4.series.length; f3 ? b3-- : b3++) {
        var y3 = i3.group({ class: "apexcharts-series apexcharts-radial-series", seriesName: x2.escapeString(e4.globals.seriesNames[b3]) });
        r2.add(y3), y3.attr({ rel: b3 + 1, "data:realIndex": b3 }), this.ctx.series.addCollapsedClassToSeries(y3, b3), t4.size = t4.size - o3 - this.margin;
        var w3 = a3.fillPath({ seriesNumber: b3, size: t4.size, value: t4.series[b3] }), k3 = this.startAngle, A3 = void 0, S3 = x2.negToZero(t4.series[b3] > 100 ? 100 : t4.series[b3]) / 100, C3 = Math.round(this.totalAngle * S3) + this.startAngle, L3 = void 0;
        e4.globals.dataChanged && (A3 = this.startAngle, L3 = Math.round(this.totalAngle * x2.negToZero(e4.globals.previousPaths[b3]) / 100) + A3), Math.abs(C3) + Math.abs(k3) >= 360 && (C3 -= 0.01), Math.abs(L3) + Math.abs(A3) >= 360 && (L3 -= 0.01);
        var P3 = C3 - k3, M3 = Array.isArray(e4.config.stroke.dashArray) ? e4.config.stroke.dashArray[b3] : e4.config.stroke.dashArray, I3 = i3.drawPath({ d: "", stroke: w3, strokeWidth: o3, fill: "none", fillOpacity: e4.config.fill.opacity, classes: "apexcharts-radialbar-area apexcharts-radialbar-slice-" + b3, strokeDashArray: M3 });
        if (m2.setAttrs(I3.node, { "data:angle": P3, "data:value": t4.series[b3] }), e4.config.chart.dropShadow.enabled) {
          var T3 = e4.config.chart.dropShadow;
          s3.dropShadow(I3, T3, b3);
        }
        if (s3.setSelectionFilter(I3, 0, b3), this.addListeners(I3, this.radialDataLabels), y3.add(I3), I3.attr({ index: 0, j: b3 }), this.barLabels.enabled) {
          var z3 = x2.polarToCartesian(t4.centerX, t4.centerY, t4.size, k3), X3 = this.barLabels.formatter(e4.globals.seriesNames[b3], { seriesIndex: b3, w: e4 }), E3 = ["apexcharts-radialbar-label"];
          this.barLabels.onClick || E3.push("apexcharts-no-click");
          var Y3 = this.barLabels.useSeriesColors ? e4.globals.colors[b3] : e4.config.chart.foreColor;
          Y3 || (Y3 = e4.config.chart.foreColor);
          var F3 = z3.x - this.barLabels.margin, R3 = z3.y, D3 = i3.drawText({ x: F3, y: R3, text: X3, textAnchor: "end", dominantBaseline: "middle", fontFamily: this.barLabels.fontFamily, fontWeight: this.barLabels.fontWeight, fontSize: this.barLabels.fontSize, foreColor: Y3, cssClass: E3.join(" ") });
          D3.on("click", this.onBarLabelClick), D3.attr({ rel: b3 + 1 }), 0 !== k3 && D3.attr({ "transform-origin": "".concat(F3, " ").concat(R3), transform: "rotate(".concat(k3, " 0 0)") }), y3.add(D3);
        }
        var O3 = 0;
        !this.initialAnim || e4.globals.resized || e4.globals.dataChanged || (O3 = e4.config.chart.animations.speed), e4.globals.dataChanged && (O3 = e4.config.chart.animations.dynamicAnimation.speed), this.animDur = O3 / (1.2 * t4.series.length) + this.animDur, this.animBeginArr.push(this.animDur), this.animatePaths(I3, { centerX: t4.centerX, centerY: t4.centerY, endAngle: C3, startAngle: k3, prevEndAngle: L3, prevStartAngle: A3, size: t4.size, i: b3, totalItems: 2, animBeginArr: this.animBeginArr, dur: O3, shouldSetPrevPaths: true, easing: e4.globals.easing });
      }
      return { g: r2, elHollow: c3, dataLabels: u3 };
    } }, { key: "drawHollow", value: function(t4) {
      var e4 = new m2(this.ctx).drawCircle(2 * t4.size);
      return e4.attr({ class: "apexcharts-radialbar-hollow", cx: t4.centerX, cy: t4.centerY, r: t4.size, fill: t4.fill }), e4;
    } }, { key: "drawHollowImage", value: function(t4, e4, i3, a3) {
      var s3 = this.w, r2 = new H4(this.ctx), o3 = x2.randomId(), n3 = s3.config.plotOptions.radialBar.hollow.image;
      if (s3.config.plotOptions.radialBar.hollow.imageClipped) r2.clippedImgArea({ width: i3, height: i3, image: n3, patternID: "pattern".concat(s3.globals.cuid).concat(o3) }), a3 = "url(#pattern".concat(s3.globals.cuid).concat(o3, ")");
      else {
        var l3 = s3.config.plotOptions.radialBar.hollow.imageWidth, h3 = s3.config.plotOptions.radialBar.hollow.imageHeight;
        if (void 0 === l3 && void 0 === h3) {
          var c3 = s3.globals.dom.Paper.image(n3).loaded(function(e5) {
            this.move(t4.centerX - e5.width / 2 + s3.config.plotOptions.radialBar.hollow.imageOffsetX, t4.centerY - e5.height / 2 + s3.config.plotOptions.radialBar.hollow.imageOffsetY);
          });
          e4.add(c3);
        } else {
          var d3 = s3.globals.dom.Paper.image(n3).loaded(function(e5) {
            this.move(t4.centerX - l3 / 2 + s3.config.plotOptions.radialBar.hollow.imageOffsetX, t4.centerY - h3 / 2 + s3.config.plotOptions.radialBar.hollow.imageOffsetY), this.size(l3, h3);
          });
          e4.add(d3);
        }
      }
      return a3;
    } }, { key: "getStrokeWidth", value: function(t4) {
      var e4 = this.w;
      return t4.size * (100 - parseInt(e4.config.plotOptions.radialBar.hollow.size, 10)) / 100 / (t4.series.length + 1) - this.margin;
    } }, { key: "onBarLabelClick", value: function(t4) {
      var e4 = parseInt(t4.target.getAttribute("rel"), 10) - 1, i3 = this.barLabels.onClick, a3 = this.w;
      i3 && i3(a3.globals.seriesNames[e4], { w: a3, seriesIndex: e4 });
    } }]), i2;
  }(), It2 = function(t3) {
    n2(s3, yt2);
    var i2 = d2(s3);
    function s3() {
      return a2(this, s3), i2.apply(this, arguments);
    }
    return r(s3, [{ key: "draw", value: function(t4, i3) {
      var a3 = this.w, s4 = new m2(this.ctx);
      this.rangeBarOptions = this.w.config.plotOptions.rangeBar, this.series = t4, this.seriesRangeStart = a3.globals.seriesRangeStart, this.seriesRangeEnd = a3.globals.seriesRangeEnd, this.barHelpers.initVariables(t4);
      for (var r2 = s4.group({ class: "apexcharts-rangebar-series apexcharts-plot-series" }), o3 = 0; o3 < t4.length; o3++) {
        var n3, l3, h3, c3, d3 = void 0, g3 = void 0, u3 = a3.globals.comboCharts ? i3[o3] : o3, p3 = this.barHelpers.getGroupIndex(u3).columnGroupIndex, f3 = s4.group({ class: "apexcharts-series", seriesName: x2.escapeString(a3.globals.seriesNames[u3]), rel: o3 + 1, "data:realIndex": u3 });
        this.ctx.series.addCollapsedClassToSeries(f3, u3), t4[o3].length > 0 && (this.visibleI = this.visibleI + 1);
        var b3 = 0, v3 = 0, y3 = 0;
        this.yRatio.length > 1 && (this.yaxisIndex = a3.globals.seriesYAxisReverseMap[u3][0], y3 = u3);
        var w3 = this.barHelpers.initialPositions();
        g3 = w3.y, c3 = w3.zeroW, d3 = w3.x, v3 = w3.barWidth, b3 = w3.barHeight, n3 = w3.xDivision, l3 = w3.yDivision, h3 = w3.zeroH;
        for (var k3 = s4.group({ class: "apexcharts-datalabels", "data:realIndex": u3 }), A3 = s4.group({ class: "apexcharts-rangebar-goals-markers" }), S3 = 0; S3 < a3.globals.dataPoints; S3++) {
          var C3 = this.barHelpers.getStrokeWidth(o3, S3, u3), L3 = this.seriesRangeStart[o3][S3], P3 = this.seriesRangeEnd[o3][S3], M3 = null, I3 = null, T3 = null, z3 = { x: d3, y: g3, strokeWidth: C3, elSeries: f3 }, X3 = this.seriesLen;
          if (a3.config.plotOptions.bar.rangeBarGroupRows && (X3 = 1), void 0 === a3.config.series[o3].data[S3]) break;
          if (this.isHorizontal) {
            T3 = g3 + b3 * this.visibleI;
            var E3 = (l3 - b3 * X3) / 2;
            if (a3.config.series[o3].data[S3].x) {
              var Y3 = this.detectOverlappingBars({ i: o3, j: S3, barYPosition: T3, srty: E3, barHeight: b3, yDivision: l3, initPositions: w3 });
              b3 = Y3.barHeight, T3 = Y3.barYPosition;
            }
            v3 = (M3 = this.drawRangeBarPaths(e2({ indexes: { i: o3, j: S3, realIndex: u3 }, barHeight: b3, barYPosition: T3, zeroW: c3, yDivision: l3, y1: L3, y2: P3 }, z3))).barWidth;
          } else {
            a3.globals.isXNumeric && (d3 = (a3.globals.seriesX[o3][S3] - a3.globals.minX) / this.xRatio - v3 / 2), I3 = d3 + v3 * this.visibleI;
            var F3 = (n3 - v3 * X3) / 2;
            if (a3.config.series[o3].data[S3].x) {
              var R3 = this.detectOverlappingBars({ i: o3, j: S3, barXPosition: I3, srtx: F3, barWidth: v3, xDivision: n3, initPositions: w3 });
              v3 = R3.barWidth, I3 = R3.barXPosition;
            }
            b3 = (M3 = this.drawRangeColumnPaths(e2({ indexes: { i: o3, j: S3, realIndex: u3, translationsIndex: y3 }, barWidth: v3, barXPosition: I3, zeroH: h3, xDivision: n3 }, z3))).barHeight;
          }
          var H5 = this.barHelpers.drawGoalLine({ barXPosition: M3.barXPosition, barYPosition: T3, goalX: M3.goalX, goalY: M3.goalY, barHeight: b3, barWidth: v3 });
          H5 && A3.add(H5), g3 = M3.y, d3 = M3.x;
          var D3 = this.barHelpers.getPathFillColor(t4, o3, S3, u3), O3 = a3.globals.stroke.colors[u3];
          this.renderSeries({ realIndex: u3, pathFill: D3, lineFill: O3, j: S3, i: o3, x: d3, y: g3, y1: L3, y2: P3, pathFrom: M3.pathFrom, pathTo: M3.pathTo, strokeWidth: C3, elSeries: f3, series: t4, barHeight: b3, barWidth: v3, barXPosition: I3, barYPosition: T3, columnGroupIndex: p3, elDataLabelsWrap: k3, elGoalsMarkers: A3, visibleSeries: this.visibleI, type: "rangebar" });
        }
        r2.add(f3);
      }
      return r2;
    } }, { key: "detectOverlappingBars", value: function(t4) {
      var e3 = t4.i, i3 = t4.j, a3 = t4.barYPosition, s4 = t4.barXPosition, r2 = t4.srty, o3 = t4.srtx, n3 = t4.barHeight, l3 = t4.barWidth, h3 = t4.yDivision, c3 = t4.xDivision, d3 = t4.initPositions, g3 = this.w, u3 = [], p3 = g3.config.series[e3].data[i3].rangeName, f3 = g3.config.series[e3].data[i3].x, x3 = Array.isArray(f3) ? f3.join(" ") : f3, b3 = g3.globals.labels.map(function(t5) {
        return Array.isArray(t5) ? t5.join(" ") : t5;
      }).indexOf(x3), v3 = g3.globals.seriesRange[e3].findIndex(function(t5) {
        return t5.x === x3 && t5.overlaps.length > 0;
      });
      return this.isHorizontal ? (a3 = g3.config.plotOptions.bar.rangeBarGroupRows ? r2 + h3 * b3 : r2 + n3 * this.visibleI + h3 * b3, v3 > -1 && !g3.config.plotOptions.bar.rangeBarOverlap && (u3 = g3.globals.seriesRange[e3][v3].overlaps).indexOf(p3) > -1 && (a3 = (n3 = d3.barHeight / u3.length) * this.visibleI + h3 * (100 - parseInt(this.barOptions.barHeight, 10)) / 100 / 2 + n3 * (this.visibleI + u3.indexOf(p3)) + h3 * b3)) : (b3 > -1 && !g3.globals.timescaleLabels.length && (s4 = g3.config.plotOptions.bar.rangeBarGroupRows ? o3 + c3 * b3 : o3 + l3 * this.visibleI + c3 * b3), v3 > -1 && !g3.config.plotOptions.bar.rangeBarOverlap && (u3 = g3.globals.seriesRange[e3][v3].overlaps).indexOf(p3) > -1 && (s4 = (l3 = d3.barWidth / u3.length) * this.visibleI + c3 * (100 - parseInt(this.barOptions.barWidth, 10)) / 100 / 2 + l3 * (this.visibleI + u3.indexOf(p3)) + c3 * b3)), { barYPosition: a3, barXPosition: s4, barHeight: n3, barWidth: l3 };
    } }, { key: "drawRangeColumnPaths", value: function(t4) {
      var e3 = t4.indexes, i3 = t4.x, a3 = t4.xDivision, s4 = t4.barWidth, r2 = t4.barXPosition, o3 = t4.zeroH, n3 = this.w, l3 = e3.i, h3 = e3.j, c3 = e3.realIndex, d3 = e3.translationsIndex, g3 = this.yRatio[d3], u3 = this.getRangeValue(c3, h3), p3 = Math.min(u3.start, u3.end), f3 = Math.max(u3.start, u3.end);
      void 0 === this.series[l3][h3] || null === this.series[l3][h3] ? p3 = o3 : (p3 = o3 - p3 / g3, f3 = o3 - f3 / g3);
      var x3 = Math.abs(f3 - p3), b3 = this.barHelpers.getColumnPaths({ barXPosition: r2, barWidth: s4, y1: p3, y2: f3, strokeWidth: this.strokeWidth, series: this.seriesRangeEnd, realIndex: c3, i: c3, j: h3, w: n3 });
      if (n3.globals.isXNumeric) {
        var v3 = this.getBarXForNumericXAxis({ x: i3, j: h3, realIndex: c3, barWidth: s4 });
        i3 = v3.x, r2 = v3.barXPosition;
      } else i3 += a3;
      return { pathTo: b3.pathTo, pathFrom: b3.pathFrom, barHeight: x3, x: i3, y: u3.start < 0 && u3.end < 0 ? p3 : f3, goalY: this.barHelpers.getGoalValues("y", null, o3, l3, h3, d3), barXPosition: r2 };
    } }, { key: "preventBarOverflow", value: function(t4) {
      var e3 = this.w;
      return t4 < 0 && (t4 = 0), t4 > e3.globals.gridWidth && (t4 = e3.globals.gridWidth), t4;
    } }, { key: "drawRangeBarPaths", value: function(t4) {
      var e3 = t4.indexes, i3 = t4.y, a3 = t4.y1, s4 = t4.y2, r2 = t4.yDivision, o3 = t4.barHeight, n3 = t4.barYPosition, l3 = t4.zeroW, h3 = this.w, c3 = e3.realIndex, d3 = e3.j, g3 = this.preventBarOverflow(l3 + a3 / this.invertedYRatio), u3 = this.preventBarOverflow(l3 + s4 / this.invertedYRatio), p3 = this.getRangeValue(c3, d3), f3 = Math.abs(u3 - g3), x3 = this.barHelpers.getBarpaths({ barYPosition: n3, barHeight: o3, x1: g3, x2: u3, strokeWidth: this.strokeWidth, series: this.seriesRangeEnd, i: c3, realIndex: c3, j: d3, w: h3 });
      return h3.globals.isXNumeric || (i3 += r2), { pathTo: x3.pathTo, pathFrom: x3.pathFrom, barWidth: f3, x: p3.start < 0 && p3.end < 0 ? g3 : u3, goalX: this.barHelpers.getGoalValues("x", l3, null, c3, d3), y: i3 };
    } }, { key: "getRangeValue", value: function(t4, e3) {
      var i3 = this.w;
      return { start: i3.globals.seriesRangeStart[t4][e3], end: i3.globals.seriesRangeEnd[t4][e3] };
    } }]), s3;
  }(), Tt2 = function() {
    function t3(e3) {
      a2(this, t3), this.w = e3.w, this.lineCtx = e3;
    }
    return r(t3, [{ key: "sameValueSeriesFix", value: function(t4, e3) {
      var i2 = this.w;
      if (("gradient" === i2.config.fill.type || "gradient" === i2.config.fill.type[t4]) && new y2(this.lineCtx.ctx, i2).seriesHaveSameValues(t4)) {
        var a3 = e3[t4].slice();
        a3[a3.length - 1] = a3[a3.length - 1] + 1e-6, e3[t4] = a3;
      }
      return e3;
    } }, { key: "calculatePoints", value: function(t4) {
      var e3 = t4.series, i2 = t4.realIndex, a3 = t4.x, s3 = t4.y, r2 = t4.i, o3 = t4.j, n3 = t4.prevY, l3 = this.w, h3 = [], c3 = [];
      if (0 === o3) {
        var d3 = this.lineCtx.categoryAxisCorrection + l3.config.markers.offsetX;
        l3.globals.isXNumeric && (d3 = (l3.globals.seriesX[i2][0] - l3.globals.minX) / this.lineCtx.xRatio + l3.config.markers.offsetX), h3.push(d3), c3.push(x2.isNumber(e3[r2][0]) ? n3 + l3.config.markers.offsetY : null), h3.push(a3 + l3.config.markers.offsetX), c3.push(x2.isNumber(e3[r2][o3 + 1]) ? s3 + l3.config.markers.offsetY : null);
      } else h3.push(a3 + l3.config.markers.offsetX), c3.push(x2.isNumber(e3[r2][o3 + 1]) ? s3 + l3.config.markers.offsetY : null);
      return { x: h3, y: c3 };
    } }, { key: "checkPreviousPaths", value: function(t4) {
      for (var e3 = t4.pathFromLine, i2 = t4.pathFromArea, a3 = t4.realIndex, s3 = this.w, r2 = 0; r2 < s3.globals.previousPaths.length; r2++) {
        var o3 = s3.globals.previousPaths[r2];
        ("line" === o3.type || "area" === o3.type) && o3.paths.length > 0 && parseInt(o3.realIndex, 10) === parseInt(a3, 10) && ("line" === o3.type ? (this.lineCtx.appendPathFrom = false, e3 = s3.globals.previousPaths[r2].paths[0].d) : "area" === o3.type && (this.lineCtx.appendPathFrom = false, i2 = s3.globals.previousPaths[r2].paths[0].d, s3.config.stroke.show && s3.globals.previousPaths[r2].paths[1] && (e3 = s3.globals.previousPaths[r2].paths[1].d)));
      }
      return { pathFromLine: e3, pathFromArea: i2 };
    } }, { key: "determineFirstPrevY", value: function(t4) {
      var e3, i2, a3, s3 = t4.i, r2 = t4.realIndex, o3 = t4.series, n3 = t4.prevY, l3 = t4.lineYPosition, h3 = t4.translationsIndex, c3 = this.w, d3 = c3.config.chart.stacked && !c3.globals.comboCharts || c3.config.chart.stacked && c3.globals.comboCharts && (!this.w.config.chart.stackOnlyBar || "bar" === (null === (e3 = this.w.config.series[r2]) || void 0 === e3 ? void 0 : e3.type) || "column" === (null === (i2 = this.w.config.series[r2]) || void 0 === i2 ? void 0 : i2.type));
      if (void 0 !== (null === (a3 = o3[s3]) || void 0 === a3 ? void 0 : a3[0])) n3 = (l3 = d3 && s3 > 0 ? this.lineCtx.prevSeriesY[s3 - 1][0] : this.lineCtx.zeroY) - o3[s3][0] / this.lineCtx.yRatio[h3] + 2 * (this.lineCtx.isReversed ? o3[s3][0] / this.lineCtx.yRatio[h3] : 0);
      else if (d3 && s3 > 0 && void 0 === o3[s3][0]) {
        for (var g3 = s3 - 1; g3 >= 0; g3--) if (null !== o3[g3][0] && void 0 !== o3[g3][0]) {
          n3 = l3 = this.lineCtx.prevSeriesY[g3][0];
          break;
        }
      }
      return { prevY: n3, lineYPosition: l3 };
    } }]), t3;
  }(), zt2 = function(t3) {
    for (var e3, i2, a3, s3, r2 = function(t4) {
      for (var e4 = [], i3 = t4[0], a4 = t4[1], s4 = e4[0] = Yt2(i3, a4), r3 = 1, o4 = t4.length - 1; r3 < o4; r3++) i3 = a4, a4 = t4[r3 + 1], e4[r3] = 0.5 * (s4 + (s4 = Yt2(i3, a4)));
      return e4[r3] = s4, e4;
    }(t3), o3 = t3.length - 1, n3 = [], l3 = 0; l3 < o3; l3++) a3 = Yt2(t3[l3], t3[l3 + 1]), Math.abs(a3) < 1e-6 ? r2[l3] = r2[l3 + 1] = 0 : (s3 = (e3 = r2[l3] / a3) * e3 + (i2 = r2[l3 + 1] / a3) * i2) > 9 && (s3 = 3 * a3 / Math.sqrt(s3), r2[l3] = s3 * e3, r2[l3 + 1] = s3 * i2);
    for (var h3 = 0; h3 <= o3; h3++) s3 = (t3[Math.min(o3, h3 + 1)][0] - t3[Math.max(0, h3 - 1)][0]) / (6 * (1 + r2[h3] * r2[h3])), n3.push([s3 || 0, r2[h3] * s3 || 0]);
    return n3;
  }, Xt2 = function(t3) {
    var e3 = zt2(t3), i2 = t3[1], a3 = t3[0], s3 = [], r2 = e3[1], o3 = e3[0];
    s3.push(a3, [a3[0] + o3[0], a3[1] + o3[1], i2[0] - r2[0], i2[1] - r2[1], i2[0], i2[1]]);
    for (var n3 = 2, l3 = e3.length; n3 < l3; n3++) {
      var h3 = t3[n3], c3 = e3[n3];
      s3.push([h3[0] - c3[0], h3[1] - c3[1], h3[0], h3[1]]);
    }
    return s3;
  }, Et2 = function(t3, e3, i2) {
    var a3 = t3.slice(e3, i2);
    if (e3) {
      if (i2 - e3 > 1 && a3[1].length < 6) {
        var s3 = a3[0].length;
        a3[1] = [2 * a3[0][s3 - 2] - a3[0][s3 - 4], 2 * a3[0][s3 - 1] - a3[0][s3 - 3]].concat(a3[1]);
      }
      a3[0] = a3[0].slice(-2);
    }
    return a3;
  };
  function Yt2(t3, e3) {
    return (e3[1] - t3[1]) / (e3[0] - t3[0]);
  }
  var Ft2 = function() {
    function t3(e3, i2, s3) {
      a2(this, t3), this.ctx = e3, this.w = e3.w, this.xyRatios = i2, this.pointsChart = !("bubble" !== this.w.config.chart.type && "scatter" !== this.w.config.chart.type) || s3, this.scatter = new O2(this.ctx), this.noNegatives = this.w.globals.minX === Number.MAX_VALUE, this.lineHelpers = new Tt2(this), this.markers = new D2(this.ctx), this.prevSeriesY = [], this.categoryAxisCorrection = 0, this.yaxisIndex = 0;
    }
    return r(t3, [{ key: "draw", value: function(t4, i2, a3, s3) {
      var r2, o3 = this.w, n3 = new m2(this.ctx), l3 = o3.globals.comboCharts ? i2 : o3.config.chart.type, h3 = n3.group({ class: "apexcharts-".concat(l3, "-series apexcharts-plot-series") }), c3 = new y2(this.ctx, o3);
      this.yRatio = this.xyRatios.yRatio, this.zRatio = this.xyRatios.zRatio, this.xRatio = this.xyRatios.xRatio, this.baseLineY = this.xyRatios.baseLineY, t4 = c3.getLogSeries(t4), this.yRatio = c3.getLogYRatios(this.yRatio), this.prevSeriesY = [];
      for (var d3 = [], g3 = 0; g3 < t4.length; g3++) {
        t4 = this.lineHelpers.sameValueSeriesFix(g3, t4);
        var u3 = o3.globals.comboCharts ? a3[g3] : g3, p3 = this.yRatio.length > 1 ? u3 : 0;
        this._initSerieVariables(t4, g3, u3);
        var f3 = [], x3 = [], b3 = [], v3 = o3.globals.padHorizontal + this.categoryAxisCorrection;
        this.ctx.series.addCollapsedClassToSeries(this.elSeries, u3), o3.globals.isXNumeric && o3.globals.seriesX.length > 0 && (v3 = (o3.globals.seriesX[u3][0] - o3.globals.minX) / this.xRatio), b3.push(v3);
        var w3, k3 = v3, A3 = void 0, S3 = k3, C3 = this.zeroY, L3 = this.zeroY;
        C3 = this.lineHelpers.determineFirstPrevY({ i: g3, realIndex: u3, series: t4, prevY: C3, lineYPosition: 0, translationsIndex: p3 }).prevY, "monotoneCubic" === o3.config.stroke.curve && null === t4[g3][0] ? f3.push(null) : f3.push(C3), w3 = C3;
        "rangeArea" === l3 && (A3 = L3 = this.lineHelpers.determineFirstPrevY({ i: g3, realIndex: u3, series: s3, prevY: L3, lineYPosition: 0, translationsIndex: p3 }).prevY, x3.push(null !== f3[0] ? L3 : null));
        var P3 = this._calculatePathsFrom({ type: l3, series: t4, i: g3, realIndex: u3, translationsIndex: p3, prevX: S3, prevY: C3, prevY2: L3 }), M3 = [f3[0]], I3 = [x3[0]], T3 = { type: l3, series: t4, realIndex: u3, translationsIndex: p3, i: g3, x: v3, y: 1, pX: k3, pY: w3, pathsFrom: P3, linePaths: [], areaPaths: [], seriesIndex: a3, lineYPosition: 0, xArrj: b3, yArrj: f3, y2Arrj: x3, seriesRangeEnd: s3 }, z3 = this._iterateOverDataPoints(e2(e2({}, T3), {}, { iterations: "rangeArea" === l3 ? t4[g3].length - 1 : void 0, isRangeStart: true }));
        if ("rangeArea" === l3) {
          for (var X3 = this._calculatePathsFrom({ series: s3, i: g3, realIndex: u3, prevX: S3, prevY: L3 }), E3 = this._iterateOverDataPoints(e2(e2({}, T3), {}, { series: s3, xArrj: [v3], yArrj: M3, y2Arrj: I3, pY: A3, areaPaths: z3.areaPaths, pathsFrom: X3, iterations: s3[g3].length - 1, isRangeStart: false })), Y3 = z3.linePaths.length / 2, F3 = 0; F3 < Y3; F3++) z3.linePaths[F3] = E3.linePaths[F3 + Y3] + z3.linePaths[F3];
          z3.linePaths.splice(Y3), z3.pathFromLine = E3.pathFromLine + z3.pathFromLine;
        } else z3.pathFromArea += "z";
        this._handlePaths({ type: l3, realIndex: u3, i: g3, paths: z3 }), this.elSeries.add(this.elPointsMain), this.elSeries.add(this.elDataLabelsWrap), d3.push(this.elSeries);
      }
      if (void 0 !== (null === (r2 = o3.config.series[0]) || void 0 === r2 ? void 0 : r2.zIndex) && d3.sort(function(t5, e3) {
        return Number(t5.node.getAttribute("zIndex")) - Number(e3.node.getAttribute("zIndex"));
      }), o3.config.chart.stacked) for (var R3 = d3.length - 1; R3 >= 0; R3--) h3.add(d3[R3]);
      else for (var H5 = 0; H5 < d3.length; H5++) h3.add(d3[H5]);
      return h3;
    } }, { key: "_initSerieVariables", value: function(t4, e3, i2) {
      var a3 = this.w, s3 = new m2(this.ctx);
      this.xDivision = a3.globals.gridWidth / (a3.globals.dataPoints - ("on" === a3.config.xaxis.tickPlacement ? 1 : 0)), this.strokeWidth = Array.isArray(a3.config.stroke.width) ? a3.config.stroke.width[i2] : a3.config.stroke.width;
      var r2 = 0;
      this.yRatio.length > 1 && (this.yaxisIndex = a3.globals.seriesYAxisReverseMap[i2], r2 = i2), this.isReversed = a3.config.yaxis[this.yaxisIndex] && a3.config.yaxis[this.yaxisIndex].reversed, this.zeroY = a3.globals.gridHeight - this.baseLineY[r2] - (this.isReversed ? a3.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[r2] : 0), this.areaBottomY = this.zeroY, (this.zeroY > a3.globals.gridHeight || "end" === a3.config.plotOptions.area.fillTo) && (this.areaBottomY = a3.globals.gridHeight), this.categoryAxisCorrection = this.xDivision / 2, this.elSeries = s3.group({ class: "apexcharts-series", zIndex: void 0 !== a3.config.series[i2].zIndex ? a3.config.series[i2].zIndex : i2, seriesName: x2.escapeString(a3.globals.seriesNames[i2]) }), this.elPointsMain = s3.group({ class: "apexcharts-series-markers-wrap", "data:realIndex": i2 }), this.elDataLabelsWrap = s3.group({ class: "apexcharts-datalabels", "data:realIndex": i2 });
      var o3 = t4[e3].length === a3.globals.dataPoints;
      this.elSeries.attr({ "data:longestSeries": o3, rel: e3 + 1, "data:realIndex": i2 }), this.appendPathFrom = true;
    } }, { key: "_calculatePathsFrom", value: function(t4) {
      var e3, i2, a3, s3, r2 = t4.type, o3 = t4.series, n3 = t4.i, l3 = t4.realIndex, h3 = t4.translationsIndex, c3 = t4.prevX, d3 = t4.prevY, g3 = t4.prevY2, u3 = this.w, p3 = new m2(this.ctx);
      if (null === o3[n3][0]) {
        for (var f3 = 0; f3 < o3[n3].length; f3++) if (null !== o3[n3][f3]) {
          c3 = this.xDivision * f3, d3 = this.zeroY - o3[n3][f3] / this.yRatio[h3], e3 = p3.move(c3, d3), i2 = p3.move(c3, this.areaBottomY);
          break;
        }
      } else e3 = p3.move(c3, d3), "rangeArea" === r2 && (e3 = p3.move(c3, g3) + p3.line(c3, d3)), i2 = p3.move(c3, this.areaBottomY) + p3.line(c3, d3);
      if (a3 = p3.move(0, this.zeroY) + p3.line(0, this.zeroY), s3 = p3.move(0, this.zeroY) + p3.line(0, this.zeroY), u3.globals.previousPaths.length > 0) {
        var x3 = this.lineHelpers.checkPreviousPaths({ pathFromLine: a3, pathFromArea: s3, realIndex: l3 });
        a3 = x3.pathFromLine, s3 = x3.pathFromArea;
      }
      return { prevX: c3, prevY: d3, linePath: e3, areaPath: i2, pathFromLine: a3, pathFromArea: s3 };
    } }, { key: "_handlePaths", value: function(t4) {
      var i2 = t4.type, a3 = t4.realIndex, s3 = t4.i, r2 = t4.paths, o3 = this.w, n3 = new m2(this.ctx), l3 = new H4(this.ctx);
      this.prevSeriesY.push(r2.yArrj), o3.globals.seriesXvalues[a3] = r2.xArrj, o3.globals.seriesYvalues[a3] = r2.yArrj;
      var h3 = o3.config.forecastDataPoints;
      if (h3.count > 0 && "rangeArea" !== i2) {
        var c3 = o3.globals.seriesXvalues[a3][o3.globals.seriesXvalues[a3].length - h3.count - 1], d3 = n3.drawRect(c3, 0, o3.globals.gridWidth, o3.globals.gridHeight, 0);
        o3.globals.dom.elForecastMask.appendChild(d3.node);
        var g3 = n3.drawRect(0, 0, c3, o3.globals.gridHeight, 0);
        o3.globals.dom.elNonForecastMask.appendChild(g3.node);
      }
      this.pointsChart || o3.globals.delayedElements.push({ el: this.elPointsMain.node, index: a3 });
      var u3 = { i: s3, realIndex: a3, animationDelay: s3, initialSpeed: o3.config.chart.animations.speed, dataChangeSpeed: o3.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-".concat(i2) };
      if ("area" === i2) for (var p3 = l3.fillPath({ seriesNumber: a3 }), f3 = 0; f3 < r2.areaPaths.length; f3++) {
        var x3 = n3.renderPaths(e2(e2({}, u3), {}, { pathFrom: r2.pathFromArea, pathTo: r2.areaPaths[f3], stroke: "none", strokeWidth: 0, strokeLineCap: null, fill: p3 }));
        this.elSeries.add(x3);
      }
      if (o3.config.stroke.show && !this.pointsChart) {
        var b3 = null;
        if ("line" === i2) b3 = l3.fillPath({ seriesNumber: a3, i: s3 });
        else if ("solid" === o3.config.stroke.fill.type) b3 = o3.globals.stroke.colors[a3];
        else {
          var v3 = o3.config.fill;
          o3.config.fill = o3.config.stroke.fill, b3 = l3.fillPath({ seriesNumber: a3, i: s3 }), o3.config.fill = v3;
        }
        for (var y3 = 0; y3 < r2.linePaths.length; y3++) {
          var w3 = b3;
          "rangeArea" === i2 && (w3 = l3.fillPath({ seriesNumber: a3 }));
          var k3 = e2(e2({}, u3), {}, { pathFrom: r2.pathFromLine, pathTo: r2.linePaths[y3], stroke: b3, strokeWidth: this.strokeWidth, strokeLineCap: o3.config.stroke.lineCap, fill: "rangeArea" === i2 ? w3 : "none" }), A3 = n3.renderPaths(k3);
          if (this.elSeries.add(A3), A3.attr("fill-rule", "evenodd"), h3.count > 0 && "rangeArea" !== i2) {
            var S3 = n3.renderPaths(k3);
            S3.node.setAttribute("stroke-dasharray", h3.dashArray), h3.strokeWidth && S3.node.setAttribute("stroke-width", h3.strokeWidth), this.elSeries.add(S3), S3.attr("clip-path", "url(#forecastMask".concat(o3.globals.cuid, ")")), A3.attr("clip-path", "url(#nonForecastMask".concat(o3.globals.cuid, ")"));
          }
        }
      }
    } }, { key: "_iterateOverDataPoints", value: function(t4) {
      var e3, i2, a3 = this, s3 = t4.type, r2 = t4.series, o3 = t4.iterations, n3 = t4.realIndex, l3 = t4.translationsIndex, h3 = t4.i, c3 = t4.x, d3 = t4.y, g3 = t4.pX, u3 = t4.pY, p3 = t4.pathsFrom, f3 = t4.linePaths, b3 = t4.areaPaths, v3 = t4.seriesIndex, y3 = t4.lineYPosition, w3 = t4.xArrj, k3 = t4.yArrj, A3 = t4.y2Arrj, S3 = t4.isRangeStart, C3 = t4.seriesRangeEnd, L3 = this.w, P3 = new m2(this.ctx), M3 = this.yRatio, I3 = p3.prevY, T3 = p3.linePath, z3 = p3.areaPath, X3 = p3.pathFromLine, E3 = p3.pathFromArea, Y3 = x2.isNumber(L3.globals.minYArr[n3]) ? L3.globals.minYArr[n3] : L3.globals.minY;
      o3 || (o3 = L3.globals.dataPoints > 1 ? L3.globals.dataPoints - 1 : L3.globals.dataPoints);
      var F3 = function(t5, e4) {
        return e4 - t5 / M3[l3] + 2 * (a3.isReversed ? t5 / M3[l3] : 0);
      }, R3 = d3, H5 = L3.config.chart.stacked && !L3.globals.comboCharts || L3.config.chart.stacked && L3.globals.comboCharts && (!this.w.config.chart.stackOnlyBar || "bar" === (null === (e3 = this.w.config.series[n3]) || void 0 === e3 ? void 0 : e3.type) || "column" === (null === (i2 = this.w.config.series[n3]) || void 0 === i2 ? void 0 : i2.type)), D3 = L3.config.stroke.curve;
      Array.isArray(D3) && (D3 = Array.isArray(v3) ? D3[v3[h3]] : D3[h3]);
      for (var O3, N3 = 0, W3 = 0; W3 < o3; W3++) {
        var B4 = void 0 === r2[h3][W3 + 1] || null === r2[h3][W3 + 1];
        if (L3.globals.isXNumeric) {
          var G3 = L3.globals.seriesX[n3][W3 + 1];
          void 0 === L3.globals.seriesX[n3][W3 + 1] && (G3 = L3.globals.seriesX[n3][o3 - 1]), c3 = (G3 - L3.globals.minX) / this.xRatio;
        } else c3 += this.xDivision;
        if (H5) if (h3 > 0 && L3.globals.collapsedSeries.length < L3.config.series.length - 1) {
          y3 = this.prevSeriesY[function(t5) {
            for (var e4 = t5; e4 > 0; e4--) {
              if (!(L3.globals.collapsedSeriesIndices.indexOf((null == v3 ? void 0 : v3[e4]) || e4) > -1)) return e4;
              e4--;
            }
            return 0;
          }(h3 - 1)][W3 + 1];
        } else y3 = this.zeroY;
        else y3 = this.zeroY;
        B4 ? d3 = F3(Y3, y3) : (d3 = F3(r2[h3][W3 + 1], y3), "rangeArea" === s3 && (R3 = F3(C3[h3][W3 + 1], y3))), w3.push(c3), !B4 || "smooth" !== L3.config.stroke.curve && "monotoneCubic" !== L3.config.stroke.curve ? (k3.push(d3), A3.push(R3)) : (k3.push(null), A3.push(null));
        var V3 = this.lineHelpers.calculatePoints({ series: r2, x: c3, y: d3, realIndex: n3, i: h3, j: W3, prevY: I3 }), j3 = this._createPaths({ type: s3, series: r2, i: h3, realIndex: n3, j: W3, x: c3, y: d3, y2: R3, xArrj: w3, yArrj: k3, y2Arrj: A3, pX: g3, pY: u3, pathState: N3, segmentStartX: O3, linePath: T3, areaPath: z3, linePaths: f3, areaPaths: b3, curve: D3, isRangeStart: S3 });
        b3 = j3.areaPaths, f3 = j3.linePaths, g3 = j3.pX, u3 = j3.pY, N3 = j3.pathState, O3 = j3.segmentStartX, z3 = j3.areaPath, T3 = j3.linePath, !this.appendPathFrom || "monotoneCubic" === D3 && "rangeArea" === s3 || (X3 += P3.line(c3, this.zeroY), E3 += P3.line(c3, this.zeroY)), this.handleNullDataPoints(r2, V3, h3, W3, n3), this._handleMarkersAndLabels({ type: s3, pointsPos: V3, i: h3, j: W3, realIndex: n3, isRangeStart: S3 });
      }
      return { yArrj: k3, xArrj: w3, pathFromArea: E3, areaPaths: b3, pathFromLine: X3, linePaths: f3, linePath: T3, areaPath: z3 };
    } }, { key: "_handleMarkersAndLabels", value: function(t4) {
      var e3 = t4.type, i2 = t4.pointsPos, a3 = t4.isRangeStart, s3 = t4.i, r2 = t4.j, o3 = t4.realIndex, n3 = this.w, l3 = new N2(this.ctx);
      if (this.pointsChart) this.scatter.draw(this.elSeries, r2, { realIndex: o3, pointsPos: i2, zRatio: this.zRatio, elParent: this.elPointsMain });
      else {
        n3.globals.series[s3].length > 1 && this.elPointsMain.node.classList.add("apexcharts-element-hidden");
        var h3 = this.markers.plotChartMarkers(i2, o3, r2 + 1);
        null !== h3 && this.elPointsMain.add(h3);
      }
      var c3 = l3.drawDataLabel({ type: e3, isRangeStart: a3, pos: i2, i: o3, j: r2 + 1 });
      null !== c3 && this.elDataLabelsWrap.add(c3);
    } }, { key: "_createPaths", value: function(t4) {
      var e3 = t4.type, i2 = t4.series, a3 = t4.i;
      t4.realIndex;
      var s3 = t4.j, r2 = t4.x, o3 = t4.y, n3 = t4.xArrj, l3 = t4.yArrj, h3 = t4.y2, c3 = t4.y2Arrj, d3 = t4.pX, g3 = t4.pY, u3 = t4.pathState, p3 = t4.segmentStartX, f3 = t4.linePath, x3 = t4.areaPath, b3 = t4.linePaths, v3 = t4.areaPaths, y3 = t4.curve, w3 = t4.isRangeStart;
      this.w;
      var k3, A3 = new m2(this.ctx), S3 = this.areaBottomY, C3 = "rangeArea" === e3, L3 = "rangeArea" === e3 && w3;
      switch (y3) {
        case "monotoneCubic":
          var P3 = w3 ? l3 : c3;
          switch (u3) {
            case 0:
              if (null === P3[s3 + 1]) break;
              u3 = 1;
            case 1:
              if (!(C3 ? n3.length === i2[a3].length : s3 === i2[a3].length - 2)) break;
            case 2:
              var M3 = w3 ? n3 : n3.slice().reverse(), I3 = w3 ? P3 : P3.slice().reverse(), T3 = (k3 = I3, M3.map(function(t5, e4) {
                return [t5, k3[e4]];
              }).filter(function(t5) {
                return null !== t5[1];
              })), z3 = T3.length > 1 ? Xt2(T3) : T3, X3 = [];
              C3 && (L3 ? v3 = T3 : X3 = v3.reverse());
              var E3 = 0, Y3 = 0;
              if (function(t5, e4) {
                for (var i3 = function(t6) {
                  var e5 = [], i4 = 0;
                  return t6.forEach(function(t7) {
                    null !== t7 ? i4++ : i4 > 0 && (e5.push(i4), i4 = 0);
                  }), i4 > 0 && e5.push(i4), e5;
                }(t5), a4 = [], s4 = 0, r3 = 0; s4 < i3.length; r3 += i3[s4++]) a4[s4] = Et2(e4, r3, r3 + i3[s4]);
                return a4;
              }(I3, z3).forEach(function(t5) {
                E3++;
                var e4 = function(t6) {
                  for (var e5 = "", i4 = 0; i4 < t6.length; i4++) {
                    var a5 = t6[i4], s4 = a5.length;
                    s4 > 4 ? (e5 += "C".concat(a5[0], ", ").concat(a5[1]), e5 += ", ".concat(a5[2], ", ").concat(a5[3]), e5 += ", ".concat(a5[4], ", ").concat(a5[5])) : s4 > 2 && (e5 += "S".concat(a5[0], ", ").concat(a5[1]), e5 += ", ".concat(a5[2], ", ").concat(a5[3]));
                  }
                  return e5;
                }(t5), i3 = Y3, a4 = (Y3 += t5.length) - 1;
                L3 ? f3 = A3.move(T3[i3][0], T3[i3][1]) + e4 : C3 ? f3 = A3.move(X3[i3][0], X3[i3][1]) + A3.line(T3[i3][0], T3[i3][1]) + e4 + A3.line(X3[a4][0], X3[a4][1]) : (f3 = A3.move(T3[i3][0], T3[i3][1]) + e4, x3 = f3 + A3.line(T3[a4][0], S3) + A3.line(T3[i3][0], S3) + "z", v3.push(x3)), b3.push(f3);
              }), C3 && E3 > 1 && !L3) {
                var F3 = b3.slice(E3).reverse();
                b3.splice(E3), F3.forEach(function(t5) {
                  return b3.push(t5);
                });
              }
              u3 = 0;
          }
          break;
        case "smooth":
          var R3 = 0.35 * (r2 - d3);
          if (null === i2[a3][s3]) u3 = 0;
          else switch (u3) {
            case 0:
              if (p3 = d3, f3 = L3 ? A3.move(d3, c3[s3]) + A3.line(d3, g3) : A3.move(d3, g3), x3 = A3.move(d3, g3), u3 = 1, s3 < i2[a3].length - 2) {
                var H5 = A3.curve(d3 + R3, g3, r2 - R3, o3, r2, o3);
                f3 += H5, x3 += H5;
                break;
              }
            case 1:
              if (null === i2[a3][s3 + 1]) f3 += L3 ? A3.line(d3, h3) : A3.move(d3, g3), x3 += A3.line(d3, S3) + A3.line(p3, S3) + "z", b3.push(f3), v3.push(x3), u3 = -1;
              else {
                var D3 = A3.curve(d3 + R3, g3, r2 - R3, o3, r2, o3);
                f3 += D3, x3 += D3, s3 >= i2[a3].length - 2 && (L3 && (f3 += A3.curve(r2, o3, r2, o3, r2, h3) + A3.move(r2, h3)), x3 += A3.curve(r2, o3, r2, o3, r2, S3) + A3.line(p3, S3) + "z", b3.push(f3), v3.push(x3), u3 = -1);
              }
          }
          d3 = r2, g3 = o3;
          break;
        default:
          var O3 = function(t5, e4, i3) {
            var a4 = [];
            switch (t5) {
              case "stepline":
                a4 = A3.line(e4, null, "H") + A3.line(null, i3, "V");
                break;
              case "linestep":
                a4 = A3.line(null, i3, "V") + A3.line(e4, null, "H");
                break;
              case "straight":
                a4 = A3.line(e4, i3);
            }
            return a4;
          };
          if (null === i2[a3][s3]) u3 = 0;
          else switch (u3) {
            case 0:
              if (p3 = d3, f3 = L3 ? A3.move(d3, c3[s3]) + A3.line(d3, g3) : A3.move(d3, g3), x3 = A3.move(d3, g3), u3 = 1, s3 < i2[a3].length - 2) {
                var N3 = O3(y3, r2, o3);
                f3 += N3, x3 += N3;
                break;
              }
            case 1:
              if (null === i2[a3][s3 + 1]) f3 += L3 ? A3.line(d3, h3) : A3.move(d3, g3), x3 += A3.line(d3, S3) + A3.line(p3, S3) + "z", b3.push(f3), v3.push(x3), u3 = -1;
              else {
                var W3 = O3(y3, r2, o3);
                f3 += W3, x3 += W3, s3 >= i2[a3].length - 2 && (L3 && (f3 += A3.line(r2, h3)), x3 += A3.line(r2, S3) + A3.line(p3, S3) + "z", b3.push(f3), v3.push(x3), u3 = -1);
              }
          }
          d3 = r2, g3 = o3;
      }
      return { linePaths: b3, areaPaths: v3, pX: d3, pY: g3, pathState: u3, segmentStartX: p3, linePath: f3, areaPath: x3 };
    } }, { key: "handleNullDataPoints", value: function(t4, e3, i2, a3, s3) {
      var r2 = this.w;
      if (null === t4[i2][a3] && r2.config.markers.showNullDataPoints || 1 === t4[i2].length) {
        var o3 = this.strokeWidth - r2.config.markers.strokeWidth / 2;
        o3 > 0 || (o3 = 0);
        var n3 = this.markers.plotChartMarkers(e3, s3, a3 + 1, o3, true);
        null !== n3 && this.elPointsMain.add(n3);
      }
    } }]), t3;
  }();
  window.TreemapSquared = {}, window.TreemapSquared.generate = /* @__PURE__ */ function() {
    function t3(e4, i3, a4, s4) {
      this.xoffset = e4, this.yoffset = i3, this.height = s4, this.width = a4, this.shortestEdge = function() {
        return Math.min(this.height, this.width);
      }, this.getCoordinates = function(t4) {
        var e5, i4 = [], a5 = this.xoffset, s5 = this.yoffset, o4 = r2(t4) / this.height, n3 = r2(t4) / this.width;
        if (this.width >= this.height) for (e5 = 0; e5 < t4.length; e5++) i4.push([a5, s5, a5 + o4, s5 + t4[e5] / o4]), s5 += t4[e5] / o4;
        else for (e5 = 0; e5 < t4.length; e5++) i4.push([a5, s5, a5 + t4[e5] / n3, s5 + n3]), a5 += t4[e5] / n3;
        return i4;
      }, this.cutArea = function(e5) {
        var i4;
        if (this.width >= this.height) {
          var a5 = e5 / this.height, s5 = this.width - a5;
          i4 = new t3(this.xoffset + a5, this.yoffset, s5, this.height);
        } else {
          var r3 = e5 / this.width, o4 = this.height - r3;
          i4 = new t3(this.xoffset, this.yoffset + r3, this.width, o4);
        }
        return i4;
      };
    }
    function e3(e4, a4, s4, o4, n3) {
      o4 = void 0 === o4 ? 0 : o4, n3 = void 0 === n3 ? 0 : n3;
      var l3 = i2(function(t4, e5) {
        var i3, a5 = [], s5 = e5 / r2(t4);
        for (i3 = 0; i3 < t4.length; i3++) a5[i3] = t4[i3] * s5;
        return a5;
      }(e4, a4 * s4), [], new t3(o4, n3, a4, s4), []);
      return function(t4) {
        var e5, i3, a5 = [];
        for (e5 = 0; e5 < t4.length; e5++) for (i3 = 0; i3 < t4[e5].length; i3++) a5.push(t4[e5][i3]);
        return a5;
      }(l3);
    }
    function i2(t4, e4, s4, o4) {
      var n3, l3, h3;
      if (0 !== t4.length) return n3 = s4.shortestEdge(), function(t5, e5, i3) {
        var s5;
        if (0 === t5.length) return true;
        (s5 = t5.slice()).push(e5);
        var r3 = a3(t5, i3), o5 = a3(s5, i3);
        return r3 >= o5;
      }(e4, l3 = t4[0], n3) ? (e4.push(l3), i2(t4.slice(1), e4, s4, o4)) : (h3 = s4.cutArea(r2(e4), o4), o4.push(s4.getCoordinates(e4)), i2(t4, [], h3, o4)), o4;
      o4.push(s4.getCoordinates(e4));
    }
    function a3(t4, e4) {
      var i3 = Math.min.apply(Math, t4), a4 = Math.max.apply(Math, t4), s4 = r2(t4);
      return Math.max(Math.pow(e4, 2) * a4 / Math.pow(s4, 2), Math.pow(s4, 2) / (Math.pow(e4, 2) * i3));
    }
    function s3(t4) {
      return t4 && t4.constructor === Array;
    }
    function r2(t4) {
      var e4, i3 = 0;
      for (e4 = 0; e4 < t4.length; e4++) i3 += t4[e4];
      return i3;
    }
    function o3(t4) {
      var e4, i3 = 0;
      if (s3(t4[0])) for (e4 = 0; e4 < t4.length; e4++) i3 += o3(t4[e4]);
      else i3 = r2(t4);
      return i3;
    }
    return function t4(i3, a4, r3, n3, l3) {
      n3 = void 0 === n3 ? 0 : n3, l3 = void 0 === l3 ? 0 : l3;
      var h3, c3, d3 = [], g3 = [];
      if (s3(i3[0])) {
        for (c3 = 0; c3 < i3.length; c3++) d3[c3] = o3(i3[c3]);
        for (h3 = e3(d3, a4, r3, n3, l3), c3 = 0; c3 < i3.length; c3++) g3.push(t4(i3[c3], h3[c3][2] - h3[c3][0], h3[c3][3] - h3[c3][1], h3[c3][0], h3[c3][1]));
      } else g3 = e3(i3, a4, r3, n3, l3);
      return g3;
    };
  }();
  var Rt2, Ht2, Dt2 = function() {
    function t3(e3, i2) {
      a2(this, t3), this.ctx = e3, this.w = e3.w, this.strokeWidth = this.w.config.stroke.width, this.helpers = new At2(e3), this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.labels = [];
    }
    return r(t3, [{ key: "draw", value: function(t4) {
      var e3 = this, i2 = this.w, a3 = new m2(this.ctx), s3 = new H4(this.ctx), r2 = a3.group({ class: "apexcharts-treemap" });
      if (i2.globals.noData) return r2;
      var o3 = [];
      return t4.forEach(function(t5) {
        var e4 = t5.map(function(t6) {
          return Math.abs(t6);
        });
        o3.push(e4);
      }), this.negRange = this.helpers.checkColorRange(), i2.config.series.forEach(function(t5, i3) {
        t5.data.forEach(function(t6) {
          Array.isArray(e3.labels[i3]) || (e3.labels[i3] = []), e3.labels[i3].push(t6.x);
        });
      }), window.TreemapSquared.generate(o3, i2.globals.gridWidth, i2.globals.gridHeight).forEach(function(o4, n3) {
        var l3 = a3.group({ class: "apexcharts-series apexcharts-treemap-series", seriesName: x2.escapeString(i2.globals.seriesNames[n3]), rel: n3 + 1, "data:realIndex": n3 });
        if (i2.config.chart.dropShadow.enabled) {
          var h3 = i2.config.chart.dropShadow;
          new v2(e3.ctx).dropShadow(r2, h3, n3);
        }
        var c3 = a3.group({ class: "apexcharts-data-labels" });
        o4.forEach(function(r3, o5) {
          var h4 = r3[0], c4 = r3[1], d3 = r3[2], g3 = r3[3], u3 = a3.drawRect(h4, c4, d3 - h4, g3 - c4, i2.config.plotOptions.treemap.borderRadius, "#fff", 1, e3.strokeWidth, i2.config.plotOptions.treemap.useFillColorAsStroke ? f3 : i2.globals.stroke.colors[n3]);
          u3.attr({ cx: h4, cy: c4, index: n3, i: n3, j: o5, width: d3 - h4, height: g3 - c4 });
          var p3 = e3.helpers.getShadeColor(i2.config.chart.type, n3, o5, e3.negRange), f3 = p3.color;
          void 0 !== i2.config.series[n3].data[o5] && i2.config.series[n3].data[o5].fillColor && (f3 = i2.config.series[n3].data[o5].fillColor);
          var x3 = s3.fillPath({ color: f3, seriesNumber: n3, dataPointIndex: o5 });
          u3.node.classList.add("apexcharts-treemap-rect"), u3.attr({ fill: x3 }), e3.helpers.addListeners(u3);
          var b3 = { x: h4 + (d3 - h4) / 2, y: c4 + (g3 - c4) / 2, width: 0, height: 0 }, v3 = { x: h4, y: c4, width: d3 - h4, height: g3 - c4 };
          if (i2.config.chart.animations.enabled && !i2.globals.dataChanged) {
            var m3 = 1;
            i2.globals.resized || (m3 = i2.config.chart.animations.speed), e3.animateTreemap(u3, b3, v3, m3);
          }
          if (i2.globals.dataChanged) {
            var y3 = 1;
            e3.dynamicAnim.enabled && i2.globals.shouldAnimate && (y3 = e3.dynamicAnim.speed, i2.globals.previousPaths[n3] && i2.globals.previousPaths[n3][o5] && i2.globals.previousPaths[n3][o5].rect && (b3 = i2.globals.previousPaths[n3][o5].rect), e3.animateTreemap(u3, b3, v3, y3));
          }
          var w3 = e3.getFontSize(r3), k3 = i2.config.dataLabels.formatter(e3.labels[n3][o5], { value: i2.globals.series[n3][o5], seriesIndex: n3, dataPointIndex: o5, w: i2 });
          "truncate" === i2.config.plotOptions.treemap.dataLabels.format && (w3 = parseInt(i2.config.dataLabels.style.fontSize, 10), k3 = e3.truncateLabels(k3, w3, h4, c4, d3, g3));
          var A3 = e3.helpers.calculateDataLabels({ text: k3, x: (h4 + d3) / 2, y: (c4 + g3) / 2 + e3.strokeWidth / 2 + w3 / 3, i: n3, j: o5, colorProps: p3, fontSize: w3, series: t4 });
          i2.config.dataLabels.enabled && A3 && e3.rotateToFitLabel(A3, w3, k3, h4, c4, d3, g3), l3.add(u3), null !== A3 && l3.add(A3);
        }), l3.add(c3), r2.add(l3);
      }), r2;
    } }, { key: "getFontSize", value: function(t4) {
      var e3 = this.w;
      var i2, a3, s3, r2, o3 = function t5(e4) {
        var i3, a4 = 0;
        if (Array.isArray(e4[0])) for (i3 = 0; i3 < e4.length; i3++) a4 += t5(e4[i3]);
        else for (i3 = 0; i3 < e4.length; i3++) a4 += e4[i3].length;
        return a4;
      }(this.labels) / function t5(e4) {
        var i3, a4 = 0;
        if (Array.isArray(e4[0])) for (i3 = 0; i3 < e4.length; i3++) a4 += t5(e4[i3]);
        else for (i3 = 0; i3 < e4.length; i3++) a4 += 1;
        return a4;
      }(this.labels);
      return i2 = t4[2] - t4[0], a3 = t4[3] - t4[1], s3 = i2 * a3, r2 = Math.pow(s3, 0.5), Math.min(r2 / o3, parseInt(e3.config.dataLabels.style.fontSize, 10));
    } }, { key: "rotateToFitLabel", value: function(t4, e3, i2, a3, s3, r2, o3) {
      var n3 = new m2(this.ctx), l3 = n3.getTextRects(i2, e3);
      if (l3.width + this.w.config.stroke.width + 5 > r2 - a3 && l3.width <= o3 - s3) {
        var h3 = n3.rotateAroundCenter(t4.node);
        t4.node.setAttribute("transform", "rotate(-90 ".concat(h3.x, " ").concat(h3.y, ") translate(").concat(l3.height / 3, ")"));
      }
    } }, { key: "truncateLabels", value: function(t4, e3, i2, a3, s3, r2) {
      var o3 = new m2(this.ctx), n3 = o3.getTextRects(t4, e3).width + this.w.config.stroke.width + 5 > s3 - i2 && r2 - a3 > s3 - i2 ? r2 - a3 : s3 - i2, l3 = o3.getTextBasedOnMaxWidth({ text: t4, maxWidth: n3, fontSize: e3 });
      return t4.length !== l3.length && n3 / e3 < 5 ? "" : l3;
    } }, { key: "animateTreemap", value: function(t4, e3, i2, a3) {
      var s3 = new b2(this.ctx);
      s3.animateRect(t4, { x: e3.x, y: e3.y, width: e3.width, height: e3.height }, { x: i2.x, y: i2.y, width: i2.width, height: i2.height }, a3, function() {
        s3.animationCompleted(t4);
      });
    } }]), t3;
  }(), Ot2 = 86400, Nt2 = function() {
    function t3(e3) {
      a2(this, t3), this.ctx = e3, this.w = e3.w, this.timeScaleArray = [], this.utc = this.w.config.xaxis.labels.datetimeUTC;
    }
    return r(t3, [{ key: "calculateTimeScaleTicks", value: function(t4, i2) {
      var a3 = this, s3 = this.w;
      if (s3.globals.allSeriesCollapsed) return s3.globals.labels = [], s3.globals.timescaleLabels = [], [];
      var r2 = new A2(this.ctx), o3 = (i2 - t4) / 864e5;
      this.determineInterval(o3), s3.globals.disableZoomIn = false, s3.globals.disableZoomOut = false, o3 < 11574074074074075e-20 ? s3.globals.disableZoomIn = true : o3 > 5e4 && (s3.globals.disableZoomOut = true);
      var n3 = r2.getTimeUnitsfromTimestamp(t4, i2, this.utc), l3 = s3.globals.gridWidth / o3, h3 = l3 / 24, c3 = h3 / 60, d3 = c3 / 60, g3 = Math.floor(24 * o3), u3 = Math.floor(1440 * o3), p3 = Math.floor(o3 * Ot2), f3 = Math.floor(o3), x3 = Math.floor(o3 / 30), b3 = Math.floor(o3 / 365), v3 = { minMillisecond: n3.minMillisecond, minSecond: n3.minSecond, minMinute: n3.minMinute, minHour: n3.minHour, minDate: n3.minDate, minMonth: n3.minMonth, minYear: n3.minYear }, m3 = { firstVal: v3, currentMillisecond: v3.minMillisecond, currentSecond: v3.minSecond, currentMinute: v3.minMinute, currentHour: v3.minHour, currentMonthDate: v3.minDate, currentDate: v3.minDate, currentMonth: v3.minMonth, currentYear: v3.minYear, daysWidthOnXAxis: l3, hoursWidthOnXAxis: h3, minutesWidthOnXAxis: c3, secondsWidthOnXAxis: d3, numberOfSeconds: p3, numberOfMinutes: u3, numberOfHours: g3, numberOfDays: f3, numberOfMonths: x3, numberOfYears: b3 };
      switch (this.tickInterval) {
        case "years":
          this.generateYearScale(m3);
          break;
        case "months":
        case "half_year":
          this.generateMonthScale(m3);
          break;
        case "months_days":
        case "months_fortnight":
        case "days":
        case "week_days":
          this.generateDayScale(m3);
          break;
        case "hours":
          this.generateHourScale(m3);
          break;
        case "minutes_fives":
        case "minutes":
          this.generateMinuteScale(m3);
          break;
        case "seconds_tens":
        case "seconds_fives":
        case "seconds":
          this.generateSecondScale(m3);
      }
      var y3 = this.timeScaleArray.map(function(t5) {
        var i3 = { position: t5.position, unit: t5.unit, year: t5.year, day: t5.day ? t5.day : 1, hour: t5.hour ? t5.hour : 0, month: t5.month + 1 };
        return "month" === t5.unit ? e2(e2({}, i3), {}, { day: 1, value: t5.value + 1 }) : "day" === t5.unit || "hour" === t5.unit ? e2(e2({}, i3), {}, { value: t5.value }) : "minute" === t5.unit ? e2(e2({}, i3), {}, { value: t5.value, minute: t5.value }) : "second" === t5.unit ? e2(e2({}, i3), {}, { value: t5.value, minute: t5.minute, second: t5.second }) : t5;
      });
      return y3.filter(function(t5) {
        var e3 = 1, i3 = Math.ceil(s3.globals.gridWidth / 120), r3 = t5.value;
        void 0 !== s3.config.xaxis.tickAmount && (i3 = s3.config.xaxis.tickAmount), y3.length > i3 && (e3 = Math.floor(y3.length / i3));
        var o4 = false, n4 = false;
        switch (a3.tickInterval) {
          case "years":
            "year" === t5.unit && (o4 = true);
            break;
          case "half_year":
            e3 = 7, "year" === t5.unit && (o4 = true);
            break;
          case "months":
            e3 = 1, "year" === t5.unit && (o4 = true);
            break;
          case "months_fortnight":
            e3 = 15, "year" !== t5.unit && "month" !== t5.unit || (o4 = true), 30 === r3 && (n4 = true);
            break;
          case "months_days":
            e3 = 10, "month" === t5.unit && (o4 = true), 30 === r3 && (n4 = true);
            break;
          case "week_days":
            e3 = 8, "month" === t5.unit && (o4 = true);
            break;
          case "days":
            e3 = 1, "month" === t5.unit && (o4 = true);
            break;
          case "hours":
            "day" === t5.unit && (o4 = true);
            break;
          case "minutes_fives":
          case "seconds_fives":
            r3 % 5 != 0 && (n4 = true);
            break;
          case "seconds_tens":
            r3 % 10 != 0 && (n4 = true);
        }
        if ("hours" === a3.tickInterval || "minutes_fives" === a3.tickInterval || "seconds_tens" === a3.tickInterval || "seconds_fives" === a3.tickInterval) {
          if (!n4) return true;
        } else if ((r3 % e3 == 0 || o4) && !n4) return true;
      });
    } }, { key: "recalcDimensionsBasedOnFormat", value: function(t4, e3) {
      var i2 = this.w, a3 = this.formatDates(t4), s3 = this.removeOverlappingTS(a3);
      i2.globals.timescaleLabels = s3.slice(), new ot2(this.ctx).plotCoords();
    } }, { key: "determineInterval", value: function(t4) {
      var e3 = 24 * t4, i2 = 60 * e3;
      switch (true) {
        case t4 / 365 > 5:
          this.tickInterval = "years";
          break;
        case t4 > 800:
          this.tickInterval = "half_year";
          break;
        case t4 > 180:
          this.tickInterval = "months";
          break;
        case t4 > 90:
          this.tickInterval = "months_fortnight";
          break;
        case t4 > 60:
          this.tickInterval = "months_days";
          break;
        case t4 > 30:
          this.tickInterval = "week_days";
          break;
        case t4 > 2:
          this.tickInterval = "days";
          break;
        case e3 > 2.4:
          this.tickInterval = "hours";
          break;
        case i2 > 15:
          this.tickInterval = "minutes_fives";
          break;
        case i2 > 5:
          this.tickInterval = "minutes";
          break;
        case i2 > 1:
          this.tickInterval = "seconds_tens";
          break;
        case 60 * i2 > 20:
          this.tickInterval = "seconds_fives";
          break;
        default:
          this.tickInterval = "seconds";
      }
    } }, { key: "generateYearScale", value: function(t4) {
      var e3 = t4.firstVal, i2 = t4.currentMonth, a3 = t4.currentYear, s3 = t4.daysWidthOnXAxis, r2 = t4.numberOfYears, o3 = e3.minYear, n3 = 0, l3 = new A2(this.ctx), h3 = "year";
      if (e3.minDate > 1 || e3.minMonth > 0) {
        var c3 = l3.determineRemainingDaysOfYear(e3.minYear, e3.minMonth, e3.minDate);
        n3 = (l3.determineDaysOfYear(e3.minYear) - c3 + 1) * s3, o3 = e3.minYear + 1, this.timeScaleArray.push({ position: n3, value: o3, unit: h3, year: o3, month: x2.monthMod(i2 + 1) });
      } else 1 === e3.minDate && 0 === e3.minMonth && this.timeScaleArray.push({ position: n3, value: o3, unit: h3, year: a3, month: x2.monthMod(i2 + 1) });
      for (var d3 = o3, g3 = n3, u3 = 0; u3 < r2; u3++) d3++, g3 = l3.determineDaysOfYear(d3 - 1) * s3 + g3, this.timeScaleArray.push({ position: g3, value: d3, unit: h3, year: d3, month: 1 });
    } }, { key: "generateMonthScale", value: function(t4) {
      var e3 = t4.firstVal, i2 = t4.currentMonthDate, a3 = t4.currentMonth, s3 = t4.currentYear, r2 = t4.daysWidthOnXAxis, o3 = t4.numberOfMonths, n3 = a3, l3 = 0, h3 = new A2(this.ctx), c3 = "month", d3 = 0;
      if (e3.minDate > 1) {
        l3 = (h3.determineDaysOfMonths(a3 + 1, e3.minYear) - i2 + 1) * r2, n3 = x2.monthMod(a3 + 1);
        var g3 = s3 + d3, u3 = x2.monthMod(n3), p3 = n3;
        0 === n3 && (c3 = "year", p3 = g3, u3 = 1, g3 += d3 += 1), this.timeScaleArray.push({ position: l3, value: p3, unit: c3, year: g3, month: u3 });
      } else this.timeScaleArray.push({ position: l3, value: n3, unit: c3, year: s3, month: x2.monthMod(a3) });
      for (var f3 = n3 + 1, b3 = l3, v3 = 0, m3 = 1; v3 < o3; v3++, m3++) {
        0 === (f3 = x2.monthMod(f3)) ? (c3 = "year", d3 += 1) : c3 = "month";
        var y3 = this._getYear(s3, f3, d3);
        b3 = h3.determineDaysOfMonths(f3, y3) * r2 + b3;
        var w3 = 0 === f3 ? y3 : f3;
        this.timeScaleArray.push({ position: b3, value: w3, unit: c3, year: y3, month: 0 === f3 ? 1 : f3 }), f3++;
      }
    } }, { key: "generateDayScale", value: function(t4) {
      var e3 = t4.firstVal, i2 = t4.currentMonth, a3 = t4.currentYear, s3 = t4.hoursWidthOnXAxis, r2 = t4.numberOfDays, o3 = new A2(this.ctx), n3 = "day", l3 = e3.minDate + 1, h3 = l3, c3 = function(t5, e4, i3) {
        return t5 > o3.determineDaysOfMonths(e4 + 1, i3) ? (h3 = 1, n3 = "month", g3 = e4 += 1, e4) : e4;
      }, d3 = (24 - e3.minHour) * s3, g3 = l3, u3 = c3(h3, i2, a3);
      0 === e3.minHour && 1 === e3.minDate ? (d3 = 0, g3 = x2.monthMod(e3.minMonth), n3 = "month", h3 = e3.minDate) : 1 !== e3.minDate && 0 === e3.minHour && 0 === e3.minMinute && (d3 = 0, l3 = e3.minDate, g3 = l3, u3 = c3(h3 = l3, i2, a3)), this.timeScaleArray.push({ position: d3, value: g3, unit: n3, year: this._getYear(a3, u3, 0), month: x2.monthMod(u3), day: h3 });
      for (var p3 = d3, f3 = 0; f3 < r2; f3++) {
        n3 = "day", u3 = c3(h3 += 1, u3, this._getYear(a3, u3, 0));
        var b3 = this._getYear(a3, u3, 0);
        p3 = 24 * s3 + p3;
        var v3 = 1 === h3 ? x2.monthMod(u3) : h3;
        this.timeScaleArray.push({ position: p3, value: v3, unit: n3, year: b3, month: x2.monthMod(u3), day: v3 });
      }
    } }, { key: "generateHourScale", value: function(t4) {
      var e3 = t4.firstVal, i2 = t4.currentDate, a3 = t4.currentMonth, s3 = t4.currentYear, r2 = t4.minutesWidthOnXAxis, o3 = t4.numberOfHours, n3 = new A2(this.ctx), l3 = "hour", h3 = function(t5, e4) {
        return t5 > n3.determineDaysOfMonths(e4 + 1, s3) && (f3 = 1, e4 += 1), { month: e4, date: f3 };
      }, c3 = function(t5, e4) {
        return t5 > n3.determineDaysOfMonths(e4 + 1, s3) ? e4 += 1 : e4;
      }, d3 = 60 - (e3.minMinute + e3.minSecond / 60), g3 = d3 * r2, u3 = e3.minHour + 1, p3 = u3;
      60 === d3 && (g3 = 0, p3 = u3 = e3.minHour);
      var f3 = i2;
      p3 >= 24 && (p3 = 0, f3 += 1, l3 = "day");
      var b3 = h3(f3, a3).month;
      b3 = c3(f3, b3), this.timeScaleArray.push({ position: g3, value: u3, unit: l3, day: f3, hour: p3, year: s3, month: x2.monthMod(b3) }), p3++;
      for (var v3 = g3, m3 = 0; m3 < o3; m3++) {
        if (l3 = "hour", p3 >= 24) p3 = 0, l3 = "day", b3 = h3(f3 += 1, b3).month, b3 = c3(f3, b3);
        var y3 = this._getYear(s3, b3, 0);
        v3 = 60 * r2 + v3;
        var w3 = 0 === p3 ? f3 : p3;
        this.timeScaleArray.push({ position: v3, value: w3, unit: l3, hour: p3, day: f3, year: y3, month: x2.monthMod(b3) }), p3++;
      }
    } }, { key: "generateMinuteScale", value: function(t4) {
      for (var e3 = t4.currentMillisecond, i2 = t4.currentSecond, a3 = t4.currentMinute, s3 = t4.currentHour, r2 = t4.currentDate, o3 = t4.currentMonth, n3 = t4.currentYear, l3 = t4.minutesWidthOnXAxis, h3 = t4.secondsWidthOnXAxis, c3 = t4.numberOfMinutes, d3 = a3 + 1, g3 = r2, u3 = o3, p3 = n3, f3 = s3, b3 = (60 - i2 - e3 / 1e3) * h3, v3 = 0; v3 < c3; v3++) d3 >= 60 && (d3 = 0, 24 === (f3 += 1) && (f3 = 0)), this.timeScaleArray.push({ position: b3, value: d3, unit: "minute", hour: f3, minute: d3, day: g3, year: this._getYear(p3, u3, 0), month: x2.monthMod(u3) }), b3 += l3, d3++;
    } }, { key: "generateSecondScale", value: function(t4) {
      for (var e3 = t4.currentMillisecond, i2 = t4.currentSecond, a3 = t4.currentMinute, s3 = t4.currentHour, r2 = t4.currentDate, o3 = t4.currentMonth, n3 = t4.currentYear, l3 = t4.secondsWidthOnXAxis, h3 = t4.numberOfSeconds, c3 = i2 + 1, d3 = a3, g3 = r2, u3 = o3, p3 = n3, f3 = s3, b3 = (1e3 - e3) / 1e3 * l3, v3 = 0; v3 < h3; v3++) c3 >= 60 && (c3 = 0, ++d3 >= 60 && (d3 = 0, 24 === ++f3 && (f3 = 0))), this.timeScaleArray.push({ position: b3, value: c3, unit: "second", hour: f3, minute: d3, second: c3, day: g3, year: this._getYear(p3, u3, 0), month: x2.monthMod(u3) }), b3 += l3, c3++;
    } }, { key: "createRawDateString", value: function(t4, e3) {
      var i2 = t4.year;
      return 0 === t4.month && (t4.month = 1), i2 += "-" + ("0" + t4.month.toString()).slice(-2), "day" === t4.unit ? i2 += "day" === t4.unit ? "-" + ("0" + e3).slice(-2) : "-01" : i2 += "-" + ("0" + (t4.day ? t4.day : "1")).slice(-2), "hour" === t4.unit ? i2 += "hour" === t4.unit ? "T" + ("0" + e3).slice(-2) : "T00" : i2 += "T" + ("0" + (t4.hour ? t4.hour : "0")).slice(-2), "minute" === t4.unit ? i2 += ":" + ("0" + e3).slice(-2) : i2 += ":" + (t4.minute ? ("0" + t4.minute).slice(-2) : "00"), "second" === t4.unit ? i2 += ":" + ("0" + e3).slice(-2) : i2 += ":00", this.utc && (i2 += ".000Z"), i2;
    } }, { key: "formatDates", value: function(t4) {
      var e3 = this, i2 = this.w;
      return t4.map(function(t5) {
        var a3 = t5.value.toString(), s3 = new A2(e3.ctx), r2 = e3.createRawDateString(t5, a3), o3 = s3.getDate(s3.parseDate(r2));
        if (e3.utc || (o3 = s3.getDate(s3.parseDateWithTimezone(r2))), void 0 === i2.config.xaxis.labels.format) {
          var n3 = "dd MMM", l3 = i2.config.xaxis.labels.datetimeFormatter;
          "year" === t5.unit && (n3 = l3.year), "month" === t5.unit && (n3 = l3.month), "day" === t5.unit && (n3 = l3.day), "hour" === t5.unit && (n3 = l3.hour), "minute" === t5.unit && (n3 = l3.minute), "second" === t5.unit && (n3 = l3.second), a3 = s3.formatDate(o3, n3);
        } else a3 = s3.formatDate(o3, i2.config.xaxis.labels.format);
        return { dateString: r2, position: t5.position, value: a3, unit: t5.unit, year: t5.year, month: t5.month };
      });
    } }, { key: "removeOverlappingTS", value: function(t4) {
      var e3, i2 = this, a3 = new m2(this.ctx), s3 = false;
      t4.length > 0 && t4[0].value && t4.every(function(e4) {
        return e4.value.length === t4[0].value.length;
      }) && (s3 = true, e3 = a3.getTextRects(t4[0].value).width);
      var r2 = 0, o3 = t4.map(function(o4, n3) {
        if (n3 > 0 && i2.w.config.xaxis.labels.hideOverlappingLabels) {
          var l3 = s3 ? e3 : a3.getTextRects(t4[r2].value).width, h3 = t4[r2].position;
          return o4.position > h3 + l3 + 10 ? (r2 = n3, o4) : null;
        }
        return o4;
      });
      return o3 = o3.filter(function(t5) {
        return null !== t5;
      });
    } }, { key: "_getYear", value: function(t4, e3, i2) {
      return t4 + Math.floor(e3 / 12) + i2;
    } }]), t3;
  }(), Wt2 = function() {
    function t3(e3, i2) {
      a2(this, t3), this.ctx = i2, this.w = i2.w, this.el = e3;
    }
    return r(t3, [{ key: "setupElements", value: function() {
      var t4 = this.w.globals, e3 = this.w.config, i2 = e3.chart.type;
      t4.axisCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble", "radar", "heatmap", "treemap"].indexOf(i2) > -1, t4.xyCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble"].indexOf(i2) > -1, t4.isBarHorizontal = ("bar" === e3.chart.type || "rangeBar" === e3.chart.type || "boxPlot" === e3.chart.type) && e3.plotOptions.bar.horizontal, t4.chartClass = ".apexcharts" + t4.chartID, t4.dom.baseEl = this.el, t4.dom.elWrap = document.createElement("div"), m2.setAttrs(t4.dom.elWrap, { id: t4.chartClass.substring(1), class: "apexcharts-canvas " + t4.chartClass.substring(1) }), this.el.appendChild(t4.dom.elWrap), t4.dom.Paper = new window.SVG.Doc(t4.dom.elWrap), t4.dom.Paper.attr({ class: "apexcharts-svg", "xmlns:data": "ApexChartsNS", transform: "translate(".concat(e3.chart.offsetX, ", ").concat(e3.chart.offsetY, ")") }), t4.dom.Paper.node.style.background = "dark" !== e3.theme.mode || e3.chart.background ? e3.chart.background : "rgba(0, 0, 0, 0.8)", this.setSVGDimensions(), t4.dom.elLegendForeign = document.createElementNS(t4.SVGNS, "foreignObject"), m2.setAttrs(t4.dom.elLegendForeign, { x: 0, y: 0, width: t4.svgWidth, height: t4.svgHeight }), t4.dom.elLegendWrap = document.createElement("div"), t4.dom.elLegendWrap.classList.add("apexcharts-legend"), t4.dom.elLegendWrap.setAttribute("xmlns", "http://www.w3.org/1999/xhtml"), t4.dom.elLegendForeign.appendChild(t4.dom.elLegendWrap), t4.dom.Paper.node.appendChild(t4.dom.elLegendForeign), t4.dom.elGraphical = t4.dom.Paper.group().attr({ class: "apexcharts-inner apexcharts-graphical" }), t4.dom.elDefs = t4.dom.Paper.defs(), t4.dom.Paper.add(t4.dom.elGraphical), t4.dom.elGraphical.add(t4.dom.elDefs);
    } }, { key: "plotChartType", value: function(t4, e3) {
      var i2 = this.w, a3 = i2.config, s3 = i2.globals, r2 = { series: [], i: [] }, o3 = { series: [], i: [] }, n3 = { series: [], i: [] }, l3 = { series: [], i: [] }, h3 = { series: [], i: [] }, c3 = { series: [], i: [] }, d3 = { series: [], i: [] }, g3 = { series: [], i: [] }, p3 = { series: [], seriesRangeEnd: [], i: [] }, f3 = void 0 !== a3.chart.type ? a3.chart.type : "line", x3 = null, b3 = 0;
      s3.series.forEach(function(e4, a4) {
        var u3 = t4[a4].type || f3;
        switch (u3) {
          case "column":
          case "bar":
            h3.series.push(e4), h3.i.push(a4), i2.globals.columnSeries = h3;
            break;
          case "area":
            o3.series.push(e4), o3.i.push(a4);
            break;
          case "line":
            r2.series.push(e4), r2.i.push(a4);
            break;
          case "scatter":
            n3.series.push(e4), n3.i.push(a4);
            break;
          case "bubble":
            l3.series.push(e4), l3.i.push(a4);
            break;
          case "candlestick":
            c3.series.push(e4), c3.i.push(a4);
            break;
          case "boxPlot":
            d3.series.push(e4), d3.i.push(a4);
            break;
          case "rangeBar":
            g3.series.push(e4), g3.i.push(a4);
            break;
          case "rangeArea":
            p3.series.push(s3.seriesRangeStart[a4]), p3.seriesRangeEnd.push(s3.seriesRangeEnd[a4]), p3.i.push(a4);
            break;
          case "heatmap":
          case "treemap":
          case "pie":
          case "donut":
          case "polarArea":
          case "radialBar":
          case "radar":
            x3 = u3;
            break;
          default:
            console.warn("You have specified an unrecognized series type (", u3, ").");
        }
        f3 !== u3 && "scatter" !== u3 && b3++;
      }), b3 > 0 && (null !== x3 && console.warn("Chart or series type ", x3, " can not appear with other chart or series types."), h3.series.length > 0 && a3.plotOptions.bar.horizontal && (b3 -= h3.length, h3 = { series: [], i: [] }, i2.globals.columnSeries = { series: [], i: [] }, console.warn("Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`"))), s3.comboCharts || (s3.comboCharts = b3 > 0);
      var v3 = new Ft2(this.ctx, e3), m3 = new kt2(this.ctx, e3);
      this.ctx.pie = new Lt2(this.ctx);
      var w3 = new Mt2(this.ctx);
      this.ctx.rangeBar = new It2(this.ctx, e3);
      var k3 = new Pt2(this.ctx), A3 = [];
      if (s3.comboCharts) {
        var S3, C3, L3 = new y2(this.ctx);
        if (o3.series.length > 0) (S3 = A3).push.apply(S3, u2(L3.drawSeriesByGroup(o3, s3.areaGroups, "area", v3)));
        if (h3.series.length > 0) if (i2.config.chart.stacked) {
          var P3 = new wt2(this.ctx, e3);
          A3.push(P3.draw(h3.series, h3.i));
        } else this.ctx.bar = new yt2(this.ctx, e3), A3.push(this.ctx.bar.draw(h3.series, h3.i));
        if (p3.series.length > 0 && A3.push(v3.draw(p3.series, "rangeArea", p3.i, p3.seriesRangeEnd)), r2.series.length > 0) (C3 = A3).push.apply(C3, u2(L3.drawSeriesByGroup(r2, s3.lineGroups, "line", v3)));
        if (c3.series.length > 0 && A3.push(m3.draw(c3.series, "candlestick", c3.i)), d3.series.length > 0 && A3.push(m3.draw(d3.series, "boxPlot", d3.i)), g3.series.length > 0 && A3.push(this.ctx.rangeBar.draw(g3.series, g3.i)), n3.series.length > 0) {
          var M3 = new Ft2(this.ctx, e3, true);
          A3.push(M3.draw(n3.series, "scatter", n3.i));
        }
        if (l3.series.length > 0) {
          var I3 = new Ft2(this.ctx, e3, true);
          A3.push(I3.draw(l3.series, "bubble", l3.i));
        }
      } else switch (a3.chart.type) {
        case "line":
          A3 = v3.draw(s3.series, "line");
          break;
        case "area":
          A3 = v3.draw(s3.series, "area");
          break;
        case "bar":
          if (a3.chart.stacked) A3 = new wt2(this.ctx, e3).draw(s3.series);
          else this.ctx.bar = new yt2(this.ctx, e3), A3 = this.ctx.bar.draw(s3.series);
          break;
        case "candlestick":
          A3 = new kt2(this.ctx, e3).draw(s3.series, "candlestick");
          break;
        case "boxPlot":
          A3 = new kt2(this.ctx, e3).draw(s3.series, a3.chart.type);
          break;
        case "rangeBar":
          A3 = this.ctx.rangeBar.draw(s3.series);
          break;
        case "rangeArea":
          A3 = v3.draw(s3.seriesRangeStart, "rangeArea", void 0, s3.seriesRangeEnd);
          break;
        case "heatmap":
          A3 = new St(this.ctx, e3).draw(s3.series);
          break;
        case "treemap":
          A3 = new Dt2(this.ctx, e3).draw(s3.series);
          break;
        case "pie":
        case "donut":
        case "polarArea":
          A3 = this.ctx.pie.draw(s3.series);
          break;
        case "radialBar":
          A3 = w3.draw(s3.series);
          break;
        case "radar":
          A3 = k3.draw(s3.series);
          break;
        default:
          A3 = v3.draw(s3.series);
      }
      return A3;
    } }, { key: "setSVGDimensions", value: function() {
      var t4 = this.w.globals, e3 = this.w.config;
      t4.svgWidth = e3.chart.width, t4.svgHeight = e3.chart.height;
      var i2 = x2.getDimensions(this.el), a3 = e3.chart.width.toString().split(/[0-9]+/g).pop();
      "%" === a3 ? x2.isNumber(i2[0]) && (0 === i2[0].width && (i2 = x2.getDimensions(this.el.parentNode)), t4.svgWidth = i2[0] * parseInt(e3.chart.width, 10) / 100) : "px" !== a3 && "" !== a3 || (t4.svgWidth = parseInt(e3.chart.width, 10));
      var s3 = e3.chart.height.toString().split(/[0-9]+/g).pop();
      if ("auto" !== t4.svgHeight && "" !== t4.svgHeight) if ("%" === s3) {
        var r2 = x2.getDimensions(this.el.parentNode);
        t4.svgHeight = r2[1] * parseInt(e3.chart.height, 10) / 100;
      } else t4.svgHeight = parseInt(e3.chart.height, 10);
      else t4.axisCharts ? t4.svgHeight = t4.svgWidth / 1.61 : t4.svgHeight = t4.svgWidth / 1.2;
      if (t4.svgWidth < 0 && (t4.svgWidth = 0), t4.svgHeight < 0 && (t4.svgHeight = 0), m2.setAttrs(t4.dom.Paper.node, { width: t4.svgWidth, height: t4.svgHeight }), "%" !== s3) {
        var o3 = e3.chart.sparkline.enabled ? 0 : t4.axisCharts ? e3.chart.parentHeightOffset : 0;
        t4.dom.Paper.node.parentNode.parentNode.style.minHeight = t4.svgHeight + o3 + "px";
      }
      t4.dom.elWrap.style.width = t4.svgWidth + "px", t4.dom.elWrap.style.height = t4.svgHeight + "px";
    } }, { key: "shiftGraphPosition", value: function() {
      var t4 = this.w.globals, e3 = t4.translateY, i2 = { transform: "translate(" + t4.translateX + ", " + e3 + ")" };
      m2.setAttrs(t4.dom.elGraphical.node, i2);
    } }, { key: "resizeNonAxisCharts", value: function() {
      var t4 = this.w, e3 = t4.globals, i2 = 0, a3 = t4.config.chart.sparkline.enabled ? 1 : 15;
      a3 += t4.config.grid.padding.bottom, "top" !== t4.config.legend.position && "bottom" !== t4.config.legend.position || !t4.config.legend.show || t4.config.legend.floating || (i2 = new lt2(this.ctx).legendHelpers.getLegendBBox().clwh + 10);
      var s3 = t4.globals.dom.baseEl.querySelector(".apexcharts-radialbar, .apexcharts-pie"), r2 = 2.05 * t4.globals.radialSize;
      if (s3 && !t4.config.chart.sparkline.enabled && 0 !== t4.config.plotOptions.radialBar.startAngle) {
        var o3 = x2.getBoundingClientRect(s3);
        r2 = o3.bottom;
        var n3 = o3.bottom - o3.top;
        r2 = Math.max(2.05 * t4.globals.radialSize, n3);
      }
      var l3 = r2 + e3.translateY + i2 + a3;
      e3.dom.elLegendForeign && e3.dom.elLegendForeign.setAttribute("height", l3), t4.config.chart.height && String(t4.config.chart.height).indexOf("%") > 0 || (e3.dom.elWrap.style.height = l3 + "px", m2.setAttrs(e3.dom.Paper.node, { height: l3 }), e3.dom.Paper.node.parentNode.parentNode.style.minHeight = l3 + "px");
    } }, { key: "coreCalculations", value: function() {
      new U2(this.ctx).init();
    } }, { key: "resetGlobals", value: function() {
      var t4 = this, e3 = function() {
        return t4.w.config.series.map(function(t5) {
          return [];
        });
      }, i2 = new F2(), a3 = this.w.globals;
      i2.initGlobalVars(a3), a3.seriesXvalues = e3(), a3.seriesYvalues = e3();
    } }, { key: "isMultipleY", value: function() {
      if (this.w.config.yaxis.constructor === Array && this.w.config.yaxis.length > 1) return this.w.globals.isMultipleYAxis = true, true;
    } }, { key: "xySettings", value: function() {
      var t4 = null, e3 = this.w;
      if (e3.globals.axisCharts) {
        if ("back" === e3.config.xaxis.crosshairs.position) new Q2(this.ctx).drawXCrosshairs();
        if ("back" === e3.config.yaxis[0].crosshairs.position) new Q2(this.ctx).drawYCrosshairs();
        if ("datetime" === e3.config.xaxis.type && void 0 === e3.config.xaxis.labels.formatter) {
          this.ctx.timeScale = new Nt2(this.ctx);
          var i2 = [];
          isFinite(e3.globals.minX) && isFinite(e3.globals.maxX) && !e3.globals.isBarHorizontal ? i2 = this.ctx.timeScale.calculateTimeScaleTicks(e3.globals.minX, e3.globals.maxX) : e3.globals.isBarHorizontal && (i2 = this.ctx.timeScale.calculateTimeScaleTicks(e3.globals.minY, e3.globals.maxY)), this.ctx.timeScale.recalcDimensionsBasedOnFormat(i2);
        }
        t4 = new y2(this.ctx).getCalculatedRatios();
      }
      return t4;
    } }, { key: "updateSourceChart", value: function(t4) {
      this.ctx.w.globals.selection = void 0, this.ctx.updateHelpers._updateOptions({ chart: { selection: { xaxis: { min: t4.w.globals.minX, max: t4.w.globals.maxX } } } }, false, false);
    } }, { key: "setupBrushHandler", value: function() {
      var t4 = this, e3 = this.w;
      if (e3.config.chart.brush.enabled && "function" != typeof e3.config.chart.events.selection) {
        var i2 = Array.isArray(e3.config.chart.brush.targets) ? e3.config.chart.brush.targets : [e3.config.chart.brush.target];
        i2.forEach(function(e4) {
          var i3 = ApexCharts.getChartByID(e4);
          i3.w.globals.brushSource = t4.ctx, "function" != typeof i3.w.config.chart.events.zoomed && (i3.w.config.chart.events.zoomed = function() {
            t4.updateSourceChart(i3);
          }), "function" != typeof i3.w.config.chart.events.scrolled && (i3.w.config.chart.events.scrolled = function() {
            t4.updateSourceChart(i3);
          });
        }), e3.config.chart.events.selection = function(t5, e4) {
          i2.forEach(function(t6) {
            ApexCharts.getChartByID(t6).ctx.updateHelpers._updateOptions({ xaxis: { min: e4.xaxis.min, max: e4.xaxis.max } }, false, false, false, false);
          });
        };
      }
    } }]), t3;
  }(), Bt2 = function() {
    function t3(e3) {
      a2(this, t3), this.ctx = e3, this.w = e3.w;
    }
    return r(t3, [{ key: "_updateOptions", value: function(t4) {
      var e3 = this, a3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], s3 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], r2 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], o3 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
      return new Promise(function(n3) {
        var l3 = [e3.ctx];
        r2 && (l3 = e3.ctx.getSyncedCharts()), e3.ctx.w.globals.isExecCalled && (l3 = [e3.ctx], e3.ctx.w.globals.isExecCalled = false), l3.forEach(function(r3, h3) {
          var c3 = r3.w;
          if (c3.globals.shouldAnimate = s3, a3 || (c3.globals.resized = true, c3.globals.dataChanged = true, s3 && r3.series.getPreviousPaths()), t4 && "object" === i(t4) && (r3.config = new Y2(t4), t4 = y2.extendArrayProps(r3.config, t4, c3), r3.w.globals.chartID !== e3.ctx.w.globals.chartID && delete t4.series, c3.config = x2.extend(c3.config, t4), o3 && (c3.globals.lastXAxis = t4.xaxis ? x2.clone(t4.xaxis) : [], c3.globals.lastYAxis = t4.yaxis ? x2.clone(t4.yaxis) : [], c3.globals.initialConfig = x2.extend({}, c3.config), c3.globals.initialSeries = x2.clone(c3.config.series), t4.series))) {
            for (var d3 = 0; d3 < c3.globals.collapsedSeriesIndices.length; d3++) {
              var g3 = c3.config.series[c3.globals.collapsedSeriesIndices[d3]];
              c3.globals.collapsedSeries[d3].data = c3.globals.axisCharts ? g3.data.slice() : g3;
            }
            for (var u3 = 0; u3 < c3.globals.ancillaryCollapsedSeriesIndices.length; u3++) {
              var p3 = c3.config.series[c3.globals.ancillaryCollapsedSeriesIndices[u3]];
              c3.globals.ancillaryCollapsedSeries[u3].data = c3.globals.axisCharts ? p3.data.slice() : p3;
            }
            r3.series.emptyCollapsedSeries(c3.config.series);
          }
          return r3.update(t4).then(function() {
            h3 === l3.length - 1 && n3(r3);
          });
        });
      });
    } }, { key: "_updateSeries", value: function(t4, e3) {
      var i2 = this, a3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
      return new Promise(function(s3) {
        var r2, o3 = i2.w;
        return o3.globals.shouldAnimate = e3, o3.globals.dataChanged = true, e3 && i2.ctx.series.getPreviousPaths(), o3.globals.axisCharts ? (0 === (r2 = t4.map(function(t5, e4) {
          return i2._extendSeries(t5, e4);
        })).length && (r2 = [{ data: [] }]), o3.config.series = r2) : o3.config.series = t4.slice(), a3 && (o3.globals.initialConfig.series = x2.clone(o3.config.series), o3.globals.initialSeries = x2.clone(o3.config.series)), i2.ctx.update().then(function() {
          s3(i2.ctx);
        });
      });
    } }, { key: "_extendSeries", value: function(t4, i2) {
      var a3 = this.w, s3 = a3.config.series[i2];
      return e2(e2({}, a3.config.series[i2]), {}, { name: t4.name ? t4.name : null == s3 ? void 0 : s3.name, color: t4.color ? t4.color : null == s3 ? void 0 : s3.color, type: t4.type ? t4.type : null == s3 ? void 0 : s3.type, group: t4.group ? t4.group : null == s3 ? void 0 : s3.group, data: t4.data ? t4.data : null == s3 ? void 0 : s3.data, zIndex: void 0 !== t4.zIndex ? t4.zIndex : i2 });
    } }, { key: "toggleDataPointSelection", value: function(t4, e3) {
      var i2 = this.w, a3 = null, s3 = ".apexcharts-series[data\\:realIndex='".concat(t4, "']");
      return i2.globals.axisCharts ? a3 = i2.globals.dom.Paper.select("".concat(s3, " path[j='").concat(e3, "'], ").concat(s3, " circle[j='").concat(e3, "'], ").concat(s3, " rect[j='").concat(e3, "']")).members[0] : void 0 === e3 && (a3 = i2.globals.dom.Paper.select("".concat(s3, " path[j='").concat(t4, "']")).members[0], "pie" !== i2.config.chart.type && "polarArea" !== i2.config.chart.type && "donut" !== i2.config.chart.type || this.ctx.pie.pieClicked(t4)), a3 ? (new m2(this.ctx).pathMouseDown(a3, null), a3.node ? a3.node : null) : (console.warn("toggleDataPointSelection: Element not found"), null);
    } }, { key: "forceXAxisUpdate", value: function(t4) {
      var e3 = this.w;
      if (["min", "max"].forEach(function(i3) {
        void 0 !== t4.xaxis[i3] && (e3.config.xaxis[i3] = t4.xaxis[i3], e3.globals.lastXAxis[i3] = t4.xaxis[i3]);
      }), t4.xaxis.categories && t4.xaxis.categories.length && (e3.config.xaxis.categories = t4.xaxis.categories), e3.config.xaxis.convertedCatToNumeric) {
        var i2 = new E2(t4);
        t4 = i2.convertCatToNumericXaxis(t4, this.ctx);
      }
      return t4;
    } }, { key: "forceYAxisUpdate", value: function(t4) {
      return t4.chart && t4.chart.stacked && "100%" === t4.chart.stackType && (Array.isArray(t4.yaxis) ? t4.yaxis.forEach(function(e3, i2) {
        t4.yaxis[i2].min = 0, t4.yaxis[i2].max = 100;
      }) : (t4.yaxis.min = 0, t4.yaxis.max = 100)), t4;
    } }, { key: "revertDefaultAxisMinMax", value: function(t4) {
      var e3 = this, i2 = this.w, a3 = i2.globals.lastXAxis, s3 = i2.globals.lastYAxis;
      t4 && t4.xaxis && (a3 = t4.xaxis), t4 && t4.yaxis && (s3 = t4.yaxis), i2.config.xaxis.min = a3.min, i2.config.xaxis.max = a3.max;
      var r2 = function(t5) {
        void 0 !== s3[t5] && (i2.config.yaxis[t5].min = s3[t5].min, i2.config.yaxis[t5].max = s3[t5].max);
      };
      i2.config.yaxis.map(function(t5, a4) {
        i2.globals.zoomed || void 0 !== s3[a4] ? r2(a4) : void 0 !== e3.ctx.opts.yaxis[a4] && (t5.min = e3.ctx.opts.yaxis[a4].min, t5.max = e3.ctx.opts.yaxis[a4].max);
      });
    } }]), t3;
  }();
  Rt2 = "undefined" != typeof window ? window : void 0, Ht2 = function(t3, e3) {
    var a3 = (void 0 !== this ? this : t3).SVG = function(t4) {
      if (a3.supported) return t4 = new a3.Doc(t4), a3.parser.draw || a3.prepare(), t4;
    };
    if (a3.ns = "http://www.w3.org/2000/svg", a3.xmlns = "http://www.w3.org/2000/xmlns/", a3.xlink = "http://www.w3.org/1999/xlink", a3.svgjs = "http://svgjs.dev", a3.supported = true, !a3.supported) return false;
    a3.did = 1e3, a3.eid = function(t4) {
      return "Svgjs" + d3(t4) + a3.did++;
    }, a3.create = function(t4) {
      var i2 = e3.createElementNS(this.ns, t4);
      return i2.setAttribute("id", this.eid(t4)), i2;
    }, a3.extend = function() {
      var t4, e4;
      e4 = (t4 = [].slice.call(arguments)).pop();
      for (var i2 = t4.length - 1; i2 >= 0; i2--) if (t4[i2]) for (var s4 in e4) t4[i2].prototype[s4] = e4[s4];
      a3.Set && a3.Set.inherit && a3.Set.inherit();
    }, a3.invent = function(t4) {
      var e4 = "function" == typeof t4.create ? t4.create : function() {
        this.constructor.call(this, a3.create(t4.create));
      };
      return t4.inherit && (e4.prototype = new t4.inherit()), t4.extend && a3.extend(e4, t4.extend), t4.construct && a3.extend(t4.parent || a3.Container, t4.construct), e4;
    }, a3.adopt = function(e4) {
      return e4 ? e4.instance ? e4.instance : ((i2 = "svg" == e4.nodeName ? e4.parentNode instanceof t3.SVGElement ? new a3.Nested() : new a3.Doc() : "linearGradient" == e4.nodeName ? new a3.Gradient("linear") : "radialGradient" == e4.nodeName ? new a3.Gradient("radial") : a3[d3(e4.nodeName)] ? new a3[d3(e4.nodeName)]() : new a3.Element(e4)).type = e4.nodeName, i2.node = e4, e4.instance = i2, i2 instanceof a3.Doc && i2.namespace().defs(), i2.setData(JSON.parse(e4.getAttribute("svgjs:data")) || {}), i2) : null;
      var i2;
    }, a3.prepare = function() {
      var t4 = e3.getElementsByTagName("body")[0], i2 = (t4 ? new a3.Doc(t4) : a3.adopt(e3.documentElement).nested()).size(2, 0);
      a3.parser = { body: t4 || e3.documentElement, draw: i2.style("opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden").node, poly: i2.polyline().node, path: i2.path().node, native: a3.create("svg") };
    }, a3.parser = { native: a3.create("svg") }, e3.addEventListener("DOMContentLoaded", function() {
      a3.parser.draw || a3.prepare();
    }, false), a3.regex = { numberAndUnit: /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i, hex: /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i, rgb: /rgb\((\d+),(\d+),(\d+)\)/, reference: /#([a-z0-9\-_]+)/i, transforms: /\)\s*,?\s*/, whitespace: /\s/g, isHex: /^#[a-f0-9]{3,6}$/i, isRgb: /^rgb\(/, isCss: /[^:]+:[^;]+;?/, isBlank: /^(\s+)?$/, isNumber: /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, isPercent: /^-?[\d\.]+%$/, isImage: /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i, delimiter: /[\s,]+/, hyphen: /([^e])\-/gi, pathLetters: /[MLHVCSQTAZ]/gi, isPathLetter: /[MLHVCSQTAZ]/i, numbersWithDots: /((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi, dots: /\./g }, a3.utils = { map: function(t4, e4) {
      for (var i2 = t4.length, a4 = [], s4 = 0; s4 < i2; s4++) a4.push(e4(t4[s4]));
      return a4;
    }, filter: function(t4, e4) {
      for (var i2 = t4.length, a4 = [], s4 = 0; s4 < i2; s4++) e4(t4[s4]) && a4.push(t4[s4]);
      return a4;
    }, filterSVGElements: function(e4) {
      return this.filter(e4, function(e5) {
        return e5 instanceof t3.SVGElement;
      });
    } }, a3.defaults = { attrs: { "fill-opacity": 1, "stroke-opacity": 1, "stroke-width": 0, "stroke-linejoin": "miter", "stroke-linecap": "butt", fill: "#000000", stroke: "#000000", opacity: 1, x: 0, y: 0, cx: 0, cy: 0, width: 0, height: 0, r: 0, rx: 0, ry: 0, offset: 0, "stop-opacity": 1, "stop-color": "#000000", "font-size": 16, "font-family": "Helvetica, Arial, sans-serif", "text-anchor": "start" } }, a3.Color = function(t4) {
      var e4, s4;
      this.r = 0, this.g = 0, this.b = 0, t4 && ("string" == typeof t4 ? a3.regex.isRgb.test(t4) ? (e4 = a3.regex.rgb.exec(t4.replace(a3.regex.whitespace, "")), this.r = parseInt(e4[1]), this.g = parseInt(e4[2]), this.b = parseInt(e4[3])) : a3.regex.isHex.test(t4) && (e4 = a3.regex.hex.exec(4 == (s4 = t4).length ? ["#", s4.substring(1, 2), s4.substring(1, 2), s4.substring(2, 3), s4.substring(2, 3), s4.substring(3, 4), s4.substring(3, 4)].join("") : s4), this.r = parseInt(e4[1], 16), this.g = parseInt(e4[2], 16), this.b = parseInt(e4[3], 16)) : "object" === i(t4) && (this.r = t4.r, this.g = t4.g, this.b = t4.b));
    }, a3.extend(a3.Color, { toString: function() {
      return this.toHex();
    }, toHex: function() {
      return "#" + g3(this.r) + g3(this.g) + g3(this.b);
    }, toRgb: function() {
      return "rgb(" + [this.r, this.g, this.b].join() + ")";
    }, brightness: function() {
      return this.r / 255 * 0.3 + this.g / 255 * 0.59 + this.b / 255 * 0.11;
    }, morph: function(t4) {
      return this.destination = new a3.Color(t4), this;
    }, at: function(t4) {
      return this.destination ? (t4 = t4 < 0 ? 0 : t4 > 1 ? 1 : t4, new a3.Color({ r: ~~(this.r + (this.destination.r - this.r) * t4), g: ~~(this.g + (this.destination.g - this.g) * t4), b: ~~(this.b + (this.destination.b - this.b) * t4) })) : this;
    } }), a3.Color.test = function(t4) {
      return t4 += "", a3.regex.isHex.test(t4) || a3.regex.isRgb.test(t4);
    }, a3.Color.isRgb = function(t4) {
      return t4 && "number" == typeof t4.r && "number" == typeof t4.g && "number" == typeof t4.b;
    }, a3.Color.isColor = function(t4) {
      return a3.Color.isRgb(t4) || a3.Color.test(t4);
    }, a3.Array = function(t4, e4) {
      0 == (t4 = (t4 || []).valueOf()).length && e4 && (t4 = e4.valueOf()), this.value = this.parse(t4);
    }, a3.extend(a3.Array, { toString: function() {
      return this.value.join(" ");
    }, valueOf: function() {
      return this.value;
    }, parse: function(t4) {
      return t4 = t4.valueOf(), Array.isArray(t4) ? t4 : this.split(t4);
    } }), a3.PointArray = function(t4, e4) {
      a3.Array.call(this, t4, e4 || [[0, 0]]);
    }, a3.PointArray.prototype = new a3.Array(), a3.PointArray.prototype.constructor = a3.PointArray;
    for (var s3 = { M: function(t4, e4, i2) {
      return e4.x = i2.x = t4[0], e4.y = i2.y = t4[1], ["M", e4.x, e4.y];
    }, L: function(t4, e4) {
      return e4.x = t4[0], e4.y = t4[1], ["L", t4[0], t4[1]];
    }, H: function(t4, e4) {
      return e4.x = t4[0], ["H", t4[0]];
    }, V: function(t4, e4) {
      return e4.y = t4[0], ["V", t4[0]];
    }, C: function(t4, e4) {
      return e4.x = t4[4], e4.y = t4[5], ["C", t4[0], t4[1], t4[2], t4[3], t4[4], t4[5]];
    }, Q: function(t4, e4) {
      return e4.x = t4[2], e4.y = t4[3], ["Q", t4[0], t4[1], t4[2], t4[3]];
    }, S: function(t4, e4) {
      return e4.x = t4[2], e4.y = t4[3], ["S", t4[0], t4[1], t4[2], t4[3]];
    }, Z: function(t4, e4, i2) {
      return e4.x = i2.x, e4.y = i2.y, ["Z"];
    } }, r2 = "mlhvqtcsaz".split(""), o3 = 0, n3 = r2.length; o3 < n3; ++o3) s3[r2[o3]] = /* @__PURE__ */ function(t4) {
      return function(e4, i2, a4) {
        if ("H" == t4) e4[0] = e4[0] + i2.x;
        else if ("V" == t4) e4[0] = e4[0] + i2.y;
        else if ("A" == t4) e4[5] = e4[5] + i2.x, e4[6] = e4[6] + i2.y;
        else for (var r3 = 0, o4 = e4.length; r3 < o4; ++r3) e4[r3] = e4[r3] + (r3 % 2 ? i2.y : i2.x);
        if (s3 && "function" == typeof s3[t4]) return s3[t4](e4, i2, a4);
      };
    }(r2[o3].toUpperCase());
    a3.PathArray = function(t4, e4) {
      a3.Array.call(this, t4, e4 || [["M", 0, 0]]);
    }, a3.PathArray.prototype = new a3.Array(), a3.PathArray.prototype.constructor = a3.PathArray, a3.extend(a3.PathArray, { toString: function() {
      return function(t4) {
        for (var e4 = 0, i2 = t4.length, a4 = ""; e4 < i2; e4++) a4 += t4[e4][0], null != t4[e4][1] && (a4 += t4[e4][1], null != t4[e4][2] && (a4 += " ", a4 += t4[e4][2], null != t4[e4][3] && (a4 += " ", a4 += t4[e4][3], a4 += " ", a4 += t4[e4][4], null != t4[e4][5] && (a4 += " ", a4 += t4[e4][5], a4 += " ", a4 += t4[e4][6], null != t4[e4][7] && (a4 += " ", a4 += t4[e4][7])))));
        return a4 + " ";
      }(this.value);
    }, move: function(t4, e4) {
      var i2 = this.bbox();
      return i2.x, i2.y, this;
    }, at: function(t4) {
      if (!this.destination) return this;
      for (var e4 = this.value, i2 = this.destination.value, s4 = [], r3 = new a3.PathArray(), o4 = 0, n4 = e4.length; o4 < n4; o4++) {
        s4[o4] = [e4[o4][0]];
        for (var l4 = 1, h4 = e4[o4].length; l4 < h4; l4++) s4[o4][l4] = e4[o4][l4] + (i2[o4][l4] - e4[o4][l4]) * t4;
        "A" === s4[o4][0] && (s4[o4][4] = +(0 != s4[o4][4]), s4[o4][5] = +(0 != s4[o4][5]));
      }
      return r3.value = s4, r3;
    }, parse: function(t4) {
      if (t4 instanceof a3.PathArray) return t4.valueOf();
      var e4, i2 = { M: 2, L: 2, H: 1, V: 1, C: 6, S: 4, Q: 4, T: 2, A: 7, Z: 0 };
      t4 = "string" == typeof t4 ? t4.replace(a3.regex.numbersWithDots, h3).replace(a3.regex.pathLetters, " $& ").replace(a3.regex.hyphen, "$1 -").trim().split(a3.regex.delimiter) : t4.reduce(function(t5, e5) {
        return [].concat.call(t5, e5);
      }, []);
      var r3 = [], o4 = new a3.Point(), n4 = new a3.Point(), l4 = 0, c4 = t4.length;
      do {
        a3.regex.isPathLetter.test(t4[l4]) ? (e4 = t4[l4], ++l4) : "M" == e4 ? e4 = "L" : "m" == e4 && (e4 = "l"), r3.push(s3[e4].call(null, t4.slice(l4, l4 += i2[e4.toUpperCase()]).map(parseFloat), o4, n4));
      } while (c4 > l4);
      return r3;
    }, bbox: function() {
      return a3.parser.draw || a3.prepare(), a3.parser.path.setAttribute("d", this.toString()), a3.parser.path.getBBox();
    } }), a3.Number = a3.invent({ create: function(t4, e4) {
      this.value = 0, this.unit = e4 || "", "number" == typeof t4 ? this.value = isNaN(t4) ? 0 : isFinite(t4) ? t4 : t4 < 0 ? -34e37 : 34e37 : "string" == typeof t4 ? (e4 = t4.match(a3.regex.numberAndUnit)) && (this.value = parseFloat(e4[1]), "%" == e4[5] ? this.value /= 100 : "s" == e4[5] && (this.value *= 1e3), this.unit = e4[5]) : t4 instanceof a3.Number && (this.value = t4.valueOf(), this.unit = t4.unit);
    }, extend: { toString: function() {
      return ("%" == this.unit ? ~~(1e8 * this.value) / 1e6 : "s" == this.unit ? this.value / 1e3 : this.value) + this.unit;
    }, toJSON: function() {
      return this.toString();
    }, valueOf: function() {
      return this.value;
    }, plus: function(t4) {
      return t4 = new a3.Number(t4), new a3.Number(this + t4, this.unit || t4.unit);
    }, minus: function(t4) {
      return t4 = new a3.Number(t4), new a3.Number(this - t4, this.unit || t4.unit);
    }, times: function(t4) {
      return t4 = new a3.Number(t4), new a3.Number(this * t4, this.unit || t4.unit);
    }, divide: function(t4) {
      return t4 = new a3.Number(t4), new a3.Number(this / t4, this.unit || t4.unit);
    }, to: function(t4) {
      var e4 = new a3.Number(this);
      return "string" == typeof t4 && (e4.unit = t4), e4;
    }, morph: function(t4) {
      return this.destination = new a3.Number(t4), t4.relative && (this.destination.value += this.value), this;
    }, at: function(t4) {
      return this.destination ? new a3.Number(this.destination).minus(this).times(t4).plus(this) : this;
    } } }), a3.Element = a3.invent({ create: function(t4) {
      this._stroke = a3.defaults.attrs.stroke, this._event = null, this.dom = {}, (this.node = t4) && (this.type = t4.nodeName, this.node.instance = this, this._stroke = t4.getAttribute("stroke") || this._stroke);
    }, extend: { x: function(t4) {
      return this.attr("x", t4);
    }, y: function(t4) {
      return this.attr("y", t4);
    }, cx: function(t4) {
      return null == t4 ? this.x() + this.width() / 2 : this.x(t4 - this.width() / 2);
    }, cy: function(t4) {
      return null == t4 ? this.y() + this.height() / 2 : this.y(t4 - this.height() / 2);
    }, move: function(t4, e4) {
      return this.x(t4).y(e4);
    }, center: function(t4, e4) {
      return this.cx(t4).cy(e4);
    }, width: function(t4) {
      return this.attr("width", t4);
    }, height: function(t4) {
      return this.attr("height", t4);
    }, size: function(t4, e4) {
      var i2 = u3(this, t4, e4);
      return this.width(new a3.Number(i2.width)).height(new a3.Number(i2.height));
    }, clone: function(t4) {
      this.writeDataToDom();
      var e4 = x3(this.node.cloneNode(true));
      return t4 ? t4.add(e4) : this.after(e4), e4;
    }, remove: function() {
      return this.parent() && this.parent().removeElement(this), this;
    }, replace: function(t4) {
      return this.after(t4).remove(), t4;
    }, addTo: function(t4) {
      return t4.put(this);
    }, putIn: function(t4) {
      return t4.add(this);
    }, id: function(t4) {
      return this.attr("id", t4);
    }, show: function() {
      return this.style("display", "");
    }, hide: function() {
      return this.style("display", "none");
    }, visible: function() {
      return "none" != this.style("display");
    }, toString: function() {
      return this.attr("id");
    }, classes: function() {
      var t4 = this.attr("class");
      return null == t4 ? [] : t4.trim().split(a3.regex.delimiter);
    }, hasClass: function(t4) {
      return -1 != this.classes().indexOf(t4);
    }, addClass: function(t4) {
      if (!this.hasClass(t4)) {
        var e4 = this.classes();
        e4.push(t4), this.attr("class", e4.join(" "));
      }
      return this;
    }, removeClass: function(t4) {
      return this.hasClass(t4) && this.attr("class", this.classes().filter(function(e4) {
        return e4 != t4;
      }).join(" ")), this;
    }, toggleClass: function(t4) {
      return this.hasClass(t4) ? this.removeClass(t4) : this.addClass(t4);
    }, reference: function(t4) {
      return a3.get(this.attr(t4));
    }, parent: function(e4) {
      var i2 = this;
      if (!i2.node.parentNode) return null;
      if (i2 = a3.adopt(i2.node.parentNode), !e4) return i2;
      for (; i2 && i2.node instanceof t3.SVGElement; ) {
        if ("string" == typeof e4 ? i2.matches(e4) : i2 instanceof e4) return i2;
        if (!i2.node.parentNode || "#document" == i2.node.parentNode.nodeName) return null;
        i2 = a3.adopt(i2.node.parentNode);
      }
    }, doc: function() {
      return this instanceof a3.Doc ? this : this.parent(a3.Doc);
    }, parents: function(t4) {
      var e4 = [], i2 = this;
      do {
        if (!(i2 = i2.parent(t4)) || !i2.node) break;
        e4.push(i2);
      } while (i2.parent);
      return e4;
    }, matches: function(t4) {
      return function(t5, e4) {
        return (t5.matches || t5.matchesSelector || t5.msMatchesSelector || t5.mozMatchesSelector || t5.webkitMatchesSelector || t5.oMatchesSelector).call(t5, e4);
      }(this.node, t4);
    }, native: function() {
      return this.node;
    }, svg: function(t4) {
      var i2 = e3.createElementNS("http://www.w3.org/2000/svg", "svg");
      if (!(t4 && this instanceof a3.Parent)) return i2.appendChild(t4 = e3.createElementNS("http://www.w3.org/2000/svg", "svg")), this.writeDataToDom(), t4.appendChild(this.node.cloneNode(true)), i2.innerHTML.replace(/^<svg>/, "").replace(/<\/svg>$/, "");
      i2.innerHTML = "<svg>" + t4.replace(/\n/, "").replace(/<([\w:-]+)([^<]+?)\/>/g, "<$1$2></$1>") + "</svg>";
      for (var s4 = 0, r3 = i2.firstChild.childNodes.length; s4 < r3; s4++) this.node.appendChild(i2.firstChild.firstChild);
      return this;
    }, writeDataToDom: function() {
      return (this.each || this.lines) && (this.each ? this : this.lines()).each(function() {
        this.writeDataToDom();
      }), this.node.removeAttribute("svgjs:data"), Object.keys(this.dom).length && this.node.setAttribute("svgjs:data", JSON.stringify(this.dom)), this;
    }, setData: function(t4) {
      return this.dom = t4, this;
    }, is: function(t4) {
      return function(t5, e4) {
        return t5 instanceof e4;
      }(this, t4);
    } } }), a3.easing = { "-": function(t4) {
      return t4;
    }, "<>": function(t4) {
      return -Math.cos(t4 * Math.PI) / 2 + 0.5;
    }, ">": function(t4) {
      return Math.sin(t4 * Math.PI / 2);
    }, "<": function(t4) {
      return 1 - Math.cos(t4 * Math.PI / 2);
    } }, a3.morph = function(t4) {
      return function(e4, i2) {
        return new a3.MorphObj(e4, i2).at(t4);
      };
    }, a3.Situation = a3.invent({ create: function(t4) {
      this.init = false, this.reversed = false, this.reversing = false, this.duration = new a3.Number(t4.duration).valueOf(), this.delay = new a3.Number(t4.delay).valueOf(), this.start = +/* @__PURE__ */ new Date() + this.delay, this.finish = this.start + this.duration, this.ease = t4.ease, this.loop = 0, this.loops = false, this.animations = {}, this.attrs = {}, this.styles = {}, this.transforms = [], this.once = {};
    } }), a3.FX = a3.invent({ create: function(t4) {
      this._target = t4, this.situations = [], this.active = false, this.situation = null, this.paused = false, this.lastPos = 0, this.pos = 0, this.absPos = 0, this._speed = 1;
    }, extend: { animate: function(t4, e4, s4) {
      "object" === i(t4) && (e4 = t4.ease, s4 = t4.delay, t4 = t4.duration);
      var r3 = new a3.Situation({ duration: t4 || 1e3, delay: s4 || 0, ease: a3.easing[e4 || "-"] || e4 });
      return this.queue(r3), this;
    }, target: function(t4) {
      return t4 && t4 instanceof a3.Element ? (this._target = t4, this) : this._target;
    }, timeToAbsPos: function(t4) {
      return (t4 - this.situation.start) / (this.situation.duration / this._speed);
    }, absPosToTime: function(t4) {
      return this.situation.duration / this._speed * t4 + this.situation.start;
    }, startAnimFrame: function() {
      this.stopAnimFrame(), this.animationFrame = t3.requestAnimationFrame((function() {
        this.step();
      }).bind(this));
    }, stopAnimFrame: function() {
      t3.cancelAnimationFrame(this.animationFrame);
    }, start: function() {
      return !this.active && this.situation && (this.active = true, this.startCurrent()), this;
    }, startCurrent: function() {
      return this.situation.start = +/* @__PURE__ */ new Date() + this.situation.delay / this._speed, this.situation.finish = this.situation.start + this.situation.duration / this._speed, this.initAnimations().step();
    }, queue: function(t4) {
      return ("function" == typeof t4 || t4 instanceof a3.Situation) && this.situations.push(t4), this.situation || (this.situation = this.situations.shift()), this;
    }, dequeue: function() {
      return this.stop(), this.situation = this.situations.shift(), this.situation && (this.situation instanceof a3.Situation ? this.start() : this.situation.call(this)), this;
    }, initAnimations: function() {
      var t4, e4 = this.situation;
      if (e4.init) return this;
      for (var i2 in e4.animations) {
        t4 = this.target()[i2](), Array.isArray(t4) || (t4 = [t4]), Array.isArray(e4.animations[i2]) || (e4.animations[i2] = [e4.animations[i2]]);
        for (var s4 = t4.length; s4--; ) e4.animations[i2][s4] instanceof a3.Number && (t4[s4] = new a3.Number(t4[s4])), e4.animations[i2][s4] = t4[s4].morph(e4.animations[i2][s4]);
      }
      for (var i2 in e4.attrs) e4.attrs[i2] = new a3.MorphObj(this.target().attr(i2), e4.attrs[i2]);
      for (var i2 in e4.styles) e4.styles[i2] = new a3.MorphObj(this.target().style(i2), e4.styles[i2]);
      return e4.initialTransformation = this.target().matrixify(), e4.init = true, this;
    }, clearQueue: function() {
      return this.situations = [], this;
    }, clearCurrent: function() {
      return this.situation = null, this;
    }, stop: function(t4, e4) {
      var i2 = this.active;
      return this.active = false, e4 && this.clearQueue(), t4 && this.situation && (!i2 && this.startCurrent(), this.atEnd()), this.stopAnimFrame(), this.clearCurrent();
    }, after: function(t4) {
      var e4 = this.last();
      return this.target().on("finished.fx", function i2(a4) {
        a4.detail.situation == e4 && (t4.call(this, e4), this.off("finished.fx", i2));
      }), this._callStart();
    }, during: function(t4) {
      var e4 = this.last(), i2 = function(i3) {
        i3.detail.situation == e4 && t4.call(this, i3.detail.pos, a3.morph(i3.detail.pos), i3.detail.eased, e4);
      };
      return this.target().off("during.fx", i2).on("during.fx", i2), this.after(function() {
        this.off("during.fx", i2);
      }), this._callStart();
    }, afterAll: function(t4) {
      var e4 = function e5(i2) {
        t4.call(this), this.off("allfinished.fx", e5);
      };
      return this.target().off("allfinished.fx", e4).on("allfinished.fx", e4), this._callStart();
    }, last: function() {
      return this.situations.length ? this.situations[this.situations.length - 1] : this.situation;
    }, add: function(t4, e4, i2) {
      return this.last()[i2 || "animations"][t4] = e4, this._callStart();
    }, step: function(t4) {
      var e4, i2, a4;
      t4 || (this.absPos = this.timeToAbsPos(+/* @__PURE__ */ new Date())), false !== this.situation.loops ? (e4 = Math.max(this.absPos, 0), i2 = Math.floor(e4), true === this.situation.loops || i2 < this.situation.loops ? (this.pos = e4 - i2, a4 = this.situation.loop, this.situation.loop = i2) : (this.absPos = this.situation.loops, this.pos = 1, a4 = this.situation.loop - 1, this.situation.loop = this.situation.loops), this.situation.reversing && (this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - a4) % 2))) : (this.absPos = Math.min(this.absPos, 1), this.pos = this.absPos), this.pos < 0 && (this.pos = 0), this.situation.reversed && (this.pos = 1 - this.pos);
      var s4 = this.situation.ease(this.pos);
      for (var r3 in this.situation.once) r3 > this.lastPos && r3 <= s4 && (this.situation.once[r3].call(this.target(), this.pos, s4), delete this.situation.once[r3]);
      return this.active && this.target().fire("during", { pos: this.pos, eased: s4, fx: this, situation: this.situation }), this.situation ? (this.eachAt(), 1 == this.pos && !this.situation.reversed || this.situation.reversed && 0 == this.pos ? (this.stopAnimFrame(), this.target().fire("finished", { fx: this, situation: this.situation }), this.situations.length || (this.target().fire("allfinished"), this.situations.length || (this.target().off(".fx"), this.active = false)), this.active ? this.dequeue() : this.clearCurrent()) : !this.paused && this.active && this.startAnimFrame(), this.lastPos = s4, this) : this;
    }, eachAt: function() {
      var t4, e4 = this, i2 = this.target(), s4 = this.situation;
      for (var r3 in s4.animations) t4 = [].concat(s4.animations[r3]).map(function(t5) {
        return "string" != typeof t5 && t5.at ? t5.at(s4.ease(e4.pos), e4.pos) : t5;
      }), i2[r3].apply(i2, t4);
      for (var r3 in s4.attrs) t4 = [r3].concat(s4.attrs[r3]).map(function(t5) {
        return "string" != typeof t5 && t5.at ? t5.at(s4.ease(e4.pos), e4.pos) : t5;
      }), i2.attr.apply(i2, t4);
      for (var r3 in s4.styles) t4 = [r3].concat(s4.styles[r3]).map(function(t5) {
        return "string" != typeof t5 && t5.at ? t5.at(s4.ease(e4.pos), e4.pos) : t5;
      }), i2.style.apply(i2, t4);
      if (s4.transforms.length) {
        t4 = s4.initialTransformation, r3 = 0;
        for (var o4 = s4.transforms.length; r3 < o4; r3++) {
          var n4 = s4.transforms[r3];
          n4 instanceof a3.Matrix ? t4 = n4.relative ? t4.multiply(new a3.Matrix().morph(n4).at(s4.ease(this.pos))) : t4.morph(n4).at(s4.ease(this.pos)) : (n4.relative || n4.undo(t4.extract()), t4 = t4.multiply(n4.at(s4.ease(this.pos))));
        }
        i2.matrix(t4);
      }
      return this;
    }, once: function(t4, e4, i2) {
      var a4 = this.last();
      return i2 || (t4 = a4.ease(t4)), a4.once[t4] = e4, this;
    }, _callStart: function() {
      return setTimeout((function() {
        this.start();
      }).bind(this), 0), this;
    } }, parent: a3.Element, construct: { animate: function(t4, e4, i2) {
      return (this.fx || (this.fx = new a3.FX(this))).animate(t4, e4, i2);
    }, delay: function(t4) {
      return (this.fx || (this.fx = new a3.FX(this))).delay(t4);
    }, stop: function(t4, e4) {
      return this.fx && this.fx.stop(t4, e4), this;
    }, finish: function() {
      return this.fx && this.fx.finish(), this;
    } } }), a3.MorphObj = a3.invent({ create: function(t4, e4) {
      return a3.Color.isColor(e4) ? new a3.Color(t4).morph(e4) : a3.regex.delimiter.test(t4) ? a3.regex.pathLetters.test(t4) ? new a3.PathArray(t4).morph(e4) : new a3.Array(t4).morph(e4) : a3.regex.numberAndUnit.test(e4) ? new a3.Number(t4).morph(e4) : (this.value = t4, void (this.destination = e4));
    }, extend: { at: function(t4, e4) {
      return e4 < 1 ? this.value : this.destination;
    }, valueOf: function() {
      return this.value;
    } } }), a3.extend(a3.FX, { attr: function(t4, e4, a4) {
      if ("object" === i(t4)) for (var s4 in t4) this.attr(s4, t4[s4]);
      else this.add(t4, e4, "attrs");
      return this;
    }, plot: function(t4, e4, i2, a4) {
      return 4 == arguments.length ? this.plot([t4, e4, i2, a4]) : this.add("plot", new (this.target()).morphArray(t4));
    } }), a3.Box = a3.invent({ create: function(t4, e4, s4, r3) {
      if (!("object" !== i(t4) || t4 instanceof a3.Element)) return a3.Box.call(this, null != t4.left ? t4.left : t4.x, null != t4.top ? t4.top : t4.y, t4.width, t4.height);
      var o4;
      4 == arguments.length && (this.x = t4, this.y = e4, this.width = s4, this.height = r3), null == (o4 = this).x && (o4.x = 0, o4.y = 0, o4.width = 0, o4.height = 0), o4.w = o4.width, o4.h = o4.height, o4.x2 = o4.x + o4.width, o4.y2 = o4.y + o4.height, o4.cx = o4.x + o4.width / 2, o4.cy = o4.y + o4.height / 2;
    } }), a3.BBox = a3.invent({ create: function(t4) {
      if (a3.Box.apply(this, [].slice.call(arguments)), t4 instanceof a3.Element) {
        var i2;
        try {
          if (!e3.documentElement.contains) {
            for (var s4 = t4.node; s4.parentNode; ) s4 = s4.parentNode;
            if (s4 != e3) throw new Error("Element not in the dom");
          }
          i2 = t4.node.getBBox();
        } catch (e4) {
          if (t4 instanceof a3.Shape) {
            a3.parser.draw || a3.prepare();
            var r3 = t4.clone(a3.parser.draw.instance).show();
            r3 && r3.node && "function" == typeof r3.node.getBBox && (i2 = r3.node.getBBox()), r3 && "function" == typeof r3.remove && r3.remove();
          } else i2 = { x: t4.node.clientLeft, y: t4.node.clientTop, width: t4.node.clientWidth, height: t4.node.clientHeight };
        }
        a3.Box.call(this, i2);
      }
    }, inherit: a3.Box, parent: a3.Element, construct: { bbox: function() {
      return new a3.BBox(this);
    } } }), a3.BBox.prototype.constructor = a3.BBox, a3.Matrix = a3.invent({ create: function(t4) {
      var e4 = f3([1, 0, 0, 1, 0, 0]);
      t4 = null === t4 ? e4 : t4 instanceof a3.Element ? t4.matrixify() : "string" == typeof t4 ? f3(t4.split(a3.regex.delimiter).map(parseFloat)) : 6 == arguments.length ? f3([].slice.call(arguments)) : Array.isArray(t4) ? f3(t4) : t4 && "object" === i(t4) ? t4 : e4;
      for (var s4 = v3.length - 1; s4 >= 0; --s4) this[v3[s4]] = null != t4[v3[s4]] ? t4[v3[s4]] : e4[v3[s4]];
    }, extend: { extract: function() {
      var t4 = p3(this, 0, 1);
      p3(this, 1, 0);
      var e4 = 180 / Math.PI * Math.atan2(t4.y, t4.x) - 90;
      return { x: this.e, y: this.f, transformedX: (this.e * Math.cos(e4 * Math.PI / 180) + this.f * Math.sin(e4 * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b), transformedY: (this.f * Math.cos(e4 * Math.PI / 180) + this.e * Math.sin(-e4 * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d), rotation: e4, a: this.a, b: this.b, c: this.c, d: this.d, e: this.e, f: this.f, matrix: new a3.Matrix(this) };
    }, clone: function() {
      return new a3.Matrix(this);
    }, morph: function(t4) {
      return this.destination = new a3.Matrix(t4), this;
    }, multiply: function(t4) {
      return new a3.Matrix(this.native().multiply(function(t5) {
        return t5 instanceof a3.Matrix || (t5 = new a3.Matrix(t5)), t5;
      }(t4).native()));
    }, inverse: function() {
      return new a3.Matrix(this.native().inverse());
    }, translate: function(t4, e4) {
      return new a3.Matrix(this.native().translate(t4 || 0, e4 || 0));
    }, native: function() {
      for (var t4 = a3.parser.native.createSVGMatrix(), e4 = v3.length - 1; e4 >= 0; e4--) t4[v3[e4]] = this[v3[e4]];
      return t4;
    }, toString: function() {
      return "matrix(" + b3(this.a) + "," + b3(this.b) + "," + b3(this.c) + "," + b3(this.d) + "," + b3(this.e) + "," + b3(this.f) + ")";
    } }, parent: a3.Element, construct: { ctm: function() {
      return new a3.Matrix(this.node.getCTM());
    }, screenCTM: function() {
      if (this instanceof a3.Nested) {
        var t4 = this.rect(1, 1), e4 = t4.node.getScreenCTM();
        return t4.remove(), new a3.Matrix(e4);
      }
      return new a3.Matrix(this.node.getScreenCTM());
    } } }), a3.Point = a3.invent({ create: function(t4, e4) {
      var a4;
      a4 = Array.isArray(t4) ? { x: t4[0], y: t4[1] } : "object" === i(t4) ? { x: t4.x, y: t4.y } : null != t4 ? { x: t4, y: null != e4 ? e4 : t4 } : { x: 0, y: 0 }, this.x = a4.x, this.y = a4.y;
    }, extend: { clone: function() {
      return new a3.Point(this);
    }, morph: function(t4, e4) {
      return this.destination = new a3.Point(t4, e4), this;
    } } }), a3.extend(a3.Element, { point: function(t4, e4) {
      return new a3.Point(t4, e4).transform(this.screenCTM().inverse());
    } }), a3.extend(a3.Element, { attr: function(t4, e4, s4) {
      if (null == t4) {
        for (t4 = {}, s4 = (e4 = this.node.attributes).length - 1; s4 >= 0; s4--) t4[e4[s4].nodeName] = a3.regex.isNumber.test(e4[s4].nodeValue) ? parseFloat(e4[s4].nodeValue) : e4[s4].nodeValue;
        return t4;
      }
      if ("object" === i(t4)) for (var r3 in t4) this.attr(r3, t4[r3]);
      else if (null === e4) this.node.removeAttribute(t4);
      else {
        if (null == e4) return null == (e4 = this.node.getAttribute(t4)) ? a3.defaults.attrs[t4] : a3.regex.isNumber.test(e4) ? parseFloat(e4) : e4;
        "stroke-width" == t4 ? this.attr("stroke", parseFloat(e4) > 0 ? this._stroke : null) : "stroke" == t4 && (this._stroke = e4), "fill" != t4 && "stroke" != t4 || (a3.regex.isImage.test(e4) && (e4 = this.doc().defs().image(e4, 0, 0)), e4 instanceof a3.Image && (e4 = this.doc().defs().pattern(0, 0, function() {
          this.add(e4);
        }))), "number" == typeof e4 ? e4 = new a3.Number(e4) : a3.Color.isColor(e4) ? e4 = new a3.Color(e4) : Array.isArray(e4) && (e4 = new a3.Array(e4)), "leading" == t4 ? this.leading && this.leading(e4) : "string" == typeof s4 ? this.node.setAttributeNS(s4, t4, e4.toString()) : this.node.setAttribute(t4, e4.toString()), !this.rebuild || "font-size" != t4 && "x" != t4 || this.rebuild(t4, e4);
      }
      return this;
    } }), a3.extend(a3.Element, { transform: function(t4, e4) {
      var s4;
      return "object" !== i(t4) ? (s4 = new a3.Matrix(this).extract(), "string" == typeof t4 ? s4[t4] : s4) : (s4 = new a3.Matrix(this), e4 = !!e4 || !!t4.relative, null != t4.a && (s4 = e4 ? s4.multiply(new a3.Matrix(t4)) : new a3.Matrix(t4)), this.attr("transform", s4));
    } }), a3.extend(a3.Element, { untransform: function() {
      return this.attr("transform", null);
    }, matrixify: function() {
      return (this.attr("transform") || "").split(a3.regex.transforms).slice(0, -1).map(function(t4) {
        var e4 = t4.trim().split("(");
        return [e4[0], e4[1].split(a3.regex.delimiter).map(function(t5) {
          return parseFloat(t5);
        })];
      }).reduce(function(t4, e4) {
        return "matrix" == e4[0] ? t4.multiply(f3(e4[1])) : t4[e4[0]].apply(t4, e4[1]);
      }, new a3.Matrix());
    }, toParent: function(t4) {
      if (this == t4) return this;
      var e4 = this.screenCTM(), i2 = t4.screenCTM().inverse();
      return this.addTo(t4).untransform().transform(i2.multiply(e4)), this;
    }, toDoc: function() {
      return this.toParent(this.doc());
    } }), a3.Transformation = a3.invent({ create: function(t4, e4) {
      if (arguments.length > 1 && "boolean" != typeof e4) return this.constructor.call(this, [].slice.call(arguments));
      if (Array.isArray(t4)) for (var a4 = 0, s4 = this.arguments.length; a4 < s4; ++a4) this[this.arguments[a4]] = t4[a4];
      else if (t4 && "object" === i(t4)) for (a4 = 0, s4 = this.arguments.length; a4 < s4; ++a4) this[this.arguments[a4]] = t4[this.arguments[a4]];
      this.inversed = false, true === e4 && (this.inversed = true);
    } }), a3.Translate = a3.invent({ parent: a3.Matrix, inherit: a3.Transformation, create: function(t4, e4) {
      this.constructor.apply(this, [].slice.call(arguments));
    }, extend: { arguments: ["transformedX", "transformedY"], method: "translate" } }), a3.extend(a3.Element, { style: function(t4, e4) {
      if (0 == arguments.length) return this.node.style.cssText || "";
      if (arguments.length < 2) if ("object" === i(t4)) for (var s4 in t4) this.style(s4, t4[s4]);
      else {
        if (!a3.regex.isCss.test(t4)) return this.node.style[c3(t4)];
        for (t4 = t4.split(/\s*;\s*/).filter(function(t5) {
          return !!t5;
        }).map(function(t5) {
          return t5.split(/\s*:\s*/);
        }); e4 = t4.pop(); ) this.style(e4[0], e4[1]);
      }
      else this.node.style[c3(t4)] = null === e4 || a3.regex.isBlank.test(e4) ? "" : e4;
      return this;
    } }), a3.Parent = a3.invent({ create: function(t4) {
      this.constructor.call(this, t4);
    }, inherit: a3.Element, extend: { children: function() {
      return a3.utils.map(a3.utils.filterSVGElements(this.node.childNodes), function(t4) {
        return a3.adopt(t4);
      });
    }, add: function(t4, e4) {
      return null == e4 ? this.node.appendChild(t4.node) : t4.node != this.node.childNodes[e4] && this.node.insertBefore(t4.node, this.node.childNodes[e4]), this;
    }, put: function(t4, e4) {
      return this.add(t4, e4), t4;
    }, has: function(t4) {
      return this.index(t4) >= 0;
    }, index: function(t4) {
      return [].slice.call(this.node.childNodes).indexOf(t4.node);
    }, get: function(t4) {
      return a3.adopt(this.node.childNodes[t4]);
    }, first: function() {
      return this.get(0);
    }, last: function() {
      return this.get(this.node.childNodes.length - 1);
    }, each: function(t4, e4) {
      for (var i2 = this.children(), s4 = 0, r3 = i2.length; s4 < r3; s4++) i2[s4] instanceof a3.Element && t4.apply(i2[s4], [s4, i2]), e4 && i2[s4] instanceof a3.Container && i2[s4].each(t4, e4);
      return this;
    }, removeElement: function(t4) {
      return this.node.removeChild(t4.node), this;
    }, clear: function() {
      for (; this.node.hasChildNodes(); ) this.node.removeChild(this.node.lastChild);
      return delete this._defs, this;
    }, defs: function() {
      return this.doc().defs();
    } } }), a3.extend(a3.Parent, { ungroup: function(t4, e4) {
      return 0 === e4 || this instanceof a3.Defs || this.node == a3.parser.draw || (t4 = t4 || (this instanceof a3.Doc ? this : this.parent(a3.Parent)), e4 = e4 || 1 / 0, this.each(function() {
        return this instanceof a3.Defs ? this : this instanceof a3.Parent ? this.ungroup(t4, e4 - 1) : this.toParent(t4);
      }), this.node.firstChild || this.remove()), this;
    }, flatten: function(t4, e4) {
      return this.ungroup(t4, e4);
    } }), a3.Container = a3.invent({ create: function(t4) {
      this.constructor.call(this, t4);
    }, inherit: a3.Parent }), a3.ViewBox = a3.invent({ parent: a3.Container, construct: {} }), ["click", "dblclick", "mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "touchstart", "touchmove", "touchleave", "touchend", "touchcancel"].forEach(function(t4) {
      a3.Element.prototype[t4] = function(e4) {
        return a3.on(this.node, t4, e4), this;
      };
    }), a3.listeners = [], a3.handlerMap = [], a3.listenerId = 0, a3.on = function(t4, e4, i2, s4, r3) {
      var o4 = i2.bind(s4 || t4.instance || t4), n4 = (a3.handlerMap.indexOf(t4) + 1 || a3.handlerMap.push(t4)) - 1, l4 = e4.split(".")[0], h4 = e4.split(".")[1] || "*";
      a3.listeners[n4] = a3.listeners[n4] || {}, a3.listeners[n4][l4] = a3.listeners[n4][l4] || {}, a3.listeners[n4][l4][h4] = a3.listeners[n4][l4][h4] || {}, i2._svgjsListenerId || (i2._svgjsListenerId = ++a3.listenerId), a3.listeners[n4][l4][h4][i2._svgjsListenerId] = o4, t4.addEventListener(l4, o4, r3 || { passive: false });
    }, a3.off = function(t4, e4, i2) {
      var s4 = a3.handlerMap.indexOf(t4), r3 = e4 && e4.split(".")[0], o4 = e4 && e4.split(".")[1], n4 = "";
      if (-1 != s4) if (i2) {
        if ("function" == typeof i2 && (i2 = i2._svgjsListenerId), !i2) return;
        a3.listeners[s4][r3] && a3.listeners[s4][r3][o4 || "*"] && (t4.removeEventListener(r3, a3.listeners[s4][r3][o4 || "*"][i2], false), delete a3.listeners[s4][r3][o4 || "*"][i2]);
      } else if (o4 && r3) {
        if (a3.listeners[s4][r3] && a3.listeners[s4][r3][o4]) {
          for (var l4 in a3.listeners[s4][r3][o4]) a3.off(t4, [r3, o4].join("."), l4);
          delete a3.listeners[s4][r3][o4];
        }
      } else if (o4) for (var h4 in a3.listeners[s4]) for (var n4 in a3.listeners[s4][h4]) o4 === n4 && a3.off(t4, [h4, o4].join("."));
      else if (r3) {
        if (a3.listeners[s4][r3]) {
          for (var n4 in a3.listeners[s4][r3]) a3.off(t4, [r3, n4].join("."));
          delete a3.listeners[s4][r3];
        }
      } else {
        for (var h4 in a3.listeners[s4]) a3.off(t4, h4);
        delete a3.listeners[s4], delete a3.handlerMap[s4];
      }
    }, a3.extend(a3.Element, { on: function(t4, e4, i2, s4) {
      return a3.on(this.node, t4, e4, i2, s4), this;
    }, off: function(t4, e4) {
      return a3.off(this.node, t4, e4), this;
    }, fire: function(e4, i2) {
      return e4 instanceof t3.Event ? this.node.dispatchEvent(e4) : this.node.dispatchEvent(e4 = new a3.CustomEvent(e4, { detail: i2, cancelable: true })), this._event = e4, this;
    }, event: function() {
      return this._event;
    } }), a3.Defs = a3.invent({ create: "defs", inherit: a3.Container }), a3.G = a3.invent({ create: "g", inherit: a3.Container, extend: { x: function(t4) {
      return null == t4 ? this.transform("x") : this.transform({ x: t4 - this.x() }, true);
    } }, construct: { group: function() {
      return this.put(new a3.G());
    } } }), a3.Doc = a3.invent({ create: function(t4) {
      t4 && ("svg" == (t4 = "string" == typeof t4 ? e3.getElementById(t4) : t4).nodeName ? this.constructor.call(this, t4) : (this.constructor.call(this, a3.create("svg")), t4.appendChild(this.node), this.size("100%", "100%")), this.namespace().defs());
    }, inherit: a3.Container, extend: { namespace: function() {
      return this.attr({ xmlns: a3.ns, version: "1.1" }).attr("xmlns:xlink", a3.xlink, a3.xmlns).attr("xmlns:svgjs", a3.svgjs, a3.xmlns);
    }, defs: function() {
      var t4;
      return this._defs || ((t4 = this.node.getElementsByTagName("defs")[0]) ? this._defs = a3.adopt(t4) : this._defs = new a3.Defs(), this.node.appendChild(this._defs.node)), this._defs;
    }, parent: function() {
      return this.node.parentNode && "#document" != this.node.parentNode.nodeName ? this.node.parentNode : null;
    }, remove: function() {
      return this.parent() && this.parent().removeChild(this.node), this;
    }, clear: function() {
      for (; this.node.hasChildNodes(); ) this.node.removeChild(this.node.lastChild);
      return delete this._defs, a3.parser.draw && !a3.parser.draw.parentNode && this.node.appendChild(a3.parser.draw), this;
    }, clone: function(t4) {
      this.writeDataToDom();
      var e4 = this.node, i2 = x3(e4.cloneNode(true));
      return t4 ? (t4.node || t4).appendChild(i2.node) : e4.parentNode.insertBefore(i2.node, e4.nextSibling), i2;
    } } }), a3.extend(a3.Element, {}), a3.Gradient = a3.invent({ create: function(t4) {
      this.constructor.call(this, a3.create(t4 + "Gradient")), this.type = t4;
    }, inherit: a3.Container, extend: { at: function(t4, e4, i2) {
      return this.put(new a3.Stop()).update(t4, e4, i2);
    }, update: function(t4) {
      return this.clear(), "function" == typeof t4 && t4.call(this, this), this;
    }, fill: function() {
      return "url(#" + this.id() + ")";
    }, toString: function() {
      return this.fill();
    }, attr: function(t4, e4, i2) {
      return "transform" == t4 && (t4 = "gradientTransform"), a3.Container.prototype.attr.call(this, t4, e4, i2);
    } }, construct: { gradient: function(t4, e4) {
      return this.defs().gradient(t4, e4);
    } } }), a3.extend(a3.Gradient, a3.FX, { from: function(t4, e4) {
      return "radial" == (this._target || this).type ? this.attr({ fx: new a3.Number(t4), fy: new a3.Number(e4) }) : this.attr({ x1: new a3.Number(t4), y1: new a3.Number(e4) });
    }, to: function(t4, e4) {
      return "radial" == (this._target || this).type ? this.attr({ cx: new a3.Number(t4), cy: new a3.Number(e4) }) : this.attr({ x2: new a3.Number(t4), y2: new a3.Number(e4) });
    } }), a3.extend(a3.Defs, { gradient: function(t4, e4) {
      return this.put(new a3.Gradient(t4)).update(e4);
    } }), a3.Stop = a3.invent({ create: "stop", inherit: a3.Element, extend: { update: function(t4) {
      return ("number" == typeof t4 || t4 instanceof a3.Number) && (t4 = { offset: arguments[0], color: arguments[1], opacity: arguments[2] }), null != t4.opacity && this.attr("stop-opacity", t4.opacity), null != t4.color && this.attr("stop-color", t4.color), null != t4.offset && this.attr("offset", new a3.Number(t4.offset)), this;
    } } }), a3.Pattern = a3.invent({ create: "pattern", inherit: a3.Container, extend: { fill: function() {
      return "url(#" + this.id() + ")";
    }, update: function(t4) {
      return this.clear(), "function" == typeof t4 && t4.call(this, this), this;
    }, toString: function() {
      return this.fill();
    }, attr: function(t4, e4, i2) {
      return "transform" == t4 && (t4 = "patternTransform"), a3.Container.prototype.attr.call(this, t4, e4, i2);
    } }, construct: { pattern: function(t4, e4, i2) {
      return this.defs().pattern(t4, e4, i2);
    } } }), a3.extend(a3.Defs, { pattern: function(t4, e4, i2) {
      return this.put(new a3.Pattern()).update(i2).attr({ x: 0, y: 0, width: t4, height: e4, patternUnits: "userSpaceOnUse" });
    } }), a3.Shape = a3.invent({ create: function(t4) {
      this.constructor.call(this, t4);
    }, inherit: a3.Element }), a3.Symbol = a3.invent({ create: "symbol", inherit: a3.Container, construct: { symbol: function() {
      return this.put(new a3.Symbol());
    } } }), a3.Use = a3.invent({ create: "use", inherit: a3.Shape, extend: { element: function(t4, e4) {
      return this.attr("href", (e4 || "") + "#" + t4, a3.xlink);
    } }, construct: { use: function(t4, e4) {
      return this.put(new a3.Use()).element(t4, e4);
    } } }), a3.Rect = a3.invent({ create: "rect", inherit: a3.Shape, construct: { rect: function(t4, e4) {
      return this.put(new a3.Rect()).size(t4, e4);
    } } }), a3.Circle = a3.invent({ create: "circle", inherit: a3.Shape, construct: { circle: function(t4) {
      return this.put(new a3.Circle()).rx(new a3.Number(t4).divide(2)).move(0, 0);
    } } }), a3.extend(a3.Circle, a3.FX, { rx: function(t4) {
      return this.attr("r", t4);
    }, ry: function(t4) {
      return this.rx(t4);
    } }), a3.Ellipse = a3.invent({ create: "ellipse", inherit: a3.Shape, construct: { ellipse: function(t4, e4) {
      return this.put(new a3.Ellipse()).size(t4, e4).move(0, 0);
    } } }), a3.extend(a3.Ellipse, a3.Rect, a3.FX, { rx: function(t4) {
      return this.attr("rx", t4);
    }, ry: function(t4) {
      return this.attr("ry", t4);
    } }), a3.extend(a3.Circle, a3.Ellipse, { x: function(t4) {
      return null == t4 ? this.cx() - this.rx() : this.cx(t4 + this.rx());
    }, y: function(t4) {
      return null == t4 ? this.cy() - this.ry() : this.cy(t4 + this.ry());
    }, cx: function(t4) {
      return null == t4 ? this.attr("cx") : this.attr("cx", t4);
    }, cy: function(t4) {
      return null == t4 ? this.attr("cy") : this.attr("cy", t4);
    }, width: function(t4) {
      return null == t4 ? 2 * this.rx() : this.rx(new a3.Number(t4).divide(2));
    }, height: function(t4) {
      return null == t4 ? 2 * this.ry() : this.ry(new a3.Number(t4).divide(2));
    }, size: function(t4, e4) {
      var i2 = u3(this, t4, e4);
      return this.rx(new a3.Number(i2.width).divide(2)).ry(new a3.Number(i2.height).divide(2));
    } }), a3.Line = a3.invent({ create: "line", inherit: a3.Shape, extend: { array: function() {
      return new a3.PointArray([[this.attr("x1"), this.attr("y1")], [this.attr("x2"), this.attr("y2")]]);
    }, plot: function(t4, e4, i2, s4) {
      return null == t4 ? this.array() : (t4 = void 0 !== e4 ? { x1: t4, y1: e4, x2: i2, y2: s4 } : new a3.PointArray(t4).toLine(), this.attr(t4));
    }, move: function(t4, e4) {
      return this.attr(this.array().move(t4, e4).toLine());
    }, size: function(t4, e4) {
      var i2 = u3(this, t4, e4);
      return this.attr(this.array().size(i2.width, i2.height).toLine());
    } }, construct: { line: function(t4, e4, i2, s4) {
      return a3.Line.prototype.plot.apply(this.put(new a3.Line()), null != t4 ? [t4, e4, i2, s4] : [0, 0, 0, 0]);
    } } }), a3.Polyline = a3.invent({ create: "polyline", inherit: a3.Shape, construct: { polyline: function(t4) {
      return this.put(new a3.Polyline()).plot(t4 || new a3.PointArray());
    } } }), a3.Polygon = a3.invent({ create: "polygon", inherit: a3.Shape, construct: { polygon: function(t4) {
      return this.put(new a3.Polygon()).plot(t4 || new a3.PointArray());
    } } }), a3.extend(a3.Polyline, a3.Polygon, { array: function() {
      return this._array || (this._array = new a3.PointArray(this.attr("points")));
    }, plot: function(t4) {
      return null == t4 ? this.array() : this.clear().attr("points", "string" == typeof t4 ? t4 : this._array = new a3.PointArray(t4));
    }, clear: function() {
      return delete this._array, this;
    }, move: function(t4, e4) {
      return this.attr("points", this.array().move(t4, e4));
    }, size: function(t4, e4) {
      var i2 = u3(this, t4, e4);
      return this.attr("points", this.array().size(i2.width, i2.height));
    } }), a3.extend(a3.Line, a3.Polyline, a3.Polygon, { morphArray: a3.PointArray, x: function(t4) {
      return null == t4 ? this.bbox().x : this.move(t4, this.bbox().y);
    }, y: function(t4) {
      return null == t4 ? this.bbox().y : this.move(this.bbox().x, t4);
    }, width: function(t4) {
      var e4 = this.bbox();
      return null == t4 ? e4.width : this.size(t4, e4.height);
    }, height: function(t4) {
      var e4 = this.bbox();
      return null == t4 ? e4.height : this.size(e4.width, t4);
    } }), a3.Path = a3.invent({ create: "path", inherit: a3.Shape, extend: { morphArray: a3.PathArray, array: function() {
      return this._array || (this._array = new a3.PathArray(this.attr("d")));
    }, plot: function(t4) {
      return null == t4 ? this.array() : this.clear().attr("d", "string" == typeof t4 ? t4 : this._array = new a3.PathArray(t4));
    }, clear: function() {
      return delete this._array, this;
    } }, construct: { path: function(t4) {
      return this.put(new a3.Path()).plot(t4 || new a3.PathArray());
    } } }), a3.Image = a3.invent({ create: "image", inherit: a3.Shape, extend: { load: function(e4) {
      if (!e4) return this;
      var i2 = this, s4 = new t3.Image();
      return a3.on(s4, "load", function() {
        a3.off(s4);
        var t4 = i2.parent(a3.Pattern);
        null !== t4 && (0 == i2.width() && 0 == i2.height() && i2.size(s4.width, s4.height), t4 && 0 == t4.width() && 0 == t4.height() && t4.size(i2.width(), i2.height()), "function" == typeof i2._loaded && i2._loaded.call(i2, { width: s4.width, height: s4.height, ratio: s4.width / s4.height, url: e4 }));
      }), a3.on(s4, "error", function(t4) {
        a3.off(s4), "function" == typeof i2._error && i2._error.call(i2, t4);
      }), this.attr("href", s4.src = this.src = e4, a3.xlink);
    }, loaded: function(t4) {
      return this._loaded = t4, this;
    }, error: function(t4) {
      return this._error = t4, this;
    } }, construct: { image: function(t4, e4, i2) {
      return this.put(new a3.Image()).load(t4).size(e4 || 0, i2 || e4 || 0);
    } } }), a3.Text = a3.invent({ create: function() {
      this.constructor.call(this, a3.create("text")), this.dom.leading = new a3.Number(1.3), this._rebuild = true, this._build = false, this.attr("font-family", a3.defaults.attrs["font-family"]);
    }, inherit: a3.Shape, extend: { x: function(t4) {
      return null == t4 ? this.attr("x") : this.attr("x", t4);
    }, text: function(t4) {
      if (void 0 === t4) {
        t4 = "";
        for (var e4 = this.node.childNodes, i2 = 0, s4 = e4.length; i2 < s4; ++i2) 0 != i2 && 3 != e4[i2].nodeType && 1 == a3.adopt(e4[i2]).dom.newLined && (t4 += "\n"), t4 += e4[i2].textContent;
        return t4;
      }
      if (this.clear().build(true), "function" == typeof t4) t4.call(this, this);
      else {
        i2 = 0;
        for (var r3 = (t4 = t4.split("\n")).length; i2 < r3; i2++) this.tspan(t4[i2]).newLine();
      }
      return this.build(false).rebuild();
    }, size: function(t4) {
      return this.attr("font-size", t4).rebuild();
    }, leading: function(t4) {
      return null == t4 ? this.dom.leading : (this.dom.leading = new a3.Number(t4), this.rebuild());
    }, lines: function() {
      var t4 = (this.textPath && this.textPath() || this).node, e4 = a3.utils.map(a3.utils.filterSVGElements(t4.childNodes), function(t5) {
        return a3.adopt(t5);
      });
      return new a3.Set(e4);
    }, rebuild: function(t4) {
      if ("boolean" == typeof t4 && (this._rebuild = t4), this._rebuild) {
        var e4 = this, i2 = 0, s4 = this.dom.leading * new a3.Number(this.attr("font-size"));
        this.lines().each(function() {
          this.dom.newLined && (e4.textPath() || this.attr("x", e4.attr("x")), "\n" == this.text() ? i2 += s4 : (this.attr("dy", s4 + i2), i2 = 0));
        }), this.fire("rebuild");
      }
      return this;
    }, build: function(t4) {
      return this._build = !!t4, this;
    }, setData: function(t4) {
      return this.dom = t4, this.dom.leading = new a3.Number(t4.leading || 1.3), this;
    } }, construct: { text: function(t4) {
      return this.put(new a3.Text()).text(t4);
    }, plain: function(t4) {
      return this.put(new a3.Text()).plain(t4);
    } } }), a3.Tspan = a3.invent({ create: "tspan", inherit: a3.Shape, extend: { text: function(t4) {
      return null == t4 ? this.node.textContent + (this.dom.newLined ? "\n" : "") : ("function" == typeof t4 ? t4.call(this, this) : this.plain(t4), this);
    }, dx: function(t4) {
      return this.attr("dx", t4);
    }, dy: function(t4) {
      return this.attr("dy", t4);
    }, newLine: function() {
      var t4 = this.parent(a3.Text);
      return this.dom.newLined = true, this.dy(t4.dom.leading * t4.attr("font-size")).attr("x", t4.x());
    } } }), a3.extend(a3.Text, a3.Tspan, { plain: function(t4) {
      return false === this._build && this.clear(), this.node.appendChild(e3.createTextNode(t4)), this;
    }, tspan: function(t4) {
      var e4 = (this.textPath && this.textPath() || this).node, i2 = new a3.Tspan();
      return false === this._build && this.clear(), e4.appendChild(i2.node), i2.text(t4);
    }, clear: function() {
      for (var t4 = (this.textPath && this.textPath() || this).node; t4.hasChildNodes(); ) t4.removeChild(t4.lastChild);
      return this;
    }, length: function() {
      return this.node.getComputedTextLength();
    } }), a3.TextPath = a3.invent({ create: "textPath", inherit: a3.Parent, parent: a3.Text, construct: { morphArray: a3.PathArray, array: function() {
      var t4 = this.track();
      return t4 ? t4.array() : null;
    }, plot: function(t4) {
      var e4 = this.track(), i2 = null;
      return e4 && (i2 = e4.plot(t4)), null == t4 ? i2 : this;
    }, track: function() {
      var t4 = this.textPath();
      if (t4) return t4.reference("href");
    }, textPath: function() {
      if (this.node.firstChild && "textPath" == this.node.firstChild.nodeName) return a3.adopt(this.node.firstChild);
    } } }), a3.Nested = a3.invent({ create: function() {
      this.constructor.call(this, a3.create("svg")), this.style("overflow", "visible");
    }, inherit: a3.Container, construct: { nested: function() {
      return this.put(new a3.Nested());
    } } });
    var l3 = { stroke: ["color", "width", "opacity", "linecap", "linejoin", "miterlimit", "dasharray", "dashoffset"], fill: ["color", "opacity", "rule"], prefix: function(t4, e4) {
      return "color" == e4 ? t4 : t4 + "-" + e4;
    } };
    function h3(t4, e4, i2, s4) {
      return i2 + s4.replace(a3.regex.dots, " .");
    }
    function c3(t4) {
      return t4.toLowerCase().replace(/-(.)/g, function(t5, e4) {
        return e4.toUpperCase();
      });
    }
    function d3(t4) {
      return t4.charAt(0).toUpperCase() + t4.slice(1);
    }
    function g3(t4) {
      var e4 = t4.toString(16);
      return 1 == e4.length ? "0" + e4 : e4;
    }
    function u3(t4, e4, i2) {
      if (null == e4 || null == i2) {
        var a4 = t4.bbox();
        null == e4 ? e4 = a4.width / a4.height * i2 : null == i2 && (i2 = a4.height / a4.width * e4);
      }
      return { width: e4, height: i2 };
    }
    function p3(t4, e4, i2) {
      return { x: e4 * t4.a + i2 * t4.c + 0, y: e4 * t4.b + i2 * t4.d + 0 };
    }
    function f3(t4) {
      return { a: t4[0], b: t4[1], c: t4[2], d: t4[3], e: t4[4], f: t4[5] };
    }
    function x3(e4) {
      for (var i2 = e4.childNodes.length - 1; i2 >= 0; i2--) e4.childNodes[i2] instanceof t3.SVGElement && x3(e4.childNodes[i2]);
      return a3.adopt(e4).id(a3.eid(e4.nodeName));
    }
    function b3(t4) {
      return Math.abs(t4) > 1e-37 ? t4 : 0;
    }
    ["fill", "stroke"].forEach(function(t4) {
      var e4 = {};
      e4[t4] = function(e5) {
        if (void 0 === e5) return this;
        if ("string" == typeof e5 || a3.Color.isRgb(e5) || e5 && "function" == typeof e5.fill) this.attr(t4, e5);
        else for (var i2 = l3[t4].length - 1; i2 >= 0; i2--) null != e5[l3[t4][i2]] && this.attr(l3.prefix(t4, l3[t4][i2]), e5[l3[t4][i2]]);
        return this;
      }, a3.extend(a3.Element, a3.FX, e4);
    }), a3.extend(a3.Element, a3.FX, { translate: function(t4, e4) {
      return this.transform({ x: t4, y: e4 });
    }, matrix: function(t4) {
      return this.attr("transform", new a3.Matrix(6 == arguments.length ? [].slice.call(arguments) : t4));
    }, opacity: function(t4) {
      return this.attr("opacity", t4);
    }, dx: function(t4) {
      return this.x(new a3.Number(t4).plus(this instanceof a3.FX ? 0 : this.x()), true);
    }, dy: function(t4) {
      return this.y(new a3.Number(t4).plus(this instanceof a3.FX ? 0 : this.y()), true);
    } }), a3.extend(a3.Path, { length: function() {
      return this.node.getTotalLength();
    }, pointAt: function(t4) {
      return this.node.getPointAtLength(t4);
    } }), a3.Set = a3.invent({ create: function(t4) {
      Array.isArray(t4) ? this.members = t4 : this.clear();
    }, extend: { add: function() {
      for (var t4 = [].slice.call(arguments), e4 = 0, i2 = t4.length; e4 < i2; e4++) this.members.push(t4[e4]);
      return this;
    }, remove: function(t4) {
      var e4 = this.index(t4);
      return e4 > -1 && this.members.splice(e4, 1), this;
    }, each: function(t4) {
      for (var e4 = 0, i2 = this.members.length; e4 < i2; e4++) t4.apply(this.members[e4], [e4, this.members]);
      return this;
    }, clear: function() {
      return this.members = [], this;
    }, length: function() {
      return this.members.length;
    }, has: function(t4) {
      return this.index(t4) >= 0;
    }, index: function(t4) {
      return this.members.indexOf(t4);
    }, get: function(t4) {
      return this.members[t4];
    }, first: function() {
      return this.get(0);
    }, last: function() {
      return this.get(this.members.length - 1);
    }, valueOf: function() {
      return this.members;
    } }, construct: { set: function(t4) {
      return new a3.Set(t4);
    } } }), a3.FX.Set = a3.invent({ create: function(t4) {
      this.set = t4;
    } }), a3.Set.inherit = function() {
      var t4 = [];
      for (var e4 in a3.Shape.prototype) "function" == typeof a3.Shape.prototype[e4] && "function" != typeof a3.Set.prototype[e4] && t4.push(e4);
      for (var e4 in t4.forEach(function(t5) {
        a3.Set.prototype[t5] = function() {
          for (var e5 = 0, i2 = this.members.length; e5 < i2; e5++) this.members[e5] && "function" == typeof this.members[e5][t5] && this.members[e5][t5].apply(this.members[e5], arguments);
          return "animate" == t5 ? this.fx || (this.fx = new a3.FX.Set(this)) : this;
        };
      }), t4 = [], a3.FX.prototype) "function" == typeof a3.FX.prototype[e4] && "function" != typeof a3.FX.Set.prototype[e4] && t4.push(e4);
      t4.forEach(function(t5) {
        a3.FX.Set.prototype[t5] = function() {
          for (var e5 = 0, i2 = this.set.members.length; e5 < i2; e5++) this.set.members[e5].fx[t5].apply(this.set.members[e5].fx, arguments);
          return this;
        };
      });
    }, a3.extend(a3.Element, {}), a3.extend(a3.Element, { remember: function(t4, e4) {
      if ("object" === i(arguments[0])) for (var a4 in t4) this.remember(a4, t4[a4]);
      else {
        if (1 == arguments.length) return this.memory()[t4];
        this.memory()[t4] = e4;
      }
      return this;
    }, forget: function() {
      if (0 == arguments.length) this._memory = {};
      else for (var t4 = arguments.length - 1; t4 >= 0; t4--) delete this.memory()[arguments[t4]];
      return this;
    }, memory: function() {
      return this._memory || (this._memory = {});
    } }), a3.get = function(t4) {
      var i2 = e3.getElementById(function(t5) {
        var e4 = (t5 || "").toString().match(a3.regex.reference);
        if (e4) return e4[1];
      }(t4) || t4);
      return a3.adopt(i2);
    }, a3.select = function(t4, i2) {
      return new a3.Set(a3.utils.map((i2 || e3).querySelectorAll(t4), function(t5) {
        return a3.adopt(t5);
      }));
    }, a3.extend(a3.Parent, { select: function(t4) {
      return a3.select(t4, this.node);
    } });
    var v3 = "abcdef".split("");
    if ("function" != typeof t3.CustomEvent) {
      var m3 = function(t4, i2) {
        i2 = i2 || { bubbles: false, cancelable: false, detail: void 0 };
        var a4 = e3.createEvent("CustomEvent");
        return a4.initCustomEvent(t4, i2.bubbles, i2.cancelable, i2.detail), a4;
      };
      m3.prototype = t3.Event.prototype, a3.CustomEvent = m3;
    } else a3.CustomEvent = t3.CustomEvent;
    return a3;
  }, "object" === i(exports) && true ? module.exports = Rt2.document ? Ht2(Rt2, Rt2.document) : function(t3) {
    return Ht2(t3, t3.document);
  } : Rt2.SVG = Ht2(Rt2, Rt2.document), /*! svg.filter.js - v2.0.2 - 2016-02-24
  * https://github.com/wout/svg.filter.js
  * Copyright (c) 2016 Wout Fierens; Licensed MIT */
  (function() {
    SVG.Filter = SVG.invent({ create: "filter", inherit: SVG.Parent, extend: { source: "SourceGraphic", sourceAlpha: "SourceAlpha", background: "BackgroundImage", backgroundAlpha: "BackgroundAlpha", fill: "FillPaint", stroke: "StrokePaint", autoSetIn: true, put: function(t4, e4) {
      return this.add(t4, e4), !t4.attr("in") && this.autoSetIn && t4.attr("in", this.source), t4.attr("result") || t4.attr("result", t4), t4;
    }, blend: function(t4, e4, i3) {
      return this.put(new SVG.BlendEffect(t4, e4, i3));
    }, colorMatrix: function(t4, e4) {
      return this.put(new SVG.ColorMatrixEffect(t4, e4));
    }, convolveMatrix: function(t4) {
      return this.put(new SVG.ConvolveMatrixEffect(t4));
    }, componentTransfer: function(t4) {
      return this.put(new SVG.ComponentTransferEffect(t4));
    }, composite: function(t4, e4, i3) {
      return this.put(new SVG.CompositeEffect(t4, e4, i3));
    }, flood: function(t4, e4) {
      return this.put(new SVG.FloodEffect(t4, e4));
    }, offset: function(t4, e4) {
      return this.put(new SVG.OffsetEffect(t4, e4));
    }, image: function(t4) {
      return this.put(new SVG.ImageEffect(t4));
    }, merge: function() {
      var t4 = [void 0];
      for (var e4 in arguments) t4.push(arguments[e4]);
      return this.put(new (SVG.MergeEffect.bind.apply(SVG.MergeEffect, t4))());
    }, gaussianBlur: function(t4, e4) {
      return this.put(new SVG.GaussianBlurEffect(t4, e4));
    }, morphology: function(t4, e4) {
      return this.put(new SVG.MorphologyEffect(t4, e4));
    }, diffuseLighting: function(t4, e4, i3) {
      return this.put(new SVG.DiffuseLightingEffect(t4, e4, i3));
    }, displacementMap: function(t4, e4, i3, a4, s4) {
      return this.put(new SVG.DisplacementMapEffect(t4, e4, i3, a4, s4));
    }, specularLighting: function(t4, e4, i3, a4) {
      return this.put(new SVG.SpecularLightingEffect(t4, e4, i3, a4));
    }, tile: function() {
      return this.put(new SVG.TileEffect());
    }, turbulence: function(t4, e4, i3, a4, s4) {
      return this.put(new SVG.TurbulenceEffect(t4, e4, i3, a4, s4));
    }, toString: function() {
      return "url(#" + this.attr("id") + ")";
    } } }), SVG.extend(SVG.Defs, { filter: function(t4) {
      var e4 = this.put(new SVG.Filter());
      return "function" == typeof t4 && t4.call(e4, e4), e4;
    } }), SVG.extend(SVG.Container, { filter: function(t4) {
      return this.defs().filter(t4);
    } }), SVG.extend(SVG.Element, SVG.G, SVG.Nested, { filter: function(t4) {
      return this.filterer = t4 instanceof SVG.Element ? t4 : this.doc().filter(t4), this.doc() && this.filterer.doc() !== this.doc() && this.doc().defs().add(this.filterer), this.attr("filter", this.filterer), this.filterer;
    }, unfilter: function(t4) {
      return this.filterer && true === t4 && this.filterer.remove(), delete this.filterer, this.attr("filter", null);
    } }), SVG.Effect = SVG.invent({ create: function() {
      this.constructor.call(this);
    }, inherit: SVG.Element, extend: { in: function(t4) {
      return null == t4 ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", t4);
    }, result: function(t4) {
      return null == t4 ? this.attr("result") : this.attr("result", t4);
    }, toString: function() {
      return this.result();
    } } }), SVG.ParentEffect = SVG.invent({ create: function() {
      this.constructor.call(this);
    }, inherit: SVG.Parent, extend: { in: function(t4) {
      return null == t4 ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", t4);
    }, result: function(t4) {
      return null == t4 ? this.attr("result") : this.attr("result", t4);
    }, toString: function() {
      return this.result();
    } } });
    var t3 = { blend: function(t4, e4) {
      return this.parent() && this.parent().blend(this, t4, e4);
    }, colorMatrix: function(t4, e4) {
      return this.parent() && this.parent().colorMatrix(t4, e4).in(this);
    }, convolveMatrix: function(t4) {
      return this.parent() && this.parent().convolveMatrix(t4).in(this);
    }, componentTransfer: function(t4) {
      return this.parent() && this.parent().componentTransfer(t4).in(this);
    }, composite: function(t4, e4) {
      return this.parent() && this.parent().composite(this, t4, e4);
    }, flood: function(t4, e4) {
      return this.parent() && this.parent().flood(t4, e4);
    }, offset: function(t4, e4) {
      return this.parent() && this.parent().offset(t4, e4).in(this);
    }, image: function(t4) {
      return this.parent() && this.parent().image(t4);
    }, merge: function() {
      return this.parent() && this.parent().merge.apply(this.parent(), [this].concat(arguments));
    }, gaussianBlur: function(t4, e4) {
      return this.parent() && this.parent().gaussianBlur(t4, e4).in(this);
    }, morphology: function(t4, e4) {
      return this.parent() && this.parent().morphology(t4, e4).in(this);
    }, diffuseLighting: function(t4, e4, i3) {
      return this.parent() && this.parent().diffuseLighting(t4, e4, i3).in(this);
    }, displacementMap: function(t4, e4, i3, a4) {
      return this.parent() && this.parent().displacementMap(this, t4, e4, i3, a4);
    }, specularLighting: function(t4, e4, i3, a4) {
      return this.parent() && this.parent().specularLighting(t4, e4, i3, a4).in(this);
    }, tile: function() {
      return this.parent() && this.parent().tile().in(this);
    }, turbulence: function(t4, e4, i3, a4, s4) {
      return this.parent() && this.parent().turbulence(t4, e4, i3, a4, s4).in(this);
    } };
    SVG.extend(SVG.Effect, t3), SVG.extend(SVG.ParentEffect, t3), SVG.ChildEffect = SVG.invent({ create: function() {
      this.constructor.call(this);
    }, inherit: SVG.Element, extend: { in: function(t4) {
      this.attr("in", t4);
    } } });
    var e3 = { blend: function(t4, e4, i3) {
      this.attr({ in: t4, in2: e4, mode: i3 || "normal" });
    }, colorMatrix: function(t4, e4) {
      "matrix" == t4 && (e4 = s3(e4)), this.attr({ type: t4, values: void 0 === e4 ? null : e4 });
    }, convolveMatrix: function(t4) {
      t4 = s3(t4), this.attr({ order: Math.sqrt(t4.split(" ").length), kernelMatrix: t4 });
    }, composite: function(t4, e4, i3) {
      this.attr({ in: t4, in2: e4, operator: i3 });
    }, flood: function(t4, e4) {
      this.attr("flood-color", t4), null != e4 && this.attr("flood-opacity", e4);
    }, offset: function(t4, e4) {
      this.attr({ dx: t4, dy: e4 });
    }, image: function(t4) {
      this.attr("href", t4, SVG.xlink);
    }, displacementMap: function(t4, e4, i3, a4, s4) {
      this.attr({ in: t4, in2: e4, scale: i3, xChannelSelector: a4, yChannelSelector: s4 });
    }, gaussianBlur: function(t4, e4) {
      null != t4 || null != e4 ? this.attr("stdDeviation", function(t5) {
        if (!Array.isArray(t5)) return t5;
        for (var e5 = 0, i3 = t5.length, a4 = []; e5 < i3; e5++) a4.push(t5[e5]);
        return a4.join(" ");
      }(Array.prototype.slice.call(arguments))) : this.attr("stdDeviation", "0 0");
    }, morphology: function(t4, e4) {
      this.attr({ operator: t4, radius: e4 });
    }, tile: function() {
    }, turbulence: function(t4, e4, i3, a4, s4) {
      this.attr({ numOctaves: e4, seed: i3, stitchTiles: a4, baseFrequency: t4, type: s4 });
    } }, i2 = { merge: function() {
      var t4;
      if (arguments[0] instanceof SVG.Set) {
        var e4 = this;
        arguments[0].each(function(t5) {
          this instanceof SVG.MergeNode ? e4.put(this) : (this instanceof SVG.Effect || this instanceof SVG.ParentEffect) && e4.put(new SVG.MergeNode(this));
        });
      } else {
        t4 = Array.isArray(arguments[0]) ? arguments[0] : arguments;
        for (var i3 = 0; i3 < t4.length; i3++) t4[i3] instanceof SVG.MergeNode ? this.put(t4[i3]) : this.put(new SVG.MergeNode(t4[i3]));
      }
    }, componentTransfer: function(t4) {
      if (this.rgb = new SVG.Set(), ["r", "g", "b", "a"].forEach((function(t5) {
        this[t5] = new SVG["Func" + t5.toUpperCase()]("identity"), this.rgb.add(this[t5]), this.node.appendChild(this[t5].node);
      }).bind(this)), t4) for (var e4 in t4.rgb && (["r", "g", "b"].forEach((function(e5) {
        this[e5].attr(t4.rgb);
      }).bind(this)), delete t4.rgb), t4) this[e4].attr(t4[e4]);
    }, diffuseLighting: function(t4, e4, i3) {
      this.attr({ surfaceScale: t4, diffuseConstant: e4, kernelUnitLength: i3 });
    }, specularLighting: function(t4, e4, i3, a4) {
      this.attr({ surfaceScale: t4, diffuseConstant: e4, specularExponent: i3, kernelUnitLength: a4 });
    } }, a3 = { distantLight: function(t4, e4) {
      this.attr({ azimuth: t4, elevation: e4 });
    }, pointLight: function(t4, e4, i3) {
      this.attr({ x: t4, y: e4, z: i3 });
    }, spotLight: function(t4, e4, i3, a4, s4, r3) {
      this.attr({ x: t4, y: e4, z: i3, pointsAtX: a4, pointsAtY: s4, pointsAtZ: r3 });
    }, mergeNode: function(t4) {
      this.attr("in", t4);
    } };
    function s3(t4) {
      return Array.isArray(t4) && (t4 = new SVG.Array(t4)), t4.toString().replace(/^\s+/, "").replace(/\s+$/, "").replace(/\s+/g, " ");
    }
    function r2() {
      var t4 = function() {
      };
      for (var e4 in "function" == typeof arguments[arguments.length - 1] && (t4 = arguments[arguments.length - 1], Array.prototype.splice.call(arguments, arguments.length - 1, 1)), arguments) for (var i3 in arguments[e4]) t4(arguments[e4][i3], i3, arguments[e4]);
    }
    ["r", "g", "b", "a"].forEach(function(t4) {
      a3["Func" + t4.toUpperCase()] = function(t5) {
        switch (this.attr("type", t5), t5) {
          case "table":
            this.attr("tableValues", arguments[1]);
            break;
          case "linear":
            this.attr("slope", arguments[1]), this.attr("intercept", arguments[2]);
            break;
          case "gamma":
            this.attr("amplitude", arguments[1]), this.attr("exponent", arguments[2]), this.attr("offset", arguments[2]);
        }
      };
    }), r2(e3, function(t4, e4) {
      var i3 = e4.charAt(0).toUpperCase() + e4.slice(1);
      SVG[i3 + "Effect"] = SVG.invent({ create: function() {
        this.constructor.call(this, SVG.create("fe" + i3)), t4.apply(this, arguments), this.result(this.attr("id") + "Out");
      }, inherit: SVG.Effect, extend: {} });
    }), r2(i2, function(t4, e4) {
      var i3 = e4.charAt(0).toUpperCase() + e4.slice(1);
      SVG[i3 + "Effect"] = SVG.invent({ create: function() {
        this.constructor.call(this, SVG.create("fe" + i3)), t4.apply(this, arguments), this.result(this.attr("id") + "Out");
      }, inherit: SVG.ParentEffect, extend: {} });
    }), r2(a3, function(t4, e4) {
      var i3 = e4.charAt(0).toUpperCase() + e4.slice(1);
      SVG[i3] = SVG.invent({ create: function() {
        this.constructor.call(this, SVG.create("fe" + i3)), t4.apply(this, arguments);
      }, inherit: SVG.ChildEffect, extend: {} });
    }), SVG.extend(SVG.MergeEffect, { in: function(t4) {
      return t4 instanceof SVG.MergeNode ? this.add(t4, 0) : this.add(new SVG.MergeNode(t4), 0), this;
    } }), SVG.extend(SVG.CompositeEffect, SVG.BlendEffect, SVG.DisplacementMapEffect, { in2: function(t4) {
      return null == t4 ? this.parent() && this.parent().select('[result="' + this.attr("in2") + '"]').get(0) || this.attr("in2") : this.attr("in2", t4);
    } }), SVG.filter = { sepiatone: [0.343, 0.669, 0.119, 0, 0, 0.249, 0.626, 0.13, 0, 0, 0.172, 0.334, 0.111, 0, 0, 0, 0, 0, 1, 0] };
  }).call(void 0), function() {
    function t3(t4, s4, r2, o3, n3, l3, h3) {
      for (var c3 = t4.slice(s4, r2 || h3), d3 = o3.slice(n3, l3 || h3), g3 = 0, u3 = { pos: [0, 0], start: [0, 0] }, p3 = { pos: [0, 0], start: [0, 0] }; ; ) {
        if (c3[g3] = e3.call(u3, c3[g3]), d3[g3] = e3.call(p3, d3[g3]), c3[g3][0] != d3[g3][0] || "M" == c3[g3][0] || "A" == c3[g3][0] && (c3[g3][4] != d3[g3][4] || c3[g3][5] != d3[g3][5]) ? (Array.prototype.splice.apply(c3, [g3, 1].concat(a3.call(u3, c3[g3]))), Array.prototype.splice.apply(d3, [g3, 1].concat(a3.call(p3, d3[g3])))) : (c3[g3] = i2.call(u3, c3[g3]), d3[g3] = i2.call(p3, d3[g3])), ++g3 == c3.length && g3 == d3.length) break;
        g3 == c3.length && c3.push(["C", u3.pos[0], u3.pos[1], u3.pos[0], u3.pos[1], u3.pos[0], u3.pos[1]]), g3 == d3.length && d3.push(["C", p3.pos[0], p3.pos[1], p3.pos[0], p3.pos[1], p3.pos[0], p3.pos[1]]);
      }
      return { start: c3, dest: d3 };
    }
    function e3(t4) {
      switch (t4[0]) {
        case "z":
        case "Z":
          t4[0] = "L", t4[1] = this.start[0], t4[2] = this.start[1];
          break;
        case "H":
          t4[0] = "L", t4[2] = this.pos[1];
          break;
        case "V":
          t4[0] = "L", t4[2] = t4[1], t4[1] = this.pos[0];
          break;
        case "T":
          t4[0] = "Q", t4[3] = t4[1], t4[4] = t4[2], t4[1] = this.reflection[1], t4[2] = this.reflection[0];
          break;
        case "S":
          t4[0] = "C", t4[6] = t4[4], t4[5] = t4[3], t4[4] = t4[2], t4[3] = t4[1], t4[2] = this.reflection[1], t4[1] = this.reflection[0];
      }
      return t4;
    }
    function i2(t4) {
      var e4 = t4.length;
      return this.pos = [t4[e4 - 2], t4[e4 - 1]], -1 != "SCQT".indexOf(t4[0]) && (this.reflection = [2 * this.pos[0] - t4[e4 - 4], 2 * this.pos[1] - t4[e4 - 3]]), t4;
    }
    function a3(t4) {
      var e4 = [t4];
      switch (t4[0]) {
        case "M":
          return this.pos = this.start = [t4[1], t4[2]], e4;
        case "L":
          t4[5] = t4[3] = t4[1], t4[6] = t4[4] = t4[2], t4[1] = this.pos[0], t4[2] = this.pos[1];
          break;
        case "Q":
          t4[6] = t4[4], t4[5] = t4[3], t4[4] = 1 * t4[4] / 3 + 2 * t4[2] / 3, t4[3] = 1 * t4[3] / 3 + 2 * t4[1] / 3, t4[2] = 1 * this.pos[1] / 3 + 2 * t4[2] / 3, t4[1] = 1 * this.pos[0] / 3 + 2 * t4[1] / 3;
          break;
        case "A":
          e4 = function(t5, e5) {
            var i3, a4, s4, r2, o3, n3, l3, h3, c3, d3, g3, u3, p3, f3, x3, b3, v3, m3, y3, w3, k3, A3, S3, C3, L3, P3, M3 = Math.abs(e5[1]), I3 = Math.abs(e5[2]), T3 = e5[3] % 360, z3 = e5[4], X3 = e5[5], E3 = e5[6], Y3 = e5[7], F3 = new SVG.Point(t5), R3 = new SVG.Point(E3, Y3), H5 = [];
            if (0 === M3 || 0 === I3 || F3.x === R3.x && F3.y === R3.y) return [["C", F3.x, F3.y, R3.x, R3.y, R3.x, R3.y]];
            i3 = new SVG.Point((F3.x - R3.x) / 2, (F3.y - R3.y) / 2).transform(new SVG.Matrix().rotate(T3)), (a4 = i3.x * i3.x / (M3 * M3) + i3.y * i3.y / (I3 * I3)) > 1 && (M3 *= a4 = Math.sqrt(a4), I3 *= a4);
            s4 = new SVG.Matrix().rotate(T3).scale(1 / M3, 1 / I3).rotate(-T3), F3 = F3.transform(s4), R3 = R3.transform(s4), r2 = [R3.x - F3.x, R3.y - F3.y], n3 = r2[0] * r2[0] + r2[1] * r2[1], o3 = Math.sqrt(n3), r2[0] /= o3, r2[1] /= o3, l3 = n3 < 4 ? Math.sqrt(1 - n3 / 4) : 0, z3 === X3 && (l3 *= -1);
            h3 = new SVG.Point((R3.x + F3.x) / 2 + l3 * -r2[1], (R3.y + F3.y) / 2 + l3 * r2[0]), c3 = new SVG.Point(F3.x - h3.x, F3.y - h3.y), d3 = new SVG.Point(R3.x - h3.x, R3.y - h3.y), g3 = Math.acos(c3.x / Math.sqrt(c3.x * c3.x + c3.y * c3.y)), c3.y < 0 && (g3 *= -1);
            u3 = Math.acos(d3.x / Math.sqrt(d3.x * d3.x + d3.y * d3.y)), d3.y < 0 && (u3 *= -1);
            X3 && g3 > u3 && (u3 += 2 * Math.PI);
            !X3 && g3 < u3 && (u3 -= 2 * Math.PI);
            for (f3 = Math.ceil(2 * Math.abs(g3 - u3) / Math.PI), b3 = [], v3 = g3, p3 = (u3 - g3) / f3, x3 = 4 * Math.tan(p3 / 4) / 3, k3 = 0; k3 <= f3; k3++) y3 = Math.cos(v3), m3 = Math.sin(v3), w3 = new SVG.Point(h3.x + y3, h3.y + m3), b3[k3] = [new SVG.Point(w3.x + x3 * m3, w3.y - x3 * y3), w3, new SVG.Point(w3.x - x3 * m3, w3.y + x3 * y3)], v3 += p3;
            for (b3[0][0] = b3[0][1].clone(), b3[b3.length - 1][2] = b3[b3.length - 1][1].clone(), s4 = new SVG.Matrix().rotate(T3).scale(M3, I3).rotate(-T3), k3 = 0, A3 = b3.length; k3 < A3; k3++) b3[k3][0] = b3[k3][0].transform(s4), b3[k3][1] = b3[k3][1].transform(s4), b3[k3][2] = b3[k3][2].transform(s4);
            for (k3 = 1, A3 = b3.length; k3 < A3; k3++) S3 = (w3 = b3[k3 - 1][2]).x, C3 = w3.y, L3 = (w3 = b3[k3][0]).x, P3 = w3.y, E3 = (w3 = b3[k3][1]).x, Y3 = w3.y, H5.push(["C", S3, C3, L3, P3, E3, Y3]);
            return H5;
          }(this.pos, t4), t4 = e4[0];
      }
      return t4[0] = "C", this.pos = [t4[5], t4[6]], this.reflection = [2 * t4[5] - t4[3], 2 * t4[6] - t4[4]], e4;
    }
    function s3(t4, e4) {
      if (false === e4) return false;
      for (var i3 = e4, a4 = t4.length; i3 < a4; ++i3) if ("M" == t4[i3][0]) return i3;
      return false;
    }
    SVG.extend(SVG.PathArray, { morph: function(e4) {
      for (var i3 = this.value, a4 = this.parse(e4), r2 = 0, o3 = 0, n3 = false, l3 = false; false !== r2 || false !== o3; ) {
        var h3;
        n3 = s3(i3, false !== r2 && r2 + 1), l3 = s3(a4, false !== o3 && o3 + 1), false === r2 && (r2 = 0 == (h3 = new SVG.PathArray(c3.start).bbox()).height || 0 == h3.width ? i3.push(i3[0]) - 1 : i3.push(["M", h3.x + h3.width / 2, h3.y + h3.height / 2]) - 1), false === o3 && (o3 = 0 == (h3 = new SVG.PathArray(c3.dest).bbox()).height || 0 == h3.width ? a4.push(a4[0]) - 1 : a4.push(["M", h3.x + h3.width / 2, h3.y + h3.height / 2]) - 1);
        var c3 = t3(i3, r2, n3, a4, o3, l3);
        i3 = i3.slice(0, r2).concat(c3.start, false === n3 ? [] : i3.slice(n3)), a4 = a4.slice(0, o3).concat(c3.dest, false === l3 ? [] : a4.slice(l3)), r2 = false !== n3 && r2 + c3.start.length, o3 = false !== l3 && o3 + c3.dest.length;
      }
      return this.value = i3, this.destination = new SVG.PathArray(), this.destination.value = a4, this;
    } });
  }(), /*! svg.draggable.js - v2.2.2 - 2019-01-08
  * https://github.com/svgdotjs/svg.draggable.js
  * Copyright (c) 2019 Wout Fierens; Licensed MIT */
  (function() {
    function t3(t4) {
      t4.remember("_draggable", this), this.el = t4;
    }
    t3.prototype.init = function(t4, e3) {
      var i2 = this;
      this.constraint = t4, this.value = e3, this.el.on("mousedown.drag", function(t5) {
        i2.start(t5);
      }), this.el.on("touchstart.drag", function(t5) {
        i2.start(t5);
      });
    }, t3.prototype.transformPoint = function(t4, e3) {
      var i2 = (t4 = t4 || window.event).changedTouches && t4.changedTouches[0] || t4;
      return this.p.x = i2.clientX - (e3 || 0), this.p.y = i2.clientY, this.p.matrixTransform(this.m);
    }, t3.prototype.getBBox = function() {
      var t4 = this.el.bbox();
      return this.el instanceof SVG.Nested && (t4 = this.el.rbox()), (this.el instanceof SVG.G || this.el instanceof SVG.Use || this.el instanceof SVG.Nested) && (t4.x = this.el.x(), t4.y = this.el.y()), t4;
    }, t3.prototype.start = function(t4) {
      if ("click" != t4.type && "mousedown" != t4.type && "mousemove" != t4.type || 1 == (t4.which || t4.buttons)) {
        var e3 = this;
        if (this.el.fire("beforedrag", { event: t4, handler: this }), !this.el.event().defaultPrevented) {
          t4.preventDefault(), t4.stopPropagation(), this.parent = this.parent || this.el.parent(SVG.Nested) || this.el.parent(SVG.Doc), this.p = this.parent.node.createSVGPoint(), this.m = this.el.node.getScreenCTM().inverse();
          var i2, a3 = this.getBBox();
          if (this.el instanceof SVG.Text) switch (i2 = this.el.node.getComputedTextLength(), this.el.attr("text-anchor")) {
            case "middle":
              i2 /= 2;
              break;
            case "start":
              i2 = 0;
          }
          this.startPoints = { point: this.transformPoint(t4, i2), box: a3, transform: this.el.transform() }, SVG.on(window, "mousemove.drag", function(t5) {
            e3.drag(t5);
          }), SVG.on(window, "touchmove.drag", function(t5) {
            e3.drag(t5);
          }), SVG.on(window, "mouseup.drag", function(t5) {
            e3.end(t5);
          }), SVG.on(window, "touchend.drag", function(t5) {
            e3.end(t5);
          }), this.el.fire("dragstart", { event: t4, p: this.startPoints.point, m: this.m, handler: this });
        }
      }
    }, t3.prototype.drag = function(t4) {
      var e3 = this.getBBox(), i2 = this.transformPoint(t4), a3 = this.startPoints.box.x + i2.x - this.startPoints.point.x, s3 = this.startPoints.box.y + i2.y - this.startPoints.point.y, r2 = this.constraint, o3 = i2.x - this.startPoints.point.x, n3 = i2.y - this.startPoints.point.y;
      if (this.el.fire("dragmove", { event: t4, p: i2, m: this.m, handler: this }), this.el.event().defaultPrevented) return i2;
      if ("function" == typeof r2) {
        var l3 = r2.call(this.el, a3, s3, this.m);
        "boolean" == typeof l3 && (l3 = { x: l3, y: l3 }), true === l3.x ? this.el.x(a3) : false !== l3.x && this.el.x(l3.x), true === l3.y ? this.el.y(s3) : false !== l3.y && this.el.y(l3.y);
      } else "object" == typeof r2 && (null != r2.minX && a3 < r2.minX ? o3 = (a3 = r2.minX) - this.startPoints.box.x : null != r2.maxX && a3 > r2.maxX - e3.width && (o3 = (a3 = r2.maxX - e3.width) - this.startPoints.box.x), null != r2.minY && s3 < r2.minY ? n3 = (s3 = r2.minY) - this.startPoints.box.y : null != r2.maxY && s3 > r2.maxY - e3.height && (n3 = (s3 = r2.maxY - e3.height) - this.startPoints.box.y), null != r2.snapToGrid && (a3 -= a3 % r2.snapToGrid, s3 -= s3 % r2.snapToGrid, o3 -= o3 % r2.snapToGrid, n3 -= n3 % r2.snapToGrid), this.el instanceof SVG.G ? this.el.matrix(this.startPoints.transform).transform({ x: o3, y: n3 }, true) : this.el.move(a3, s3));
      return i2;
    }, t3.prototype.end = function(t4) {
      var e3 = this.drag(t4);
      this.el.fire("dragend", { event: t4, p: e3, m: this.m, handler: this }), SVG.off(window, "mousemove.drag"), SVG.off(window, "touchmove.drag"), SVG.off(window, "mouseup.drag"), SVG.off(window, "touchend.drag");
    }, SVG.extend(SVG.Element, { draggable: function(e3, i2) {
      "function" != typeof e3 && "object" != typeof e3 || (i2 = e3, e3 = true);
      var a3 = this.remember("_draggable") || new t3(this);
      return (e3 = void 0 === e3 || e3) ? a3.init(i2 || {}, e3) : (this.off("mousedown.drag"), this.off("touchstart.drag")), this;
    } });
  }).call(void 0), function() {
    function t3(t4) {
      this.el = t4, t4.remember("_selectHandler", this), this.pointSelection = { isSelected: false }, this.rectSelection = { isSelected: false }, this.pointsList = { lt: [0, 0], rt: ["width", 0], rb: ["width", "height"], lb: [0, "height"], t: ["width", 0], r: ["width", "height"], b: ["width", "height"], l: [0, "height"] }, this.pointCoord = function(t5, e3, i2) {
        var a3 = "string" != typeof t5 ? t5 : e3[t5];
        return i2 ? a3 / 2 : a3;
      }, this.pointCoords = function(t5, e3) {
        var i2 = this.pointsList[t5];
        return { x: this.pointCoord(i2[0], e3, "t" === t5 || "b" === t5), y: this.pointCoord(i2[1], e3, "r" === t5 || "l" === t5) };
      };
    }
    t3.prototype.init = function(t4, e3) {
      var i2 = this.el.bbox();
      this.options = {};
      var a3 = this.el.selectize.defaults.points;
      for (var s3 in this.el.selectize.defaults) this.options[s3] = this.el.selectize.defaults[s3], void 0 !== e3[s3] && (this.options[s3] = e3[s3]);
      var r2 = ["points", "pointsExclude"];
      for (var s3 in r2) {
        var o3 = this.options[r2[s3]];
        "string" == typeof o3 ? o3 = o3.length > 0 ? o3.split(/\s*,\s*/i) : [] : "boolean" == typeof o3 && "points" === r2[s3] && (o3 = o3 ? a3 : []), this.options[r2[s3]] = o3;
      }
      this.options.points = [a3, this.options.points].reduce(function(t5, e4) {
        return t5.filter(function(t6) {
          return e4.indexOf(t6) > -1;
        });
      }), this.options.points = [this.options.points, this.options.pointsExclude].reduce(function(t5, e4) {
        return t5.filter(function(t6) {
          return e4.indexOf(t6) < 0;
        });
      }), this.parent = this.el.parent(), this.nested = this.nested || this.parent.group(), this.nested.matrix(new SVG.Matrix(this.el).translate(i2.x, i2.y)), this.options.deepSelect && -1 !== ["line", "polyline", "polygon"].indexOf(this.el.type) ? this.selectPoints(t4) : this.selectRect(t4), this.observe(), this.cleanup();
    }, t3.prototype.selectPoints = function(t4) {
      return this.pointSelection.isSelected = t4, this.pointSelection.set || (this.pointSelection.set = this.parent.set(), this.drawPoints()), this;
    }, t3.prototype.getPointArray = function() {
      var t4 = this.el.bbox();
      return this.el.array().valueOf().map(function(e3) {
        return [e3[0] - t4.x, e3[1] - t4.y];
      });
    }, t3.prototype.drawPoints = function() {
      for (var t4 = this, e3 = this.getPointArray(), i2 = 0, a3 = e3.length; i2 < a3; ++i2) {
        var s3 = /* @__PURE__ */ function(e4) {
          return function(i3) {
            (i3 = i3 || window.event).preventDefault ? i3.preventDefault() : i3.returnValue = false, i3.stopPropagation();
            var a4 = i3.pageX || i3.touches[0].pageX, s4 = i3.pageY || i3.touches[0].pageY;
            t4.el.fire("point", { x: a4, y: s4, i: e4, event: i3 });
          };
        }(i2), r2 = this.drawPoint(e3[i2][0], e3[i2][1]).addClass(this.options.classPoints).addClass(this.options.classPoints + "_point").on("touchstart", s3).on("mousedown", s3);
        this.pointSelection.set.add(r2);
      }
    }, t3.prototype.drawPoint = function(t4, e3) {
      var i2 = this.options.pointType;
      switch (i2) {
        case "circle":
          return this.drawCircle(t4, e3);
        case "rect":
          return this.drawRect(t4, e3);
        default:
          if ("function" == typeof i2) return i2.call(this, t4, e3);
          throw new Error("Unknown " + i2 + " point type!");
      }
    }, t3.prototype.drawCircle = function(t4, e3) {
      return this.nested.circle(this.options.pointSize).center(t4, e3);
    }, t3.prototype.drawRect = function(t4, e3) {
      return this.nested.rect(this.options.pointSize, this.options.pointSize).center(t4, e3);
    }, t3.prototype.updatePointSelection = function() {
      var t4 = this.getPointArray();
      this.pointSelection.set.each(function(e3) {
        this.cx() === t4[e3][0] && this.cy() === t4[e3][1] || this.center(t4[e3][0], t4[e3][1]);
      });
    }, t3.prototype.updateRectSelection = function() {
      var t4 = this, e3 = this.el.bbox();
      if (this.rectSelection.set.get(0).attr({ width: e3.width, height: e3.height }), this.options.points.length && this.options.points.map(function(i3, a3) {
        var s3 = t4.pointCoords(i3, e3);
        t4.rectSelection.set.get(a3 + 1).center(s3.x, s3.y);
      }), this.options.rotationPoint) {
        var i2 = this.rectSelection.set.length();
        this.rectSelection.set.get(i2 - 1).center(e3.width / 2, 20);
      }
    }, t3.prototype.selectRect = function(t4) {
      var e3 = this, i2 = this.el.bbox();
      function a3(t5) {
        return function(i3) {
          (i3 = i3 || window.event).preventDefault ? i3.preventDefault() : i3.returnValue = false, i3.stopPropagation();
          var a4 = i3.pageX || i3.touches[0].pageX, s4 = i3.pageY || i3.touches[0].pageY;
          e3.el.fire(t5, { x: a4, y: s4, event: i3 });
        };
      }
      if (this.rectSelection.isSelected = t4, this.rectSelection.set = this.rectSelection.set || this.parent.set(), this.rectSelection.set.get(0) || this.rectSelection.set.add(this.nested.rect(i2.width, i2.height).addClass(this.options.classRect)), this.options.points.length && this.rectSelection.set.length() < 2) {
        this.options.points.map(function(t5, s4) {
          var r3 = e3.pointCoords(t5, i2), o3 = e3.drawPoint(r3.x, r3.y).attr("class", e3.options.classPoints + "_" + t5).on("mousedown", a3(t5)).on("touchstart", a3(t5));
          e3.rectSelection.set.add(o3);
        }), this.rectSelection.set.each(function() {
          this.addClass(e3.options.classPoints);
        });
      }
      if (this.options.rotationPoint && (this.options.points && !this.rectSelection.set.get(9) || !this.options.points && !this.rectSelection.set.get(1))) {
        var s3 = function(t5) {
          (t5 = t5 || window.event).preventDefault ? t5.preventDefault() : t5.returnValue = false, t5.stopPropagation();
          var i3 = t5.pageX || t5.touches[0].pageX, a4 = t5.pageY || t5.touches[0].pageY;
          e3.el.fire("rot", { x: i3, y: a4, event: t5 });
        }, r2 = this.drawPoint(i2.width / 2, 20).attr("class", this.options.classPoints + "_rot").on("touchstart", s3).on("mousedown", s3);
        this.rectSelection.set.add(r2);
      }
    }, t3.prototype.handler = function() {
      var t4 = this.el.bbox();
      this.nested.matrix(new SVG.Matrix(this.el).translate(t4.x, t4.y)), this.rectSelection.isSelected && this.updateRectSelection(), this.pointSelection.isSelected && this.updatePointSelection();
    }, t3.prototype.observe = function() {
      var t4 = this;
      if (MutationObserver) if (this.rectSelection.isSelected || this.pointSelection.isSelected) this.observerInst = this.observerInst || new MutationObserver(function() {
        t4.handler();
      }), this.observerInst.observe(this.el.node, { attributes: true });
      else try {
        this.observerInst.disconnect(), delete this.observerInst;
      } catch (t5) {
      }
      else this.el.off("DOMAttrModified.select"), (this.rectSelection.isSelected || this.pointSelection.isSelected) && this.el.on("DOMAttrModified.select", function() {
        t4.handler();
      });
    }, t3.prototype.cleanup = function() {
      !this.rectSelection.isSelected && this.rectSelection.set && (this.rectSelection.set.each(function() {
        this.remove();
      }), this.rectSelection.set.clear(), delete this.rectSelection.set), !this.pointSelection.isSelected && this.pointSelection.set && (this.pointSelection.set.each(function() {
        this.remove();
      }), this.pointSelection.set.clear(), delete this.pointSelection.set), this.pointSelection.isSelected || this.rectSelection.isSelected || (this.nested.remove(), delete this.nested);
    }, SVG.extend(SVG.Element, { selectize: function(e3, i2) {
      return "object" == typeof e3 && (i2 = e3, e3 = true), (this.remember("_selectHandler") || new t3(this)).init(void 0 === e3 || e3, i2 || {}), this;
    } }), SVG.Element.prototype.selectize.defaults = { points: ["lt", "rt", "rb", "lb", "t", "r", "b", "l"], pointsExclude: [], classRect: "svg_select_boundingRect", classPoints: "svg_select_points", pointSize: 7, rotationPoint: true, deepSelect: false, pointType: "circle" };
  }(), function() {
    (function() {
      function t3(t4) {
        t4.remember("_resizeHandler", this), this.el = t4, this.parameters = {}, this.lastUpdateCall = null, this.p = t4.doc().node.createSVGPoint();
      }
      t3.prototype.transformPoint = function(t4, e3, i2) {
        return this.p.x = t4 - (this.offset.x - window.pageXOffset), this.p.y = e3 - (this.offset.y - window.pageYOffset), this.p.matrixTransform(i2 || this.m);
      }, t3.prototype._extractPosition = function(t4) {
        return { x: null != t4.clientX ? t4.clientX : t4.touches[0].clientX, y: null != t4.clientY ? t4.clientY : t4.touches[0].clientY };
      }, t3.prototype.init = function(t4) {
        var e3 = this;
        if (this.stop(), "stop" !== t4) {
          for (var i2 in this.options = {}, this.el.resize.defaults) this.options[i2] = this.el.resize.defaults[i2], void 0 !== t4[i2] && (this.options[i2] = t4[i2]);
          this.el.on("lt.resize", function(t5) {
            e3.resize(t5 || window.event);
          }), this.el.on("rt.resize", function(t5) {
            e3.resize(t5 || window.event);
          }), this.el.on("rb.resize", function(t5) {
            e3.resize(t5 || window.event);
          }), this.el.on("lb.resize", function(t5) {
            e3.resize(t5 || window.event);
          }), this.el.on("t.resize", function(t5) {
            e3.resize(t5 || window.event);
          }), this.el.on("r.resize", function(t5) {
            e3.resize(t5 || window.event);
          }), this.el.on("b.resize", function(t5) {
            e3.resize(t5 || window.event);
          }), this.el.on("l.resize", function(t5) {
            e3.resize(t5 || window.event);
          }), this.el.on("rot.resize", function(t5) {
            e3.resize(t5 || window.event);
          }), this.el.on("point.resize", function(t5) {
            e3.resize(t5 || window.event);
          }), this.update();
        }
      }, t3.prototype.stop = function() {
        return this.el.off("lt.resize"), this.el.off("rt.resize"), this.el.off("rb.resize"), this.el.off("lb.resize"), this.el.off("t.resize"), this.el.off("r.resize"), this.el.off("b.resize"), this.el.off("l.resize"), this.el.off("rot.resize"), this.el.off("point.resize"), this;
      }, t3.prototype.resize = function(t4) {
        var e3 = this;
        this.m = this.el.node.getScreenCTM().inverse(), this.offset = { x: window.pageXOffset, y: window.pageYOffset };
        var i2 = this._extractPosition(t4.detail.event);
        if (this.parameters = { type: this.el.type, p: this.transformPoint(i2.x, i2.y), x: t4.detail.x, y: t4.detail.y, box: this.el.bbox(), rotation: this.el.transform().rotation }, "text" === this.el.type && (this.parameters.fontSize = this.el.attr()["font-size"]), void 0 !== t4.detail.i) {
          var a3 = this.el.array().valueOf();
          this.parameters.i = t4.detail.i, this.parameters.pointCoords = [a3[t4.detail.i][0], a3[t4.detail.i][1]];
        }
        switch (t4.type) {
          case "lt":
            this.calc = function(t5, e4) {
              var i3 = this.snapToGrid(t5, e4);
              if (this.parameters.box.width - i3[0] > 0 && this.parameters.box.height - i3[1] > 0) {
                if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x + i3[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - i3[0]);
                i3 = this.checkAspectRatio(i3), this.el.move(this.parameters.box.x + i3[0], this.parameters.box.y + i3[1]).size(this.parameters.box.width - i3[0], this.parameters.box.height - i3[1]);
              }
            };
            break;
          case "rt":
            this.calc = function(t5, e4) {
              var i3 = this.snapToGrid(t5, e4, 2);
              if (this.parameters.box.width + i3[0] > 0 && this.parameters.box.height - i3[1] > 0) {
                if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x - i3[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + i3[0]);
                i3 = this.checkAspectRatio(i3, true), this.el.move(this.parameters.box.x, this.parameters.box.y + i3[1]).size(this.parameters.box.width + i3[0], this.parameters.box.height - i3[1]);
              }
            };
            break;
          case "rb":
            this.calc = function(t5, e4) {
              var i3 = this.snapToGrid(t5, e4, 0);
              if (this.parameters.box.width + i3[0] > 0 && this.parameters.box.height + i3[1] > 0) {
                if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x - i3[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + i3[0]);
                i3 = this.checkAspectRatio(i3), this.el.move(this.parameters.box.x, this.parameters.box.y).size(this.parameters.box.width + i3[0], this.parameters.box.height + i3[1]);
              }
            };
            break;
          case "lb":
            this.calc = function(t5, e4) {
              var i3 = this.snapToGrid(t5, e4, 1);
              if (this.parameters.box.width - i3[0] > 0 && this.parameters.box.height + i3[1] > 0) {
                if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x + i3[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - i3[0]);
                i3 = this.checkAspectRatio(i3, true), this.el.move(this.parameters.box.x + i3[0], this.parameters.box.y).size(this.parameters.box.width - i3[0], this.parameters.box.height + i3[1]);
              }
            };
            break;
          case "t":
            this.calc = function(t5, e4) {
              var i3 = this.snapToGrid(t5, e4, 2);
              if (this.parameters.box.height - i3[1] > 0) {
                if ("text" === this.parameters.type) return;
                this.el.move(this.parameters.box.x, this.parameters.box.y + i3[1]).height(this.parameters.box.height - i3[1]);
              }
            };
            break;
          case "r":
            this.calc = function(t5, e4) {
              var i3 = this.snapToGrid(t5, e4, 0);
              if (this.parameters.box.width + i3[0] > 0) {
                if ("text" === this.parameters.type) return;
                this.el.move(this.parameters.box.x, this.parameters.box.y).width(this.parameters.box.width + i3[0]);
              }
            };
            break;
          case "b":
            this.calc = function(t5, e4) {
              var i3 = this.snapToGrid(t5, e4, 0);
              if (this.parameters.box.height + i3[1] > 0) {
                if ("text" === this.parameters.type) return;
                this.el.move(this.parameters.box.x, this.parameters.box.y).height(this.parameters.box.height + i3[1]);
              }
            };
            break;
          case "l":
            this.calc = function(t5, e4) {
              var i3 = this.snapToGrid(t5, e4, 1);
              if (this.parameters.box.width - i3[0] > 0) {
                if ("text" === this.parameters.type) return;
                this.el.move(this.parameters.box.x + i3[0], this.parameters.box.y).width(this.parameters.box.width - i3[0]);
              }
            };
            break;
          case "rot":
            this.calc = function(t5, e4) {
              var i3 = t5 + this.parameters.p.x, a4 = e4 + this.parameters.p.y, s3 = Math.atan2(this.parameters.p.y - this.parameters.box.y - this.parameters.box.height / 2, this.parameters.p.x - this.parameters.box.x - this.parameters.box.width / 2), r2 = Math.atan2(a4 - this.parameters.box.y - this.parameters.box.height / 2, i3 - this.parameters.box.x - this.parameters.box.width / 2), o3 = this.parameters.rotation + 180 * (r2 - s3) / Math.PI + this.options.snapToAngle / 2;
              this.el.center(this.parameters.box.cx, this.parameters.box.cy).rotate(o3 - o3 % this.options.snapToAngle, this.parameters.box.cx, this.parameters.box.cy);
            };
            break;
          case "point":
            this.calc = function(t5, e4) {
              var i3 = this.snapToGrid(t5, e4, this.parameters.pointCoords[0], this.parameters.pointCoords[1]), a4 = this.el.array().valueOf();
              a4[this.parameters.i][0] = this.parameters.pointCoords[0] + i3[0], a4[this.parameters.i][1] = this.parameters.pointCoords[1] + i3[1], this.el.plot(a4);
            };
        }
        this.el.fire("resizestart", { dx: this.parameters.x, dy: this.parameters.y, event: t4 }), SVG.on(window, "touchmove.resize", function(t5) {
          e3.update(t5 || window.event);
        }), SVG.on(window, "touchend.resize", function() {
          e3.done();
        }), SVG.on(window, "mousemove.resize", function(t5) {
          e3.update(t5 || window.event);
        }), SVG.on(window, "mouseup.resize", function() {
          e3.done();
        });
      }, t3.prototype.update = function(t4) {
        if (t4) {
          var e3 = this._extractPosition(t4), i2 = this.transformPoint(e3.x, e3.y), a3 = i2.x - this.parameters.p.x, s3 = i2.y - this.parameters.p.y;
          this.lastUpdateCall = [a3, s3], this.calc(a3, s3), this.el.fire("resizing", { dx: a3, dy: s3, event: t4 });
        } else this.lastUpdateCall && this.calc(this.lastUpdateCall[0], this.lastUpdateCall[1]);
      }, t3.prototype.done = function() {
        this.lastUpdateCall = null, SVG.off(window, "mousemove.resize"), SVG.off(window, "mouseup.resize"), SVG.off(window, "touchmove.resize"), SVG.off(window, "touchend.resize"), this.el.fire("resizedone");
      }, t3.prototype.snapToGrid = function(t4, e3, i2, a3) {
        var s3;
        return void 0 !== a3 ? s3 = [(i2 + t4) % this.options.snapToGrid, (a3 + e3) % this.options.snapToGrid] : (i2 = null == i2 ? 3 : i2, s3 = [(this.parameters.box.x + t4 + (1 & i2 ? 0 : this.parameters.box.width)) % this.options.snapToGrid, (this.parameters.box.y + e3 + (2 & i2 ? 0 : this.parameters.box.height)) % this.options.snapToGrid]), t4 < 0 && (s3[0] -= this.options.snapToGrid), e3 < 0 && (s3[1] -= this.options.snapToGrid), t4 -= Math.abs(s3[0]) < this.options.snapToGrid / 2 ? s3[0] : s3[0] - (t4 < 0 ? -this.options.snapToGrid : this.options.snapToGrid), e3 -= Math.abs(s3[1]) < this.options.snapToGrid / 2 ? s3[1] : s3[1] - (e3 < 0 ? -this.options.snapToGrid : this.options.snapToGrid), this.constraintToBox(t4, e3, i2, a3);
      }, t3.prototype.constraintToBox = function(t4, e3, i2, a3) {
        var s3, r2, o3 = this.options.constraint || {};
        return void 0 !== a3 ? (s3 = i2, r2 = a3) : (s3 = this.parameters.box.x + (1 & i2 ? 0 : this.parameters.box.width), r2 = this.parameters.box.y + (2 & i2 ? 0 : this.parameters.box.height)), void 0 !== o3.minX && s3 + t4 < o3.minX && (t4 = o3.minX - s3), void 0 !== o3.maxX && s3 + t4 > o3.maxX && (t4 = o3.maxX - s3), void 0 !== o3.minY && r2 + e3 < o3.minY && (e3 = o3.minY - r2), void 0 !== o3.maxY && r2 + e3 > o3.maxY && (e3 = o3.maxY - r2), [t4, e3];
      }, t3.prototype.checkAspectRatio = function(t4, e3) {
        if (!this.options.saveAspectRatio) return t4;
        var i2 = t4.slice(), a3 = this.parameters.box.width / this.parameters.box.height, s3 = this.parameters.box.width + t4[0], r2 = this.parameters.box.height - t4[1], o3 = s3 / r2;
        return o3 < a3 ? (i2[1] = s3 / a3 - this.parameters.box.height, e3 && (i2[1] = -i2[1])) : o3 > a3 && (i2[0] = this.parameters.box.width - r2 * a3, e3 && (i2[0] = -i2[0])), i2;
      }, SVG.extend(SVG.Element, { resize: function(e3) {
        return (this.remember("_resizeHandler") || new t3(this)).init(e3 || {}), this;
      } }), SVG.Element.prototype.resize.defaults = { snapToAngle: 0.1, snapToGrid: 1, constraint: {}, saveAspectRatio: false };
    }).call(this);
  }(), void 0 === window.Apex && (window.Apex = {});
  var Gt2 = function() {
    function t3(e3) {
      a2(this, t3), this.ctx = e3, this.w = e3.w;
    }
    return r(t3, [{ key: "initModules", value: function() {
      this.ctx.publicMethods = ["updateOptions", "updateSeries", "appendData", "appendSeries", "isSeriesHidden", "toggleSeries", "showSeries", "hideSeries", "setLocale", "resetSeries", "zoomX", "toggleDataPointSelection", "dataURI", "exportToCSV", "addXaxisAnnotation", "addYaxisAnnotation", "addPointAnnotation", "clearAnnotations", "removeAnnotation", "paper", "destroy"], this.ctx.eventList = ["click", "mousedown", "mousemove", "mouseleave", "touchstart", "touchmove", "touchleave", "mouseup", "touchend"], this.ctx.animations = new b2(this.ctx), this.ctx.axes = new J2(this.ctx), this.ctx.core = new Wt2(this.ctx.el, this.ctx), this.ctx.config = new Y2({}), this.ctx.data = new B3(this.ctx), this.ctx.grid = new j2(this.ctx), this.ctx.graphics = new m2(this.ctx), this.ctx.coreUtils = new y2(this.ctx), this.ctx.crosshairs = new Q2(this.ctx), this.ctx.events = new Z2(this.ctx), this.ctx.exports = new G2(this.ctx), this.ctx.localization = new $2(this.ctx), this.ctx.options = new I2(), this.ctx.responsive = new K2(this.ctx), this.ctx.series = new W2(this.ctx), this.ctx.theme = new tt2(this.ctx), this.ctx.formatters = new S2(this.ctx), this.ctx.titleSubtitle = new et2(this.ctx), this.ctx.legend = new lt2(this.ctx), this.ctx.toolbar = new ht2(this.ctx), this.ctx.tooltip = new bt2(this.ctx), this.ctx.dimensions = new ot2(this.ctx), this.ctx.updateHelpers = new Bt2(this.ctx), this.ctx.zoomPanSelection = new ct2(this.ctx), this.ctx.w.globals.tooltip = new bt2(this.ctx);
    } }]), t3;
  }(), Vt2 = function() {
    function t3(e3) {
      a2(this, t3), this.ctx = e3, this.w = e3.w;
    }
    return r(t3, [{ key: "clear", value: function(t4) {
      var e3 = t4.isUpdating;
      this.ctx.zoomPanSelection && this.ctx.zoomPanSelection.destroy(), this.ctx.toolbar && this.ctx.toolbar.destroy(), this.ctx.animations = null, this.ctx.axes = null, this.ctx.annotations = null, this.ctx.core = null, this.ctx.data = null, this.ctx.grid = null, this.ctx.series = null, this.ctx.responsive = null, this.ctx.theme = null, this.ctx.formatters = null, this.ctx.titleSubtitle = null, this.ctx.legend = null, this.ctx.dimensions = null, this.ctx.options = null, this.ctx.crosshairs = null, this.ctx.zoomPanSelection = null, this.ctx.updateHelpers = null, this.ctx.toolbar = null, this.ctx.localization = null, this.ctx.w.globals.tooltip = null, this.clearDomElements({ isUpdating: e3 });
    } }, { key: "killSVG", value: function(t4) {
      t4.each(function(t5, e3) {
        this.removeClass("*"), this.off(), this.stop();
      }, true), t4.ungroup(), t4.clear();
    } }, { key: "clearDomElements", value: function(t4) {
      var e3 = this, i2 = t4.isUpdating, a3 = this.w.globals.dom.Paper.node;
      a3.parentNode && a3.parentNode.parentNode && !i2 && (a3.parentNode.parentNode.style.minHeight = "unset");
      var s3 = this.w.globals.dom.baseEl;
      s3 && this.ctx.eventList.forEach(function(t5) {
        s3.removeEventListener(t5, e3.ctx.events.documentEvent);
      });
      var r2 = this.w.globals.dom;
      if (null !== this.ctx.el) for (; this.ctx.el.firstChild; ) this.ctx.el.removeChild(this.ctx.el.firstChild);
      this.killSVG(r2.Paper), r2.Paper.remove(), r2.elWrap = null, r2.elGraphical = null, r2.elLegendWrap = null, r2.elLegendForeign = null, r2.baseEl = null, r2.elGridRect = null, r2.elGridRectMask = null, r2.elGridRectMarkerMask = null, r2.elForecastMask = null, r2.elNonForecastMask = null, r2.elDefs = null;
    } }]), t3;
  }(), jt2 = /* @__PURE__ */ new WeakMap();
  var _t2 = function() {
    function t3(e3, i2) {
      a2(this, t3), this.opts = i2, this.ctx = this, this.w = new R2(i2).init(), this.el = e3, this.w.globals.cuid = x2.randomId(), this.w.globals.chartID = this.w.config.chart.id ? x2.escapeString(this.w.config.chart.id) : this.w.globals.cuid, new Gt2(this).initModules(), this.create = x2.bind(this.create, this), this.windowResizeHandler = this._windowResizeHandler.bind(this), this.parentResizeHandler = this._parentResizeCallback.bind(this);
    }
    return r(t3, [{ key: "render", value: function() {
      var t4 = this;
      return new Promise(function(e3, i2) {
        if (null !== t4.el) {
          void 0 === Apex._chartInstances && (Apex._chartInstances = []), t4.w.config.chart.id && Apex._chartInstances.push({ id: t4.w.globals.chartID, group: t4.w.config.chart.group, chart: t4 }), t4.setLocale(t4.w.config.chart.defaultLocale);
          var a3 = t4.w.config.chart.events.beforeMount;
          "function" == typeof a3 && a3(t4, t4.w), t4.events.fireEvent("beforeMount", [t4, t4.w]), window.addEventListener("resize", t4.windowResizeHandler), function(t5, e4) {
            var i3 = false;
            if (t5.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
              var a4 = t5.getBoundingClientRect();
              "none" !== t5.style.display && 0 !== a4.width || (i3 = true);
            }
            var s4 = new ResizeObserver(function(a5) {
              i3 && e4.call(t5, a5), i3 = true;
            });
            t5.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? Array.from(t5.children).forEach(function(t6) {
              return s4.observe(t6);
            }) : s4.observe(t5), jt2.set(e4, s4);
          }(t4.el.parentNode, t4.parentResizeHandler);
          var s3 = t4.el.getRootNode && t4.el.getRootNode(), r2 = x2.is("ShadowRoot", s3), o3 = t4.el.ownerDocument, n3 = r2 ? s3.getElementById("apexcharts-css") : o3.getElementById("apexcharts-css");
          if (!n3) {
            var l3;
            (n3 = document.createElement("style")).id = "apexcharts-css", n3.textContent = '@keyframes opaque {\n  0% {\n    opacity: 0\n  }\n\n  to {\n    opacity: 1\n  }\n}\n\n@keyframes resizeanim {\n\n  0%,\n  to {\n    opacity: 0\n  }\n}\n\n.apexcharts-canvas {\n  position: relative;\n  user-select: none\n}\n\n.apexcharts-canvas ::-webkit-scrollbar {\n  -webkit-appearance: none;\n  width: 6px\n}\n\n.apexcharts-canvas ::-webkit-scrollbar-thumb {\n  border-radius: 4px;\n  background-color: rgba(0, 0, 0, .5);\n  box-shadow: 0 0 1px rgba(255, 255, 255, .5);\n  -webkit-box-shadow: 0 0 1px rgba(255, 255, 255, .5)\n}\n\n.apexcharts-inner {\n  position: relative\n}\n\n.apexcharts-text tspan {\n  font-family: inherit\n}\n\nrect.legend-mouseover-inactive,\n.legend-mouseover-inactive rect,\n.legend-mouseover-inactive path,\n.legend-mouseover-inactive circle,\n.legend-mouseover-inactive line,\n.legend-mouseover-inactive text.apexcharts-yaxis-title-text,\n.legend-mouseover-inactive text.apexcharts-yaxis-label {\n  transition: .15s ease all;\n  opacity: .2\n}\n\n.apexcharts-legend-text {\n  padding-left: 15px;\n  margin-left: -15px;\n}\n\n.apexcharts-series-collapsed {\n  opacity: 0\n}\n\n.apexcharts-tooltip {\n  border-radius: 5px;\n  box-shadow: 2px 2px 6px -4px #999;\n  cursor: default;\n  font-size: 14px;\n  left: 62px;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 20px;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  white-space: nowrap;\n  z-index: 12;\n  transition: .15s ease all\n}\n\n.apexcharts-tooltip.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-tooltip.apexcharts-theme-light {\n  border: 1px solid #e3e3e3;\n  background: rgba(255, 255, 255, .96)\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark {\n  color: #fff;\n  background: rgba(30, 30, 30, .8)\n}\n\n.apexcharts-tooltip * {\n  font-family: inherit\n}\n\n.apexcharts-tooltip-title {\n  padding: 6px;\n  font-size: 15px;\n  margin-bottom: 4px\n}\n\n.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {\n  background: #eceff1;\n  border-bottom: 1px solid #ddd\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {\n  background: rgba(0, 0, 0, .7);\n  border-bottom: 1px solid #333\n}\n\n.apexcharts-tooltip-text-goals-value,\n.apexcharts-tooltip-text-y-value,\n.apexcharts-tooltip-text-z-value {\n  display: inline-block;\n  margin-left: 5px;\n  font-weight: 600\n}\n\n.apexcharts-tooltip-text-goals-label:empty,\n.apexcharts-tooltip-text-goals-value:empty,\n.apexcharts-tooltip-text-y-label:empty,\n.apexcharts-tooltip-text-y-value:empty,\n.apexcharts-tooltip-text-z-value:empty,\n.apexcharts-tooltip-title:empty {\n  display: none\n}\n\n.apexcharts-tooltip-text-goals-label,\n.apexcharts-tooltip-text-goals-value {\n  padding: 6px 0 5px\n}\n\n.apexcharts-tooltip-goals-group,\n.apexcharts-tooltip-text-goals-label,\n.apexcharts-tooltip-text-goals-value {\n  display: flex\n}\n\n.apexcharts-tooltip-text-goals-label:not(:empty),\n.apexcharts-tooltip-text-goals-value:not(:empty) {\n  margin-top: -6px\n}\n\n.apexcharts-tooltip-marker {\n  width: 12px;\n  height: 12px;\n  position: relative;\n  top: 0;\n  margin-right: 10px;\n  border-radius: 50%\n}\n\n.apexcharts-tooltip-series-group {\n  padding: 0 10px;\n  display: none;\n  text-align: left;\n  justify-content: left;\n  align-items: center\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {\n  opacity: 1\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active,\n.apexcharts-tooltip-series-group:last-child {\n  padding-bottom: 4px\n}\n\n.apexcharts-tooltip-series-group-hidden {\n  opacity: 0;\n  height: 0;\n  line-height: 0;\n  padding: 0 !important\n}\n\n.apexcharts-tooltip-y-group {\n  padding: 6px 0 5px\n}\n\n.apexcharts-custom-tooltip,\n.apexcharts-tooltip-box {\n  padding: 4px 8px\n}\n\n.apexcharts-tooltip-boxPlot {\n  display: flex;\n  flex-direction: column-reverse\n}\n\n.apexcharts-tooltip-box>div {\n  margin: 4px 0\n}\n\n.apexcharts-tooltip-box span.value {\n  font-weight: 700\n}\n\n.apexcharts-tooltip-rangebar {\n  padding: 5px 8px\n}\n\n.apexcharts-tooltip-rangebar .category {\n  font-weight: 600;\n  color: #777\n}\n\n.apexcharts-tooltip-rangebar .series-name {\n  font-weight: 700;\n  display: block;\n  margin-bottom: 5px\n}\n\n.apexcharts-xaxistooltip,\n.apexcharts-yaxistooltip {\n  opacity: 0;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #eceff1;\n  border: 1px solid #90a4ae\n}\n\n.apexcharts-xaxistooltip {\n  padding: 9px 10px;\n  transition: .15s ease all\n}\n\n.apexcharts-xaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, .7);\n  border: 1px solid rgba(0, 0, 0, .5);\n  color: #fff\n}\n\n.apexcharts-xaxistooltip:after,\n.apexcharts-xaxistooltip:before {\n  left: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none\n}\n\n.apexcharts-xaxistooltip:after {\n  border-color: transparent;\n  border-width: 6px;\n  margin-left: -6px\n}\n\n.apexcharts-xaxistooltip:before {\n  border-color: transparent;\n  border-width: 7px;\n  margin-left: -7px\n}\n\n.apexcharts-xaxistooltip-bottom:after,\n.apexcharts-xaxistooltip-bottom:before {\n  bottom: 100%\n}\n\n.apexcharts-xaxistooltip-top:after,\n.apexcharts-xaxistooltip-top:before {\n  top: 100%\n}\n\n.apexcharts-xaxistooltip-bottom:after {\n  border-bottom-color: #eceff1\n}\n\n.apexcharts-xaxistooltip-bottom:before {\n  border-bottom-color: #90a4ae\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after,\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {\n  border-bottom-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-xaxistooltip-top:after {\n  border-top-color: #eceff1\n}\n\n.apexcharts-xaxistooltip-top:before {\n  border-top-color: #90a4ae\n}\n\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after,\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {\n  border-top-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-xaxistooltip.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-yaxistooltip {\n  padding: 4px 10px\n}\n\n.apexcharts-yaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, .7);\n  border: 1px solid rgba(0, 0, 0, .5);\n  color: #fff\n}\n\n.apexcharts-yaxistooltip:after,\n.apexcharts-yaxistooltip:before {\n  top: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none\n}\n\n.apexcharts-yaxistooltip:after {\n  border-color: transparent;\n  border-width: 6px;\n  margin-top: -6px\n}\n\n.apexcharts-yaxistooltip:before {\n  border-color: transparent;\n  border-width: 7px;\n  margin-top: -7px\n}\n\n.apexcharts-yaxistooltip-left:after,\n.apexcharts-yaxistooltip-left:before {\n  left: 100%\n}\n\n.apexcharts-yaxistooltip-right:after,\n.apexcharts-yaxistooltip-right:before {\n  right: 100%\n}\n\n.apexcharts-yaxistooltip-left:after {\n  border-left-color: #eceff1\n}\n\n.apexcharts-yaxistooltip-left:before {\n  border-left-color: #90a4ae\n}\n\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after,\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {\n  border-left-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-yaxistooltip-right:after {\n  border-right-color: #eceff1\n}\n\n.apexcharts-yaxistooltip-right:before {\n  border-right-color: #90a4ae\n}\n\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after,\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {\n  border-right-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-yaxistooltip.apexcharts-active {\n  opacity: 1\n}\n\n.apexcharts-yaxistooltip-hidden {\n  display: none\n}\n\n.apexcharts-xcrosshairs,\n.apexcharts-ycrosshairs {\n  pointer-events: none;\n  opacity: 0;\n  transition: .15s ease all\n}\n\n.apexcharts-xcrosshairs.apexcharts-active,\n.apexcharts-ycrosshairs.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-ycrosshairs-hidden {\n  opacity: 0\n}\n\n.apexcharts-selection-rect {\n  cursor: move\n}\n\n.svg_select_boundingRect,\n.svg_select_points_rot {\n  pointer-events: none;\n  opacity: 0;\n  visibility: hidden\n}\n\n.apexcharts-selection-rect+g .svg_select_boundingRect,\n.apexcharts-selection-rect+g .svg_select_points_rot {\n  opacity: 0;\n  visibility: hidden\n}\n\n.apexcharts-selection-rect+g .svg_select_points_l,\n.apexcharts-selection-rect+g .svg_select_points_r {\n  cursor: ew-resize;\n  opacity: 1;\n  visibility: visible\n}\n\n.svg_select_points {\n  fill: #efefef;\n  stroke: #333;\n  rx: 2\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-zoom {\n  cursor: crosshair\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-pan {\n  cursor: move\n}\n\n.apexcharts-menu-icon,\n.apexcharts-pan-icon,\n.apexcharts-reset-icon,\n.apexcharts-selection-icon,\n.apexcharts-toolbar-custom-icon,\n.apexcharts-zoom-icon,\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon {\n  cursor: pointer;\n  width: 20px;\n  height: 20px;\n  line-height: 24px;\n  color: #6e8192;\n  text-align: center\n}\n\n.apexcharts-menu-icon svg,\n.apexcharts-reset-icon svg,\n.apexcharts-zoom-icon svg,\n.apexcharts-zoomin-icon svg,\n.apexcharts-zoomout-icon svg {\n  fill: #6e8192\n}\n\n.apexcharts-selection-icon svg {\n  fill: #444;\n  transform: scale(.76)\n}\n\n.apexcharts-theme-dark .apexcharts-menu-icon svg,\n.apexcharts-theme-dark .apexcharts-pan-icon svg,\n.apexcharts-theme-dark .apexcharts-reset-icon svg,\n.apexcharts-theme-dark .apexcharts-selection-icon svg,\n.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg,\n.apexcharts-theme-dark .apexcharts-zoom-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomin-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomout-icon svg {\n  fill: #f3f4f5\n}\n\n.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg {\n  fill: #008ffb\n}\n\n.apexcharts-theme-light .apexcharts-menu-icon:hover svg,\n.apexcharts-theme-light .apexcharts-reset-icon:hover svg,\n.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoomin-icon:hover svg,\n.apexcharts-theme-light .apexcharts-zoomout-icon:hover svg {\n  fill: #333\n}\n\n.apexcharts-menu-icon,\n.apexcharts-selection-icon {\n  position: relative\n}\n\n.apexcharts-reset-icon {\n  margin-left: 5px\n}\n\n.apexcharts-menu-icon,\n.apexcharts-reset-icon,\n.apexcharts-zoom-icon {\n  transform: scale(.85)\n}\n\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon {\n  transform: scale(.7)\n}\n\n.apexcharts-zoomout-icon {\n  margin-right: 3px\n}\n\n.apexcharts-pan-icon {\n  transform: scale(.62);\n  position: relative;\n  left: 1px;\n  top: 0\n}\n\n.apexcharts-pan-icon svg {\n  fill: #fff;\n  stroke: #6e8192;\n  stroke-width: 2\n}\n\n.apexcharts-pan-icon.apexcharts-selected svg {\n  stroke: #008ffb\n}\n\n.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {\n  stroke: #333\n}\n\n.apexcharts-toolbar {\n  position: absolute;\n  z-index: 11;\n  max-width: 176px;\n  text-align: right;\n  border-radius: 3px;\n  padding: 0 6px 2px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center\n}\n\n.apexcharts-menu {\n  background: #fff;\n  position: absolute;\n  top: 100%;\n  border: 1px solid #ddd;\n  border-radius: 3px;\n  padding: 3px;\n  right: 10px;\n  opacity: 0;\n  min-width: 110px;\n  transition: .15s ease all;\n  pointer-events: none\n}\n\n.apexcharts-menu.apexcharts-menu-open {\n  opacity: 1;\n  pointer-events: all;\n  transition: .15s ease all\n}\n\n.apexcharts-menu-item {\n  padding: 6px 7px;\n  font-size: 12px;\n  cursor: pointer\n}\n\n.apexcharts-theme-light .apexcharts-menu-item:hover {\n  background: #eee\n}\n\n.apexcharts-theme-dark .apexcharts-menu {\n  background: rgba(0, 0, 0, .7);\n  color: #fff\n}\n\n@media screen and (min-width:768px) {\n  .apexcharts-canvas:hover .apexcharts-toolbar {\n    opacity: 1\n  }\n}\n\n.apexcharts-canvas .apexcharts-element-hidden,\n.apexcharts-datalabel.apexcharts-element-hidden,\n.apexcharts-hide .apexcharts-series-points {\n  opacity: 0;\n}\n\n.apexcharts-hidden-element-shown {\n  opacity: 1;\n  transition: 0.25s ease all;\n}\n\n.apexcharts-datalabel,\n.apexcharts-datalabel-label,\n.apexcharts-datalabel-value,\n.apexcharts-datalabels,\n.apexcharts-pie-label {\n  cursor: default;\n  pointer-events: none\n}\n\n.apexcharts-pie-label-delay {\n  opacity: 0;\n  animation-name: opaque;\n  animation-duration: .3s;\n  animation-fill-mode: forwards;\n  animation-timing-function: ease\n}\n\n.apexcharts-radialbar-label {\n  cursor: pointer;\n}\n\n.apexcharts-annotation-rect,\n.apexcharts-area-series .apexcharts-area,\n.apexcharts-area-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,\n.apexcharts-gridline,\n.apexcharts-line,\n.apexcharts-line-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,\n.apexcharts-point-annotation-label,\n.apexcharts-radar-series path,\n.apexcharts-radar-series polygon,\n.apexcharts-toolbar svg,\n.apexcharts-tooltip .apexcharts-marker,\n.apexcharts-xaxis-annotation-label,\n.apexcharts-yaxis-annotation-label,\n.apexcharts-zoom-rect {\n  pointer-events: none\n}\n\n.apexcharts-marker {\n  transition: .15s ease all\n}\n\n.resize-triggers {\n  animation: 1ms resizeanim;\n  visibility: hidden;\n  opacity: 0;\n  height: 100%;\n  width: 100%;\n  overflow: hidden\n}\n\n.contract-trigger:before,\n.resize-triggers,\n.resize-triggers>div {\n  content: " ";\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0\n}\n\n.resize-triggers>div {\n  height: 100%;\n  width: 100%;\n  background: #eee;\n  overflow: auto\n}\n\n.contract-trigger:before {\n  overflow: hidden;\n  width: 200%;\n  height: 200%\n}\n\n.apexcharts-bar-goals-markers {\n  pointer-events: none\n}\n\n.apexcharts-bar-shadows {\n  pointer-events: none\n}\n\n.apexcharts-rangebar-goals-markers {\n  pointer-events: none\n}';
            var h3 = (null === (l3 = t4.opts.chart) || void 0 === l3 ? void 0 : l3.nonce) || t4.w.config.chart.nonce;
            h3 && n3.setAttribute("nonce", h3), r2 ? s3.prepend(n3) : o3.head.appendChild(n3);
          }
          var c3 = t4.create(t4.w.config.series, {});
          if (!c3) return e3(t4);
          t4.mount(c3).then(function() {
            "function" == typeof t4.w.config.chart.events.mounted && t4.w.config.chart.events.mounted(t4, t4.w), t4.events.fireEvent("mounted", [t4, t4.w]), e3(c3);
          }).catch(function(t5) {
            i2(t5);
          });
        } else i2(new Error("Element not found"));
      });
    } }, { key: "create", value: function(t4, e3) {
      var i2 = this.w;
      new Gt2(this).initModules();
      var a3 = this.w.globals;
      (a3.noData = false, a3.animationEnded = false, this.responsive.checkResponsiveConfig(e3), i2.config.xaxis.convertedCatToNumeric) && new E2(i2.config).convertCatToNumericXaxis(i2.config, this.ctx);
      if (null === this.el) return a3.animationEnded = true, null;
      if (this.core.setupElements(), "treemap" === i2.config.chart.type && (i2.config.grid.show = false, i2.config.yaxis[0].show = false), 0 === a3.svgWidth) return a3.animationEnded = true, null;
      var s3 = y2.checkComboSeries(t4, i2.config.chart.type);
      a3.comboCharts = s3.comboCharts, a3.comboBarCount = s3.comboBarCount;
      var r2 = t4.every(function(t5) {
        return t5.data && 0 === t5.data.length;
      });
      (0 === t4.length || r2 && a3.collapsedSeries.length < 1) && this.series.handleNoData(), this.events.setupEventHandlers(), this.data.parseData(t4), this.theme.init(), new D2(this).setGlobalMarkerSize(), this.formatters.setLabelFormatters(), this.titleSubtitle.draw(), a3.noData && a3.collapsedSeries.length !== a3.series.length && !i2.config.legend.showForSingleSeries || this.legend.init(), this.series.hasAllSeriesEqualX(), a3.axisCharts && (this.core.coreCalculations(), "category" !== i2.config.xaxis.type && this.formatters.setLabelFormatters(), this.ctx.toolbar.minX = i2.globals.minX, this.ctx.toolbar.maxX = i2.globals.maxX), this.formatters.heatmapLabelFormatters(), new y2(this).getLargestMarkerSize(), this.dimensions.plotCoords();
      var o3 = this.core.xySettings();
      this.grid.createGridMask();
      var n3 = this.core.plotChartType(t4, o3), l3 = new N2(this);
      return l3.bringForward(), i2.config.dataLabels.background.enabled && l3.dataLabelsBackground(), this.core.shiftGraphPosition(), { elGraph: n3, xyRatios: o3, dimensions: { plot: { left: i2.globals.translateX, top: i2.globals.translateY, width: i2.globals.gridWidth, height: i2.globals.gridHeight } } };
    } }, { key: "mount", value: function() {
      var t4 = this, e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, i2 = this, a3 = i2.w;
      return new Promise(function(s3, r2) {
        if (null === i2.el) return r2(new Error("Not enough data to display or target element not found"));
        (null === e3 || a3.globals.allSeriesCollapsed) && i2.series.handleNoData(), i2.grid = new j2(i2);
        var o3, n3, l3 = i2.grid.drawGrid();
        (i2.annotations = new T2(i2), i2.annotations.drawImageAnnos(), i2.annotations.drawTextAnnos(), "back" === a3.config.grid.position) && (l3 && a3.globals.dom.elGraphical.add(l3.el), null != l3 && null !== (o3 = l3.elGridBorders) && void 0 !== o3 && o3.node && a3.globals.dom.elGraphical.add(l3.elGridBorders));
        if (Array.isArray(e3.elGraph)) for (var h3 = 0; h3 < e3.elGraph.length; h3++) a3.globals.dom.elGraphical.add(e3.elGraph[h3]);
        else a3.globals.dom.elGraphical.add(e3.elGraph);
        "front" === a3.config.grid.position && (l3 && a3.globals.dom.elGraphical.add(l3.el), null != l3 && null !== (n3 = l3.elGridBorders) && void 0 !== n3 && n3.node && a3.globals.dom.elGraphical.add(l3.elGridBorders));
        "front" === a3.config.xaxis.crosshairs.position && i2.crosshairs.drawXCrosshairs(), "front" === a3.config.yaxis[0].crosshairs.position && i2.crosshairs.drawYCrosshairs(), "treemap" !== a3.config.chart.type && i2.axes.drawAxis(a3.config.chart.type, l3);
        var c3 = new V2(t4.ctx, l3), d3 = new q2(t4.ctx, l3);
        if (null !== l3 && (c3.xAxisLabelCorrections(l3.xAxisTickWidth), d3.setYAxisTextAlignments(), a3.config.yaxis.map(function(t5, e4) {
          -1 === a3.globals.ignoreYAxisIndexes.indexOf(e4) && d3.yAxisTitleRotate(e4, t5.opposite);
        })), i2.annotations.drawAxesAnnotations(), !a3.globals.noData) {
          if (a3.config.tooltip.enabled && !a3.globals.noData && i2.w.globals.tooltip.drawTooltip(e3.xyRatios), a3.globals.axisCharts && (a3.globals.isXNumeric || a3.config.xaxis.convertedCatToNumeric || a3.globals.isRangeBar)) (a3.config.chart.zoom.enabled || a3.config.chart.selection && a3.config.chart.selection.enabled || a3.config.chart.pan && a3.config.chart.pan.enabled) && i2.zoomPanSelection.init({ xyRatios: e3.xyRatios });
          else {
            var g3 = a3.config.chart.toolbar.tools;
            ["zoom", "zoomin", "zoomout", "selection", "pan", "reset"].forEach(function(t5) {
              g3[t5] = false;
            });
          }
          a3.config.chart.toolbar.show && !a3.globals.allSeriesCollapsed && i2.toolbar.createToolbar();
        }
        a3.globals.memory.methodsToExec.length > 0 && a3.globals.memory.methodsToExec.forEach(function(t5) {
          t5.method(t5.params, false, t5.context);
        }), a3.globals.axisCharts || a3.globals.noData || i2.core.resizeNonAxisCharts(), s3(i2);
      });
    } }, { key: "destroy", value: function() {
      var t4, e3;
      window.removeEventListener("resize", this.windowResizeHandler), this.el.parentNode, t4 = this.parentResizeHandler, (e3 = jt2.get(t4)) && (e3.disconnect(), jt2.delete(t4));
      var i2 = this.w.config.chart.id;
      i2 && Apex._chartInstances.forEach(function(t5, e4) {
        t5.id === x2.escapeString(i2) && Apex._chartInstances.splice(e4, 1);
      }), new Vt2(this.ctx).clear({ isUpdating: false });
    } }, { key: "updateOptions", value: function(t4) {
      var e3 = this, i2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], a3 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], s3 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], r2 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4], o3 = this.w;
      return o3.globals.selection = void 0, t4.series && (this.series.resetSeries(false, true, false), t4.series.length && t4.series[0].data && (t4.series = t4.series.map(function(t5, i3) {
        return e3.updateHelpers._extendSeries(t5, i3);
      })), this.updateHelpers.revertDefaultAxisMinMax()), t4.xaxis && (t4 = this.updateHelpers.forceXAxisUpdate(t4)), t4.yaxis && (t4 = this.updateHelpers.forceYAxisUpdate(t4)), o3.globals.collapsedSeriesIndices.length > 0 && this.series.clearPreviousPaths(), t4.theme && (t4 = this.theme.updateThemeOptions(t4)), this.updateHelpers._updateOptions(t4, i2, a3, s3, r2);
    } }, { key: "updateSeries", value: function() {
      var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
      return this.series.resetSeries(false), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(t4, e3, i2);
    } }, { key: "appendSeries", value: function(t4) {
      var e3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], a3 = this.w.config.series.slice();
      return a3.push(t4), this.series.resetSeries(false), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(a3, e3, i2);
    } }, { key: "appendData", value: function(t4) {
      var e3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = this;
      i2.w.globals.dataChanged = true, i2.series.getPreviousPaths();
      for (var a3 = i2.w.config.series.slice(), s3 = 0; s3 < a3.length; s3++) if (null !== t4[s3] && void 0 !== t4[s3]) for (var r2 = 0; r2 < t4[s3].data.length; r2++) a3[s3].data.push(t4[s3].data[r2]);
      return i2.w.config.series = a3, e3 && (i2.w.globals.initialSeries = x2.clone(i2.w.config.series)), this.update();
    } }, { key: "update", value: function(t4) {
      var e3 = this;
      return new Promise(function(i2, a3) {
        new Vt2(e3.ctx).clear({ isUpdating: true });
        var s3 = e3.create(e3.w.config.series, t4);
        if (!s3) return i2(e3);
        e3.mount(s3).then(function() {
          "function" == typeof e3.w.config.chart.events.updated && e3.w.config.chart.events.updated(e3, e3.w), e3.events.fireEvent("updated", [e3, e3.w]), e3.w.globals.isDirty = true, i2(e3);
        }).catch(function(t5) {
          a3(t5);
        });
      });
    } }, { key: "getSyncedCharts", value: function() {
      var t4 = this.getGroupedCharts(), e3 = [this];
      return t4.length && (e3 = [], t4.forEach(function(t5) {
        e3.push(t5);
      })), e3;
    } }, { key: "getGroupedCharts", value: function() {
      var t4 = this;
      return Apex._chartInstances.filter(function(t5) {
        if (t5.group) return true;
      }).map(function(e3) {
        return t4.w.config.chart.group === e3.group ? e3.chart : t4;
      });
    } }, { key: "toggleSeries", value: function(t4) {
      return this.series.toggleSeries(t4);
    } }, { key: "highlightSeriesOnLegendHover", value: function(t4, e3) {
      return this.series.toggleSeriesOnHover(t4, e3);
    } }, { key: "showSeries", value: function(t4) {
      this.series.showSeries(t4);
    } }, { key: "hideSeries", value: function(t4) {
      this.series.hideSeries(t4);
    } }, { key: "isSeriesHidden", value: function(t4) {
      this.series.isSeriesHidden(t4);
    } }, { key: "resetSeries", value: function() {
      var t4 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], e3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      this.series.resetSeries(t4, e3);
    } }, { key: "addEventListener", value: function(t4, e3) {
      this.events.addEventListener(t4, e3);
    } }, { key: "removeEventListener", value: function(t4, e3) {
      this.events.removeEventListener(t4, e3);
    } }, { key: "addXaxisAnnotation", value: function(t4) {
      var e3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, a3 = this;
      i2 && (a3 = i2), a3.annotations.addXaxisAnnotationExternal(t4, e3, a3);
    } }, { key: "addYaxisAnnotation", value: function(t4) {
      var e3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, a3 = this;
      i2 && (a3 = i2), a3.annotations.addYaxisAnnotationExternal(t4, e3, a3);
    } }, { key: "addPointAnnotation", value: function(t4) {
      var e3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, a3 = this;
      i2 && (a3 = i2), a3.annotations.addPointAnnotationExternal(t4, e3, a3);
    } }, { key: "clearAnnotations", value: function() {
      var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0, e3 = this;
      t4 && (e3 = t4), e3.annotations.clearAnnotations(e3);
    } }, { key: "removeAnnotation", value: function(t4) {
      var e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0, i2 = this;
      e3 && (i2 = e3), i2.annotations.removeAnnotation(i2, t4);
    } }, { key: "getChartArea", value: function() {
      return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner");
    } }, { key: "getSeriesTotalXRange", value: function(t4, e3) {
      return this.coreUtils.getSeriesTotalsXRange(t4, e3);
    } }, { key: "getHighestValueInSeries", value: function() {
      var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
      return new U2(this.ctx).getMinYMaxY(t4).highestY;
    } }, { key: "getLowestValueInSeries", value: function() {
      var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
      return new U2(this.ctx).getMinYMaxY(t4).lowestY;
    } }, { key: "getSeriesTotal", value: function() {
      return this.w.globals.seriesTotals;
    } }, { key: "toggleDataPointSelection", value: function(t4, e3) {
      return this.updateHelpers.toggleDataPointSelection(t4, e3);
    } }, { key: "zoomX", value: function(t4, e3) {
      this.ctx.toolbar.zoomUpdateOptions(t4, e3);
    } }, { key: "setLocale", value: function(t4) {
      this.localization.setCurrentLocaleValues(t4);
    } }, { key: "dataURI", value: function(t4) {
      return new G2(this.ctx).dataURI(t4);
    } }, { key: "exportToCSV", value: function() {
      var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      return new G2(this.ctx).exportToCSV(t4);
    } }, { key: "paper", value: function() {
      return this.w.globals.dom.Paper;
    } }, { key: "_parentResizeCallback", value: function() {
      this.w.globals.animationEnded && this.w.config.chart.redrawOnParentResize && this._windowResize();
    } }, { key: "_windowResize", value: function() {
      var t4 = this;
      clearTimeout(this.w.globals.resizeTimer), this.w.globals.resizeTimer = window.setTimeout(function() {
        t4.w.globals.resized = true, t4.w.globals.dataChanged = false, t4.ctx.update();
      }, 150);
    } }, { key: "_windowResizeHandler", value: function() {
      var t4 = this.w.config.chart.redrawOnWindowResize;
      "function" == typeof t4 && (t4 = t4()), t4 && this._windowResize();
    } }], [{ key: "getChartByID", value: function(t4) {
      var e3 = x2.escapeString(t4);
      if (Apex._chartInstances) {
        var i2 = Apex._chartInstances.filter(function(t5) {
          return t5.id === e3;
        })[0];
        return i2 && i2.chart;
      }
    } }, { key: "initOnLoad", value: function() {
      for (var e3 = document.querySelectorAll("[data-apexcharts]"), i2 = 0; i2 < e3.length; i2++) {
        new t3(e3[i2], JSON.parse(e3[i2].getAttribute("data-options"))).render();
      }
    } }, { key: "exec", value: function(t4, e3) {
      var i2 = this.getChartByID(t4);
      if (i2) {
        i2.w.globals.isExecCalled = true;
        var a3 = null;
        if (-1 !== i2.publicMethods.indexOf(e3)) {
          for (var s3 = arguments.length, r2 = new Array(s3 > 2 ? s3 - 2 : 0), o3 = 2; o3 < s3; o3++) r2[o3 - 2] = arguments[o3];
          a3 = i2[e3].apply(i2, r2);
        }
        return a3;
      }
    } }, { key: "merge", value: function(t4, e3) {
      return x2.extend(t4, e3);
    } }]), t3;
  }();
  module.exports = _t2;
})(apexcharts_common, apexcharts_common.exports);
const getSensorData = async (sensor, type = "h", value2 = 6) => {
  try {
    const useUsers = storeUsers();
    const response = await axiosInstance.post(`/sensors/data`, {
      sensor,
      farm: useUsers.farm._id,
      type,
      value: value2
    });
    return response.data;
  } catch (error) {
    console.error(error);
    notifyErrorRequest$1(error.message || "Error al obtener datos del sensor");
  }
};
const getSensorsApi = async () => {
  try {
    const response = await axiosInstance.get(`/sensorsDB`);
    console.log(response);
    return response.data;
  } catch (error) {
    console.error(error);
    const message = error.response.data.message || "Error al obtener los sensores";
    notifyErrorRequest$1(message);
  }
};
const createSensorApi = async (dataSensor) => {
  try {
    const response = await axiosInstance.post(`/sensorsDB/create`, dataSensor);
    console.log(response);
    return response;
  } catch (error) {
    console.error(error);
    const message = error.response.data.message || "Error al crear el sensor";
    notifyErrorRequest$1(message);
  }
};
const updateSensorApi = async (dataSensor) => {
  try {
    const response = await axiosInstance.put(`/sensorsDB/update`, dataSensor);
    console.log(response);
    return response;
  } catch (error) {
    console.error(error);
    const message = error.response.data.message || "Error al actualizar el sensor";
    notifyErrorRequest$1(message);
  }
};
const _withScopeId$c = (n2) => (pushScopeId("data-v-9f4f30a5"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$g = {
  key: 0,
  id: "chart",
  class: "q-ma-xl"
};
const _hoisted_2$g = {
  key: 1,
  class: "justify-center flex"
};
const _hoisted_3$g = /* @__PURE__ */ _withScopeId$c(() => /* @__PURE__ */ createBaseVNode("h5", { class: "read-the-docs" }, "Sin datos para mostrar", -1));
const _hoisted_4$f = [
  _hoisted_3$g
];
const _sfc_main$g = {
  __name: "Home",
  setup(__props) {
    let dataTemperature = ref([]);
    let chartOptions = ref({});
    let series = ref([]);
    onBeforeMount(async () => {
      const dataSensors = await getSensorData();
      console.log(dataSensors);
      dataTemperature.value = dataSensors.data["senaiot/aula22/co2"].temperature;
      series.value = [{
        name: "Temperatura",
        data: dataTemperature.value.map((item) => item.value)
      }];
      chartOptions.value = {
        chart: {
          height: 350,
          type: "line",
          zoom: {
            enabled: false
          }
        },
        dataLabels: {
          enabled: false
        },
        stroke: {
          curve: "straight"
        },
        title: {
          text: "Termometro",
          align: "center"
        },
        grid: {
          row: {
            colors: ["#f3f3f3", "transparent"],
            // takes an array which will be repeated on columns
            opacity: 0.5
          }
        },
        xaxis: {
          categories: dataTemperature.value.map((item) => item.name)
        }
      };
    });
    return (_ctx, _cache) => {
      const _component_apexchart = resolveComponent("apexchart");
      return unref(dataTemperature).length > 0 ? (openBlock(), createElementBlock("div", _hoisted_1$g, [
        createVNode(_component_apexchart, {
          apexchart: "",
          type: "area",
          height: "350",
          options: unref(chartOptions),
          series: unref(series)
        }, null, 8, ["options", "series"])
      ])) : (openBlock(), createElementBlock("div", _hoisted_2$g, _hoisted_4$f));
    };
  }
};
const Home = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["__scopeId", "data-v-9f4f30a5"]]);
const QToolbarTitle = createComponent({
  name: "QToolbarTitle",
  props: {
    shrink: Boolean
  },
  setup(props2, { slots }) {
    const classes = computed(
      () => "q-toolbar__title ellipsis" + (props2.shrink === true ? " col-shrink" : "")
    );
    return () => h$1("div", { class: classes.value }, hSlot(slots.default));
  }
});
const QToolbar = createComponent({
  name: "QToolbar",
  props: {
    inset: Boolean
  },
  setup(props2, { slots }) {
    const classes = computed(
      () => "q-toolbar row no-wrap items-center" + (props2.inset === true ? " q-toolbar--inset" : "")
    );
    return () => h$1("div", { class: classes.value, role: "toolbar" }, hSlot(slots.default));
  }
});
const QHeader = createComponent({
  name: "QHeader",
  props: {
    modelValue: {
      type: Boolean,
      default: true
    },
    reveal: Boolean,
    revealOffset: {
      type: Number,
      default: 250
    },
    bordered: Boolean,
    elevated: Boolean,
    heightHint: {
      type: [String, Number],
      default: 50
    }
  },
  emits: ["reveal", "focusin"],
  setup(props2, { slots, emit: emit2 }) {
    const { proxy: { $q } } = getCurrentInstance();
    const $layout = inject(layoutKey, emptyRenderFn);
    if ($layout === emptyRenderFn) {
      console.error("QHeader needs to be child of QLayout");
      return emptyRenderFn;
    }
    const size2 = ref(parseInt(props2.heightHint, 10));
    const revealed = ref(true);
    const fixed = computed(
      () => props2.reveal === true || $layout.view.value.indexOf("H") !== -1 || $q.platform.is.ios && $layout.isContainer.value === true
    );
    const offset = computed(() => {
      if (props2.modelValue !== true) {
        return 0;
      }
      if (fixed.value === true) {
        return revealed.value === true ? size2.value : 0;
      }
      const offset2 = size2.value - $layout.scroll.value.position;
      return offset2 > 0 ? offset2 : 0;
    });
    const hidden = computed(
      () => props2.modelValue !== true || fixed.value === true && revealed.value !== true
    );
    const revealOnFocus = computed(
      () => props2.modelValue === true && hidden.value === true && props2.reveal === true
    );
    const classes = computed(
      () => "q-header q-layout__section--marginal " + (fixed.value === true ? "fixed" : "absolute") + "-top" + (props2.bordered === true ? " q-header--bordered" : "") + (hidden.value === true ? " q-header--hidden" : "") + (props2.modelValue !== true ? " q-layout--prevent-focus" : "")
    );
    const style = computed(() => {
      const view = $layout.rows.value.top, css2 = {};
      if (view[0] === "l" && $layout.left.space === true) {
        css2[$q.lang.rtl === true ? "right" : "left"] = `${$layout.left.size}px`;
      }
      if (view[2] === "r" && $layout.right.space === true) {
        css2[$q.lang.rtl === true ? "left" : "right"] = `${$layout.right.size}px`;
      }
      return css2;
    });
    function updateLayout(prop, val) {
      $layout.update("header", prop, val);
    }
    function updateLocal(prop, val) {
      if (prop.value !== val) {
        prop.value = val;
      }
    }
    function onResize({ height }) {
      updateLocal(size2, height);
      updateLayout("size", height);
    }
    function onFocusin(evt) {
      if (revealOnFocus.value === true) {
        updateLocal(revealed, true);
      }
      emit2("focusin", evt);
    }
    watch(() => props2.modelValue, (val) => {
      updateLayout("space", val);
      updateLocal(revealed, true);
      $layout.animate();
    });
    watch(offset, (val) => {
      updateLayout("offset", val);
    });
    watch(() => props2.reveal, (val) => {
      val === false && updateLocal(revealed, props2.modelValue);
    });
    watch(revealed, (val) => {
      $layout.animate();
      emit2("reveal", val);
    });
    watch($layout.scroll, (scroll) => {
      props2.reveal === true && updateLocal(
        revealed,
        scroll.direction === "up" || scroll.position <= props2.revealOffset || scroll.position - scroll.inflectionPoint < 100
      );
    });
    const instance = {};
    $layout.instances.header = instance;
    props2.modelValue === true && updateLayout("size", size2.value);
    updateLayout("space", props2.modelValue);
    updateLayout("offset", offset.value);
    onBeforeUnmount(() => {
      if ($layout.instances.header === instance) {
        $layout.instances.header = void 0;
        updateLayout("size", 0);
        updateLayout("offset", 0);
        updateLayout("space", false);
      }
    });
    return () => {
      const child = hUniqueSlot(slots.default, []);
      props2.elevated === true && child.push(
        h$1("div", {
          class: "q-layout__shadow absolute-full overflow-hidden no-pointer-events"
        })
      );
      child.push(
        h$1(QResizeObserver, {
          debounce: 0,
          onResize
        })
      );
      return h$1("header", {
        class: classes.value,
        style: style.value,
        onFocusin
      }, child);
    };
  }
});
const QItemSection = createComponent({
  name: "QItemSection",
  props: {
    avatar: Boolean,
    thumbnail: Boolean,
    side: Boolean,
    top: Boolean,
    noWrap: Boolean
  },
  setup(props2, { slots }) {
    const classes = computed(
      () => `q-item__section column q-item__section--${props2.avatar === true || props2.side === true || props2.thumbnail === true ? "side" : "main"}` + (props2.top === true ? " q-item__section--top justify-start" : " justify-center") + (props2.avatar === true ? " q-item__section--avatar" : "") + (props2.thumbnail === true ? " q-item__section--thumbnail" : "") + (props2.noWrap === true ? " q-item__section--nowrap" : "")
    );
    return () => h$1("div", { class: classes.value }, hSlot(slots.default));
  }
});
const QItem = createComponent({
  name: "QItem",
  props: {
    ...useDarkProps,
    ...useRouterLinkProps,
    tag: {
      type: String,
      default: "div"
    },
    active: {
      type: Boolean,
      default: null
    },
    clickable: Boolean,
    dense: Boolean,
    insetLevel: Number,
    tabindex: [String, Number],
    focused: Boolean,
    manualFocus: Boolean
  },
  emits: ["click", "keyup"],
  setup(props2, { slots, emit: emit2 }) {
    const { proxy: { $q } } = getCurrentInstance();
    const isDark = useDark(props2, $q);
    const { hasLink, linkAttrs, linkClass, linkTag, navigateOnClick } = useRouterLink();
    const rootRef = ref(null);
    const blurTargetRef = ref(null);
    const isActionable = computed(
      () => props2.clickable === true || hasLink.value === true || props2.tag === "label"
    );
    const isClickable = computed(
      () => props2.disable !== true && isActionable.value === true
    );
    const classes = computed(
      () => "q-item q-item-type row no-wrap" + (props2.dense === true ? " q-item--dense" : "") + (isDark.value === true ? " q-item--dark" : "") + (hasLink.value === true && props2.active === null ? linkClass.value : props2.active === true ? ` q-item--active${props2.activeClass !== void 0 ? ` ${props2.activeClass}` : ""}` : "") + (props2.disable === true ? " disabled" : "") + (isClickable.value === true ? " q-item--clickable q-link cursor-pointer " + (props2.manualFocus === true ? "q-manual-focusable" : "q-focusable q-hoverable") + (props2.focused === true ? " q-manual-focusable--focused" : "") : "")
    );
    const style = computed(() => {
      if (props2.insetLevel === void 0) {
        return null;
      }
      const dir = $q.lang.rtl === true ? "Right" : "Left";
      return {
        ["padding" + dir]: 16 + props2.insetLevel * 56 + "px"
      };
    });
    function onClick(e2) {
      if (isClickable.value === true) {
        if (blurTargetRef.value !== null) {
          if (e2.qKeyEvent !== true && document.activeElement === rootRef.value) {
            blurTargetRef.value.focus();
          } else if (document.activeElement === blurTargetRef.value) {
            rootRef.value.focus();
          }
        }
        navigateOnClick(e2);
      }
    }
    function onKeyup2(e2) {
      if (isClickable.value === true && isKeyCode(e2, [13, 32]) === true) {
        stopAndPrevent(e2);
        e2.qKeyEvent = true;
        const evt = new MouseEvent("click", e2);
        evt.qKeyEvent = true;
        rootRef.value.dispatchEvent(evt);
      }
      emit2("keyup", e2);
    }
    function getContent() {
      const child = hUniqueSlot(slots.default, []);
      isClickable.value === true && child.unshift(
        h$1("div", { class: "q-focus-helper", tabindex: -1, ref: blurTargetRef })
      );
      return child;
    }
    return () => {
      const data = {
        ref: rootRef,
        class: classes.value,
        style: style.value,
        role: "listitem",
        onClick,
        onKeyup: onKeyup2
      };
      if (isClickable.value === true) {
        data.tabindex = props2.tabindex || "0";
        Object.assign(data, linkAttrs.value);
      } else if (isActionable.value === true) {
        data["aria-disabled"] = "true";
      }
      return h$1(
        linkTag.value,
        data,
        getContent()
      );
    };
  }
});
const QList = createComponent({
  name: "QList",
  props: {
    ...useDarkProps,
    bordered: Boolean,
    dense: Boolean,
    separator: Boolean,
    padding: Boolean,
    tag: {
      type: String,
      default: "div"
    }
  },
  setup(props2, { slots }) {
    const vm2 = getCurrentInstance();
    const isDark = useDark(props2, vm2.proxy.$q);
    const classes = computed(
      () => "q-list" + (props2.bordered === true ? " q-list--bordered" : "") + (props2.dense === true ? " q-list--dense" : "") + (props2.separator === true ? " q-list--separator" : "") + (isDark.value === true ? " q-list--dark" : "") + (props2.padding === true ? " q-list--padding" : "")
    );
    return () => h$1(props2.tag, { class: classes.value }, hSlot(slots.default));
  }
});
const modifiersAll = {
  left: true,
  right: true,
  up: true,
  down: true,
  horizontal: true,
  vertical: true
};
const directionList = Object.keys(modifiersAll);
modifiersAll.all = true;
function getModifierDirections(mod2) {
  const dir = {};
  for (const direction2 of directionList) {
    if (mod2[direction2] === true) {
      dir[direction2] = true;
    }
  }
  if (Object.keys(dir).length === 0) {
    return modifiersAll;
  }
  if (dir.horizontal === true) {
    dir.left = dir.right = true;
  } else if (dir.left === true && dir.right === true) {
    dir.horizontal = true;
  }
  if (dir.vertical === true) {
    dir.up = dir.down = true;
  } else if (dir.up === true && dir.down === true) {
    dir.vertical = true;
  }
  if (dir.horizontal === true && dir.vertical === true) {
    dir.all = true;
  }
  return dir;
}
const avoidNodeNamesList = ["INPUT", "TEXTAREA"];
function shouldStart(evt, ctx) {
  return ctx.event === void 0 && evt.target !== void 0 && evt.target.draggable !== true && typeof ctx.handler === "function" && avoidNodeNamesList.includes(evt.target.nodeName.toUpperCase()) === false && (evt.qClonedBy === void 0 || evt.qClonedBy.indexOf(ctx.uid) === -1);
}
function clearSelection() {
  if (window.getSelection !== void 0) {
    const selection = window.getSelection();
    if (selection.empty !== void 0) {
      selection.empty();
    } else if (selection.removeAllRanges !== void 0) {
      selection.removeAllRanges();
      Platform.is.mobile !== true && selection.addRange(document.createRange());
    }
  } else if (document.selection !== void 0) {
    document.selection.empty();
  }
}
function getChanges(evt, ctx, isFinal) {
  const pos = position$1(evt);
  let dir, distX = pos.left - ctx.event.x, distY = pos.top - ctx.event.y, absX = Math.abs(distX), absY = Math.abs(distY);
  const direction2 = ctx.direction;
  if (direction2.horizontal === true && direction2.vertical !== true) {
    dir = distX < 0 ? "left" : "right";
  } else if (direction2.horizontal !== true && direction2.vertical === true) {
    dir = distY < 0 ? "up" : "down";
  } else if (direction2.up === true && distY < 0) {
    dir = "up";
    if (absX > absY) {
      if (direction2.left === true && distX < 0) {
        dir = "left";
      } else if (direction2.right === true && distX > 0) {
        dir = "right";
      }
    }
  } else if (direction2.down === true && distY > 0) {
    dir = "down";
    if (absX > absY) {
      if (direction2.left === true && distX < 0) {
        dir = "left";
      } else if (direction2.right === true && distX > 0) {
        dir = "right";
      }
    }
  } else if (direction2.left === true && distX < 0) {
    dir = "left";
    if (absX < absY) {
      if (direction2.up === true && distY < 0) {
        dir = "up";
      } else if (direction2.down === true && distY > 0) {
        dir = "down";
      }
    }
  } else if (direction2.right === true && distX > 0) {
    dir = "right";
    if (absX < absY) {
      if (direction2.up === true && distY < 0) {
        dir = "up";
      } else if (direction2.down === true && distY > 0) {
        dir = "down";
      }
    }
  }
  let synthetic = false;
  if (dir === void 0 && isFinal === false) {
    if (ctx.event.isFirst === true || ctx.event.lastDir === void 0) {
      return {};
    }
    dir = ctx.event.lastDir;
    synthetic = true;
    if (dir === "left" || dir === "right") {
      pos.left -= distX;
      absX = 0;
      distX = 0;
    } else {
      pos.top -= distY;
      absY = 0;
      distY = 0;
    }
  }
  return {
    synthetic,
    payload: {
      evt,
      touch: ctx.event.mouse !== true,
      mouse: ctx.event.mouse === true,
      position: pos,
      direction: dir,
      isFirst: ctx.event.isFirst,
      isFinal: isFinal === true,
      duration: Date.now() - ctx.event.time,
      distance: {
        x: absX,
        y: absY
      },
      offset: {
        x: distX,
        y: distY
      },
      delta: {
        x: pos.left - ctx.event.lastX,
        y: pos.top - ctx.event.lastY
      }
    }
  };
}
let uid = 0;
const TouchPan = createDirective(
  {
    name: "touch-pan",
    beforeMount(el, { value: value2, modifiers }) {
      if (modifiers.mouse !== true && client.has.touch !== true) {
        return;
      }
      function handleEvent(evt, mouseEvent) {
        if (modifiers.mouse === true && mouseEvent === true) {
          stopAndPrevent(evt);
        } else {
          modifiers.stop === true && stop(evt);
          modifiers.prevent === true && prevent(evt);
        }
      }
      const ctx = {
        uid: "qvtp_" + uid++,
        handler: value2,
        modifiers,
        direction: getModifierDirections(modifiers),
        noop: noop$3,
        mouseStart(evt) {
          if (shouldStart(evt, ctx) && leftClick(evt)) {
            addEvt(ctx, "temp", [
              [document, "mousemove", "move", "notPassiveCapture"],
              [document, "mouseup", "end", "passiveCapture"]
            ]);
            ctx.start(evt, true);
          }
        },
        touchStart(evt) {
          if (shouldStart(evt, ctx)) {
            const target2 = evt.target;
            addEvt(ctx, "temp", [
              [target2, "touchmove", "move", "notPassiveCapture"],
              [target2, "touchcancel", "end", "passiveCapture"],
              [target2, "touchend", "end", "passiveCapture"]
            ]);
            ctx.start(evt);
          }
        },
        start(evt, mouseEvent) {
          client.is.firefox === true && preventDraggable(el, true);
          ctx.lastEvt = evt;
          if (mouseEvent === true || modifiers.stop === true) {
            if (ctx.direction.all !== true && (mouseEvent !== true || ctx.modifiers.mouseAllDir !== true && ctx.modifiers.mousealldir !== true)) {
              const clone = evt.type.indexOf("mouse") !== -1 ? new MouseEvent(evt.type, evt) : new TouchEvent(evt.type, evt);
              evt.defaultPrevented === true && prevent(clone);
              evt.cancelBubble === true && stop(clone);
              Object.assign(clone, {
                qKeyEvent: evt.qKeyEvent,
                qClickOutside: evt.qClickOutside,
                qAnchorHandled: evt.qAnchorHandled,
                qClonedBy: evt.qClonedBy === void 0 ? [ctx.uid] : evt.qClonedBy.concat(ctx.uid)
              });
              ctx.initialEvent = {
                target: evt.target,
                event: clone
              };
            }
            stop(evt);
          }
          const { left, top } = position$1(evt);
          ctx.event = {
            x: left,
            y: top,
            time: Date.now(),
            mouse: mouseEvent === true,
            detected: false,
            isFirst: true,
            isFinal: false,
            lastX: left,
            lastY: top
          };
        },
        move(evt) {
          if (ctx.event === void 0) {
            return;
          }
          const pos = position$1(evt), distX = pos.left - ctx.event.x, distY = pos.top - ctx.event.y;
          if (distX === 0 && distY === 0) {
            return;
          }
          ctx.lastEvt = evt;
          const isMouseEvt = ctx.event.mouse === true;
          const start = () => {
            handleEvent(evt, isMouseEvt);
            let cursor;
            if (modifiers.preserveCursor !== true && modifiers.preservecursor !== true) {
              cursor = document.documentElement.style.cursor || "";
              document.documentElement.style.cursor = "grabbing";
            }
            isMouseEvt === true && document.body.classList.add("no-pointer-events--children");
            document.body.classList.add("non-selectable");
            clearSelection();
            ctx.styleCleanup = (withDelayedFn) => {
              ctx.styleCleanup = void 0;
              if (cursor !== void 0) {
                document.documentElement.style.cursor = cursor;
              }
              document.body.classList.remove("non-selectable");
              if (isMouseEvt === true) {
                const remove2 = () => {
                  document.body.classList.remove("no-pointer-events--children");
                };
                if (withDelayedFn !== void 0) {
                  setTimeout(() => {
                    remove2();
                    withDelayedFn();
                  }, 50);
                } else {
                  remove2();
                }
              } else if (withDelayedFn !== void 0) {
                withDelayedFn();
              }
            };
          };
          if (ctx.event.detected === true) {
            ctx.event.isFirst !== true && handleEvent(evt, ctx.event.mouse);
            const { payload, synthetic } = getChanges(evt, ctx, false);
            if (payload !== void 0) {
              if (ctx.handler(payload) === false) {
                ctx.end(evt);
              } else {
                if (ctx.styleCleanup === void 0 && ctx.event.isFirst === true) {
                  start();
                }
                ctx.event.lastX = payload.position.left;
                ctx.event.lastY = payload.position.top;
                ctx.event.lastDir = synthetic === true ? void 0 : payload.direction;
                ctx.event.isFirst = false;
              }
            }
            return;
          }
          if (ctx.direction.all === true || isMouseEvt === true && (ctx.modifiers.mouseAllDir === true || ctx.modifiers.mousealldir === true)) {
            start();
            ctx.event.detected = true;
            ctx.move(evt);
            return;
          }
          const absX = Math.abs(distX), absY = Math.abs(distY);
          if (absX !== absY) {
            if (ctx.direction.horizontal === true && absX > absY || ctx.direction.vertical === true && absX < absY || ctx.direction.up === true && absX < absY && distY < 0 || ctx.direction.down === true && absX < absY && distY > 0 || ctx.direction.left === true && absX > absY && distX < 0 || ctx.direction.right === true && absX > absY && distX > 0) {
              ctx.event.detected = true;
              ctx.move(evt);
            } else {
              ctx.end(evt, true);
            }
          }
        },
        end(evt, abort) {
          if (ctx.event === void 0) {
            return;
          }
          cleanEvt(ctx, "temp");
          client.is.firefox === true && preventDraggable(el, false);
          if (abort === true) {
            ctx.styleCleanup !== void 0 && ctx.styleCleanup();
            if (ctx.event.detected !== true && ctx.initialEvent !== void 0) {
              ctx.initialEvent.target.dispatchEvent(ctx.initialEvent.event);
            }
          } else if (ctx.event.detected === true) {
            ctx.event.isFirst === true && ctx.handler(getChanges(evt === void 0 ? ctx.lastEvt : evt, ctx).payload);
            const { payload } = getChanges(evt === void 0 ? ctx.lastEvt : evt, ctx, true);
            const fn = () => {
              ctx.handler(payload);
            };
            if (ctx.styleCleanup !== void 0) {
              ctx.styleCleanup(fn);
            } else {
              fn();
            }
          }
          ctx.event = void 0;
          ctx.initialEvent = void 0;
          ctx.lastEvt = void 0;
        }
      };
      el.__qtouchpan = ctx;
      if (modifiers.mouse === true) {
        const capture = modifiers.mouseCapture === true || modifiers.mousecapture === true ? "Capture" : "";
        addEvt(ctx, "main", [
          [el, "mousedown", "mouseStart", `passive${capture}`]
        ]);
      }
      client.has.touch === true && addEvt(ctx, "main", [
        [el, "touchstart", "touchStart", `passive${modifiers.capture === true ? "Capture" : ""}`],
        [el, "touchmove", "noop", "notPassiveCapture"]
        // cannot be passive (ex: iOS scroll)
      ]);
    },
    updated(el, bindings) {
      const ctx = el.__qtouchpan;
      if (ctx !== void 0) {
        if (bindings.oldValue !== bindings.value) {
          typeof value !== "function" && ctx.end();
          ctx.handler = bindings.value;
        }
        ctx.direction = getModifierDirections(bindings.modifiers);
      }
    },
    beforeUnmount(el) {
      const ctx = el.__qtouchpan;
      if (ctx !== void 0) {
        ctx.event !== void 0 && ctx.end();
        cleanEvt(ctx, "main");
        cleanEvt(ctx, "temp");
        client.is.firefox === true && preventDraggable(el, false);
        ctx.styleCleanup !== void 0 && ctx.styleCleanup();
        delete el.__qtouchpan;
      }
    }
  }
);
function between(v2, min, max2) {
  return max2 <= min ? min : Math.min(max2, Math.max(min, v2));
}
function normalizeToInterval(v2, min, max2) {
  if (max2 <= min) {
    return min;
  }
  const size2 = max2 - min + 1;
  let index = min + (v2 - min) % size2;
  if (index < min) {
    index = size2 + index;
  }
  return index === 0 ? 0 : index;
}
function pad(v2, length = 2, char = "0") {
  if (v2 === void 0 || v2 === null) {
    return v2;
  }
  const val = "" + v2;
  return val.length >= length ? val : new Array(length - val.length + 1).join(char) + val;
}
const axisList = ["vertical", "horizontal"];
const dirProps = {
  vertical: { offset: "offsetY", scroll: "scrollTop", dir: "down", dist: "y" },
  horizontal: { offset: "offsetX", scroll: "scrollLeft", dir: "right", dist: "x" }
};
const panOpts = {
  prevent: true,
  mouse: true,
  mouseAllDir: true
};
const getMinThumbSize = (size2) => size2 >= 250 ? 50 : Math.ceil(size2 / 5);
const QScrollArea = createComponent({
  name: "QScrollArea",
  props: {
    ...useDarkProps,
    thumbStyle: Object,
    verticalThumbStyle: Object,
    horizontalThumbStyle: Object,
    barStyle: [Array, String, Object],
    verticalBarStyle: [Array, String, Object],
    horizontalBarStyle: [Array, String, Object],
    contentStyle: [Array, String, Object],
    contentActiveStyle: [Array, String, Object],
    delay: {
      type: [String, Number],
      default: 1e3
    },
    visible: {
      type: Boolean,
      default: null
    },
    tabindex: [String, Number],
    onScroll: Function
  },
  setup(props2, { slots, emit: emit2 }) {
    const tempShowing = ref(false);
    const panning = ref(false);
    const hover = ref(false);
    const container = {
      vertical: ref(0),
      horizontal: ref(0)
    };
    const scroll = {
      vertical: {
        ref: ref(null),
        position: ref(0),
        size: ref(0)
      },
      horizontal: {
        ref: ref(null),
        position: ref(0),
        size: ref(0)
      }
    };
    const { proxy } = getCurrentInstance();
    const isDark = useDark(props2, proxy.$q);
    let timer = null, panRefPos;
    const targetRef = ref(null);
    const classes = computed(
      () => "q-scrollarea" + (isDark.value === true ? " q-scrollarea--dark" : "")
    );
    scroll.vertical.percentage = computed(() => {
      const diff = scroll.vertical.size.value - container.vertical.value;
      if (diff <= 0) {
        return 0;
      }
      const p2 = between(scroll.vertical.position.value / diff, 0, 1);
      return Math.round(p2 * 1e4) / 1e4;
    });
    scroll.vertical.thumbHidden = computed(
      () => (props2.visible === null ? hover.value : props2.visible) !== true && tempShowing.value === false && panning.value === false || scroll.vertical.size.value <= container.vertical.value + 1
    );
    scroll.vertical.thumbStart = computed(
      () => scroll.vertical.percentage.value * (container.vertical.value - scroll.vertical.thumbSize.value)
    );
    scroll.vertical.thumbSize = computed(
      () => Math.round(
        between(
          container.vertical.value * container.vertical.value / scroll.vertical.size.value,
          getMinThumbSize(container.vertical.value),
          container.vertical.value
        )
      )
    );
    scroll.vertical.style = computed(() => {
      return {
        ...props2.thumbStyle,
        ...props2.verticalThumbStyle,
        top: `${scroll.vertical.thumbStart.value}px`,
        height: `${scroll.vertical.thumbSize.value}px`
      };
    });
    scroll.vertical.thumbClass = computed(
      () => "q-scrollarea__thumb q-scrollarea__thumb--v absolute-right" + (scroll.vertical.thumbHidden.value === true ? " q-scrollarea__thumb--invisible" : "")
    );
    scroll.vertical.barClass = computed(
      () => "q-scrollarea__bar q-scrollarea__bar--v absolute-right" + (scroll.vertical.thumbHidden.value === true ? " q-scrollarea__bar--invisible" : "")
    );
    scroll.horizontal.percentage = computed(() => {
      const diff = scroll.horizontal.size.value - container.horizontal.value;
      if (diff <= 0) {
        return 0;
      }
      const p2 = between(Math.abs(scroll.horizontal.position.value) / diff, 0, 1);
      return Math.round(p2 * 1e4) / 1e4;
    });
    scroll.horizontal.thumbHidden = computed(
      () => (props2.visible === null ? hover.value : props2.visible) !== true && tempShowing.value === false && panning.value === false || scroll.horizontal.size.value <= container.horizontal.value + 1
    );
    scroll.horizontal.thumbStart = computed(
      () => scroll.horizontal.percentage.value * (container.horizontal.value - scroll.horizontal.thumbSize.value)
    );
    scroll.horizontal.thumbSize = computed(
      () => Math.round(
        between(
          container.horizontal.value * container.horizontal.value / scroll.horizontal.size.value,
          getMinThumbSize(container.horizontal.value),
          container.horizontal.value
        )
      )
    );
    scroll.horizontal.style = computed(() => {
      return {
        ...props2.thumbStyle,
        ...props2.horizontalThumbStyle,
        [proxy.$q.lang.rtl === true ? "right" : "left"]: `${scroll.horizontal.thumbStart.value}px`,
        width: `${scroll.horizontal.thumbSize.value}px`
      };
    });
    scroll.horizontal.thumbClass = computed(
      () => "q-scrollarea__thumb q-scrollarea__thumb--h absolute-bottom" + (scroll.horizontal.thumbHidden.value === true ? " q-scrollarea__thumb--invisible" : "")
    );
    scroll.horizontal.barClass = computed(
      () => "q-scrollarea__bar q-scrollarea__bar--h absolute-bottom" + (scroll.horizontal.thumbHidden.value === true ? " q-scrollarea__bar--invisible" : "")
    );
    const mainStyle = computed(() => scroll.vertical.thumbHidden.value === true && scroll.horizontal.thumbHidden.value === true ? props2.contentStyle : props2.contentActiveStyle);
    const thumbVertDir = [[
      TouchPan,
      (e2) => {
        onPanThumb(e2, "vertical");
      },
      void 0,
      { vertical: true, ...panOpts }
    ]];
    const thumbHorizDir = [[
      TouchPan,
      (e2) => {
        onPanThumb(e2, "horizontal");
      },
      void 0,
      { horizontal: true, ...panOpts }
    ]];
    function getScroll() {
      const info = {};
      axisList.forEach((axis) => {
        const data = scroll[axis];
        info[axis + "Position"] = data.position.value;
        info[axis + "Percentage"] = data.percentage.value;
        info[axis + "Size"] = data.size.value;
        info[axis + "ContainerSize"] = container[axis].value;
      });
      return info;
    }
    const emitScroll = debounce(() => {
      const info = getScroll();
      info.ref = proxy;
      emit2("scroll", info);
    }, 0);
    function localSetScrollPosition(axis, offset, duration2) {
      if (axisList.includes(axis) === false) {
        console.error("[QScrollArea]: wrong first param of setScrollPosition (vertical/horizontal)");
        return;
      }
      const fn = axis === "vertical" ? setVerticalScrollPosition : setHorizontalScrollPosition;
      fn(targetRef.value, offset, duration2);
    }
    function updateContainer({ height, width: width2 }) {
      let change = false;
      if (container.vertical.value !== height) {
        container.vertical.value = height;
        change = true;
      }
      if (container.horizontal.value !== width2) {
        container.horizontal.value = width2;
        change = true;
      }
      change === true && startTimer();
    }
    function updateScroll({ position: position2 }) {
      let change = false;
      if (scroll.vertical.position.value !== position2.top) {
        scroll.vertical.position.value = position2.top;
        change = true;
      }
      if (scroll.horizontal.position.value !== position2.left) {
        scroll.horizontal.position.value = position2.left;
        change = true;
      }
      change === true && startTimer();
    }
    function updateScrollSize({ height, width: width2 }) {
      if (scroll.horizontal.size.value !== width2) {
        scroll.horizontal.size.value = width2;
        startTimer();
      }
      if (scroll.vertical.size.value !== height) {
        scroll.vertical.size.value = height;
        startTimer();
      }
    }
    function onPanThumb(e2, axis) {
      const data = scroll[axis];
      if (e2.isFirst === true) {
        if (data.thumbHidden.value === true) {
          return;
        }
        panRefPos = data.position.value;
        panning.value = true;
      } else if (panning.value !== true) {
        return;
      }
      if (e2.isFinal === true) {
        panning.value = false;
      }
      const dProp = dirProps[axis];
      const containerSize = container[axis].value;
      const multiplier = (data.size.value - containerSize) / (containerSize - data.thumbSize.value);
      const distance2 = e2.distance[dProp.dist];
      const pos = panRefPos + (e2.direction === dProp.dir ? 1 : -1) * distance2 * multiplier;
      setScroll2(pos, axis);
    }
    function onMousedown(evt, axis) {
      const data = scroll[axis];
      if (data.thumbHidden.value !== true) {
        const offset = evt[dirProps[axis].offset];
        if (offset < data.thumbStart.value || offset > data.thumbStart.value + data.thumbSize.value) {
          const pos = offset - data.thumbSize.value / 2;
          setScroll2(pos / container[axis].value * data.size.value, axis);
        }
        if (data.ref.value !== null) {
          data.ref.value.dispatchEvent(new MouseEvent(evt.type, evt));
        }
      }
    }
    function onVerticalMousedown(evt) {
      onMousedown(evt, "vertical");
    }
    function onHorizontalMousedown(evt) {
      onMousedown(evt, "horizontal");
    }
    function startTimer() {
      tempShowing.value = true;
      timer !== null && clearTimeout(timer);
      timer = setTimeout(() => {
        timer = null;
        tempShowing.value = false;
      }, props2.delay);
      props2.onScroll !== void 0 && emitScroll();
    }
    function setScroll2(offset, axis) {
      targetRef.value[dirProps[axis].scroll] = offset;
    }
    let mouseEventTimer = null;
    function onMouseenter() {
      if (mouseEventTimer !== null) {
        clearTimeout(mouseEventTimer);
      }
      mouseEventTimer = setTimeout(() => {
        mouseEventTimer = null;
        hover.value = true;
      }, proxy.$q.platform.is.ios ? 50 : 0);
    }
    function onMouseleave() {
      if (mouseEventTimer !== null) {
        clearTimeout(mouseEventTimer);
        mouseEventTimer = null;
      }
      hover.value = false;
    }
    let scrollPosition = null;
    watch(() => proxy.$q.lang.rtl, (rtl) => {
      if (targetRef.value !== null) {
        setHorizontalScrollPosition(
          targetRef.value,
          Math.abs(scroll.horizontal.position.value) * (rtl === true ? -1 : 1)
        );
      }
    });
    onDeactivated(() => {
      scrollPosition = {
        top: scroll.vertical.position.value,
        left: scroll.horizontal.position.value
      };
    });
    onActivated(() => {
      if (scrollPosition === null) return;
      const scrollTarget = targetRef.value;
      if (scrollTarget !== null) {
        setHorizontalScrollPosition(scrollTarget, scrollPosition.left);
        setVerticalScrollPosition(scrollTarget, scrollPosition.top);
      }
    });
    onBeforeUnmount(emitScroll.cancel);
    Object.assign(proxy, {
      getScrollTarget: () => targetRef.value,
      getScroll,
      getScrollPosition: () => ({
        top: scroll.vertical.position.value,
        left: scroll.horizontal.position.value
      }),
      getScrollPercentage: () => ({
        top: scroll.vertical.percentage.value,
        left: scroll.horizontal.percentage.value
      }),
      setScrollPosition: localSetScrollPosition,
      setScrollPercentage(axis, percentage, duration2) {
        localSetScrollPosition(
          axis,
          percentage * (scroll[axis].size.value - container[axis].value) * (axis === "horizontal" && proxy.$q.lang.rtl === true ? -1 : 1),
          duration2
        );
      }
    });
    return () => {
      return h$1("div", {
        class: classes.value,
        onMouseenter,
        onMouseleave
      }, [
        h$1("div", {
          ref: targetRef,
          class: "q-scrollarea__container scroll relative-position fit hide-scrollbar",
          tabindex: props2.tabindex !== void 0 ? props2.tabindex : void 0
        }, [
          h$1("div", {
            class: "q-scrollarea__content absolute",
            style: mainStyle.value
          }, hMergeSlot(slots.default, [
            h$1(QResizeObserver, {
              debounce: 0,
              onResize: updateScrollSize
            })
          ])),
          h$1(QScrollObserver, {
            axis: "both",
            onScroll: updateScroll
          })
        ]),
        h$1(QResizeObserver, {
          debounce: 0,
          onResize: updateContainer
        }),
        h$1("div", {
          class: scroll.vertical.barClass.value,
          style: [props2.barStyle, props2.verticalBarStyle],
          "aria-hidden": "true",
          onMousedown: onVerticalMousedown
        }),
        h$1("div", {
          class: scroll.horizontal.barClass.value,
          style: [props2.barStyle, props2.horizontalBarStyle],
          "aria-hidden": "true",
          onMousedown: onHorizontalMousedown
        }),
        withDirectives(
          h$1("div", {
            ref: scroll.vertical.ref,
            class: scroll.vertical.thumbClass.value,
            style: scroll.vertical.style.value,
            "aria-hidden": "true"
          }),
          thumbVertDir
        ),
        withDirectives(
          h$1("div", {
            ref: scroll.horizontal.ref,
            class: scroll.horizontal.thumbClass.value,
            style: scroll.horizontal.style.value,
            "aria-hidden": "true"
          }),
          thumbHorizDir
        )
      ]);
    };
  }
});
const QField = createComponent({
  name: "QField",
  inheritAttrs: false,
  props: {
    ...useFieldProps,
    tag: {
      type: String,
      default: "label"
    }
  },
  emits: useFieldEmits,
  setup() {
    return useField(
      useFieldState({ tagProp: true })
    );
  }
});
const defaultSizes$1 = {
  xs: 8,
  sm: 10,
  md: 14,
  lg: 20,
  xl: 24
};
const QChip = createComponent({
  name: "QChip",
  props: {
    ...useDarkProps,
    ...useSizeProps,
    dense: Boolean,
    icon: String,
    iconRight: String,
    iconRemove: String,
    iconSelected: String,
    label: [String, Number],
    color: String,
    textColor: String,
    modelValue: {
      type: Boolean,
      default: true
    },
    selected: {
      type: Boolean,
      default: null
    },
    square: Boolean,
    outline: Boolean,
    clickable: Boolean,
    removable: Boolean,
    removeAriaLabel: String,
    tabindex: [String, Number],
    disable: Boolean,
    ripple: {
      type: [Boolean, Object],
      default: true
    }
  },
  emits: ["update:modelValue", "update:selected", "remove", "click"],
  setup(props2, { slots, emit: emit2 }) {
    const { proxy: { $q } } = getCurrentInstance();
    const isDark = useDark(props2, $q);
    const sizeStyle = useSize(props2, defaultSizes$1);
    const hasLeftIcon = computed(() => props2.selected === true || props2.icon !== void 0);
    const leftIcon = computed(() => props2.selected === true ? props2.iconSelected || $q.iconSet.chip.selected : props2.icon);
    const removeIcon = computed(() => props2.iconRemove || $q.iconSet.chip.remove);
    const isClickable = computed(
      () => props2.disable === false && (props2.clickable === true || props2.selected !== null)
    );
    const classes = computed(() => {
      const text = props2.outline === true ? props2.color || props2.textColor : props2.textColor;
      return "q-chip row inline no-wrap items-center" + (props2.outline === false && props2.color !== void 0 ? ` bg-${props2.color}` : "") + (text ? ` text-${text} q-chip--colored` : "") + (props2.disable === true ? " disabled" : "") + (props2.dense === true ? " q-chip--dense" : "") + (props2.outline === true ? " q-chip--outline" : "") + (props2.selected === true ? " q-chip--selected" : "") + (isClickable.value === true ? " q-chip--clickable cursor-pointer non-selectable q-hoverable" : "") + (props2.square === true ? " q-chip--square" : "") + (isDark.value === true ? " q-chip--dark q-dark" : "");
    });
    const attributes = computed(() => {
      const chip = props2.disable === true ? { tabindex: -1, "aria-disabled": "true" } : { tabindex: props2.tabindex || 0 };
      const remove2 = {
        ...chip,
        role: "button",
        "aria-hidden": "false",
        "aria-label": props2.removeAriaLabel || $q.lang.label.remove
      };
      return { chip, remove: remove2 };
    });
    function onKeyup2(e2) {
      e2.keyCode === 13 && onClick(e2);
    }
    function onClick(e2) {
      if (!props2.disable) {
        emit2("update:selected", !props2.selected);
        emit2("click", e2);
      }
    }
    function onRemove(e2) {
      if (e2.keyCode === void 0 || e2.keyCode === 13) {
        stopAndPrevent(e2);
        if (props2.disable === false) {
          emit2("update:modelValue", false);
          emit2("remove");
        }
      }
    }
    function getContent() {
      const child = [];
      isClickable.value === true && child.push(
        h$1("div", { class: "q-focus-helper" })
      );
      hasLeftIcon.value === true && child.push(
        h$1(QIcon, {
          class: "q-chip__icon q-chip__icon--left",
          name: leftIcon.value
        })
      );
      const label = props2.label !== void 0 ? [h$1("div", { class: "ellipsis" }, [props2.label])] : void 0;
      child.push(
        h$1("div", {
          class: "q-chip__content col row no-wrap items-center q-anchor--skip"
        }, hMergeSlotSafely(slots.default, label))
      );
      props2.iconRight && child.push(
        h$1(QIcon, {
          class: "q-chip__icon q-chip__icon--right",
          name: props2.iconRight
        })
      );
      props2.removable === true && child.push(
        h$1(QIcon, {
          class: "q-chip__icon q-chip__icon--remove cursor-pointer",
          name: removeIcon.value,
          ...attributes.value.remove,
          onClick: onRemove,
          onKeyup: onRemove
        })
      );
      return child;
    }
    return () => {
      if (props2.modelValue === false) return;
      const data = {
        class: classes.value,
        style: sizeStyle.value
      };
      isClickable.value === true && Object.assign(
        data,
        attributes.value.chip,
        { onClick, onKeyup: onKeyup2 }
      );
      return hDir(
        "div",
        data,
        getContent(),
        "ripple",
        props2.ripple !== false && props2.disable !== true,
        () => [[Ripple, props2.ripple]]
      );
    };
  }
});
const QItemLabel = createComponent({
  name: "QItemLabel",
  props: {
    overline: Boolean,
    caption: Boolean,
    header: Boolean,
    lines: [Number, String]
  },
  setup(props2, { slots }) {
    const parsedLines = computed(() => parseInt(props2.lines, 10));
    const classes = computed(
      () => "q-item__label" + (props2.overline === true ? " q-item__label--overline text-overline" : "") + (props2.caption === true ? " q-item__label--caption text-caption" : "") + (props2.header === true ? " q-item__label--header" : "") + (parsedLines.value === 1 ? " ellipsis" : "")
    );
    const style = computed(() => {
      return props2.lines !== void 0 && parsedLines.value > 1 ? {
        overflow: "hidden",
        display: "-webkit-box",
        "-webkit-box-orient": "vertical",
        "-webkit-line-clamp": parsedLines.value
      } : null;
    });
    return () => h$1("div", {
      style: style.value,
      class: classes.value
    }, hSlot(slots.default));
  }
});
const useAnchorStaticProps = {
  /* SSR does not know about Element */
  target: {
    type: [Boolean, String, Element],
    default: true
  },
  noParentEvent: Boolean
};
const useAnchorProps = {
  ...useAnchorStaticProps,
  contextMenu: Boolean
};
function useAnchor({
  showing,
  avoidEmit,
  // required for QPopupProxy (true)
  configureAnchorEl
  // optional
}) {
  const { props: props2, proxy, emit: emit2 } = getCurrentInstance();
  const anchorEl = ref(null);
  let touchTimer = null;
  function canShow(evt) {
    return anchorEl.value === null ? false : evt === void 0 || evt.touches === void 0 || evt.touches.length <= 1;
  }
  const anchorEvents = {};
  if (configureAnchorEl === void 0) {
    Object.assign(anchorEvents, {
      hide(evt) {
        proxy.hide(evt);
      },
      toggle(evt) {
        proxy.toggle(evt);
        evt.qAnchorHandled = true;
      },
      toggleKey(evt) {
        isKeyCode(evt, 13) === true && anchorEvents.toggle(evt);
      },
      contextClick(evt) {
        proxy.hide(evt);
        prevent(evt);
        nextTick$1(() => {
          proxy.show(evt);
          evt.qAnchorHandled = true;
        });
      },
      prevent,
      mobileTouch(evt) {
        anchorEvents.mobileCleanup(evt);
        if (canShow(evt) !== true) {
          return;
        }
        proxy.hide(evt);
        anchorEl.value.classList.add("non-selectable");
        const target2 = evt.target;
        addEvt(anchorEvents, "anchor", [
          [target2, "touchmove", "mobileCleanup", "passive"],
          [target2, "touchend", "mobileCleanup", "passive"],
          [target2, "touchcancel", "mobileCleanup", "passive"],
          [anchorEl.value, "contextmenu", "prevent", "notPassive"]
        ]);
        touchTimer = setTimeout(() => {
          touchTimer = null;
          proxy.show(evt);
          evt.qAnchorHandled = true;
        }, 300);
      },
      mobileCleanup(evt) {
        anchorEl.value.classList.remove("non-selectable");
        if (touchTimer !== null) {
          clearTimeout(touchTimer);
          touchTimer = null;
        }
        if (showing.value === true && evt !== void 0) {
          clearSelection();
        }
      }
    });
    configureAnchorEl = function(context = props2.contextMenu) {
      if (props2.noParentEvent === true || anchorEl.value === null) return;
      let evts;
      if (context === true) {
        if (proxy.$q.platform.is.mobile === true) {
          evts = [
            [anchorEl.value, "touchstart", "mobileTouch", "passive"]
          ];
        } else {
          evts = [
            [anchorEl.value, "mousedown", "hide", "passive"],
            [anchorEl.value, "contextmenu", "contextClick", "notPassive"]
          ];
        }
      } else {
        evts = [
          [anchorEl.value, "click", "toggle", "passive"],
          [anchorEl.value, "keyup", "toggleKey", "passive"]
        ];
      }
      addEvt(anchorEvents, "anchor", evts);
    };
  }
  function unconfigureAnchorEl() {
    cleanEvt(anchorEvents, "anchor");
  }
  function setAnchorEl(el) {
    anchorEl.value = el;
    while (anchorEl.value.classList.contains("q-anchor--skip")) {
      anchorEl.value = anchorEl.value.parentNode;
    }
    configureAnchorEl();
  }
  function pickAnchorEl() {
    if (props2.target === false || props2.target === "" || proxy.$el.parentNode === null) {
      anchorEl.value = null;
    } else if (props2.target === true) {
      setAnchorEl(proxy.$el.parentNode);
    } else {
      let el = props2.target;
      if (typeof props2.target === "string") {
        try {
          el = document.querySelector(props2.target);
        } catch (err) {
          el = void 0;
        }
      }
      if (el !== void 0 && el !== null) {
        anchorEl.value = el.$el || el;
        configureAnchorEl();
      } else {
        anchorEl.value = null;
        console.error(`Anchor: target "${props2.target}" not found`);
      }
    }
  }
  watch(() => props2.contextMenu, (val) => {
    if (anchorEl.value !== null) {
      unconfigureAnchorEl();
      configureAnchorEl(val);
    }
  });
  watch(() => props2.target, () => {
    if (anchorEl.value !== null) {
      unconfigureAnchorEl();
    }
    pickAnchorEl();
  });
  watch(() => props2.noParentEvent, (val) => {
    if (anchorEl.value !== null) {
      if (val === true) {
        unconfigureAnchorEl();
      } else {
        configureAnchorEl();
      }
    }
  });
  onMounted(() => {
    pickAnchorEl();
    if (avoidEmit !== true && props2.modelValue === true && anchorEl.value === null) {
      emit2("update:modelValue", false);
    }
  });
  onBeforeUnmount(() => {
    touchTimer !== null && clearTimeout(touchTimer);
    unconfigureAnchorEl();
  });
  return {
    anchorEl,
    canShow,
    anchorEvents
  };
}
function useScrollTarget(props2, configureScrollTarget) {
  const localScrollTarget = ref(null);
  let scrollFn;
  function changeScrollEvent(scrollTarget, fn) {
    const fnProp = `${fn !== void 0 ? "add" : "remove"}EventListener`;
    const fnHandler = fn !== void 0 ? fn : scrollFn;
    if (scrollTarget !== window) {
      scrollTarget[fnProp]("scroll", fnHandler, listenOpts.passive);
    }
    window[fnProp]("scroll", fnHandler, listenOpts.passive);
    scrollFn = fn;
  }
  function unconfigureScrollTarget() {
    if (localScrollTarget.value !== null) {
      changeScrollEvent(localScrollTarget.value);
      localScrollTarget.value = null;
    }
  }
  const noParentEventWatcher = watch(() => props2.noParentEvent, () => {
    if (localScrollTarget.value !== null) {
      unconfigureScrollTarget();
      configureScrollTarget();
    }
  });
  onBeforeUnmount(noParentEventWatcher);
  return {
    localScrollTarget,
    unconfigureScrollTarget,
    changeScrollEvent
  };
}
const { notPassiveCapture } = listenOpts, registeredList = [];
function globalHandler(evt) {
  const target2 = evt.target;
  if (target2 === void 0 || target2.nodeType === 8 || target2.classList.contains("no-pointer-events") === true) {
    return;
  }
  let portalIndex2 = portalProxyList.length - 1;
  while (portalIndex2 >= 0) {
    const proxy = portalProxyList[portalIndex2].$;
    if (proxy.type.name === "QTooltip") {
      portalIndex2--;
      continue;
    }
    if (proxy.type.name !== "QDialog") {
      break;
    }
    if (proxy.props.seamless !== true) {
      return;
    }
    portalIndex2--;
  }
  for (let i = registeredList.length - 1; i >= 0; i--) {
    const state = registeredList[i];
    if ((state.anchorEl.value === null || state.anchorEl.value.contains(target2) === false) && (target2 === document.body || state.innerRef.value !== null && state.innerRef.value.contains(target2) === false)) {
      evt.qClickOutside = true;
      state.onClickOutside(evt);
    } else {
      return;
    }
  }
}
function addClickOutside(clickOutsideProps) {
  registeredList.push(clickOutsideProps);
  if (registeredList.length === 1) {
    document.addEventListener("mousedown", globalHandler, notPassiveCapture);
    document.addEventListener("touchstart", globalHandler, notPassiveCapture);
  }
}
function removeClickOutside(clickOutsideProps) {
  const index = registeredList.findIndex((h2) => h2 === clickOutsideProps);
  if (index !== -1) {
    registeredList.splice(index, 1);
    if (registeredList.length === 0) {
      document.removeEventListener("mousedown", globalHandler, notPassiveCapture);
      document.removeEventListener("touchstart", globalHandler, notPassiveCapture);
    }
  }
}
let vpLeft, vpTop;
function validatePosition(pos) {
  const parts2 = pos.split(" ");
  if (parts2.length !== 2) {
    return false;
  }
  if (["top", "center", "bottom"].includes(parts2[0]) !== true) {
    console.error("Anchor/Self position must start with one of top/center/bottom");
    return false;
  }
  if (["left", "middle", "right", "start", "end"].includes(parts2[1]) !== true) {
    console.error("Anchor/Self position must end with one of left/middle/right/start/end");
    return false;
  }
  return true;
}
function validateOffset(val) {
  if (!val) {
    return true;
  }
  if (val.length !== 2) {
    return false;
  }
  if (typeof val[0] !== "number" || typeof val[1] !== "number") {
    return false;
  }
  return true;
}
const horizontalPos = {
  "start#ltr": "left",
  "start#rtl": "right",
  "end#ltr": "right",
  "end#rtl": "left"
};
["left", "middle", "right"].forEach((pos) => {
  horizontalPos[`${pos}#ltr`] = pos;
  horizontalPos[`${pos}#rtl`] = pos;
});
function parsePosition(pos, rtl) {
  const parts2 = pos.split(" ");
  return {
    vertical: parts2[0],
    horizontal: horizontalPos[`${parts2[1]}#${rtl === true ? "rtl" : "ltr"}`]
  };
}
function getAnchorProps(el, offset) {
  let { top, left, right, bottom, width: width2, height } = el.getBoundingClientRect();
  if (offset !== void 0) {
    top -= offset[1];
    left -= offset[0];
    bottom += offset[1];
    right += offset[0];
    width2 += offset[0];
    height += offset[1];
  }
  return {
    top,
    bottom,
    height,
    left,
    right,
    width: width2,
    middle: left + (right - left) / 2,
    center: top + (bottom - top) / 2
  };
}
function getAbsoluteAnchorProps(el, absoluteOffset, offset) {
  let { top, left } = el.getBoundingClientRect();
  top += absoluteOffset.top;
  left += absoluteOffset.left;
  if (offset !== void 0) {
    top += offset[1];
    left += offset[0];
  }
  return {
    top,
    bottom: top + 1,
    height: 1,
    left,
    right: left + 1,
    width: 1,
    middle: left,
    center: top
  };
}
function getTargetProps(width2, height) {
  return {
    top: 0,
    center: height / 2,
    bottom: height,
    left: 0,
    middle: width2 / 2,
    right: width2
  };
}
function getTopLeftProps(anchorProps, targetProps, anchorOrigin, selfOrigin) {
  return {
    top: anchorProps[anchorOrigin.vertical] - targetProps[selfOrigin.vertical],
    left: anchorProps[anchorOrigin.horizontal] - targetProps[selfOrigin.horizontal]
  };
}
function setPosition(cfg, retryNumber = 0) {
  if (cfg.targetEl === null || cfg.anchorEl === null || retryNumber > 5) {
    return;
  }
  if (cfg.targetEl.offsetHeight === 0 || cfg.targetEl.offsetWidth === 0) {
    setTimeout(() => {
      setPosition(cfg, retryNumber + 1);
    }, 10);
    return;
  }
  const {
    targetEl,
    offset,
    anchorEl,
    anchorOrigin,
    selfOrigin,
    absoluteOffset,
    fit,
    cover,
    maxHeight,
    maxWidth
  } = cfg;
  if (client.is.ios === true && window.visualViewport !== void 0) {
    const el = document.body.style;
    const { offsetLeft: left, offsetTop: top } = window.visualViewport;
    if (left !== vpLeft) {
      el.setProperty("--q-pe-left", left + "px");
      vpLeft = left;
    }
    if (top !== vpTop) {
      el.setProperty("--q-pe-top", top + "px");
      vpTop = top;
    }
  }
  const { scrollLeft, scrollTop } = targetEl;
  const anchorProps = absoluteOffset === void 0 ? getAnchorProps(anchorEl, cover === true ? [0, 0] : offset) : getAbsoluteAnchorProps(anchorEl, absoluteOffset, offset);
  Object.assign(targetEl.style, {
    top: 0,
    left: 0,
    minWidth: null,
    minHeight: null,
    maxWidth: maxWidth || "100vw",
    maxHeight: maxHeight || "100vh",
    visibility: "visible"
  });
  const { offsetWidth: origElWidth, offsetHeight: origElHeight } = targetEl;
  const { elWidth, elHeight } = fit === true || cover === true ? { elWidth: Math.max(anchorProps.width, origElWidth), elHeight: cover === true ? Math.max(anchorProps.height, origElHeight) : origElHeight } : { elWidth: origElWidth, elHeight: origElHeight };
  let elStyle = { maxWidth, maxHeight };
  if (fit === true || cover === true) {
    elStyle.minWidth = anchorProps.width + "px";
    if (cover === true) {
      elStyle.minHeight = anchorProps.height + "px";
    }
  }
  Object.assign(targetEl.style, elStyle);
  const targetProps = getTargetProps(elWidth, elHeight);
  let props2 = getTopLeftProps(anchorProps, targetProps, anchorOrigin, selfOrigin);
  if (absoluteOffset === void 0 || offset === void 0) {
    applyBoundaries(props2, anchorProps, targetProps, anchorOrigin, selfOrigin);
  } else {
    const { top, left } = props2;
    applyBoundaries(props2, anchorProps, targetProps, anchorOrigin, selfOrigin);
    let hasChanged2 = false;
    if (props2.top !== top) {
      hasChanged2 = true;
      const offsetY = 2 * offset[1];
      anchorProps.center = anchorProps.top -= offsetY;
      anchorProps.bottom -= offsetY + 2;
    }
    if (props2.left !== left) {
      hasChanged2 = true;
      const offsetX = 2 * offset[0];
      anchorProps.middle = anchorProps.left -= offsetX;
      anchorProps.right -= offsetX + 2;
    }
    if (hasChanged2 === true) {
      props2 = getTopLeftProps(anchorProps, targetProps, anchorOrigin, selfOrigin);
      applyBoundaries(props2, anchorProps, targetProps, anchorOrigin, selfOrigin);
    }
  }
  elStyle = {
    top: props2.top + "px",
    left: props2.left + "px"
  };
  if (props2.maxHeight !== void 0) {
    elStyle.maxHeight = props2.maxHeight + "px";
    if (anchorProps.height > props2.maxHeight) {
      elStyle.minHeight = elStyle.maxHeight;
    }
  }
  if (props2.maxWidth !== void 0) {
    elStyle.maxWidth = props2.maxWidth + "px";
    if (anchorProps.width > props2.maxWidth) {
      elStyle.minWidth = elStyle.maxWidth;
    }
  }
  Object.assign(targetEl.style, elStyle);
  if (targetEl.scrollTop !== scrollTop) {
    targetEl.scrollTop = scrollTop;
  }
  if (targetEl.scrollLeft !== scrollLeft) {
    targetEl.scrollLeft = scrollLeft;
  }
}
function applyBoundaries(props2, anchorProps, targetProps, anchorOrigin, selfOrigin) {
  const currentHeight = targetProps.bottom, currentWidth = targetProps.right, margin = getScrollbarWidth(), innerHeight = window.innerHeight - margin, innerWidth = document.body.clientWidth;
  if (props2.top < 0 || props2.top + currentHeight > innerHeight) {
    if (selfOrigin.vertical === "center") {
      props2.top = anchorProps[anchorOrigin.vertical] > innerHeight / 2 ? Math.max(0, innerHeight - currentHeight) : 0;
      props2.maxHeight = Math.min(currentHeight, innerHeight);
    } else if (anchorProps[anchorOrigin.vertical] > innerHeight / 2) {
      const anchorY = Math.min(
        innerHeight,
        anchorOrigin.vertical === "center" ? anchorProps.center : anchorOrigin.vertical === selfOrigin.vertical ? anchorProps.bottom : anchorProps.top
      );
      props2.maxHeight = Math.min(currentHeight, anchorY);
      props2.top = Math.max(0, anchorY - currentHeight);
    } else {
      props2.top = Math.max(
        0,
        anchorOrigin.vertical === "center" ? anchorProps.center : anchorOrigin.vertical === selfOrigin.vertical ? anchorProps.top : anchorProps.bottom
      );
      props2.maxHeight = Math.min(currentHeight, innerHeight - props2.top);
    }
  }
  if (props2.left < 0 || props2.left + currentWidth > innerWidth) {
    props2.maxWidth = Math.min(currentWidth, innerWidth);
    if (selfOrigin.horizontal === "middle") {
      props2.left = anchorProps[anchorOrigin.horizontal] > innerWidth / 2 ? Math.max(0, innerWidth - currentWidth) : 0;
    } else if (anchorProps[anchorOrigin.horizontal] > innerWidth / 2) {
      const anchorX = Math.min(
        innerWidth,
        anchorOrigin.horizontal === "middle" ? anchorProps.middle : anchorOrigin.horizontal === selfOrigin.horizontal ? anchorProps.right : anchorProps.left
      );
      props2.maxWidth = Math.min(currentWidth, anchorX);
      props2.left = Math.max(0, anchorX - props2.maxWidth);
    } else {
      props2.left = Math.max(
        0,
        anchorOrigin.horizontal === "middle" ? anchorProps.middle : anchorOrigin.horizontal === selfOrigin.horizontal ? anchorProps.left : anchorProps.right
      );
      props2.maxWidth = Math.min(currentWidth, innerWidth - props2.left);
    }
  }
}
const QMenu = createComponent({
  name: "QMenu",
  inheritAttrs: false,
  props: {
    ...useAnchorProps,
    ...useModelToggleProps,
    ...useDarkProps,
    ...useTransitionProps,
    persistent: Boolean,
    autoClose: Boolean,
    separateClosePopup: Boolean,
    noRouteDismiss: Boolean,
    noRefocus: Boolean,
    noFocus: Boolean,
    fit: Boolean,
    cover: Boolean,
    square: Boolean,
    anchor: {
      type: String,
      validator: validatePosition
    },
    self: {
      type: String,
      validator: validatePosition
    },
    offset: {
      type: Array,
      validator: validateOffset
    },
    scrollTarget: scrollTargetProp,
    touchPosition: Boolean,
    maxHeight: {
      type: String,
      default: null
    },
    maxWidth: {
      type: String,
      default: null
    }
  },
  emits: [
    ...useModelToggleEmits,
    "click",
    "escapeKey"
  ],
  setup(props2, { slots, emit: emit2, attrs }) {
    let refocusTarget = null, absoluteOffset, unwatchPosition, avoidAutoClose;
    const vm2 = getCurrentInstance();
    const { proxy } = vm2;
    const { $q } = proxy;
    const innerRef = ref(null);
    const showing = ref(false);
    const hideOnRouteChange = computed(
      () => props2.persistent !== true && props2.noRouteDismiss !== true
    );
    const isDark = useDark(props2, $q);
    const { registerTick, removeTick } = useTick();
    const { registerTimeout } = useTimeout();
    const { transitionProps, transitionStyle } = useTransition(props2);
    const { localScrollTarget, changeScrollEvent, unconfigureScrollTarget } = useScrollTarget(props2, configureScrollTarget);
    const { anchorEl, canShow } = useAnchor({ showing });
    const { hide } = useModelToggle({
      showing,
      canShow,
      handleShow,
      handleHide,
      hideOnRouteChange,
      processOnMount: true
    });
    const { showPortal, hidePortal, renderPortal } = usePortal(vm2, innerRef, renderPortalContent, "menu");
    const clickOutsideProps = {
      anchorEl,
      innerRef,
      onClickOutside(e2) {
        if (props2.persistent !== true && showing.value === true) {
          hide(e2);
          if (
            // always prevent touch event
            e2.type === "touchstart" || e2.target.classList.contains("q-dialog__backdrop")
          ) {
            stopAndPrevent(e2);
          }
          return true;
        }
      }
    };
    const anchorOrigin = computed(
      () => parsePosition(
        props2.anchor || (props2.cover === true ? "center middle" : "bottom start"),
        $q.lang.rtl
      )
    );
    const selfOrigin = computed(() => props2.cover === true ? anchorOrigin.value : parsePosition(props2.self || "top start", $q.lang.rtl));
    const menuClass = computed(
      () => (props2.square === true ? " q-menu--square" : "") + (isDark.value === true ? " q-menu--dark q-dark" : "")
    );
    const onEvents = computed(() => props2.autoClose === true ? { onClick: onAutoClose } : {});
    const handlesFocus = computed(
      () => showing.value === true && props2.persistent !== true
    );
    watch(handlesFocus, (val) => {
      if (val === true) {
        addEscapeKey(onEscapeKey);
        addClickOutside(clickOutsideProps);
      } else {
        removeEscapeKey(onEscapeKey);
        removeClickOutside(clickOutsideProps);
      }
    });
    function focus() {
      addFocusFn(() => {
        let node = innerRef.value;
        if (node && node.contains(document.activeElement) !== true) {
          node = node.querySelector("[autofocus][tabindex], [data-autofocus][tabindex]") || node.querySelector("[autofocus] [tabindex], [data-autofocus] [tabindex]") || node.querySelector("[autofocus], [data-autofocus]") || node;
          node.focus({ preventScroll: true });
        }
      });
    }
    function handleShow(evt) {
      refocusTarget = props2.noRefocus === false ? document.activeElement : null;
      addFocusout(onFocusout);
      showPortal();
      configureScrollTarget();
      absoluteOffset = void 0;
      if (evt !== void 0 && (props2.touchPosition || props2.contextMenu)) {
        const pos = position$1(evt);
        if (pos.left !== void 0) {
          const { top, left } = anchorEl.value.getBoundingClientRect();
          absoluteOffset = { left: pos.left - left, top: pos.top - top };
        }
      }
      if (unwatchPosition === void 0) {
        unwatchPosition = watch(
          () => $q.screen.width + "|" + $q.screen.height + "|" + props2.self + "|" + props2.anchor + "|" + $q.lang.rtl,
          updatePosition
        );
      }
      if (props2.noFocus !== true) {
        document.activeElement.blur();
      }
      registerTick(() => {
        updatePosition();
        props2.noFocus !== true && focus();
      });
      registerTimeout(() => {
        if ($q.platform.is.ios === true) {
          avoidAutoClose = props2.autoClose;
          innerRef.value.click();
        }
        updatePosition();
        showPortal(true);
        emit2("show", evt);
      }, props2.transitionDuration);
    }
    function handleHide(evt) {
      removeTick();
      hidePortal();
      anchorCleanup(true);
      if (refocusTarget !== null && // menu was hidden from code or ESC plugin
      (evt === void 0 || evt.qClickOutside !== true)) {
        ((evt && evt.type.indexOf("key") === 0 ? refocusTarget.closest('[tabindex]:not([tabindex^="-"])') : void 0) || refocusTarget).focus();
        refocusTarget = null;
      }
      registerTimeout(() => {
        hidePortal(true);
        emit2("hide", evt);
      }, props2.transitionDuration);
    }
    function anchorCleanup(hiding) {
      absoluteOffset = void 0;
      if (unwatchPosition !== void 0) {
        unwatchPosition();
        unwatchPosition = void 0;
      }
      if (hiding === true || showing.value === true) {
        removeFocusout(onFocusout);
        unconfigureScrollTarget();
        removeClickOutside(clickOutsideProps);
        removeEscapeKey(onEscapeKey);
      }
      if (hiding !== true) {
        refocusTarget = null;
      }
    }
    function configureScrollTarget() {
      if (anchorEl.value !== null || props2.scrollTarget !== void 0) {
        localScrollTarget.value = getScrollTarget(anchorEl.value, props2.scrollTarget);
        changeScrollEvent(localScrollTarget.value, updatePosition);
      }
    }
    function onAutoClose(e2) {
      if (avoidAutoClose !== true) {
        closePortalMenus(proxy, e2);
        emit2("click", e2);
      } else {
        avoidAutoClose = false;
      }
    }
    function onFocusout(evt) {
      if (handlesFocus.value === true && props2.noFocus !== true && childHasFocus(innerRef.value, evt.target) !== true) {
        focus();
      }
    }
    function onEscapeKey(evt) {
      emit2("escapeKey");
      hide(evt);
    }
    function updatePosition() {
      setPosition({
        targetEl: innerRef.value,
        offset: props2.offset,
        anchorEl: anchorEl.value,
        anchorOrigin: anchorOrigin.value,
        selfOrigin: selfOrigin.value,
        absoluteOffset,
        fit: props2.fit,
        cover: props2.cover,
        maxHeight: props2.maxHeight,
        maxWidth: props2.maxWidth
      });
    }
    function renderPortalContent() {
      return h$1(
        Transition,
        transitionProps.value,
        () => showing.value === true ? h$1("div", {
          role: "menu",
          ...attrs,
          ref: innerRef,
          tabindex: -1,
          class: [
            "q-menu q-position-engine scroll" + menuClass.value,
            attrs.class
          ],
          style: [
            attrs.style,
            transitionStyle.value
          ],
          ...onEvents.value
        }, hSlot(slots.default)) : null
      );
    }
    onBeforeUnmount(anchorCleanup);
    Object.assign(proxy, { focus, updatePosition });
    return renderPortal;
  }
});
let rtlHasScrollBug = false;
{
  const scroller = document.createElement("div");
  scroller.setAttribute("dir", "rtl");
  Object.assign(scroller.style, {
    width: "1px",
    height: "1px",
    overflow: "auto"
  });
  const spacer = document.createElement("div");
  Object.assign(spacer.style, {
    width: "1000px",
    height: "1px"
  });
  document.body.appendChild(scroller);
  scroller.appendChild(spacer);
  scroller.scrollLeft = -1e3;
  rtlHasScrollBug = scroller.scrollLeft >= 0;
  scroller.remove();
}
const aggBucketSize = 1e3;
const scrollToEdges = [
  "start",
  "center",
  "end",
  "start-force",
  "center-force",
  "end-force"
];
const filterProto = Array.prototype.filter;
const setOverflowAnchor = window.getComputedStyle(document.body).overflowAnchor === void 0 ? noop$3 : function(contentEl, index) {
  if (contentEl === null) {
    return;
  }
  if (contentEl._qOverflowAnimationFrame !== void 0) {
    cancelAnimationFrame(contentEl._qOverflowAnimationFrame);
  }
  contentEl._qOverflowAnimationFrame = requestAnimationFrame(() => {
    if (contentEl === null) {
      return;
    }
    contentEl._qOverflowAnimationFrame = void 0;
    const children = contentEl.children || [];
    filterProto.call(children, (el2) => el2.dataset && el2.dataset.qVsAnchor !== void 0).forEach((el2) => {
      delete el2.dataset.qVsAnchor;
    });
    const el = children[index];
    if (el && el.dataset) {
      el.dataset.qVsAnchor = "";
    }
  });
};
function sumFn(acc, h2) {
  return acc + h2;
}
function getScrollDetails(parent, child, beforeRef, afterRef, horizontal, rtl, stickyStart, stickyEnd) {
  const parentCalc = parent === window ? document.scrollingElement || document.documentElement : parent, propElSize = horizontal === true ? "offsetWidth" : "offsetHeight", details = {
    scrollStart: 0,
    scrollViewSize: -stickyStart - stickyEnd,
    scrollMaxSize: 0,
    offsetStart: -stickyStart,
    offsetEnd: -stickyEnd
  };
  if (horizontal === true) {
    if (parent === window) {
      details.scrollStart = window.pageXOffset || window.scrollX || document.body.scrollLeft || 0;
      details.scrollViewSize += document.documentElement.clientWidth;
    } else {
      details.scrollStart = parentCalc.scrollLeft;
      details.scrollViewSize += parentCalc.clientWidth;
    }
    details.scrollMaxSize = parentCalc.scrollWidth;
    if (rtl === true) {
      details.scrollStart = (rtlHasScrollBug === true ? details.scrollMaxSize - details.scrollViewSize : 0) - details.scrollStart;
    }
  } else {
    if (parent === window) {
      details.scrollStart = window.pageYOffset || window.scrollY || document.body.scrollTop || 0;
      details.scrollViewSize += document.documentElement.clientHeight;
    } else {
      details.scrollStart = parentCalc.scrollTop;
      details.scrollViewSize += parentCalc.clientHeight;
    }
    details.scrollMaxSize = parentCalc.scrollHeight;
  }
  if (beforeRef !== null) {
    for (let el = beforeRef.previousElementSibling; el !== null; el = el.previousElementSibling) {
      if (el.classList.contains("q-virtual-scroll--skip") === false) {
        details.offsetStart += el[propElSize];
      }
    }
  }
  if (afterRef !== null) {
    for (let el = afterRef.nextElementSibling; el !== null; el = el.nextElementSibling) {
      if (el.classList.contains("q-virtual-scroll--skip") === false) {
        details.offsetEnd += el[propElSize];
      }
    }
  }
  if (child !== parent) {
    const parentRect = parentCalc.getBoundingClientRect(), childRect = child.getBoundingClientRect();
    if (horizontal === true) {
      details.offsetStart += childRect.left - parentRect.left;
      details.offsetEnd -= childRect.width;
    } else {
      details.offsetStart += childRect.top - parentRect.top;
      details.offsetEnd -= childRect.height;
    }
    if (parent !== window) {
      details.offsetStart += details.scrollStart;
    }
    details.offsetEnd += details.scrollMaxSize - details.offsetStart;
  }
  return details;
}
function setScroll(parent, scroll, horizontal, rtl) {
  if (scroll === "end") {
    scroll = (parent === window ? document.body : parent)[horizontal === true ? "scrollWidth" : "scrollHeight"];
  }
  if (parent === window) {
    if (horizontal === true) {
      if (rtl === true) {
        scroll = (rtlHasScrollBug === true ? document.body.scrollWidth - document.documentElement.clientWidth : 0) - scroll;
      }
      window.scrollTo(scroll, window.pageYOffset || window.scrollY || document.body.scrollTop || 0);
    } else {
      window.scrollTo(window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, scroll);
    }
  } else if (horizontal === true) {
    if (rtl === true) {
      scroll = (rtlHasScrollBug === true ? parent.scrollWidth - parent.offsetWidth : 0) - scroll;
    }
    parent.scrollLeft = scroll;
  } else {
    parent.scrollTop = scroll;
  }
}
function sumSize(sizeAgg, size2, from, to) {
  if (from >= to) {
    return 0;
  }
  const lastTo = size2.length, fromAgg = Math.floor(from / aggBucketSize), toAgg = Math.floor((to - 1) / aggBucketSize) + 1;
  let total = sizeAgg.slice(fromAgg, toAgg).reduce(sumFn, 0);
  if (from % aggBucketSize !== 0) {
    total -= size2.slice(fromAgg * aggBucketSize, from).reduce(sumFn, 0);
  }
  if (to % aggBucketSize !== 0 && to !== lastTo) {
    total -= size2.slice(to, toAgg * aggBucketSize).reduce(sumFn, 0);
  }
  return total;
}
const commonVirtScrollProps = {
  virtualScrollSliceSize: {
    type: [Number, String],
    default: 10
  },
  virtualScrollSliceRatioBefore: {
    type: [Number, String],
    default: 1
  },
  virtualScrollSliceRatioAfter: {
    type: [Number, String],
    default: 1
  },
  virtualScrollItemSize: {
    type: [Number, String],
    default: 24
  },
  virtualScrollStickySizeStart: {
    type: [Number, String],
    default: 0
  },
  virtualScrollStickySizeEnd: {
    type: [Number, String],
    default: 0
  },
  tableColspan: [Number, String]
};
const commonVirtScrollPropsList = Object.keys(commonVirtScrollProps);
const useVirtualScrollProps = {
  virtualScrollHorizontal: Boolean,
  onVirtualScroll: Function,
  ...commonVirtScrollProps
};
function useVirtualScroll({
  virtualScrollLength,
  getVirtualScrollTarget,
  getVirtualScrollEl,
  virtualScrollItemSizeComputed
  // optional
}) {
  const vm2 = getCurrentInstance();
  const { props: props2, emit: emit2, proxy } = vm2;
  const { $q } = proxy;
  let prevScrollStart, prevToIndex, localScrollViewSize, virtualScrollSizesAgg = [], virtualScrollSizes;
  const virtualScrollPaddingBefore = ref(0);
  const virtualScrollPaddingAfter = ref(0);
  const virtualScrollSliceSizeComputed = ref({});
  const beforeRef = ref(null);
  const afterRef = ref(null);
  const contentRef = ref(null);
  const virtualScrollSliceRange = ref({ from: 0, to: 0 });
  const colspanAttr = computed(() => props2.tableColspan !== void 0 ? props2.tableColspan : 100);
  if (virtualScrollItemSizeComputed === void 0) {
    virtualScrollItemSizeComputed = computed(() => props2.virtualScrollItemSize);
  }
  const needsReset = computed(() => virtualScrollItemSizeComputed.value + ";" + props2.virtualScrollHorizontal);
  const needsSliceRecalc = computed(
    () => needsReset.value + ";" + props2.virtualScrollSliceRatioBefore + ";" + props2.virtualScrollSliceRatioAfter
  );
  watch(needsSliceRecalc, () => {
    setVirtualScrollSize();
  });
  watch(needsReset, reset);
  function reset() {
    localResetVirtualScroll(prevToIndex, true);
  }
  function refresh(toIndex) {
    localResetVirtualScroll(toIndex === void 0 ? prevToIndex : toIndex);
  }
  function scrollTo(toIndex, edge) {
    const scrollEl = getVirtualScrollTarget();
    if (scrollEl === void 0 || scrollEl === null || scrollEl.nodeType === 8) {
      return;
    }
    const scrollDetails = getScrollDetails(
      scrollEl,
      getVirtualScrollEl(),
      beforeRef.value,
      afterRef.value,
      props2.virtualScrollHorizontal,
      $q.lang.rtl,
      props2.virtualScrollStickySizeStart,
      props2.virtualScrollStickySizeEnd
    );
    localScrollViewSize !== scrollDetails.scrollViewSize && setVirtualScrollSize(scrollDetails.scrollViewSize);
    setVirtualScrollSliceRange(
      scrollEl,
      scrollDetails,
      Math.min(virtualScrollLength.value - 1, Math.max(0, parseInt(toIndex, 10) || 0)),
      0,
      scrollToEdges.indexOf(edge) !== -1 ? edge : prevToIndex !== -1 && toIndex > prevToIndex ? "end" : "start"
    );
  }
  function localOnVirtualScrollEvt() {
    const scrollEl = getVirtualScrollTarget();
    if (scrollEl === void 0 || scrollEl === null || scrollEl.nodeType === 8) {
      return;
    }
    const scrollDetails = getScrollDetails(
      scrollEl,
      getVirtualScrollEl(),
      beforeRef.value,
      afterRef.value,
      props2.virtualScrollHorizontal,
      $q.lang.rtl,
      props2.virtualScrollStickySizeStart,
      props2.virtualScrollStickySizeEnd
    ), listLastIndex = virtualScrollLength.value - 1, listEndOffset = scrollDetails.scrollMaxSize - scrollDetails.offsetStart - scrollDetails.offsetEnd - virtualScrollPaddingAfter.value;
    if (prevScrollStart === scrollDetails.scrollStart) {
      return;
    }
    if (scrollDetails.scrollMaxSize <= 0) {
      setVirtualScrollSliceRange(scrollEl, scrollDetails, 0, 0);
      return;
    }
    localScrollViewSize !== scrollDetails.scrollViewSize && setVirtualScrollSize(scrollDetails.scrollViewSize);
    updateVirtualScrollSizes(virtualScrollSliceRange.value.from);
    const scrollMaxStart = Math.floor(scrollDetails.scrollMaxSize - Math.max(scrollDetails.scrollViewSize, scrollDetails.offsetEnd) - Math.min(virtualScrollSizes[listLastIndex], scrollDetails.scrollViewSize / 2));
    if (scrollMaxStart > 0 && Math.ceil(scrollDetails.scrollStart) >= scrollMaxStart) {
      setVirtualScrollSliceRange(
        scrollEl,
        scrollDetails,
        listLastIndex,
        scrollDetails.scrollMaxSize - scrollDetails.offsetEnd - virtualScrollSizesAgg.reduce(sumFn, 0)
      );
      return;
    }
    let toIndex = 0, listOffset = scrollDetails.scrollStart - scrollDetails.offsetStart, offset = listOffset;
    if (listOffset <= listEndOffset && listOffset + scrollDetails.scrollViewSize >= virtualScrollPaddingBefore.value) {
      listOffset -= virtualScrollPaddingBefore.value;
      toIndex = virtualScrollSliceRange.value.from;
      offset = listOffset;
    } else {
      for (let j2 = 0; listOffset >= virtualScrollSizesAgg[j2] && toIndex < listLastIndex; j2++) {
        listOffset -= virtualScrollSizesAgg[j2];
        toIndex += aggBucketSize;
      }
    }
    while (listOffset > 0 && toIndex < listLastIndex) {
      listOffset -= virtualScrollSizes[toIndex];
      if (listOffset > -scrollDetails.scrollViewSize) {
        toIndex++;
        offset = listOffset;
      } else {
        offset = virtualScrollSizes[toIndex] + listOffset;
      }
    }
    setVirtualScrollSliceRange(
      scrollEl,
      scrollDetails,
      toIndex,
      offset
    );
  }
  function setVirtualScrollSliceRange(scrollEl, scrollDetails, toIndex, offset, align) {
    const alignForce = typeof align === "string" && align.indexOf("-force") !== -1;
    const alignEnd = alignForce === true ? align.replace("-force", "") : align;
    const alignRange = alignEnd !== void 0 ? alignEnd : "start";
    let from = Math.max(0, toIndex - virtualScrollSliceSizeComputed.value[alignRange]), to = from + virtualScrollSliceSizeComputed.value.total;
    if (to > virtualScrollLength.value) {
      to = virtualScrollLength.value;
      from = Math.max(0, to - virtualScrollSliceSizeComputed.value.total);
    }
    prevScrollStart = scrollDetails.scrollStart;
    const rangeChanged = from !== virtualScrollSliceRange.value.from || to !== virtualScrollSliceRange.value.to;
    if (rangeChanged === false && alignEnd === void 0) {
      emitScroll(toIndex);
      return;
    }
    const { activeElement } = document;
    const contentEl = contentRef.value;
    if (rangeChanged === true && contentEl !== null && contentEl !== activeElement && contentEl.contains(activeElement) === true) {
      contentEl.addEventListener("focusout", onBlurRefocusFn);
      setTimeout(() => {
        contentEl !== null && contentEl.removeEventListener("focusout", onBlurRefocusFn);
      });
    }
    setOverflowAnchor(contentEl, toIndex - from);
    const sizeBefore = alignEnd !== void 0 ? virtualScrollSizes.slice(from, toIndex).reduce(sumFn, 0) : 0;
    if (rangeChanged === true) {
      const tempTo = to >= virtualScrollSliceRange.value.from && from <= virtualScrollSliceRange.value.to ? virtualScrollSliceRange.value.to : to;
      virtualScrollSliceRange.value = { from, to: tempTo };
      virtualScrollPaddingBefore.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, 0, from);
      virtualScrollPaddingAfter.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, to, virtualScrollLength.value);
      requestAnimationFrame(() => {
        if (virtualScrollSliceRange.value.to !== to && prevScrollStart === scrollDetails.scrollStart) {
          virtualScrollSliceRange.value = { from: virtualScrollSliceRange.value.from, to };
          virtualScrollPaddingAfter.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, to, virtualScrollLength.value);
        }
      });
    }
    requestAnimationFrame(() => {
      if (prevScrollStart !== scrollDetails.scrollStart) {
        return;
      }
      if (rangeChanged === true) {
        updateVirtualScrollSizes(from);
      }
      const sizeAfter = virtualScrollSizes.slice(from, toIndex).reduce(sumFn, 0), posStart = sizeAfter + scrollDetails.offsetStart + virtualScrollPaddingBefore.value, posEnd = posStart + virtualScrollSizes[toIndex];
      let scrollPosition = posStart + offset;
      if (alignEnd !== void 0) {
        const sizeDiff = sizeAfter - sizeBefore;
        const scrollStart = scrollDetails.scrollStart + sizeDiff;
        scrollPosition = alignForce !== true && scrollStart < posStart && posEnd < scrollStart + scrollDetails.scrollViewSize ? scrollStart : alignEnd === "end" ? posEnd - scrollDetails.scrollViewSize : posStart - (alignEnd === "start" ? 0 : Math.round((scrollDetails.scrollViewSize - virtualScrollSizes[toIndex]) / 2));
      }
      prevScrollStart = scrollPosition;
      setScroll(
        scrollEl,
        scrollPosition,
        props2.virtualScrollHorizontal,
        $q.lang.rtl
      );
      emitScroll(toIndex);
    });
  }
  function updateVirtualScrollSizes(from) {
    const contentEl = contentRef.value;
    if (contentEl) {
      const children = filterProto.call(
        contentEl.children,
        (el) => el.classList && el.classList.contains("q-virtual-scroll--skip") === false
      ), childrenLength = children.length, sizeFn = props2.virtualScrollHorizontal === true ? (el) => el.getBoundingClientRect().width : (el) => el.offsetHeight;
      let index = from, size2, diff;
      for (let i = 0; i < childrenLength; ) {
        size2 = sizeFn(children[i]);
        i++;
        while (i < childrenLength && children[i].classList.contains("q-virtual-scroll--with-prev") === true) {
          size2 += sizeFn(children[i]);
          i++;
        }
        diff = size2 - virtualScrollSizes[index];
        if (diff !== 0) {
          virtualScrollSizes[index] += diff;
          virtualScrollSizesAgg[Math.floor(index / aggBucketSize)] += diff;
        }
        index++;
      }
    }
  }
  function onBlurRefocusFn() {
    contentRef.value !== null && contentRef.value !== void 0 && contentRef.value.focus();
  }
  function localResetVirtualScroll(toIndex, fullReset) {
    const defaultSize = 1 * virtualScrollItemSizeComputed.value;
    if (fullReset === true || Array.isArray(virtualScrollSizes) === false) {
      virtualScrollSizes = [];
    }
    const oldVirtualScrollSizesLength = virtualScrollSizes.length;
    virtualScrollSizes.length = virtualScrollLength.value;
    for (let i = virtualScrollLength.value - 1; i >= oldVirtualScrollSizesLength; i--) {
      virtualScrollSizes[i] = defaultSize;
    }
    const jMax = Math.floor((virtualScrollLength.value - 1) / aggBucketSize);
    virtualScrollSizesAgg = [];
    for (let j2 = 0; j2 <= jMax; j2++) {
      let size2 = 0;
      const iMax = Math.min((j2 + 1) * aggBucketSize, virtualScrollLength.value);
      for (let i = j2 * aggBucketSize; i < iMax; i++) {
        size2 += virtualScrollSizes[i];
      }
      virtualScrollSizesAgg.push(size2);
    }
    prevToIndex = -1;
    prevScrollStart = void 0;
    virtualScrollPaddingBefore.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, 0, virtualScrollSliceRange.value.from);
    virtualScrollPaddingAfter.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, virtualScrollSliceRange.value.to, virtualScrollLength.value);
    if (toIndex >= 0) {
      updateVirtualScrollSizes(virtualScrollSliceRange.value.from);
      nextTick$1(() => {
        scrollTo(toIndex);
      });
    } else {
      onVirtualScrollEvt();
    }
  }
  function setVirtualScrollSize(scrollViewSize) {
    if (scrollViewSize === void 0 && typeof window !== "undefined") {
      const scrollEl = getVirtualScrollTarget();
      if (scrollEl !== void 0 && scrollEl !== null && scrollEl.nodeType !== 8) {
        scrollViewSize = getScrollDetails(
          scrollEl,
          getVirtualScrollEl(),
          beforeRef.value,
          afterRef.value,
          props2.virtualScrollHorizontal,
          $q.lang.rtl,
          props2.virtualScrollStickySizeStart,
          props2.virtualScrollStickySizeEnd
        ).scrollViewSize;
      }
    }
    localScrollViewSize = scrollViewSize;
    const virtualScrollSliceRatioBefore = parseFloat(props2.virtualScrollSliceRatioBefore) || 0;
    const virtualScrollSliceRatioAfter = parseFloat(props2.virtualScrollSliceRatioAfter) || 0;
    const multiplier = 1 + virtualScrollSliceRatioBefore + virtualScrollSliceRatioAfter;
    const view = scrollViewSize === void 0 || scrollViewSize <= 0 ? 1 : Math.ceil(scrollViewSize / virtualScrollItemSizeComputed.value);
    const baseSize = Math.max(
      1,
      view,
      Math.ceil((props2.virtualScrollSliceSize > 0 ? props2.virtualScrollSliceSize : 10) / multiplier)
    );
    virtualScrollSliceSizeComputed.value = {
      total: Math.ceil(baseSize * multiplier),
      start: Math.ceil(baseSize * virtualScrollSliceRatioBefore),
      center: Math.ceil(baseSize * (0.5 + virtualScrollSliceRatioBefore)),
      end: Math.ceil(baseSize * (1 + virtualScrollSliceRatioBefore)),
      view
    };
  }
  function padVirtualScroll(tag, content2) {
    const paddingSize = props2.virtualScrollHorizontal === true ? "width" : "height";
    const style = {
      ["--q-virtual-scroll-item-" + paddingSize]: virtualScrollItemSizeComputed.value + "px"
    };
    return [
      tag === "tbody" ? h$1(tag, {
        class: "q-virtual-scroll__padding",
        key: "before",
        ref: beforeRef
      }, [
        h$1("tr", [
          h$1("td", {
            style: { [paddingSize]: `${virtualScrollPaddingBefore.value}px`, ...style },
            colspan: colspanAttr.value
          })
        ])
      ]) : h$1(tag, {
        class: "q-virtual-scroll__padding",
        key: "before",
        ref: beforeRef,
        style: { [paddingSize]: `${virtualScrollPaddingBefore.value}px`, ...style }
      }),
      h$1(tag, {
        class: "q-virtual-scroll__content",
        key: "content",
        ref: contentRef,
        tabindex: -1
      }, content2.flat()),
      tag === "tbody" ? h$1(tag, {
        class: "q-virtual-scroll__padding",
        key: "after",
        ref: afterRef
      }, [
        h$1("tr", [
          h$1("td", {
            style: { [paddingSize]: `${virtualScrollPaddingAfter.value}px`, ...style },
            colspan: colspanAttr.value
          })
        ])
      ]) : h$1(tag, {
        class: "q-virtual-scroll__padding",
        key: "after",
        ref: afterRef,
        style: { [paddingSize]: `${virtualScrollPaddingAfter.value}px`, ...style }
      })
    ];
  }
  function emitScroll(index) {
    if (prevToIndex !== index) {
      props2.onVirtualScroll !== void 0 && emit2("virtualScroll", {
        index,
        from: virtualScrollSliceRange.value.from,
        to: virtualScrollSliceRange.value.to - 1,
        direction: index < prevToIndex ? "decrease" : "increase",
        ref: proxy
      });
      prevToIndex = index;
    }
  }
  setVirtualScrollSize();
  const onVirtualScrollEvt = debounce(
    localOnVirtualScrollEvt,
    $q.platform.is.ios === true ? 120 : 35
  );
  onBeforeMount(() => {
    setVirtualScrollSize();
  });
  let shouldActivate = false;
  onDeactivated(() => {
    shouldActivate = true;
  });
  onActivated(() => {
    if (shouldActivate !== true) return;
    const scrollEl = getVirtualScrollTarget();
    if (prevScrollStart !== void 0 && scrollEl !== void 0 && scrollEl !== null && scrollEl.nodeType !== 8) {
      setScroll(
        scrollEl,
        prevScrollStart,
        props2.virtualScrollHorizontal,
        $q.lang.rtl
      );
    } else {
      scrollTo(prevToIndex);
    }
  });
  onBeforeUnmount(() => {
    onVirtualScrollEvt.cancel();
  });
  Object.assign(proxy, { scrollTo, reset, refresh });
  return {
    virtualScrollSliceRange,
    virtualScrollSliceSizeComputed,
    setVirtualScrollSize,
    onVirtualScrollEvt,
    localResetVirtualScroll,
    padVirtualScroll,
    scrollTo,
    reset,
    refresh
  };
}
const validateNewValueMode = (v2) => ["add", "add-unique", "toggle"].includes(v2);
const reEscapeList = ".*+?^${}()|[]\\";
const fieldPropsList = Object.keys(useFieldProps);
const QSelect = createComponent({
  name: "QSelect",
  inheritAttrs: false,
  props: {
    ...useVirtualScrollProps,
    ...useFormProps,
    ...useFieldProps,
    // override of useFieldProps > modelValue
    modelValue: {
      required: true
    },
    multiple: Boolean,
    displayValue: [String, Number],
    displayValueHtml: Boolean,
    dropdownIcon: String,
    options: {
      type: Array,
      default: () => []
    },
    optionValue: [Function, String],
    optionLabel: [Function, String],
    optionDisable: [Function, String],
    hideSelected: Boolean,
    hideDropdownIcon: Boolean,
    fillInput: Boolean,
    maxValues: [Number, String],
    optionsDense: Boolean,
    optionsDark: {
      type: Boolean,
      default: null
    },
    optionsSelectedClass: String,
    optionsHtml: Boolean,
    optionsCover: Boolean,
    menuShrink: Boolean,
    menuAnchor: String,
    menuSelf: String,
    menuOffset: Array,
    popupContentClass: String,
    popupContentStyle: [String, Array, Object],
    popupNoRouteDismiss: Boolean,
    useInput: Boolean,
    useChips: Boolean,
    newValueMode: {
      type: String,
      validator: validateNewValueMode
    },
    mapOptions: Boolean,
    emitValue: Boolean,
    inputDebounce: {
      type: [Number, String],
      default: 500
    },
    inputClass: [Array, String, Object],
    inputStyle: [Array, String, Object],
    tabindex: {
      type: [String, Number],
      default: 0
    },
    autocomplete: String,
    transitionShow: {},
    transitionHide: {},
    transitionDuration: {},
    behavior: {
      type: String,
      validator: (v2) => ["default", "menu", "dialog"].includes(v2),
      default: "default"
    },
    // override of useVirtualScrollProps > virtualScrollItemSize (no default)
    virtualScrollItemSize: useVirtualScrollProps.virtualScrollItemSize.type,
    onNewValue: Function,
    onFilter: Function
  },
  emits: [
    ...useFieldEmits,
    "add",
    "remove",
    "inputValue",
    "keyup",
    "keypress",
    "keydown",
    "popupShow",
    "popupHide",
    "filterAbort"
  ],
  setup(props2, { slots, emit: emit2 }) {
    const { proxy } = getCurrentInstance();
    const { $q } = proxy;
    const menu = ref(false);
    const dialog = ref(false);
    const optionIndex = ref(-1);
    const inputValue = ref("");
    const dialogFieldFocused = ref(false);
    const innerLoadingIndicator = ref(false);
    let filterTimer = null, inputValueTimer = null, innerValueCache, hasDialog, userInputValue, filterId = null, defaultInputValue, transitionShowComputed, searchBuffer, searchBufferExp;
    const inputRef = ref(null);
    const targetRef = ref(null);
    const menuRef = ref(null);
    const dialogRef = ref(null);
    const menuContentRef = ref(null);
    const nameProp = useFormInputNameAttr(props2);
    const onComposition = useKeyComposition(onInput);
    const virtualScrollLength = computed(() => Array.isArray(props2.options) ? props2.options.length : 0);
    const virtualScrollItemSizeComputed = computed(() => props2.virtualScrollItemSize === void 0 ? props2.optionsDense === true ? 24 : 48 : props2.virtualScrollItemSize);
    const {
      virtualScrollSliceRange,
      virtualScrollSliceSizeComputed,
      localResetVirtualScroll,
      padVirtualScroll,
      onVirtualScrollEvt,
      scrollTo,
      setVirtualScrollSize
    } = useVirtualScroll({
      virtualScrollLength,
      getVirtualScrollTarget,
      getVirtualScrollEl,
      virtualScrollItemSizeComputed
    });
    const state = useFieldState();
    const innerValue = computed(() => {
      const mapNull = props2.mapOptions === true && props2.multiple !== true, val = props2.modelValue !== void 0 && (props2.modelValue !== null || mapNull === true) ? props2.multiple === true && Array.isArray(props2.modelValue) ? props2.modelValue : [props2.modelValue] : [];
      if (props2.mapOptions === true && Array.isArray(props2.options) === true) {
        const cache2 = props2.mapOptions === true && innerValueCache !== void 0 ? innerValueCache : [];
        const values = val.map((v2) => getOption(v2, cache2));
        return props2.modelValue === null && mapNull === true ? values.filter((v2) => v2 !== null) : values;
      }
      return val;
    });
    const innerFieldProps = computed(() => {
      const acc = {};
      fieldPropsList.forEach((key) => {
        const val = props2[key];
        if (val !== void 0) {
          acc[key] = val;
        }
      });
      return acc;
    });
    const isOptionsDark = computed(() => props2.optionsDark === null ? state.isDark.value : props2.optionsDark);
    const hasValue = computed(() => fieldValueIsFilled(innerValue.value));
    const computedInputClass = computed(() => {
      let cls = "q-field__input q-placeholder col";
      if (props2.hideSelected === true || innerValue.value.length === 0) {
        return [cls, props2.inputClass];
      }
      cls += " q-field__input--padding";
      return props2.inputClass === void 0 ? cls : [cls, props2.inputClass];
    });
    const menuContentClass = computed(
      () => (props2.virtualScrollHorizontal === true ? "q-virtual-scroll--horizontal" : "") + (props2.popupContentClass ? " " + props2.popupContentClass : "")
    );
    const noOptions = computed(() => virtualScrollLength.value === 0);
    const selectedString = computed(
      () => innerValue.value.map((opt) => getOptionLabel.value(opt)).join(", ")
    );
    const ariaCurrentValue = computed(() => props2.displayValue !== void 0 ? props2.displayValue : selectedString.value);
    const needsHtmlFn = computed(() => props2.optionsHtml === true ? () => true : (opt) => opt !== void 0 && opt !== null && opt.html === true);
    const valueAsHtml = computed(() => props2.displayValueHtml === true || props2.displayValue === void 0 && (props2.optionsHtml === true || innerValue.value.some(needsHtmlFn.value)));
    const tabindex = computed(() => state.focused.value === true ? props2.tabindex : -1);
    const comboboxAttrs = computed(() => {
      const attrs = {
        tabindex: props2.tabindex,
        role: "combobox",
        "aria-label": props2.label,
        "aria-readonly": props2.readonly === true ? "true" : "false",
        "aria-autocomplete": props2.useInput === true ? "list" : "none",
        "aria-expanded": menu.value === true ? "true" : "false",
        "aria-controls": `${state.targetUid.value}_lb`
      };
      if (optionIndex.value >= 0) {
        attrs["aria-activedescendant"] = `${state.targetUid.value}_${optionIndex.value}`;
      }
      return attrs;
    });
    const listboxAttrs = computed(() => ({
      id: `${state.targetUid.value}_lb`,
      role: "listbox",
      "aria-multiselectable": props2.multiple === true ? "true" : "false"
    }));
    const selectedScope = computed(() => {
      return innerValue.value.map((opt, i) => ({
        index: i,
        opt,
        html: needsHtmlFn.value(opt),
        selected: true,
        removeAtIndex: removeAtIndexAndFocus,
        toggleOption,
        tabindex: tabindex.value
      }));
    });
    const optionScope = computed(() => {
      if (virtualScrollLength.value === 0) {
        return [];
      }
      const { from, to } = virtualScrollSliceRange.value;
      return props2.options.slice(from, to).map((opt, i) => {
        const disable = isOptionDisabled.value(opt) === true;
        const active = isOptionSelected(opt) === true;
        const index = from + i;
        const itemProps = {
          clickable: true,
          active,
          activeClass: computedOptionsSelectedClass.value,
          manualFocus: true,
          focused: false,
          disable,
          tabindex: -1,
          dense: props2.optionsDense,
          dark: isOptionsDark.value,
          role: "option",
          "aria-selected": active === true ? "true" : "false",
          id: `${state.targetUid.value}_${index}`,
          onClick: () => {
            toggleOption(opt);
          }
        };
        if (disable !== true) {
          optionIndex.value === index && (itemProps.focused = true);
          if ($q.platform.is.desktop === true) {
            itemProps.onMousemove = () => {
              menu.value === true && setOptionIndex(index);
            };
          }
        }
        return {
          index,
          opt,
          html: needsHtmlFn.value(opt),
          label: getOptionLabel.value(opt),
          selected: itemProps.active,
          focused: itemProps.focused,
          toggleOption,
          setOptionIndex,
          itemProps
        };
      });
    });
    const dropdownArrowIcon = computed(() => props2.dropdownIcon !== void 0 ? props2.dropdownIcon : $q.iconSet.arrow.dropdown);
    const squaredMenu = computed(
      () => props2.optionsCover === false && props2.outlined !== true && props2.standout !== true && props2.borderless !== true && props2.rounded !== true
    );
    const computedOptionsSelectedClass = computed(() => props2.optionsSelectedClass !== void 0 ? props2.optionsSelectedClass : props2.color !== void 0 ? `text-${props2.color}` : "");
    const getOptionValue = computed(() => getPropValueFn(props2.optionValue, "value"));
    const getOptionLabel = computed(() => getPropValueFn(props2.optionLabel, "label"));
    const isOptionDisabled = computed(() => getPropValueFn(props2.optionDisable, "disable"));
    const innerOptionsValue = computed(() => innerValue.value.map((opt) => getOptionValue.value(opt)));
    const inputControlEvents = computed(() => {
      const evt = {
        onInput,
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        onChange: onComposition,
        onKeydown: onTargetKeydown,
        onKeyup: onTargetAutocomplete,
        onKeypress: onTargetKeypress,
        onFocus: selectInputText,
        onClick(e2) {
          hasDialog === true && stop(e2);
        }
      };
      evt.onCompositionstart = evt.onCompositionupdate = evt.onCompositionend = onComposition;
      return evt;
    });
    watch(innerValue, (val) => {
      innerValueCache = val;
      if (props2.useInput === true && props2.fillInput === true && props2.multiple !== true && state.innerLoading.value !== true && (dialog.value !== true && menu.value !== true || hasValue.value !== true)) {
        userInputValue !== true && resetInputValue();
        if (dialog.value === true || menu.value === true) {
          filter2("");
        }
      }
    }, { immediate: true });
    watch(() => props2.fillInput, resetInputValue);
    watch(menu, updateMenu);
    watch(virtualScrollLength, rerenderMenu);
    function getEmittingOptionValue(opt) {
      return props2.emitValue === true ? getOptionValue.value(opt) : opt;
    }
    function removeAtIndex(index) {
      if (index !== -1 && index < innerValue.value.length) {
        if (props2.multiple === true) {
          const model = props2.modelValue.slice();
          emit2("remove", { index, value: model.splice(index, 1)[0] });
          emit2("update:modelValue", model);
        } else {
          emit2("update:modelValue", null);
        }
      }
    }
    function removeAtIndexAndFocus(index) {
      removeAtIndex(index);
      state.focus();
    }
    function add2(opt, unique) {
      const val = getEmittingOptionValue(opt);
      if (props2.multiple !== true) {
        props2.fillInput === true && updateInputValue(
          getOptionLabel.value(opt),
          true,
          true
        );
        emit2("update:modelValue", val);
        return;
      }
      if (innerValue.value.length === 0) {
        emit2("add", { index: 0, value: val });
        emit2("update:modelValue", props2.multiple === true ? [val] : val);
        return;
      }
      if (unique === true && isOptionSelected(opt) === true) {
        return;
      }
      if (props2.maxValues !== void 0 && props2.modelValue.length >= props2.maxValues) {
        return;
      }
      const model = props2.modelValue.slice();
      emit2("add", { index: model.length, value: val });
      model.push(val);
      emit2("update:modelValue", model);
    }
    function toggleOption(opt, keepOpen) {
      if (state.editable.value !== true || opt === void 0 || isOptionDisabled.value(opt) === true) {
        return;
      }
      const optValue = getOptionValue.value(opt);
      if (props2.multiple !== true) {
        if (keepOpen !== true) {
          updateInputValue(
            props2.fillInput === true ? getOptionLabel.value(opt) : "",
            true,
            true
          );
          hidePopup();
        }
        targetRef.value !== null && targetRef.value.focus();
        if (innerValue.value.length === 0 || isDeepEqual(getOptionValue.value(innerValue.value[0]), optValue) !== true) {
          emit2("update:modelValue", props2.emitValue === true ? optValue : opt);
        }
        return;
      }
      (hasDialog !== true || dialogFieldFocused.value === true) && state.focus();
      selectInputText();
      if (innerValue.value.length === 0) {
        const val = props2.emitValue === true ? optValue : opt;
        emit2("add", { index: 0, value: val });
        emit2("update:modelValue", props2.multiple === true ? [val] : val);
        return;
      }
      const model = props2.modelValue.slice(), index = innerOptionsValue.value.findIndex((v2) => isDeepEqual(v2, optValue));
      if (index !== -1) {
        emit2("remove", { index, value: model.splice(index, 1)[0] });
      } else {
        if (props2.maxValues !== void 0 && model.length >= props2.maxValues) {
          return;
        }
        const val = props2.emitValue === true ? optValue : opt;
        emit2("add", { index: model.length, value: val });
        model.push(val);
      }
      emit2("update:modelValue", model);
    }
    function setOptionIndex(index) {
      if ($q.platform.is.desktop !== true) return;
      const val = index !== -1 && index < virtualScrollLength.value ? index : -1;
      if (optionIndex.value !== val) {
        optionIndex.value = val;
      }
    }
    function moveOptionSelection(offset = 1, skipInputValue) {
      if (menu.value === true) {
        let index = optionIndex.value;
        do {
          index = normalizeToInterval(
            index + offset,
            -1,
            virtualScrollLength.value - 1
          );
        } while (index !== -1 && index !== optionIndex.value && isOptionDisabled.value(props2.options[index]) === true);
        if (optionIndex.value !== index) {
          setOptionIndex(index);
          scrollTo(index);
          if (skipInputValue !== true && props2.useInput === true && props2.fillInput === true) {
            setInputValue(
              index >= 0 ? getOptionLabel.value(props2.options[index]) : defaultInputValue,
              true
            );
          }
        }
      }
    }
    function getOption(value2, valueCache) {
      const fn = (opt) => isDeepEqual(getOptionValue.value(opt), value2);
      return props2.options.find(fn) || valueCache.find(fn) || value2;
    }
    function getPropValueFn(propValue, defaultVal) {
      const val = propValue !== void 0 ? propValue : defaultVal;
      return typeof val === "function" ? val : (opt) => opt !== null && typeof opt === "object" && val in opt ? opt[val] : opt;
    }
    function isOptionSelected(opt) {
      const val = getOptionValue.value(opt);
      return innerOptionsValue.value.find((v2) => isDeepEqual(v2, val)) !== void 0;
    }
    function selectInputText(e2) {
      if (props2.useInput === true && targetRef.value !== null && (e2 === void 0 || targetRef.value === e2.target && e2.target.value === selectedString.value)) {
        targetRef.value.select();
      }
    }
    function onTargetKeyup(e2) {
      if (isKeyCode(e2, 27) === true && menu.value === true) {
        stop(e2);
        hidePopup();
        resetInputValue();
      }
      emit2("keyup", e2);
    }
    function onTargetAutocomplete(e2) {
      const { value: value2 } = e2.target;
      if (e2.keyCode !== void 0) {
        onTargetKeyup(e2);
        return;
      }
      e2.target.value = "";
      if (filterTimer !== null) {
        clearTimeout(filterTimer);
        filterTimer = null;
      }
      if (inputValueTimer !== null) {
        clearTimeout(inputValueTimer);
        inputValueTimer = null;
      }
      resetInputValue();
      if (typeof value2 === "string" && value2.length !== 0) {
        const needle = value2.toLocaleLowerCase();
        const findFn = (extractFn) => {
          const option = props2.options.find((opt) => extractFn.value(opt).toLocaleLowerCase() === needle);
          if (option === void 0) {
            return false;
          }
          if (innerValue.value.indexOf(option) === -1) {
            toggleOption(option);
          } else {
            hidePopup();
          }
          return true;
        };
        const fillFn = (afterFilter) => {
          if (findFn(getOptionValue) === true) {
            return;
          }
          if (findFn(getOptionLabel) === true || afterFilter === true) {
            return;
          }
          filter2(value2, true, () => fillFn(true));
        };
        fillFn();
      } else {
        state.clearValue(e2);
      }
    }
    function onTargetKeypress(e2) {
      emit2("keypress", e2);
    }
    function onTargetKeydown(e2) {
      emit2("keydown", e2);
      if (shouldIgnoreKey(e2) === true) {
        return;
      }
      const newValueModeValid = inputValue.value.length !== 0 && (props2.newValueMode !== void 0 || props2.onNewValue !== void 0);
      const tabShouldSelect = e2.shiftKey !== true && props2.multiple !== true && (optionIndex.value !== -1 || newValueModeValid === true);
      if (e2.keyCode === 27) {
        prevent(e2);
        return;
      }
      if (e2.keyCode === 9 && tabShouldSelect === false) {
        closeMenu();
        return;
      }
      if (e2.target === void 0 || e2.target.id !== state.targetUid.value || state.editable.value !== true) return;
      if (e2.keyCode === 40 && state.innerLoading.value !== true && menu.value === false) {
        stopAndPrevent(e2);
        showPopup();
        return;
      }
      if (e2.keyCode === 8 && (props2.useChips === true || props2.clearable === true) && props2.hideSelected !== true && inputValue.value.length === 0) {
        if (props2.multiple === true && Array.isArray(props2.modelValue) === true) {
          removeAtIndex(props2.modelValue.length - 1);
        } else if (props2.multiple !== true && props2.modelValue !== null) {
          emit2("update:modelValue", null);
        }
        return;
      }
      if ((e2.keyCode === 35 || e2.keyCode === 36) && (typeof inputValue.value !== "string" || inputValue.value.length === 0)) {
        stopAndPrevent(e2);
        optionIndex.value = -1;
        moveOptionSelection(e2.keyCode === 36 ? 1 : -1, props2.multiple);
      }
      if ((e2.keyCode === 33 || e2.keyCode === 34) && virtualScrollSliceSizeComputed.value !== void 0) {
        stopAndPrevent(e2);
        optionIndex.value = Math.max(
          -1,
          Math.min(
            virtualScrollLength.value,
            optionIndex.value + (e2.keyCode === 33 ? -1 : 1) * virtualScrollSliceSizeComputed.value.view
          )
        );
        moveOptionSelection(e2.keyCode === 33 ? 1 : -1, props2.multiple);
      }
      if (e2.keyCode === 38 || e2.keyCode === 40) {
        stopAndPrevent(e2);
        moveOptionSelection(e2.keyCode === 38 ? -1 : 1, props2.multiple);
      }
      const optionsLength = virtualScrollLength.value;
      if (searchBuffer === void 0 || searchBufferExp < Date.now()) {
        searchBuffer = "";
      }
      if (optionsLength > 0 && props2.useInput !== true && e2.key !== void 0 && e2.key.length === 1 && e2.altKey === false && e2.ctrlKey === false && e2.metaKey === false && (e2.keyCode !== 32 || searchBuffer.length !== 0)) {
        menu.value !== true && showPopup(e2);
        const char = e2.key.toLocaleLowerCase(), keyRepeat = searchBuffer.length === 1 && searchBuffer[0] === char;
        searchBufferExp = Date.now() + 1500;
        if (keyRepeat === false) {
          stopAndPrevent(e2);
          searchBuffer += char;
        }
        const searchRe = new RegExp("^" + searchBuffer.split("").map((l2) => reEscapeList.indexOf(l2) !== -1 ? "\\" + l2 : l2).join(".*"), "i");
        let index = optionIndex.value;
        if (keyRepeat === true || index < 0 || searchRe.test(getOptionLabel.value(props2.options[index])) !== true) {
          do {
            index = normalizeToInterval(index + 1, -1, optionsLength - 1);
          } while (index !== optionIndex.value && (isOptionDisabled.value(props2.options[index]) === true || searchRe.test(getOptionLabel.value(props2.options[index])) !== true));
        }
        if (optionIndex.value !== index) {
          nextTick$1(() => {
            setOptionIndex(index);
            scrollTo(index);
            if (index >= 0 && props2.useInput === true && props2.fillInput === true) {
              setInputValue(getOptionLabel.value(props2.options[index]), true);
            }
          });
        }
        return;
      }
      if (e2.keyCode !== 13 && (e2.keyCode !== 32 || props2.useInput === true || searchBuffer !== "") && (e2.keyCode !== 9 || tabShouldSelect === false)) return;
      e2.keyCode !== 9 && stopAndPrevent(e2);
      if (optionIndex.value !== -1 && optionIndex.value < optionsLength) {
        toggleOption(props2.options[optionIndex.value]);
        return;
      }
      if (newValueModeValid === true) {
        const done = (val, mode) => {
          if (mode) {
            if (validateNewValueMode(mode) !== true) {
              return;
            }
          } else {
            mode = props2.newValueMode;
          }
          updateInputValue("", props2.multiple !== true, true);
          if (val === void 0 || val === null) {
            return;
          }
          const fn = mode === "toggle" ? toggleOption : add2;
          fn(val, mode === "add-unique");
          if (props2.multiple !== true) {
            targetRef.value !== null && targetRef.value.focus();
            hidePopup();
          }
        };
        if (props2.onNewValue !== void 0) {
          emit2("newValue", inputValue.value, done);
        } else {
          done(inputValue.value);
        }
        if (props2.multiple !== true) {
          return;
        }
      }
      if (menu.value === true) {
        closeMenu();
      } else if (state.innerLoading.value !== true) {
        showPopup();
      }
    }
    function getVirtualScrollEl() {
      return hasDialog === true ? menuContentRef.value : menuRef.value !== null && menuRef.value.contentEl !== null ? menuRef.value.contentEl : void 0;
    }
    function getVirtualScrollTarget() {
      return getVirtualScrollEl();
    }
    function getSelection() {
      if (props2.hideSelected === true) {
        return [];
      }
      if (slots["selected-item"] !== void 0) {
        return selectedScope.value.map((scope) => slots["selected-item"](scope)).slice();
      }
      if (slots.selected !== void 0) {
        return [].concat(slots.selected());
      }
      if (props2.useChips === true) {
        return selectedScope.value.map((scope, i) => h$1(QChip, {
          key: "option-" + i,
          removable: state.editable.value === true && isOptionDisabled.value(scope.opt) !== true,
          dense: true,
          textColor: props2.color,
          tabindex: tabindex.value,
          onRemove() {
            scope.removeAtIndex(i);
          }
        }, () => h$1("span", {
          class: "ellipsis",
          [scope.html === true ? "innerHTML" : "textContent"]: getOptionLabel.value(scope.opt)
        })));
      }
      return [
        h$1("span", {
          [valueAsHtml.value === true ? "innerHTML" : "textContent"]: ariaCurrentValue.value
        })
      ];
    }
    function getAllOptions() {
      if (noOptions.value === true) {
        return slots["no-option"] !== void 0 ? slots["no-option"]({ inputValue: inputValue.value }) : void 0;
      }
      const fn = slots.option !== void 0 ? slots.option : (scope) => {
        return h$1(QItem, {
          key: scope.index,
          ...scope.itemProps
        }, () => {
          return h$1(
            QItemSection,
            () => h$1(
              QItemLabel,
              () => h$1("span", {
                [scope.html === true ? "innerHTML" : "textContent"]: scope.label
              })
            )
          );
        });
      };
      let options = padVirtualScroll("div", optionScope.value.map(fn));
      if (slots["before-options"] !== void 0) {
        options = slots["before-options"]().concat(options);
      }
      return hMergeSlot(slots["after-options"], options);
    }
    function getInput(fromDialog, isTarget) {
      const attrs = isTarget === true ? { ...comboboxAttrs.value, ...state.splitAttrs.attributes.value } : void 0;
      const data = {
        ref: isTarget === true ? targetRef : void 0,
        key: "i_t",
        class: computedInputClass.value,
        style: props2.inputStyle,
        value: inputValue.value !== void 0 ? inputValue.value : "",
        // required for Android in order to show ENTER key when in form
        type: "search",
        ...attrs,
        id: isTarget === true ? state.targetUid.value : void 0,
        maxlength: props2.maxlength,
        autocomplete: props2.autocomplete,
        "data-autofocus": fromDialog === true || props2.autofocus === true || void 0,
        disabled: props2.disable === true,
        readonly: props2.readonly === true,
        ...inputControlEvents.value
      };
      if (fromDialog !== true && hasDialog === true) {
        if (Array.isArray(data.class) === true) {
          data.class = [...data.class, "no-pointer-events"];
        } else {
          data.class += " no-pointer-events";
        }
      }
      return h$1("input", data);
    }
    function onInput(e2) {
      if (filterTimer !== null) {
        clearTimeout(filterTimer);
        filterTimer = null;
      }
      if (inputValueTimer !== null) {
        clearTimeout(inputValueTimer);
        inputValueTimer = null;
      }
      if (e2 && e2.target && e2.target.qComposing === true) {
        return;
      }
      setInputValue(e2.target.value || "");
      userInputValue = true;
      defaultInputValue = inputValue.value;
      if (state.focused.value !== true && (hasDialog !== true || dialogFieldFocused.value === true)) {
        state.focus();
      }
      if (props2.onFilter !== void 0) {
        filterTimer = setTimeout(() => {
          filterTimer = null;
          filter2(inputValue.value);
        }, props2.inputDebounce);
      }
    }
    function setInputValue(val, emitImmediately) {
      if (inputValue.value !== val) {
        inputValue.value = val;
        if (emitImmediately === true || props2.inputDebounce === 0 || props2.inputDebounce === "0") {
          emit2("inputValue", val);
        } else {
          inputValueTimer = setTimeout(() => {
            inputValueTimer = null;
            emit2("inputValue", val);
          }, props2.inputDebounce);
        }
      }
    }
    function updateInputValue(val, noFiltering, internal) {
      userInputValue = internal !== true;
      if (props2.useInput === true) {
        setInputValue(val, true);
        if (noFiltering === true || internal !== true) {
          defaultInputValue = val;
        }
        noFiltering !== true && filter2(val);
      }
    }
    function filter2(val, keepClosed, afterUpdateFn) {
      if (props2.onFilter === void 0 || keepClosed !== true && state.focused.value !== true) {
        return;
      }
      if (state.innerLoading.value === true) {
        emit2("filterAbort");
      } else {
        state.innerLoading.value = true;
        innerLoadingIndicator.value = true;
      }
      if (val !== "" && props2.multiple !== true && innerValue.value.length !== 0 && userInputValue !== true && val === getOptionLabel.value(innerValue.value[0])) {
        val = "";
      }
      const localFilterId = setTimeout(() => {
        menu.value === true && (menu.value = false);
      }, 10);
      filterId !== null && clearTimeout(filterId);
      filterId = localFilterId;
      emit2(
        "filter",
        val,
        (fn, afterFn) => {
          if ((keepClosed === true || state.focused.value === true) && filterId === localFilterId) {
            clearTimeout(filterId);
            typeof fn === "function" && fn();
            innerLoadingIndicator.value = false;
            nextTick$1(() => {
              state.innerLoading.value = false;
              if (state.editable.value === true) {
                if (keepClosed === true) {
                  menu.value === true && hidePopup();
                } else if (menu.value === true) {
                  updateMenu(true);
                } else {
                  menu.value = true;
                }
              }
              typeof afterFn === "function" && nextTick$1(() => {
                afterFn(proxy);
              });
              typeof afterUpdateFn === "function" && nextTick$1(() => {
                afterUpdateFn(proxy);
              });
            });
          }
        },
        () => {
          if (state.focused.value === true && filterId === localFilterId) {
            clearTimeout(filterId);
            state.innerLoading.value = false;
            innerLoadingIndicator.value = false;
          }
          menu.value === true && (menu.value = false);
        }
      );
    }
    function getMenu() {
      return h$1(QMenu, {
        ref: menuRef,
        class: menuContentClass.value,
        style: props2.popupContentStyle,
        modelValue: menu.value,
        fit: props2.menuShrink !== true,
        cover: props2.optionsCover === true && noOptions.value !== true && props2.useInput !== true,
        anchor: props2.menuAnchor,
        self: props2.menuSelf,
        offset: props2.menuOffset,
        dark: isOptionsDark.value,
        noParentEvent: true,
        noRefocus: true,
        noFocus: true,
        noRouteDismiss: props2.popupNoRouteDismiss,
        square: squaredMenu.value,
        transitionShow: props2.transitionShow,
        transitionHide: props2.transitionHide,
        transitionDuration: props2.transitionDuration,
        separateClosePopup: true,
        ...listboxAttrs.value,
        onScrollPassive: onVirtualScrollEvt,
        onBeforeShow: onControlPopupShow,
        onBeforeHide: onMenuBeforeHide,
        onShow: onMenuShow
      }, getAllOptions);
    }
    function onMenuBeforeHide(e2) {
      onControlPopupHide(e2);
      closeMenu();
    }
    function onMenuShow() {
      setVirtualScrollSize();
    }
    function onDialogFieldFocus(e2) {
      stop(e2);
      targetRef.value !== null && targetRef.value.focus();
      dialogFieldFocused.value = true;
      window.scrollTo(window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, 0);
    }
    function onDialogFieldBlur(e2) {
      stop(e2);
      nextTick$1(() => {
        dialogFieldFocused.value = false;
      });
    }
    function getDialog() {
      const content2 = [
        h$1(QField, {
          class: `col-auto ${state.fieldClass.value}`,
          ...innerFieldProps.value,
          for: state.targetUid.value,
          dark: isOptionsDark.value,
          square: true,
          loading: innerLoadingIndicator.value,
          itemAligned: false,
          filled: true,
          stackLabel: inputValue.value.length !== 0,
          ...state.splitAttrs.listeners.value,
          onFocus: onDialogFieldFocus,
          onBlur: onDialogFieldBlur
        }, {
          ...slots,
          rawControl: () => state.getControl(true),
          before: void 0,
          after: void 0
        })
      ];
      menu.value === true && content2.push(
        h$1("div", {
          ref: menuContentRef,
          class: menuContentClass.value + " scroll",
          style: props2.popupContentStyle,
          ...listboxAttrs.value,
          onClick: prevent,
          onScrollPassive: onVirtualScrollEvt
        }, getAllOptions())
      );
      return h$1(QDialog, {
        ref: dialogRef,
        modelValue: dialog.value,
        position: props2.useInput === true ? "top" : void 0,
        transitionShow: transitionShowComputed,
        transitionHide: props2.transitionHide,
        transitionDuration: props2.transitionDuration,
        noRouteDismiss: props2.popupNoRouteDismiss,
        onBeforeShow: onControlPopupShow,
        onBeforeHide: onDialogBeforeHide,
        onHide: onDialogHide,
        onShow: onDialogShow
      }, () => h$1("div", {
        class: "q-select__dialog" + (isOptionsDark.value === true ? " q-select__dialog--dark q-dark" : "") + (dialogFieldFocused.value === true ? " q-select__dialog--focused" : "")
      }, content2));
    }
    function onDialogBeforeHide(e2) {
      onControlPopupHide(e2);
      if (dialogRef.value !== null) {
        dialogRef.value.__updateRefocusTarget(
          state.rootRef.value.querySelector(".q-field__native > [tabindex]:last-child")
        );
      }
      state.focused.value = false;
    }
    function onDialogHide(e2) {
      hidePopup();
      state.focused.value === false && emit2("blur", e2);
      resetInputValue();
    }
    function onDialogShow() {
      const el = document.activeElement;
      if ((el === null || el.id !== state.targetUid.value) && targetRef.value !== null && targetRef.value !== el) {
        targetRef.value.focus();
      }
      setVirtualScrollSize();
    }
    function closeMenu() {
      if (dialog.value === true) {
        return;
      }
      optionIndex.value = -1;
      if (menu.value === true) {
        menu.value = false;
      }
      if (state.focused.value === false) {
        if (filterId !== null) {
          clearTimeout(filterId);
          filterId = null;
        }
        if (state.innerLoading.value === true) {
          emit2("filterAbort");
          state.innerLoading.value = false;
          innerLoadingIndicator.value = false;
        }
      }
    }
    function showPopup(e2) {
      if (state.editable.value !== true) {
        return;
      }
      if (hasDialog === true) {
        state.onControlFocusin(e2);
        dialog.value = true;
        nextTick$1(() => {
          state.focus();
        });
      } else {
        state.focus();
      }
      if (props2.onFilter !== void 0) {
        filter2(inputValue.value);
      } else if (noOptions.value !== true || slots["no-option"] !== void 0) {
        menu.value = true;
      }
    }
    function hidePopup() {
      dialog.value = false;
      closeMenu();
    }
    function resetInputValue() {
      props2.useInput === true && updateInputValue(
        props2.multiple !== true && props2.fillInput === true && innerValue.value.length !== 0 ? getOptionLabel.value(innerValue.value[0]) || "" : "",
        true,
        true
      );
    }
    function updateMenu(show) {
      let optionIndex2 = -1;
      if (show === true) {
        if (innerValue.value.length !== 0) {
          const val = getOptionValue.value(innerValue.value[0]);
          optionIndex2 = props2.options.findIndex((v2) => isDeepEqual(getOptionValue.value(v2), val));
        }
        localResetVirtualScroll(optionIndex2);
      }
      setOptionIndex(optionIndex2);
    }
    function rerenderMenu(newLength, oldLength) {
      if (menu.value === true && state.innerLoading.value === false) {
        localResetVirtualScroll(-1, true);
        nextTick$1(() => {
          if (menu.value === true && state.innerLoading.value === false) {
            if (newLength > oldLength) {
              localResetVirtualScroll();
            } else {
              updateMenu(true);
            }
          }
        });
      }
    }
    function updateMenuPosition() {
      if (dialog.value === false && menuRef.value !== null) {
        menuRef.value.updatePosition();
      }
    }
    function onControlPopupShow(e2) {
      e2 !== void 0 && stop(e2);
      emit2("popupShow", e2);
      state.hasPopupOpen = true;
      state.onControlFocusin(e2);
    }
    function onControlPopupHide(e2) {
      e2 !== void 0 && stop(e2);
      emit2("popupHide", e2);
      state.hasPopupOpen = false;
      state.onControlFocusout(e2);
    }
    function updatePreState() {
      hasDialog = $q.platform.is.mobile !== true && props2.behavior !== "dialog" ? false : props2.behavior !== "menu" && (props2.useInput === true ? slots["no-option"] !== void 0 || props2.onFilter !== void 0 || noOptions.value === false : true);
      transitionShowComputed = $q.platform.is.ios === true && hasDialog === true && props2.useInput === true ? "fade" : props2.transitionShow;
    }
    onBeforeUpdate(updatePreState);
    onUpdated(updateMenuPosition);
    updatePreState();
    onBeforeUnmount(() => {
      filterTimer !== null && clearTimeout(filterTimer);
      inputValueTimer !== null && clearTimeout(inputValueTimer);
    });
    Object.assign(proxy, {
      showPopup,
      hidePopup,
      removeAtIndex,
      add: add2,
      toggleOption,
      getOptionIndex: () => optionIndex.value,
      setOptionIndex,
      moveOptionSelection,
      filter: filter2,
      updateMenuPosition,
      updateInputValue,
      isOptionSelected,
      getEmittingOptionValue,
      isOptionDisabled: (...args) => isOptionDisabled.value.apply(null, args) === true,
      getOptionValue: (...args) => getOptionValue.value.apply(null, args),
      getOptionLabel: (...args) => getOptionLabel.value.apply(null, args)
    });
    Object.assign(state, {
      innerValue,
      fieldClass: computed(
        () => `q-select q-field--auto-height q-select--with${props2.useInput !== true ? "out" : ""}-input q-select--with${props2.useChips !== true ? "out" : ""}-chips q-select--${props2.multiple === true ? "multiple" : "single"}`
      ),
      inputRef,
      targetRef,
      hasValue,
      showPopup,
      floatingLabel: computed(
        () => props2.hideSelected !== true && hasValue.value === true || typeof inputValue.value === "number" || inputValue.value.length !== 0 || fieldValueIsFilled(props2.displayValue)
      ),
      getControlChild: () => {
        if (state.editable.value !== false && (dialog.value === true || noOptions.value !== true || slots["no-option"] !== void 0)) {
          return hasDialog === true ? getDialog() : getMenu();
        } else if (state.hasPopupOpen === true) {
          state.hasPopupOpen = false;
        }
      },
      controlEvents: {
        onFocusin(e2) {
          state.onControlFocusin(e2);
        },
        onFocusout(e2) {
          state.onControlFocusout(e2, () => {
            resetInputValue();
            closeMenu();
          });
        },
        onClick(e2) {
          prevent(e2);
          if (hasDialog !== true && menu.value === true) {
            closeMenu();
            targetRef.value !== null && targetRef.value.focus();
            return;
          }
          showPopup(e2);
        }
      },
      getControl: (fromDialog) => {
        const child = getSelection();
        const isTarget = fromDialog === true || dialog.value !== true || hasDialog !== true;
        if (props2.useInput === true) {
          child.push(getInput(fromDialog, isTarget));
        } else if (state.editable.value === true) {
          const attrs2 = isTarget === true ? comboboxAttrs.value : void 0;
          child.push(
            h$1("input", {
              ref: isTarget === true ? targetRef : void 0,
              key: "d_t",
              class: "q-select__focus-target",
              id: isTarget === true ? state.targetUid.value : void 0,
              value: ariaCurrentValue.value,
              readonly: true,
              "data-autofocus": fromDialog === true || props2.autofocus === true || void 0,
              ...attrs2,
              onKeydown: onTargetKeydown,
              onKeyup: onTargetKeyup,
              onKeypress: onTargetKeypress
            })
          );
          if (isTarget === true && typeof props2.autocomplete === "string" && props2.autocomplete.length !== 0) {
            child.push(
              h$1("input", {
                class: "q-select__autocomplete-input",
                autocomplete: props2.autocomplete,
                tabindex: -1,
                onKeyup: onTargetAutocomplete
              })
            );
          }
        }
        if (nameProp.value !== void 0 && props2.disable !== true && innerOptionsValue.value.length !== 0) {
          const opts = innerOptionsValue.value.map((value2) => h$1("option", { value: value2, selected: true }));
          child.push(
            h$1("select", {
              class: "hidden",
              name: nameProp.value,
              multiple: props2.multiple
            }, opts)
          );
        }
        const attrs = props2.useInput === true || isTarget !== true ? void 0 : state.splitAttrs.attributes.value;
        return h$1("div", {
          class: "q-field__native row items-center",
          ...attrs,
          ...state.splitAttrs.listeners.value
        }, child);
      },
      getInnerAppend: () => props2.loading !== true && innerLoadingIndicator.value !== true && props2.hideDropdownIcon !== true ? [
        h$1(QIcon, {
          class: "q-select__dropdown-icon" + (menu.value === true ? " rotate-180" : ""),
          name: dropdownArrowIcon.value
        })
      ] : null
    });
    return useField(state);
  }
});
const useRatioProps = {
  ratio: [String, Number]
};
function useRatio(props2, naturalRatio) {
  return computed(() => {
    const ratio = Number(
      props2.ratio || (naturalRatio !== void 0 ? naturalRatio.value : void 0)
    );
    return isNaN(ratio) !== true && ratio > 0 ? { paddingBottom: `${100 / ratio}%` } : null;
  });
}
const defaultRatio = 1.7778;
const QImg = createComponent({
  name: "QImg",
  props: {
    ...useRatioProps,
    src: String,
    srcset: String,
    sizes: String,
    alt: String,
    crossorigin: String,
    decoding: String,
    referrerpolicy: String,
    draggable: Boolean,
    loading: {
      type: String,
      default: "lazy"
    },
    loadingShowDelay: {
      type: [Number, String],
      default: 0
    },
    fetchpriority: {
      type: String,
      default: "auto"
    },
    width: String,
    height: String,
    initialRatio: {
      type: [Number, String],
      default: defaultRatio
    },
    placeholderSrc: String,
    errorSrc: String,
    fit: {
      type: String,
      default: "cover"
    },
    position: {
      type: String,
      default: "50% 50%"
    },
    imgClass: String,
    imgStyle: Object,
    noSpinner: Boolean,
    noNativeMenu: Boolean,
    noTransition: Boolean,
    spinnerColor: String,
    spinnerSize: String
  },
  emits: ["load", "error"],
  setup(props2, { slots, emit: emit2 }) {
    const naturalRatio = ref(props2.initialRatio);
    const ratioStyle = useRatio(props2, naturalRatio);
    const vm2 = getCurrentInstance();
    const { registerTimeout: registerLoadTimeout, removeTimeout: removeLoadTimeout } = useTimeout();
    const { registerTimeout: registerLoadShowTimeout, removeTimeout: removeLoadShowTimeout } = useTimeout();
    const placeholderImg = computed(() => props2.placeholderSrc !== void 0 ? { src: props2.placeholderSrc } : null);
    const errorImg = computed(() => props2.errorSrc !== void 0 ? { src: props2.errorSrc, __qerror: true } : null);
    const images = [
      ref(null),
      ref(placeholderImg.value)
    ];
    const position2 = ref(0);
    const isLoading = ref(false);
    const hasError = ref(false);
    const classes = computed(
      () => `q-img q-img--${props2.noNativeMenu === true ? "no-" : ""}menu`
    );
    const style = computed(() => ({
      width: props2.width,
      height: props2.height
    }));
    const imgClass = computed(
      () => `q-img__image ${props2.imgClass !== void 0 ? props2.imgClass + " " : ""}q-img__image--with${props2.noTransition === true ? "out" : ""}-transition q-img__image--`
    );
    const imgStyle = computed(() => ({
      ...props2.imgStyle,
      objectFit: props2.fit,
      objectPosition: props2.position
    }));
    function setLoading() {
      removeLoadShowTimeout();
      if (props2.loadingShowDelay === 0) {
        isLoading.value = true;
        return;
      }
      registerLoadShowTimeout(() => {
        isLoading.value = true;
      }, props2.loadingShowDelay);
    }
    function clearLoading() {
      removeLoadShowTimeout();
      isLoading.value = false;
    }
    function onLoad({ target: target2 }) {
      if (vmIsDestroyed(vm2) === false) {
        removeLoadTimeout();
        naturalRatio.value = target2.naturalHeight === 0 ? 0.5 : target2.naturalWidth / target2.naturalHeight;
        waitForCompleteness(target2, 1);
      }
    }
    function waitForCompleteness(target2, count) {
      if (count === 1e3 || vmIsDestroyed(vm2) === true) return;
      if (target2.complete === true) {
        onReady(target2);
      } else {
        registerLoadTimeout(() => {
          waitForCompleteness(target2, count + 1);
        }, 50);
      }
    }
    function onReady(target2) {
      if (vmIsDestroyed(vm2) === true) return;
      position2.value = position2.value ^ 1;
      images[position2.value].value = null;
      clearLoading();
      if (target2.getAttribute("__qerror") !== "true") {
        hasError.value = false;
      }
      emit2("load", target2.currentSrc || target2.src);
    }
    function onError(err) {
      removeLoadTimeout();
      clearLoading();
      hasError.value = true;
      images[position2.value].value = errorImg.value;
      images[position2.value ^ 1].value = placeholderImg.value;
      emit2("error", err);
    }
    function getImage(index) {
      const img = images[index].value;
      const data = {
        key: "img_" + index,
        class: imgClass.value,
        style: imgStyle.value,
        alt: props2.alt,
        crossorigin: props2.crossorigin,
        decoding: props2.decoding,
        referrerpolicy: props2.referrerpolicy,
        height: props2.height,
        width: props2.width,
        loading: props2.loading,
        fetchpriority: props2.fetchpriority,
        "aria-hidden": "true",
        draggable: props2.draggable,
        ...img
      };
      if (position2.value === index) {
        Object.assign(data, {
          class: data.class + "current",
          onLoad,
          onError
        });
      } else {
        data.class += "loaded";
      }
      return h$1(
        "div",
        { class: "q-img__container absolute-full", key: "img" + index },
        h$1("img", data)
      );
    }
    function getContent() {
      if (isLoading.value === false) {
        return h$1("div", {
          key: "content",
          class: "q-img__content absolute-full q-anchor--skip"
        }, hSlot(slots[hasError.value === true ? "error" : "default"]));
      }
      return h$1("div", {
        key: "loading",
        class: "q-img__loading absolute-full flex flex-center"
      }, slots.loading !== void 0 ? slots.loading() : props2.noSpinner === true ? void 0 : [
        h$1(QSpinner, {
          color: props2.spinnerColor,
          size: props2.spinnerSize
        })
      ]);
    }
    {
      let watchSrc = function() {
        watch(
          () => props2.src || props2.srcset || props2.sizes ? {
            src: props2.src,
            srcset: props2.srcset,
            sizes: props2.sizes
          } : null,
          (imgProps) => {
            removeLoadTimeout();
            hasError.value = false;
            if (imgProps === null) {
              clearLoading();
              images[position2.value ^ 1].value = placeholderImg.value;
            } else {
              setLoading();
            }
            images[position2.value].value = imgProps;
          },
          { immediate: true }
        );
      };
      if (isRuntimeSsrPreHydration.value === true) {
        onMounted(watchSrc);
      } else {
        watchSrc();
      }
    }
    return () => {
      const content2 = [];
      if (ratioStyle.value !== null) {
        content2.push(
          h$1("div", { key: "filler", style: ratioStyle.value })
        );
      }
      if (images[0].value !== null) {
        content2.push(
          getImage(0)
        );
      }
      if (images[1].value !== null) {
        content2.push(
          getImage(1)
        );
      }
      content2.push(
        h$1(Transition, { name: "q-transition--fade" }, getContent)
      );
      return h$1("div", {
        key: "main",
        class: classes.value,
        style: style.value,
        role: "img",
        "aria-label": props2.alt
      }, content2);
    };
  }
});
const duration$1 = 150;
const QDrawer = createComponent({
  name: "QDrawer",
  inheritAttrs: false,
  props: {
    ...useModelToggleProps,
    ...useDarkProps,
    side: {
      type: String,
      default: "left",
      validator: (v2) => ["left", "right"].includes(v2)
    },
    width: {
      type: Number,
      default: 300
    },
    mini: Boolean,
    miniToOverlay: Boolean,
    miniWidth: {
      type: Number,
      default: 57
    },
    noMiniAnimation: Boolean,
    breakpoint: {
      type: Number,
      default: 1023
    },
    showIfAbove: Boolean,
    behavior: {
      type: String,
      validator: (v2) => ["default", "desktop", "mobile"].includes(v2),
      default: "default"
    },
    bordered: Boolean,
    elevated: Boolean,
    overlay: Boolean,
    persistent: Boolean,
    noSwipeOpen: Boolean,
    noSwipeClose: Boolean,
    noSwipeBackdrop: Boolean
  },
  emits: [
    ...useModelToggleEmits,
    "onLayout",
    "miniState"
  ],
  setup(props2, { slots, emit: emit2, attrs }) {
    const vm2 = getCurrentInstance();
    const { proxy: { $q } } = vm2;
    const isDark = useDark(props2, $q);
    const { preventBodyScroll } = usePreventScroll();
    const { registerTimeout, removeTimeout } = useTimeout();
    const $layout = inject(layoutKey, emptyRenderFn);
    if ($layout === emptyRenderFn) {
      console.error("QDrawer needs to be child of QLayout");
      return emptyRenderFn;
    }
    let lastDesktopState, timerMini = null, layoutTotalWidthWatcher;
    const belowBreakpoint = ref(
      props2.behavior === "mobile" || props2.behavior !== "desktop" && $layout.totalWidth.value <= props2.breakpoint
    );
    const isMini = computed(
      () => props2.mini === true && belowBreakpoint.value !== true
    );
    const size2 = computed(() => isMini.value === true ? props2.miniWidth : props2.width);
    const showing = ref(
      props2.showIfAbove === true && belowBreakpoint.value === false ? true : props2.modelValue === true
    );
    const hideOnRouteChange = computed(
      () => props2.persistent !== true && (belowBreakpoint.value === true || onScreenOverlay.value === true)
    );
    function handleShow(evt, noEvent) {
      addToHistory();
      evt !== false && $layout.animate();
      applyPosition(0);
      if (belowBreakpoint.value === true) {
        const otherInstance = $layout.instances[otherSide.value];
        if (otherInstance !== void 0 && otherInstance.belowBreakpoint === true) {
          otherInstance.hide(false);
        }
        applyBackdrop(1);
        $layout.isContainer.value !== true && preventBodyScroll(true);
      } else {
        applyBackdrop(0);
        evt !== false && setScrollable(false);
      }
      registerTimeout(() => {
        evt !== false && setScrollable(true);
        noEvent !== true && emit2("show", evt);
      }, duration$1);
    }
    function handleHide(evt, noEvent) {
      removeFromHistory();
      evt !== false && $layout.animate();
      applyBackdrop(0);
      applyPosition(stateDirection.value * size2.value);
      cleanup();
      if (noEvent !== true) {
        registerTimeout(() => {
          emit2("hide", evt);
        }, duration$1);
      } else {
        removeTimeout();
      }
    }
    const { show, hide } = useModelToggle({
      showing,
      hideOnRouteChange,
      handleShow,
      handleHide
    });
    const { addToHistory, removeFromHistory } = useHistory(showing, hide, hideOnRouteChange);
    const instance = {
      belowBreakpoint,
      hide
    };
    const rightSide = computed(() => props2.side === "right");
    const stateDirection = computed(
      () => ($q.lang.rtl === true ? -1 : 1) * (rightSide.value === true ? 1 : -1)
    );
    const flagBackdropBg = ref(0);
    const flagPanning = ref(false);
    const flagMiniAnimate = ref(false);
    const flagContentPosition = ref(
      // starting with "hidden" for SSR
      size2.value * stateDirection.value
    );
    const otherSide = computed(() => rightSide.value === true ? "left" : "right");
    const offset = computed(() => showing.value === true && belowBreakpoint.value === false && props2.overlay === false ? props2.miniToOverlay === true ? props2.miniWidth : size2.value : 0);
    const fixed = computed(
      () => props2.overlay === true || props2.miniToOverlay === true || $layout.view.value.indexOf(rightSide.value ? "R" : "L") !== -1 || $q.platform.is.ios === true && $layout.isContainer.value === true
    );
    const onLayout = computed(
      () => props2.overlay === false && showing.value === true && belowBreakpoint.value === false
    );
    const onScreenOverlay = computed(
      () => props2.overlay === true && showing.value === true && belowBreakpoint.value === false
    );
    const backdropClass = computed(
      () => "fullscreen q-drawer__backdrop" + (showing.value === false && flagPanning.value === false ? " hidden" : "")
    );
    const backdropStyle = computed(() => ({
      backgroundColor: `rgba(0,0,0,${flagBackdropBg.value * 0.4})`
    }));
    const headerSlot = computed(() => rightSide.value === true ? $layout.rows.value.top[2] === "r" : $layout.rows.value.top[0] === "l");
    const footerSlot = computed(() => rightSide.value === true ? $layout.rows.value.bottom[2] === "r" : $layout.rows.value.bottom[0] === "l");
    const aboveStyle = computed(() => {
      const css2 = {};
      if ($layout.header.space === true && headerSlot.value === false) {
        if (fixed.value === true) {
          css2.top = `${$layout.header.offset}px`;
        } else if ($layout.header.space === true) {
          css2.top = `${$layout.header.size}px`;
        }
      }
      if ($layout.footer.space === true && footerSlot.value === false) {
        if (fixed.value === true) {
          css2.bottom = `${$layout.footer.offset}px`;
        } else if ($layout.footer.space === true) {
          css2.bottom = `${$layout.footer.size}px`;
        }
      }
      return css2;
    });
    const style = computed(() => {
      const style2 = {
        width: `${size2.value}px`,
        transform: `translateX(${flagContentPosition.value}px)`
      };
      return belowBreakpoint.value === true ? style2 : Object.assign(style2, aboveStyle.value);
    });
    const contentClass = computed(
      () => "q-drawer__content fit " + ($layout.isContainer.value !== true ? "scroll" : "overflow-auto")
    );
    const classes = computed(
      () => `q-drawer q-drawer--${props2.side}` + (flagMiniAnimate.value === true ? " q-drawer--mini-animate" : "") + (props2.bordered === true ? " q-drawer--bordered" : "") + (isDark.value === true ? " q-drawer--dark q-dark" : "") + (flagPanning.value === true ? " no-transition" : showing.value === true ? "" : " q-layout--prevent-focus") + (belowBreakpoint.value === true ? " fixed q-drawer--on-top q-drawer--mobile q-drawer--top-padding" : ` q-drawer--${isMini.value === true ? "mini" : "standard"}` + (fixed.value === true || onLayout.value !== true ? " fixed" : "") + (props2.overlay === true || props2.miniToOverlay === true ? " q-drawer--on-top" : "") + (headerSlot.value === true ? " q-drawer--top-padding" : ""))
    );
    const openDirective = computed(() => {
      const dir = $q.lang.rtl === true ? props2.side : otherSide.value;
      return [[
        TouchPan,
        onOpenPan,
        void 0,
        {
          [dir]: true,
          mouse: true
        }
      ]];
    });
    const contentCloseDirective = computed(() => {
      const dir = $q.lang.rtl === true ? otherSide.value : props2.side;
      return [[
        TouchPan,
        onClosePan,
        void 0,
        {
          [dir]: true,
          mouse: true
        }
      ]];
    });
    const backdropCloseDirective = computed(() => {
      const dir = $q.lang.rtl === true ? otherSide.value : props2.side;
      return [[
        TouchPan,
        onClosePan,
        void 0,
        {
          [dir]: true,
          mouse: true,
          mouseAllDir: true
        }
      ]];
    });
    function updateBelowBreakpoint() {
      updateLocal(belowBreakpoint, props2.behavior === "mobile" || props2.behavior !== "desktop" && $layout.totalWidth.value <= props2.breakpoint);
    }
    watch(belowBreakpoint, (val) => {
      if (val === true) {
        lastDesktopState = showing.value;
        showing.value === true && hide(false);
      } else if (props2.overlay === false && props2.behavior !== "mobile" && lastDesktopState !== false) {
        if (showing.value === true) {
          applyPosition(0);
          applyBackdrop(0);
          cleanup();
        } else {
          show(false);
        }
      }
    });
    watch(() => props2.side, (newSide, oldSide) => {
      if ($layout.instances[oldSide] === instance) {
        $layout.instances[oldSide] = void 0;
        $layout[oldSide].space = false;
        $layout[oldSide].offset = 0;
      }
      $layout.instances[newSide] = instance;
      $layout[newSide].size = size2.value;
      $layout[newSide].space = onLayout.value;
      $layout[newSide].offset = offset.value;
    });
    watch($layout.totalWidth, () => {
      if ($layout.isContainer.value === true || document.qScrollPrevented !== true) {
        updateBelowBreakpoint();
      }
    });
    watch(
      () => props2.behavior + props2.breakpoint,
      updateBelowBreakpoint
    );
    watch($layout.isContainer, (val) => {
      showing.value === true && preventBodyScroll(val !== true);
      val === true && updateBelowBreakpoint();
    });
    watch($layout.scrollbarWidth, () => {
      applyPosition(showing.value === true ? 0 : void 0);
    });
    watch(offset, (val) => {
      updateLayout("offset", val);
    });
    watch(onLayout, (val) => {
      emit2("onLayout", val);
      updateLayout("space", val);
    });
    watch(rightSide, () => {
      applyPosition();
    });
    watch(size2, (val) => {
      applyPosition();
      updateSizeOnLayout(props2.miniToOverlay, val);
    });
    watch(() => props2.miniToOverlay, (val) => {
      updateSizeOnLayout(val, size2.value);
    });
    watch(() => $q.lang.rtl, () => {
      applyPosition();
    });
    watch(() => props2.mini, () => {
      if (props2.noMiniAnimation) return;
      if (props2.modelValue === true) {
        animateMini();
        $layout.animate();
      }
    });
    watch(isMini, (val) => {
      emit2("miniState", val);
    });
    function applyPosition(position2) {
      if (position2 === void 0) {
        nextTick$1(() => {
          position2 = showing.value === true ? 0 : size2.value;
          applyPosition(stateDirection.value * position2);
        });
      } else {
        if ($layout.isContainer.value === true && rightSide.value === true && (belowBreakpoint.value === true || Math.abs(position2) === size2.value)) {
          position2 += stateDirection.value * $layout.scrollbarWidth.value;
        }
        flagContentPosition.value = position2;
      }
    }
    function applyBackdrop(x2) {
      flagBackdropBg.value = x2;
    }
    function setScrollable(v2) {
      const action = v2 === true ? "remove" : $layout.isContainer.value !== true ? "add" : "";
      action !== "" && document.body.classList[action]("q-body--drawer-toggle");
    }
    function animateMini() {
      timerMini !== null && clearTimeout(timerMini);
      if (vm2.proxy && vm2.proxy.$el) {
        vm2.proxy.$el.classList.add("q-drawer--mini-animate");
      }
      flagMiniAnimate.value = true;
      timerMini = setTimeout(() => {
        timerMini = null;
        flagMiniAnimate.value = false;
        if (vm2 && vm2.proxy && vm2.proxy.$el) {
          vm2.proxy.$el.classList.remove("q-drawer--mini-animate");
        }
      }, 150);
    }
    function onOpenPan(evt) {
      if (showing.value !== false) {
        return;
      }
      const width2 = size2.value, position2 = between(evt.distance.x, 0, width2);
      if (evt.isFinal === true) {
        const opened = position2 >= Math.min(75, width2);
        if (opened === true) {
          show();
        } else {
          $layout.animate();
          applyBackdrop(0);
          applyPosition(stateDirection.value * width2);
        }
        flagPanning.value = false;
        return;
      }
      applyPosition(
        ($q.lang.rtl === true ? rightSide.value !== true : rightSide.value) ? Math.max(width2 - position2, 0) : Math.min(0, position2 - width2)
      );
      applyBackdrop(
        between(position2 / width2, 0, 1)
      );
      if (evt.isFirst === true) {
        flagPanning.value = true;
      }
    }
    function onClosePan(evt) {
      if (showing.value !== true) {
        return;
      }
      const width2 = size2.value, dir = evt.direction === props2.side, position2 = ($q.lang.rtl === true ? dir !== true : dir) ? between(evt.distance.x, 0, width2) : 0;
      if (evt.isFinal === true) {
        const opened = Math.abs(position2) < Math.min(75, width2);
        if (opened === true) {
          $layout.animate();
          applyBackdrop(1);
          applyPosition(0);
        } else {
          hide();
        }
        flagPanning.value = false;
        return;
      }
      applyPosition(stateDirection.value * position2);
      applyBackdrop(between(1 - position2 / width2, 0, 1));
      if (evt.isFirst === true) {
        flagPanning.value = true;
      }
    }
    function cleanup() {
      preventBodyScroll(false);
      setScrollable(true);
    }
    function updateLayout(prop, val) {
      $layout.update(props2.side, prop, val);
    }
    function updateLocal(prop, val) {
      if (prop.value !== val) {
        prop.value = val;
      }
    }
    function updateSizeOnLayout(miniToOverlay, size3) {
      updateLayout("size", miniToOverlay === true ? props2.miniWidth : size3);
    }
    $layout.instances[props2.side] = instance;
    updateSizeOnLayout(props2.miniToOverlay, size2.value);
    updateLayout("space", onLayout.value);
    updateLayout("offset", offset.value);
    if (props2.showIfAbove === true && props2.modelValue !== true && showing.value === true && props2["onUpdate:modelValue"] !== void 0) {
      emit2("update:modelValue", true);
    }
    onMounted(() => {
      emit2("onLayout", onLayout.value);
      emit2("miniState", isMini.value);
      lastDesktopState = props2.showIfAbove === true;
      const fn = () => {
        const action = showing.value === true ? handleShow : handleHide;
        action(false, true);
      };
      if ($layout.totalWidth.value !== 0) {
        nextTick$1(fn);
        return;
      }
      layoutTotalWidthWatcher = watch($layout.totalWidth, () => {
        layoutTotalWidthWatcher();
        layoutTotalWidthWatcher = void 0;
        if (showing.value === false && props2.showIfAbove === true && belowBreakpoint.value === false) {
          show(false);
        } else {
          fn();
        }
      });
    });
    onBeforeUnmount(() => {
      layoutTotalWidthWatcher !== void 0 && layoutTotalWidthWatcher();
      if (timerMini !== null) {
        clearTimeout(timerMini);
        timerMini = null;
      }
      showing.value === true && cleanup();
      if ($layout.instances[props2.side] === instance) {
        $layout.instances[props2.side] = void 0;
        updateLayout("size", 0);
        updateLayout("offset", 0);
        updateLayout("space", false);
      }
    });
    return () => {
      const child = [];
      if (belowBreakpoint.value === true) {
        props2.noSwipeOpen === false && child.push(
          withDirectives(
            h$1("div", {
              key: "open",
              class: `q-drawer__opener fixed-${props2.side}`,
              "aria-hidden": "true"
            }),
            openDirective.value
          )
        );
        child.push(
          hDir(
            "div",
            {
              ref: "backdrop",
              class: backdropClass.value,
              style: backdropStyle.value,
              "aria-hidden": "true",
              onClick: hide
            },
            void 0,
            "backdrop",
            props2.noSwipeBackdrop !== true && showing.value === true,
            () => backdropCloseDirective.value
          )
        );
      }
      const mini = isMini.value === true && slots.mini !== void 0;
      const content2 = [
        h$1(
          "div",
          {
            ...attrs,
            key: "" + mini,
            // required otherwise Vue will not diff correctly
            class: [
              contentClass.value,
              attrs.class
            ]
          },
          mini === true ? slots.mini() : hSlot(slots.default)
        )
      ];
      if (props2.elevated === true && showing.value === true) {
        content2.push(
          h$1("div", {
            class: "q-layout__shadow absolute-full overflow-hidden no-pointer-events"
          })
        );
      }
      child.push(
        hDir(
          "aside",
          { ref: "content", class: classes.value, style: style.value },
          content2,
          "contentclose",
          props2.noSwipeClose !== true && belowBreakpoint.value === true,
          () => contentCloseDirective.value
        )
      );
      return h$1("div", { class: "q-drawer-container" }, child);
    };
  }
});
const _withScopeId$b = (n2) => (pushScopeId("data-v-7cb8e82f"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$f = /* @__PURE__ */ _withScopeId$b(() => /* @__PURE__ */ createBaseVNode("span", { class: "text-h5" }, "SENA IOT", -1));
const _hoisted_2$f = /* @__PURE__ */ _withScopeId$b(() => /* @__PURE__ */ createBaseVNode("img", {
  class: "q-pr-xl q-mr-xl",
  src: "/images/logo-blanco.png",
  style: { "height": "38px" }
}, null, -1));
const _hoisted_3$f = { class: "absolute-bottom bg-transparent text-black" };
const _hoisted_4$e = /* @__PURE__ */ _withScopeId$b(() => /* @__PURE__ */ createBaseVNode("img", { src: "/images/LOGO-SENA.png" }, null, -1));
const _hoisted_5$c = { class: "text-weight-bolder text-h6 text-uppercase" };
const _hoisted_6$a = { style: { "font-size": "10px" } };
const _hoisted_7$a = { style: { "font-size": "12px" } };
const _sfc_main$f = {
  __name: "Nav",
  setup(__props) {
    const useUsers = storeUsers();
    const router2 = useRouter();
    let currentRoute = ref(router2.currentRoute.value.path);
    const leftDrawerOpen = ref(false);
    let farm = ref(null);
    let optionsFarm = ref([]);
    onMounted(() => {
      leftDrawerOpen.value = false;
      farm.value = {
        label: `${useUsers.farm.codeFarm} - ${useUsers.farm.name}`,
        value: useUsers.farm._id
      };
      optionsFarm.value = useUsers.farms.map((farm2) => {
        return {
          label: `${farm2.codeFarm} - ${farm2.name}`,
          value: farm2._id
        };
      });
    });
    watch(() => router2.currentRoute.value.path, (value2) => {
      currentRoute.value = value2;
    });
    function onChangeSelectFarm(farm2) {
      useUsers.setFarm(farm2.value);
    }
    const menuList = [
      {
        icon: "supervisor_account",
        label: "Usuarios",
        separator: false,
        route: "/users",
        auth: ["ADMINISTRADOR"]
      },
      {
        icon: "supervisor_account",
        label: "Fincas",
        separator: false,
        route: "/farms",
        auth: ["ADMINISTRADOR"]
      },
      {
        icon: "sensors",
        label: "Sensores",
        separator: false,
        route: "/sensors",
        auth: ["ADMINISTRADOR"]
      },
      // {
      //   icon: 'home',
      //   label: 'Termometro',
      //   separator: false,
      //   route: '/termometro',
      //   auth: ['ADMINISTRADOR', 'USUARIO'],
      // },
      {
        icon: "thermostat",
        label: "Termohigrómetro",
        separator: false,
        route: "/termohigrometro",
        auth: ["ADMINISTRADOR", "USUARIO"]
      },
      {
        icon: "water_drop",
        label: "Báscula",
        separator: false,
        route: "/weighing",
        auth: ["ADMINISTRADOR", "USUARIO"]
      },
      {
        icon: "description",
        label: "Reportes",
        separator: false,
        route: "/report",
        auth: ["ADMINISTRADOR", "USUARIO"]
      }
    ];
    const itemActive = ref("Home");
    function logout() {
      api.remove("access_token");
      router2.push("/");
    }
    return (_ctx, _cache) => {
      const _component_router_view = resolveComponent("router-view");
      return openBlock(), createBlock(QLayout, { view: "hHh lpR fFf" }, {
        default: withCtx(() => [
          createVNode(QHeader, {
            elevated: "",
            class: "header text-white"
          }, {
            default: withCtx(() => [
              createVNode(QToolbar, null, {
                default: withCtx(() => [
                  createVNode(QBtn, {
                    dense: "",
                    flat: "",
                    round: "",
                    icon: "menu",
                    onClick: _cache[0] || (_cache[0] = ($event) => leftDrawerOpen.value = !leftDrawerOpen.value)
                  }),
                  _hoisted_1$f,
                  createVNode(QToolbarTitle, { class: "justify-center flex" }, {
                    default: withCtx(() => [
                      _hoisted_2$f
                    ]),
                    _: 1
                  }),
                  createVNode(QBtn, {
                    dense: "",
                    flat: "",
                    round: "",
                    icon: "logout",
                    onClick: logout
                  })
                ]),
                _: 1
              })
            ]),
            _: 1
          }),
          createVNode(QDrawer, {
            modelValue: leftDrawerOpen.value,
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => leftDrawerOpen.value = $event),
            "show-if-above": "",
            width: 250,
            breakpoint: 500,
            bordered: "",
            overlay: "",
            class: normalizeClass(_ctx.$q.dark.isActive ? "bg-grey-9" : "bg-grey-3")
          }, {
            default: withCtx(() => [
              createVNode(QScrollArea, { style: { "height": "calc(100% - 220px)", "margin-top": "220px", "border-right": "1px solid #ddd" } }, {
                default: withCtx(() => [
                  createVNode(QList, { style: { "padding-top": "20px" } }, {
                    default: withCtx(() => [
                      (openBlock(), createElementBlock(Fragment, null, renderList(menuList, (menuItem, index) => {
                        var _a2, _b2;
                        return openBlock(), createElementBlock(Fragment, { key: index }, [
                          unref(useUsers).user && ((_b2 = menuItem.auth) == null ? void 0 : _b2.includes((_a2 = unref(useUsers).user) == null ? void 0 : _a2.role)) ? withDirectives((openBlock(), createBlock(QItem, {
                            key: 0,
                            class: normalizeClass([menuItem.route === unref(currentRoute) ? "bg-green-6 text-white" : "bg-green-9", "text-white q-mb-md q-mx-lg"]),
                            style: { "border-radius": "12px", "width": "200px" },
                            clickable: "",
                            active: menuItem.route === unref(currentRoute),
                            to: menuItem.route,
                            onClick: ($event) => itemActive.value = menuItem.label
                          }, {
                            default: withCtx(() => [
                              createVNode(QItemSection, {
                                avatar: "",
                                class: "style-text",
                                style: { "min-width": "1px" }
                              }, {
                                default: withCtx(() => [
                                  createVNode(QIcon, {
                                    class: "",
                                    name: menuItem.icon
                                  }, null, 8, ["name"])
                                ]),
                                _: 2
                              }, 1024),
                              createVNode(QItemSection, { class: "style-text" }, {
                                default: withCtx(() => [
                                  createTextVNode(toDisplayString(menuItem.label), 1)
                                ]),
                                _: 2
                              }, 1024)
                            ]),
                            _: 2
                          }, 1032, ["class", "active", "to", "onClick"])), [
                            [Ripple]
                          ]) : createCommentVNode("", true)
                        ], 64);
                      }), 64))
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }),
              createVNode(QImg, {
                class: "absolute-top bg-grey-2 text-center",
                style: { "height": "220px" }
              }, {
                default: withCtx(() => {
                  var _a2, _b2;
                  return [
                    createBaseVNode("div", _hoisted_3$f, [
                      createVNode(QAvatar, {
                        size: "80px",
                        class: "q-pt-sm"
                      }, {
                        default: withCtx(() => [
                          _hoisted_4$e
                        ]),
                        _: 1
                      }),
                      createBaseVNode("div", _hoisted_5$c, toDisplayString(((_a2 = unref(useUsers).user) == null ? void 0 : _a2.role) || ""), 1),
                      createBaseVNode("div", _hoisted_6$a, toDisplayString(((_b2 = unref(useUsers).user) == null ? void 0 : _b2.email) || ""), 1),
                      createBaseVNode("div", _hoisted_7$a, [
                        createVNode(QSelect, {
                          class: "q-mt-sm",
                          dense: "",
                          outlined: "",
                          type: "text",
                          modelValue: unref(farm),
                          "onUpdate:modelValue": [
                            _cache[1] || (_cache[1] = ($event) => isRef(farm) ? farm.value = $event : farm = $event),
                            onChangeSelectFarm
                          ],
                          options: unref(optionsFarm),
                          label: "Finca",
                          "option-label": (row) => row.label,
                          "option-value": (row) => row.value,
                          "lazy-rules": "",
                          rules: [
                            (val) => val && val.toString().trim().length > 0 || "El campo es requerido"
                          ]
                        }, null, 8, ["modelValue", "options", "option-label", "option-value", "rules"])
                      ])
                    ])
                  ];
                }),
                _: 1
              })
            ]),
            _: 1
          }, 8, ["modelValue", "class"]),
          createVNode(QPageContainer, null, {
            default: withCtx(() => [
              createVNode(_component_router_view)
            ]),
            _: 1
          })
        ]),
        _: 1
      });
    };
  }
};
const Nav = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["__scopeId", "data-v-7cb8e82f"]]);
const usePageStickyProps = {
  position: {
    type: String,
    default: "bottom-right",
    validator: (v2) => [
      "top-right",
      "top-left",
      "bottom-right",
      "bottom-left",
      "top",
      "right",
      "bottom",
      "left"
    ].includes(v2)
  },
  offset: {
    type: Array,
    validator: (v2) => v2.length === 2
  },
  expand: Boolean
};
function usePageSticky() {
  const { props: props2, proxy: { $q } } = getCurrentInstance();
  const $layout = inject(layoutKey, emptyRenderFn);
  if ($layout === emptyRenderFn) {
    console.error("QPageSticky needs to be child of QLayout");
    return emptyRenderFn;
  }
  const attach = computed(() => {
    const pos = props2.position;
    return {
      top: pos.indexOf("top") !== -1,
      right: pos.indexOf("right") !== -1,
      bottom: pos.indexOf("bottom") !== -1,
      left: pos.indexOf("left") !== -1,
      vertical: pos === "top" || pos === "bottom",
      horizontal: pos === "left" || pos === "right"
    };
  });
  const top = computed(() => $layout.header.offset);
  const right = computed(() => $layout.right.offset);
  const bottom = computed(() => $layout.footer.offset);
  const left = computed(() => $layout.left.offset);
  const style = computed(() => {
    let posX = 0, posY = 0;
    const side = attach.value;
    const dir = $q.lang.rtl === true ? -1 : 1;
    if (side.top === true && top.value !== 0) {
      posY = `${top.value}px`;
    } else if (side.bottom === true && bottom.value !== 0) {
      posY = `${-bottom.value}px`;
    }
    if (side.left === true && left.value !== 0) {
      posX = `${dir * left.value}px`;
    } else if (side.right === true && right.value !== 0) {
      posX = `${-dir * right.value}px`;
    }
    const css2 = { transform: `translate(${posX}, ${posY})` };
    if (props2.offset) {
      css2.margin = `${props2.offset[1]}px ${props2.offset[0]}px`;
    }
    if (side.vertical === true) {
      if (left.value !== 0) {
        css2[$q.lang.rtl === true ? "right" : "left"] = `${left.value}px`;
      }
      if (right.value !== 0) {
        css2[$q.lang.rtl === true ? "left" : "right"] = `${right.value}px`;
      }
    } else if (side.horizontal === true) {
      if (top.value !== 0) {
        css2.top = `${top.value}px`;
      }
      if (bottom.value !== 0) {
        css2.bottom = `${bottom.value}px`;
      }
    }
    return css2;
  });
  const classes = computed(
    () => `q-page-sticky row flex-center fixed-${props2.position} q-page-sticky--${props2.expand === true ? "expand" : "shrink"}`
  );
  function getStickyContent(slots) {
    const content2 = hSlot(slots.default);
    return h$1(
      "div",
      {
        class: classes.value,
        style: style.value
      },
      props2.expand === true ? content2 : [h$1("div", content2)]
    );
  }
  return {
    $layout,
    getStickyContent
  };
}
const QPageSticky = createComponent({
  name: "QPageSticky",
  props: usePageStickyProps,
  setup(_2, { slots }) {
    const { getStickyContent } = usePageSticky();
    return () => getStickyContent(slots);
  }
});
const _withScopeId$a = (n2) => (pushScopeId("data-v-bccae473"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$e = {
  key: 0,
  id: "chart",
  class: "q-ma-lg"
};
const _hoisted_2$e = { class: "row contGraphic" };
const _hoisted_3$e = { class: "col-2 row last-value" };
const _hoisted_4$d = { class: "title text-primary" };
const _hoisted_5$b = {
  key: 1,
  class: "justify-center flex"
};
const _hoisted_6$9 = /* @__PURE__ */ _withScopeId$a(() => /* @__PURE__ */ createBaseVNode("h5", { class: "read-the-docs" }, "Sin datos para mostrar", -1));
const _hoisted_7$9 = [
  _hoisted_6$9
];
const _sfc_main$e = {
  __name: "LineChartBasic",
  props: ["data", "categories", "name", "title", "symbolLabel"],
  setup(__props) {
    let series = ref([]);
    let chartOptions = ref({});
    const { data, categories, name, title, symbolLabel } = __props;
    onBeforeMount(async () => {
      await setConfig();
    });
    const setConfig = async () => {
      series.value = [{
        name,
        data
      }];
      chartOptions.value = {
        chart: {
          height: 350,
          type: "line",
          toolbar: {
            offsetX: 10,
            tools: {
              download: true,
              selection: true,
              zoom: true,
              zoomin: true,
              zoomout: true,
              pan: true,
              reset: true,
              customIcons: []
            }
          }
        },
        dataLabels: {
          enabled: false
        },
        stroke: {
          curve: "straight"
        },
        title: {
          text: title,
          align: "center"
        },
        grid: {
          row: {
            colors: ["#f3f3f3", "transparent"],
            // takes an array which will be repeated on columns
            opacity: 0.5
          }
        },
        xaxis: {
          categories: categories.map((item) => item.split("-")[1]),
          // min: categories.length>20 ? categories.length-20 : 0,
          // max: categories.length,
          labels: {
            rotate: 0,
            hideOverlappingLabels: true,
            style: {
              fontSize: "12px"
            }
          },
          tickAmount: 4
        },
        markers: {
          size: 2,
          colors: ["#008ffb"],
          strokeColors: "#008ffb",
          strokeWidth: 2,
          hover: {
            sizeOffset: 3
          }
        },
        yaxis: {
          labels: {
            formatter: function(val) {
              return parseFloat(val).toFixed(1) + " " + symbolLabel;
            }
          }
        },
        tooltip: {
          x: {
            formatter: function(val) {
              return categories[val - 1];
            }
          }
        },
        annotations: {
          yaxis: [
            {
              y: Math.min(...data),
              // Valor mínimo
              borderColor: "#FF0000",
              label: {
                text: "Mínimo: " + Math.min(...data),
                style: {
                  color: "#FF0000",
                  fontSize: "12px"
                }
              }
            },
            {
              y: Math.max(...data),
              // Valor máximo
              borderColor: "#00FF00",
              label: {
                text: "Máximo: " + Math.max(...data),
                style: {
                  color: "#00FF00",
                  fontSize: "12px"
                }
              }
            }
          ]
        },
        responsive: [
          {
            breakpoint: 1e3,
            options: {
              title: {
                align: "left"
              }
            }
          },
          {
            breakpoint: 800,
            options: {
              title: {
                align: "left"
              },
              dataLabels: {
                enabled: false
              }
            }
          }
        ]
      };
    };
    const screenWidth = ref(window.innerWidth > 600 ? "col-10" : "col-12");
    return (_ctx, _cache) => {
      const _component_apexchart = resolveComponent("apexchart");
      return __props.data.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_1$e, [
        createBaseVNode("div", _hoisted_2$e, [
          createBaseVNode("div", {
            class: normalizeClass(screenWidth.value)
          }, [
            createVNode(_component_apexchart, {
              apexchart: "",
              type: "area",
              height: "350",
              options: unref(chartOptions),
              series: unref(series),
              id: __props.name
            }, null, 8, ["options", "series", "id"])
          ], 2),
          createBaseVNode("div", _hoisted_3$e, [
            createBaseVNode("span", _hoisted_4$d, toDisplayString(__props.title), 1),
            createBaseVNode("span", null, toDisplayString(unref(series)[0].data[unref(series)[0].data.length - 1] + " " + __props.symbolLabel), 1)
          ])
        ])
      ])) : (openBlock(), createElementBlock("div", _hoisted_5$b, _hoisted_7$9));
    };
  }
};
const LineChartBasic = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["__scopeId", "data-v-bccae473"]]);
const svg$1 = [
  h$1("g", [
    h$1("path", {
      fill: "none",
      stroke: "currentColor",
      "stroke-width": "5",
      "stroke-miterlimit": "10",
      d: "M58.4,51.7c-0.9-0.9-1.4-2-1.4-2.3s0.5-0.4,1.4-1.4 C70.8,43.8,79.8,30.5,80,15.5H70H30H20c0.2,15,9.2,28.1,21.6,32.3c0.9,0.9,1.4,1.2,1.4,1.5s-0.5,1.6-1.4,2.5 C29.2,56.1,20.2,69.5,20,85.5h10h40h10C79.8,69.5,70.8,55.9,58.4,51.7z"
    }),
    h$1("clipPath", {
      id: "uil-hourglass-clip1"
    }, [
      h$1("rect", {
        x: "15",
        y: "20",
        width: "70",
        height: "25"
      }, [
        h$1("animate", {
          attributeName: "height",
          from: "25",
          to: "0",
          dur: "1s",
          repeatCount: "indefinite",
          values: "25;0;0",
          keyTimes: "0;0.5;1"
        }),
        h$1("animate", {
          attributeName: "y",
          from: "20",
          to: "45",
          dur: "1s",
          repeatCount: "indefinite",
          values: "20;45;45",
          keyTimes: "0;0.5;1"
        })
      ])
    ]),
    h$1("clipPath", {
      id: "uil-hourglass-clip2"
    }, [
      h$1("rect", {
        x: "15",
        y: "55",
        width: "70",
        height: "25"
      }, [
        h$1("animate", {
          attributeName: "height",
          from: "0",
          to: "25",
          dur: "1s",
          repeatCount: "indefinite",
          values: "0;25;25",
          keyTimes: "0;0.5;1"
        }),
        h$1("animate", {
          attributeName: "y",
          from: "80",
          to: "55",
          dur: "1s",
          repeatCount: "indefinite",
          values: "80;55;55",
          keyTimes: "0;0.5;1"
        })
      ])
    ]),
    h$1("path", {
      d: "M29,23c3.1,11.4,11.3,19.5,21,19.5S67.9,34.4,71,23H29z",
      "clip-path": "url(#uil-hourglass-clip1)",
      fill: "currentColor"
    }),
    h$1("path", {
      d: "M71.6,78c-3-11.6-11.5-20-21.5-20s-18.5,8.4-21.5,20H71.6z",
      "clip-path": "url(#uil-hourglass-clip2)",
      fill: "currentColor"
    }),
    h$1("animateTransform", {
      attributeName: "transform",
      type: "rotate",
      from: "0 50 50",
      to: "180 50 50",
      repeatCount: "indefinite",
      dur: "1s",
      values: "0 50 50;0 50 50;180 50 50",
      keyTimes: "0;0.7;1"
    })
  ])
];
const QSpinnerHourglass = createComponent({
  name: "QSpinnerHourglass",
  props: useSpinnerProps,
  setup(props2) {
    const { cSize, classes } = useSpinner(props2);
    return () => h$1("svg", {
      class: classes.value,
      width: cSize.value,
      height: cSize.value,
      viewBox: "0 0 100 100",
      preserveAspectRatio: "xMidYMid",
      xmlns: "http://www.w3.org/2000/svg"
    }, svg$1);
  }
});
const _sfc_main$d = {};
const _hoisted_1$d = {
  class: "justify-center flex items-center",
  style: { "height": "90vh" }
};
const _hoisted_2$d = { class: "flex-col items-center text-center" };
const _hoisted_3$d = /* @__PURE__ */ createBaseVNode("p", { class: "text-green-9" }, "Cargando ...", -1);
function _sfc_render(_ctx, _cache) {
  return openBlock(), createElementBlock("div", _hoisted_1$d, [
    createBaseVNode("div", _hoisted_2$d, [
      createVNode(QSpinnerHourglass, {
        class: "text-green-9",
        size: "3em"
      }),
      _hoisted_3$d
    ])
  ]);
}
const Spinner = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render]]);
const _hoisted_1$c = {
  class: "row",
  style: { "margin-top": "20px" }
};
const _hoisted_2$c = /* @__PURE__ */ createBaseVNode("div", { class: "col-2" }, null, -1);
const _hoisted_3$c = { class: "col-8 text-center text-h4 text-weight-bold style-text" };
const _hoisted_4$c = /* @__PURE__ */ createBaseVNode("div", { class: "col-2" }, null, -1);
const _hoisted_5$a = /* @__PURE__ */ createBaseVNode("hr", {
  class: "bg-green-9 q-mb-lg",
  style: { "width": "83%", "height": "2px" }
}, null, -1);
const _sfc_main$c = {
  __name: "headerViewsLayout",
  props: {
    title: {
      type: String,
      default: "Título"
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createBaseVNode("div", _hoisted_1$c, [
          _hoisted_2$c,
          createBaseVNode("div", _hoisted_3$c, toDisplayString(props2.title), 1),
          _hoisted_4$c
        ]),
        _hoisted_5$a
      ]);
    };
  }
};
function useRenderCache() {
  let cache2 = /* @__PURE__ */ Object.create(null);
  return {
    getCache: (key, defaultValue) => cache2[key] === void 0 ? cache2[key] = typeof defaultValue === "function" ? defaultValue() : defaultValue : cache2[key],
    setCache(key, obj) {
      cache2[key] = obj;
    },
    hasCache(key) {
      return Object.hasOwnProperty.call(cache2, key);
    },
    clearCache(key) {
      if (key !== void 0) {
        delete cache2[key];
      } else {
        cache2 = /* @__PURE__ */ Object.create(null);
      }
    }
  };
}
const breaks = [
  -61,
  9,
  38,
  199,
  426,
  686,
  756,
  818,
  1111,
  1181,
  1210,
  1635,
  2060,
  2097,
  2192,
  2262,
  2324,
  2394,
  2456,
  3178
];
function toJalaali(gy, gm, gd) {
  if (Object.prototype.toString.call(gy) === "[object Date]") {
    gd = gy.getDate();
    gm = gy.getMonth() + 1;
    gy = gy.getFullYear();
  }
  return d2j(g2d(gy, gm, gd));
}
function toGregorian(jy, jm, jd) {
  return d2g(j2d(jy, jm, jd));
}
function isLeapJalaaliYear(jy) {
  return jalCalLeap(jy) === 0;
}
function jalaaliMonthLength(jy, jm) {
  if (jm <= 6) return 31;
  if (jm <= 11) return 30;
  if (isLeapJalaaliYear(jy)) return 30;
  return 29;
}
function jalCalLeap(jy) {
  const bl = breaks.length;
  let jp = breaks[0], jm, jump, leap, n2, i;
  if (jy < jp || jy >= breaks[bl - 1]) {
    throw new Error("Invalid Jalaali year " + jy);
  }
  for (i = 1; i < bl; i += 1) {
    jm = breaks[i];
    jump = jm - jp;
    if (jy < jm) {
      break;
    }
    jp = jm;
  }
  n2 = jy - jp;
  if (jump - n2 < 6) {
    n2 = n2 - jump + div(jump + 4, 33) * 33;
  }
  leap = mod(mod(n2 + 1, 33) - 1, 4);
  if (leap === -1) {
    leap = 4;
  }
  return leap;
}
function jalCal(jy, withoutLeap) {
  const bl = breaks.length, gy = jy + 621;
  let leapJ = -14, jp = breaks[0], jm, jump, leap, n2, i;
  if (jy < jp || jy >= breaks[bl - 1]) {
    throw new Error("Invalid Jalaali year " + jy);
  }
  for (i = 1; i < bl; i += 1) {
    jm = breaks[i];
    jump = jm - jp;
    if (jy < jm) {
      break;
    }
    leapJ = leapJ + div(jump, 33) * 8 + div(mod(jump, 33), 4);
    jp = jm;
  }
  n2 = jy - jp;
  leapJ = leapJ + div(n2, 33) * 8 + div(mod(n2, 33) + 3, 4);
  if (mod(jump, 33) === 4 && jump - n2 === 4) {
    leapJ += 1;
  }
  const leapG = div(gy, 4) - div((div(gy, 100) + 1) * 3, 4) - 150;
  const march = 20 + leapJ - leapG;
  if (!withoutLeap) {
    if (jump - n2 < 6) {
      n2 = n2 - jump + div(jump + 4, 33) * 33;
    }
    leap = mod(mod(n2 + 1, 33) - 1, 4);
    if (leap === -1) {
      leap = 4;
    }
  }
  return {
    leap,
    gy,
    march
  };
}
function j2d(jy, jm, jd) {
  const r = jalCal(jy, true);
  return g2d(r.gy, 3, r.march) + (jm - 1) * 31 - div(jm, 7) * (jm - 7) + jd - 1;
}
function d2j(jdn) {
  const gy = d2g(jdn).gy;
  let jy = gy - 621, jd, jm, k2;
  const r = jalCal(jy, false), jdn1f = g2d(gy, 3, r.march);
  k2 = jdn - jdn1f;
  if (k2 >= 0) {
    if (k2 <= 185) {
      jm = 1 + div(k2, 31);
      jd = mod(k2, 31) + 1;
      return {
        jy,
        jm,
        jd
      };
    } else {
      k2 -= 186;
    }
  } else {
    jy -= 1;
    k2 += 179;
    if (r.leap === 1) {
      k2 += 1;
    }
  }
  jm = 7 + div(k2, 30);
  jd = mod(k2, 30) + 1;
  return {
    jy,
    jm,
    jd
  };
}
function g2d(gy, gm, gd) {
  let d2 = div((gy + div(gm - 8, 6) + 100100) * 1461, 4) + div(153 * mod(gm + 9, 12) + 2, 5) + gd - 34840408;
  d2 = d2 - div(div(gy + 100100 + div(gm - 8, 6), 100) * 3, 4) + 752;
  return d2;
}
function d2g(jdn) {
  let j2 = 4 * jdn + 139361631;
  j2 = j2 + div(div(4 * jdn + 183187720, 146097) * 3, 4) * 4 - 3908;
  const i = div(mod(j2, 1461), 4) * 5 + 308, gd = div(mod(i, 153), 5) + 1, gm = mod(div(i, 153), 12) + 1, gy = div(j2, 1461) - 100100 + div(8 - gm, 6);
  return {
    gy,
    gm,
    gd
  };
}
function div(a2, b2) {
  return ~~(a2 / b2);
}
function mod(a2, b2) {
  return a2 - ~~(a2 / b2) * b2;
}
const calendars = ["gregorian", "persian"];
const useDatetimeProps = {
  // should define modelValue in the target component
  mask: {
    type: String
  },
  locale: Object,
  calendar: {
    type: String,
    validator: (v2) => calendars.includes(v2),
    default: "gregorian"
  },
  landscape: Boolean,
  color: String,
  textColor: String,
  square: Boolean,
  flat: Boolean,
  bordered: Boolean,
  readonly: Boolean,
  disable: Boolean
};
const useDatetimeEmits = ["update:modelValue"];
function getDayHash(date) {
  return date.year + "/" + pad(date.month) + "/" + pad(date.day);
}
function useDatetime(props2, $q) {
  const editable = computed(() => {
    return props2.disable !== true && props2.readonly !== true;
  });
  const tabindex = computed(() => {
    return editable.value === true ? 0 : -1;
  });
  const headerClass = computed(() => {
    const cls = [];
    props2.color !== void 0 && cls.push(`bg-${props2.color}`);
    props2.textColor !== void 0 && cls.push(`text-${props2.textColor}`);
    return cls.join(" ");
  });
  function getLocale2() {
    return props2.locale !== void 0 ? { ...$q.lang.date, ...props2.locale } : $q.lang.date;
  }
  function getCurrentDate(dateOnly) {
    const d2 = /* @__PURE__ */ new Date();
    const timeFill = dateOnly === true ? null : 0;
    if (props2.calendar === "persian") {
      const jDate = toJalaali(d2);
      return {
        year: jDate.jy,
        month: jDate.jm,
        day: jDate.jd
      };
    }
    return {
      year: d2.getFullYear(),
      month: d2.getMonth() + 1,
      day: d2.getDate(),
      hour: timeFill,
      minute: timeFill,
      second: timeFill,
      millisecond: timeFill
    };
  }
  return {
    editable,
    tabindex,
    headerClass,
    getLocale: getLocale2,
    getCurrentDate
  };
}
const MILLISECONDS_IN_DAY = 864e5, MILLISECONDS_IN_HOUR = 36e5, MILLISECONDS_IN_MINUTE = 6e4, defaultMask = "YYYY-MM-DDTHH:mm:ss.SSSZ", token = /\[((?:[^\]\\]|\\]|\\)*)\]|d{1,4}|M{1,4}|m{1,2}|w{1,2}|Qo|Do|D{1,4}|YY(?:YY)?|H{1,2}|h{1,2}|s{1,2}|S{1,3}|Z{1,2}|a{1,2}|[AQExX]/g, reverseToken = /(\[[^\]]*\])|d{1,4}|M{1,4}|m{1,2}|w{1,2}|Qo|Do|D{1,4}|YY(?:YY)?|H{1,2}|h{1,2}|s{1,2}|S{1,3}|Z{1,2}|a{1,2}|[AQExX]|([.*+:?^,\s${}()|\\]+)/g, regexStore = {};
function getRegexData(mask, dateLocale) {
  const days = "(" + dateLocale.days.join("|") + ")", key = mask + days;
  if (regexStore[key] !== void 0) {
    return regexStore[key];
  }
  const daysShort = "(" + dateLocale.daysShort.join("|") + ")", months = "(" + dateLocale.months.join("|") + ")", monthsShort = "(" + dateLocale.monthsShort.join("|") + ")";
  const map = {};
  let index = 0;
  const regexText = mask.replace(reverseToken, (match) => {
    index++;
    switch (match) {
      case "YY":
        map.YY = index;
        return "(-?\\d{1,2})";
      case "YYYY":
        map.YYYY = index;
        return "(-?\\d{1,4})";
      case "M":
        map.M = index;
        return "(\\d{1,2})";
      case "MM":
        map.M = index;
        return "(\\d{2})";
      case "MMM":
        map.MMM = index;
        return monthsShort;
      case "MMMM":
        map.MMMM = index;
        return months;
      case "D":
        map.D = index;
        return "(\\d{1,2})";
      case "Do":
        map.D = index++;
        return "(\\d{1,2}(st|nd|rd|th))";
      case "DD":
        map.D = index;
        return "(\\d{2})";
      case "H":
        map.H = index;
        return "(\\d{1,2})";
      case "HH":
        map.H = index;
        return "(\\d{2})";
      case "h":
        map.h = index;
        return "(\\d{1,2})";
      case "hh":
        map.h = index;
        return "(\\d{2})";
      case "m":
        map.m = index;
        return "(\\d{1,2})";
      case "mm":
        map.m = index;
        return "(\\d{2})";
      case "s":
        map.s = index;
        return "(\\d{1,2})";
      case "ss":
        map.s = index;
        return "(\\d{2})";
      case "S":
        map.S = index;
        return "(\\d{1})";
      case "SS":
        map.S = index;
        return "(\\d{2})";
      case "SSS":
        map.S = index;
        return "(\\d{3})";
      case "A":
        map.A = index;
        return "(AM|PM)";
      case "a":
        map.a = index;
        return "(am|pm)";
      case "aa":
        map.aa = index;
        return "(a\\.m\\.|p\\.m\\.)";
      case "ddd":
        return daysShort;
      case "dddd":
        return days;
      case "Q":
      case "d":
      case "E":
        return "(\\d{1})";
      case "Qo":
        return "(1st|2nd|3rd|4th)";
      case "DDD":
      case "DDDD":
        return "(\\d{1,3})";
      case "w":
        return "(\\d{1,2})";
      case "ww":
        return "(\\d{2})";
      case "Z":
        map.Z = index;
        return "(Z|[+-]\\d{2}:\\d{2})";
      case "ZZ":
        map.ZZ = index;
        return "(Z|[+-]\\d{2}\\d{2})";
      case "X":
        map.X = index;
        return "(-?\\d+)";
      case "x":
        map.x = index;
        return "(-?\\d{4,})";
      default:
        index--;
        if (match[0] === "[") {
          match = match.substring(1, match.length - 1);
        }
        return match.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
  });
  const res = { map, regex: new RegExp("^" + regexText) };
  regexStore[key] = res;
  return res;
}
function getDateLocale(paramDateLocale, langProps) {
  return paramDateLocale !== void 0 ? paramDateLocale : langProps !== void 0 ? langProps.date : defaultLang.date;
}
function formatTimezone(offset, delimeter = "") {
  const sign = offset > 0 ? "-" : "+", absOffset = Math.abs(offset), hours = Math.floor(absOffset / 60), minutes = absOffset % 60;
  return sign + pad(hours) + delimeter + pad(minutes);
}
function __splitDate(str, mask, dateLocale, calendar, defaultModel) {
  const date = {
    year: null,
    month: null,
    day: null,
    hour: null,
    minute: null,
    second: null,
    millisecond: null,
    timezoneOffset: null,
    dateHash: null,
    timeHash: null
  };
  defaultModel !== void 0 && Object.assign(date, defaultModel);
  if (str === void 0 || str === null || str === "" || typeof str !== "string") {
    return date;
  }
  if (mask === void 0) {
    mask = defaultMask;
  }
  const langOpts = getDateLocale(dateLocale, Plugin$2.props), months = langOpts.months, monthsShort = langOpts.monthsShort;
  const { regex, map } = getRegexData(mask, langOpts);
  const match = str.match(regex);
  if (match === null) {
    return date;
  }
  let tzString = "";
  if (map.X !== void 0 || map.x !== void 0) {
    const stamp = parseInt(match[map.X !== void 0 ? map.X : map.x], 10);
    if (isNaN(stamp) === true || stamp < 0) {
      return date;
    }
    const d2 = new Date(stamp * (map.X !== void 0 ? 1e3 : 1));
    date.year = d2.getFullYear();
    date.month = d2.getMonth() + 1;
    date.day = d2.getDate();
    date.hour = d2.getHours();
    date.minute = d2.getMinutes();
    date.second = d2.getSeconds();
    date.millisecond = d2.getMilliseconds();
  } else {
    if (map.YYYY !== void 0) {
      date.year = parseInt(match[map.YYYY], 10);
    } else if (map.YY !== void 0) {
      const y2 = parseInt(match[map.YY], 10);
      date.year = y2 < 0 ? y2 : 2e3 + y2;
    }
    if (map.M !== void 0) {
      date.month = parseInt(match[map.M], 10);
      if (date.month < 1 || date.month > 12) {
        return date;
      }
    } else if (map.MMM !== void 0) {
      date.month = monthsShort.indexOf(match[map.MMM]) + 1;
    } else if (map.MMMM !== void 0) {
      date.month = months.indexOf(match[map.MMMM]) + 1;
    }
    if (map.D !== void 0) {
      date.day = parseInt(match[map.D], 10);
      if (date.year === null || date.month === null || date.day < 1) {
        return date;
      }
      const maxDay = calendar !== "persian" ? new Date(date.year, date.month, 0).getDate() : jalaaliMonthLength(date.year, date.month);
      if (date.day > maxDay) {
        return date;
      }
    }
    if (map.H !== void 0) {
      date.hour = parseInt(match[map.H], 10) % 24;
    } else if (map.h !== void 0) {
      date.hour = parseInt(match[map.h], 10) % 12;
      if (map.A && match[map.A] === "PM" || map.a && match[map.a] === "pm" || map.aa && match[map.aa] === "p.m.") {
        date.hour += 12;
      }
      date.hour = date.hour % 24;
    }
    if (map.m !== void 0) {
      date.minute = parseInt(match[map.m], 10) % 60;
    }
    if (map.s !== void 0) {
      date.second = parseInt(match[map.s], 10) % 60;
    }
    if (map.S !== void 0) {
      date.millisecond = parseInt(match[map.S], 10) * 10 ** (3 - match[map.S].length);
    }
    if (map.Z !== void 0 || map.ZZ !== void 0) {
      tzString = map.Z !== void 0 ? match[map.Z].replace(":", "") : match[map.ZZ];
      date.timezoneOffset = (tzString[0] === "+" ? -1 : 1) * (60 * tzString.slice(1, 3) + 1 * tzString.slice(3, 5));
    }
  }
  date.dateHash = pad(date.year, 6) + "/" + pad(date.month) + "/" + pad(date.day);
  date.timeHash = pad(date.hour) + ":" + pad(date.minute) + ":" + pad(date.second) + tzString;
  return date;
}
function getWeekOfYear(date) {
  const thursday = new Date(date.getFullYear(), date.getMonth(), date.getDate());
  thursday.setDate(thursday.getDate() - (thursday.getDay() + 6) % 7 + 3);
  const firstThursday = new Date(thursday.getFullYear(), 0, 4);
  firstThursday.setDate(firstThursday.getDate() - (firstThursday.getDay() + 6) % 7 + 3);
  const ds = thursday.getTimezoneOffset() - firstThursday.getTimezoneOffset();
  thursday.setHours(thursday.getHours() - ds);
  const weekDiff = (thursday - firstThursday) / (MILLISECONDS_IN_DAY * 7);
  return 1 + Math.floor(weekDiff);
}
function startOfDate(date, unit, utc) {
  const t2 = new Date(date), prefix = `set${utc === true ? "UTC" : ""}`;
  switch (unit) {
    case "year":
    case "years":
      t2[`${prefix}Month`](0);
    case "month":
    case "months":
      t2[`${prefix}Date`](1);
    case "day":
    case "days":
    case "date":
      t2[`${prefix}Hours`](0);
    case "hour":
    case "hours":
      t2[`${prefix}Minutes`](0);
    case "minute":
    case "minutes":
      t2[`${prefix}Seconds`](0);
    case "second":
    case "seconds":
      t2[`${prefix}Milliseconds`](0);
  }
  return t2;
}
function getDiff(t2, sub, interval) {
  return (t2.getTime() - t2.getTimezoneOffset() * MILLISECONDS_IN_MINUTE - (sub.getTime() - sub.getTimezoneOffset() * MILLISECONDS_IN_MINUTE)) / interval;
}
function getDateDiff(date, subtract, unit = "days") {
  const t2 = new Date(date), sub = new Date(subtract);
  switch (unit) {
    case "years":
    case "year":
      return t2.getFullYear() - sub.getFullYear();
    case "months":
    case "month":
      return (t2.getFullYear() - sub.getFullYear()) * 12 + t2.getMonth() - sub.getMonth();
    case "days":
    case "day":
    case "date":
      return getDiff(startOfDate(t2, "day"), startOfDate(sub, "day"), MILLISECONDS_IN_DAY);
    case "hours":
    case "hour":
      return getDiff(startOfDate(t2, "hour"), startOfDate(sub, "hour"), MILLISECONDS_IN_HOUR);
    case "minutes":
    case "minute":
      return getDiff(startOfDate(t2, "minute"), startOfDate(sub, "minute"), MILLISECONDS_IN_MINUTE);
    case "seconds":
    case "second":
      return getDiff(startOfDate(t2, "second"), startOfDate(sub, "second"), 1e3);
  }
}
function getDayOfYear(date) {
  return getDateDiff(date, startOfDate(date, "year"), "days") + 1;
}
function getOrdinal(n2) {
  if (n2 >= 11 && n2 <= 13) {
    return `${n2}th`;
  }
  switch (n2 % 10) {
    case 1:
      return `${n2}st`;
    case 2:
      return `${n2}nd`;
    case 3:
      return `${n2}rd`;
  }
  return `${n2}th`;
}
const formatter = {
  // Year: 00, 01, ..., 99
  YY(date, dateLocale, forcedYear) {
    const y2 = this.YYYY(date, dateLocale, forcedYear) % 100;
    return y2 >= 0 ? pad(y2) : "-" + pad(Math.abs(y2));
  },
  // Year: 1900, 1901, ..., 2099
  YYYY(date, _dateLocale, forcedYear) {
    return forcedYear !== void 0 && forcedYear !== null ? forcedYear : date.getFullYear();
  },
  // Month: 1, 2, ..., 12
  M(date) {
    return date.getMonth() + 1;
  },
  // Month: 01, 02, ..., 12
  MM(date) {
    return pad(date.getMonth() + 1);
  },
  // Month Short Name: Jan, Feb, ...
  MMM(date, dateLocale) {
    return dateLocale.monthsShort[date.getMonth()];
  },
  // Month Name: January, February, ...
  MMMM(date, dateLocale) {
    return dateLocale.months[date.getMonth()];
  },
  // Quarter: 1, 2, 3, 4
  Q(date) {
    return Math.ceil((date.getMonth() + 1) / 3);
  },
  // Quarter: 1st, 2nd, 3rd, 4th
  Qo(date) {
    return getOrdinal(this.Q(date));
  },
  // Day of month: 1, 2, ..., 31
  D(date) {
    return date.getDate();
  },
  // Day of month: 1st, 2nd, ..., 31st
  Do(date) {
    return getOrdinal(date.getDate());
  },
  // Day of month: 01, 02, ..., 31
  DD(date) {
    return pad(date.getDate());
  },
  // Day of year: 1, 2, ..., 366
  DDD(date) {
    return getDayOfYear(date);
  },
  // Day of year: 001, 002, ..., 366
  DDDD(date) {
    return pad(getDayOfYear(date), 3);
  },
  // Day of week: 0, 1, ..., 6
  d(date) {
    return date.getDay();
  },
  // Day of week: Su, Mo, ...
  dd(date, dateLocale) {
    return this.dddd(date, dateLocale).slice(0, 2);
  },
  // Day of week: Sun, Mon, ...
  ddd(date, dateLocale) {
    return dateLocale.daysShort[date.getDay()];
  },
  // Day of week: Sunday, Monday, ...
  dddd(date, dateLocale) {
    return dateLocale.days[date.getDay()];
  },
  // Day of ISO week: 1, 2, ..., 7
  E(date) {
    return date.getDay() || 7;
  },
  // Week of Year: 1 2 ... 52 53
  w(date) {
    return getWeekOfYear(date);
  },
  // Week of Year: 01 02 ... 52 53
  ww(date) {
    return pad(getWeekOfYear(date));
  },
  // Hour: 0, 1, ... 23
  H(date) {
    return date.getHours();
  },
  // Hour: 00, 01, ..., 23
  HH(date) {
    return pad(date.getHours());
  },
  // Hour: 1, 2, ..., 12
  h(date) {
    const hours = date.getHours();
    return hours === 0 ? 12 : hours > 12 ? hours % 12 : hours;
  },
  // Hour: 01, 02, ..., 12
  hh(date) {
    return pad(this.h(date));
  },
  // Minute: 0, 1, ..., 59
  m(date) {
    return date.getMinutes();
  },
  // Minute: 00, 01, ..., 59
  mm(date) {
    return pad(date.getMinutes());
  },
  // Second: 0, 1, ..., 59
  s(date) {
    return date.getSeconds();
  },
  // Second: 00, 01, ..., 59
  ss(date) {
    return pad(date.getSeconds());
  },
  // 1/10 of second: 0, 1, ..., 9
  S(date) {
    return Math.floor(date.getMilliseconds() / 100);
  },
  // 1/100 of second: 00, 01, ..., 99
  SS(date) {
    return pad(Math.floor(date.getMilliseconds() / 10));
  },
  // Millisecond: 000, 001, ..., 999
  SSS(date) {
    return pad(date.getMilliseconds(), 3);
  },
  // Meridiem: AM, PM
  A(date) {
    return this.H(date) < 12 ? "AM" : "PM";
  },
  // Meridiem: am, pm
  a(date) {
    return this.H(date) < 12 ? "am" : "pm";
  },
  // Meridiem: a.m., p.m.
  aa(date) {
    return this.H(date) < 12 ? "a.m." : "p.m.";
  },
  // Timezone: -01:00, +00:00, ... +12:00
  Z(date, _dateLocale, _forcedYear, forcedTimezoneOffset) {
    const tzOffset = forcedTimezoneOffset === void 0 || forcedTimezoneOffset === null ? date.getTimezoneOffset() : forcedTimezoneOffset;
    return formatTimezone(tzOffset, ":");
  },
  // Timezone: -0100, +0000, ... +1200
  ZZ(date, _dateLocale, _forcedYear, forcedTimezoneOffset) {
    const tzOffset = forcedTimezoneOffset === void 0 || forcedTimezoneOffset === null ? date.getTimezoneOffset() : forcedTimezoneOffset;
    return formatTimezone(tzOffset);
  },
  // Seconds timestamp: 512969520
  X(date) {
    return Math.floor(date.getTime() / 1e3);
  },
  // Milliseconds timestamp: 512969520900
  x(date) {
    return date.getTime();
  }
};
function formatDate(val, mask, dateLocale, __forcedYear, __forcedTimezoneOffset) {
  if (val !== 0 && !val || val === Infinity || val === -Infinity) {
    return;
  }
  const date = new Date(val);
  if (isNaN(date)) {
    return;
  }
  if (mask === void 0) {
    mask = defaultMask;
  }
  const locale = getDateLocale(dateLocale, Plugin$2.props);
  return mask.replace(
    token,
    (match, text) => match in formatter ? formatter[match](date, locale, __forcedYear, __forcedTimezoneOffset) : text === void 0 ? match : text.split("\\]").join("]")
  );
}
const yearsInterval = 20;
const views = ["Calendar", "Years", "Months"];
const viewIsValid = (v2) => views.includes(v2);
const yearMonthValidator = (v2) => /^-?[\d]+\/[0-1]\d$/.test(v2);
const lineStr = " — ";
function getMonthHash(date) {
  return date.year + "/" + pad(date.month);
}
const QDate = createComponent({
  name: "QDate",
  props: {
    ...useDatetimeProps,
    ...useFormProps,
    ...useDarkProps,
    modelValue: {
      required: true,
      validator: (val) => typeof val === "string" || Array.isArray(val) === true || Object(val) === val || val === null
    },
    multiple: Boolean,
    range: Boolean,
    title: String,
    subtitle: String,
    mask: {
      ...useDatetimeProps.mask,
      // this mask is forced
      // when using persian calendar
      default: "YYYY/MM/DD"
    },
    defaultYearMonth: {
      type: String,
      validator: yearMonthValidator
    },
    yearsInMonthView: Boolean,
    events: [Array, Function],
    eventColor: [String, Function],
    emitImmediately: Boolean,
    options: [Array, Function],
    navigationMinYearMonth: {
      type: String,
      validator: yearMonthValidator
    },
    navigationMaxYearMonth: {
      type: String,
      validator: yearMonthValidator
    },
    noUnset: Boolean,
    firstDayOfWeek: [String, Number],
    todayBtn: Boolean,
    minimal: Boolean,
    defaultView: {
      type: String,
      default: "Calendar",
      validator: viewIsValid
    }
  },
  emits: [
    ...useDatetimeEmits,
    "rangeStart",
    "rangeEnd",
    "navigation"
  ],
  setup(props2, { slots, emit: emit2 }) {
    const { proxy } = getCurrentInstance();
    const { $q } = proxy;
    const isDark = useDark(props2, $q);
    const { getCache } = useRenderCache();
    const { tabindex, headerClass, getLocale: getLocale2, getCurrentDate } = useDatetime(props2, $q);
    let lastEmitValue;
    const formAttrs = useFormAttrs(props2);
    const injectFormInput = useFormInject(formAttrs);
    const blurTargetRef = ref(null);
    const innerMask = ref(getMask());
    const innerLocale = ref(getLocale2());
    const mask = computed(() => getMask());
    const locale = computed(() => getLocale2());
    const today = computed(() => getCurrentDate());
    const viewModel = ref(getViewModel(innerMask.value, innerLocale.value));
    const view = ref(props2.defaultView);
    const direction2 = computed(() => $q.lang.rtl === true ? "right" : "left");
    const monthDirection = ref(direction2.value);
    const yearDirection = ref(direction2.value);
    const year = viewModel.value.year;
    const startYear = ref(year - year % yearsInterval - (year < 0 ? yearsInterval : 0));
    const editRange = ref(null);
    const classes = computed(() => {
      const type = props2.landscape === true ? "landscape" : "portrait";
      return `q-date q-date--${type} q-date--${type}-${props2.minimal === true ? "minimal" : "standard"}` + (isDark.value === true ? " q-date--dark q-dark" : "") + (props2.bordered === true ? " q-date--bordered" : "") + (props2.square === true ? " q-date--square no-border-radius" : "") + (props2.flat === true ? " q-date--flat no-shadow" : "") + (props2.disable === true ? " disabled" : props2.readonly === true ? " q-date--readonly" : "");
    });
    const computedColor = computed(() => {
      return props2.color || "primary";
    });
    const computedTextColor = computed(() => {
      return props2.textColor || "white";
    });
    const isImmediate = computed(
      () => props2.emitImmediately === true && props2.multiple !== true && props2.range !== true
    );
    const normalizedModel = computed(() => Array.isArray(props2.modelValue) === true ? props2.modelValue : props2.modelValue !== null && props2.modelValue !== void 0 ? [props2.modelValue] : []);
    const daysModel = computed(
      () => normalizedModel.value.filter((date) => typeof date === "string").map((date) => decodeString(date, innerMask.value, innerLocale.value)).filter(
        (date) => date.dateHash !== null && date.day !== null && date.month !== null && date.year !== null
      )
    );
    const rangeModel = computed(() => {
      const fn = (date) => decodeString(date, innerMask.value, innerLocale.value);
      return normalizedModel.value.filter((date) => isObject$3(date) === true && date.from !== void 0 && date.to !== void 0).map((range) => ({ from: fn(range.from), to: fn(range.to) })).filter((range) => range.from.dateHash !== null && range.to.dateHash !== null && range.from.dateHash < range.to.dateHash);
    });
    const getNativeDateFn = computed(() => props2.calendar !== "persian" ? (model) => new Date(model.year, model.month - 1, model.day) : (model) => {
      const gDate = toGregorian(model.year, model.month, model.day);
      return new Date(gDate.gy, gDate.gm - 1, gDate.gd);
    });
    const encodeObjectFn = computed(() => props2.calendar === "persian" ? getDayHash : (date, mask2, locale2) => formatDate(
      new Date(
        date.year,
        date.month - 1,
        date.day,
        date.hour,
        date.minute,
        date.second,
        date.millisecond
      ),
      mask2 === void 0 ? innerMask.value : mask2,
      locale2 === void 0 ? innerLocale.value : locale2,
      date.year,
      date.timezoneOffset
    ));
    const daysInModel = computed(
      () => daysModel.value.length + rangeModel.value.reduce(
        (acc, range) => acc + 1 + getDateDiff(
          getNativeDateFn.value(range.to),
          getNativeDateFn.value(range.from)
        ),
        0
      )
    );
    const headerTitle = computed(() => {
      if (props2.title !== void 0 && props2.title !== null && props2.title.length !== 0) {
        return props2.title;
      }
      if (editRange.value !== null) {
        const model2 = editRange.value.init;
        const date2 = getNativeDateFn.value(model2);
        return innerLocale.value.daysShort[date2.getDay()] + ", " + innerLocale.value.monthsShort[model2.month - 1] + " " + model2.day + lineStr + "?";
      }
      if (daysInModel.value === 0) {
        return lineStr;
      }
      if (daysInModel.value > 1) {
        return `${daysInModel.value} ${innerLocale.value.pluralDay}`;
      }
      const model = daysModel.value[0];
      const date = getNativeDateFn.value(model);
      if (isNaN(date.valueOf()) === true) {
        return lineStr;
      }
      if (innerLocale.value.headerTitle !== void 0) {
        return innerLocale.value.headerTitle(date, model);
      }
      return innerLocale.value.daysShort[date.getDay()] + ", " + innerLocale.value.monthsShort[model.month - 1] + " " + model.day;
    });
    const minSelectedModel = computed(() => {
      const model = daysModel.value.concat(rangeModel.value.map((range) => range.from)).sort((a2, b2) => a2.year - b2.year || a2.month - b2.month);
      return model[0];
    });
    const maxSelectedModel = computed(() => {
      const model = daysModel.value.concat(rangeModel.value.map((range) => range.to)).sort((a2, b2) => b2.year - a2.year || b2.month - a2.month);
      return model[0];
    });
    const headerSubtitle = computed(() => {
      if (props2.subtitle !== void 0 && props2.subtitle !== null && props2.subtitle.length !== 0) {
        return props2.subtitle;
      }
      if (daysInModel.value === 0) {
        return lineStr;
      }
      if (daysInModel.value > 1) {
        const from = minSelectedModel.value;
        const to = maxSelectedModel.value;
        const month = innerLocale.value.monthsShort;
        return month[from.month - 1] + (from.year !== to.year ? " " + from.year + lineStr + month[to.month - 1] + " " : from.month !== to.month ? lineStr + month[to.month - 1] : "") + " " + to.year;
      }
      return daysModel.value[0].year;
    });
    const dateArrow = computed(() => {
      const val = [$q.iconSet.datetime.arrowLeft, $q.iconSet.datetime.arrowRight];
      return $q.lang.rtl === true ? val.reverse() : val;
    });
    const computedFirstDayOfWeek = computed(() => props2.firstDayOfWeek !== void 0 ? Number(props2.firstDayOfWeek) : innerLocale.value.firstDayOfWeek);
    const daysOfWeek = computed(() => {
      const days2 = innerLocale.value.daysShort, first = computedFirstDayOfWeek.value;
      return first > 0 ? days2.slice(first, 7).concat(days2.slice(0, first)) : days2;
    });
    const daysInMonth = computed(() => {
      const date = viewModel.value;
      return props2.calendar !== "persian" ? new Date(date.year, date.month, 0).getDate() : jalaaliMonthLength(date.year, date.month);
    });
    const evtColor = computed(() => typeof props2.eventColor === "function" ? props2.eventColor : () => props2.eventColor);
    const minNav = computed(() => {
      if (props2.navigationMinYearMonth === void 0) {
        return null;
      }
      const data = props2.navigationMinYearMonth.split("/");
      return { year: parseInt(data[0], 10), month: parseInt(data[1], 10) };
    });
    const maxNav = computed(() => {
      if (props2.navigationMaxYearMonth === void 0) {
        return null;
      }
      const data = props2.navigationMaxYearMonth.split("/");
      return { year: parseInt(data[0], 10), month: parseInt(data[1], 10) };
    });
    const navBoundaries = computed(() => {
      const data = {
        month: { prev: true, next: true },
        year: { prev: true, next: true }
      };
      if (minNav.value !== null && minNav.value.year >= viewModel.value.year) {
        data.year.prev = false;
        if (minNav.value.year === viewModel.value.year && minNav.value.month >= viewModel.value.month) {
          data.month.prev = false;
        }
      }
      if (maxNav.value !== null && maxNav.value.year <= viewModel.value.year) {
        data.year.next = false;
        if (maxNav.value.year === viewModel.value.year && maxNav.value.month <= viewModel.value.month) {
          data.month.next = false;
        }
      }
      return data;
    });
    const daysMap = computed(() => {
      const map = {};
      daysModel.value.forEach((entry) => {
        const hash = getMonthHash(entry);
        if (map[hash] === void 0) {
          map[hash] = [];
        }
        map[hash].push(entry.day);
      });
      return map;
    });
    const rangeMap = computed(() => {
      const map = {};
      rangeModel.value.forEach((entry) => {
        const hashFrom = getMonthHash(entry.from);
        const hashTo = getMonthHash(entry.to);
        if (map[hashFrom] === void 0) {
          map[hashFrom] = [];
        }
        map[hashFrom].push({
          from: entry.from.day,
          to: hashFrom === hashTo ? entry.to.day : void 0,
          range: entry
        });
        if (hashFrom < hashTo) {
          let hash;
          const { year: year2, month } = entry.from;
          const cur = month < 12 ? { year: year2, month: month + 1 } : { year: year2 + 1, month: 1 };
          while ((hash = getMonthHash(cur)) <= hashTo) {
            if (map[hash] === void 0) {
              map[hash] = [];
            }
            map[hash].push({
              from: void 0,
              to: hash === hashTo ? entry.to.day : void 0,
              range: entry
            });
            cur.month++;
            if (cur.month > 12) {
              cur.year++;
              cur.month = 1;
            }
          }
        }
      });
      return map;
    });
    const rangeView = computed(() => {
      if (editRange.value === null) {
        return;
      }
      const { init: init2, initHash, final, finalHash } = editRange.value;
      const [from, to] = initHash <= finalHash ? [init2, final] : [final, init2];
      const fromHash = getMonthHash(from);
      const toHash = getMonthHash(to);
      if (fromHash !== viewMonthHash.value && toHash !== viewMonthHash.value) {
        return;
      }
      const view2 = {};
      if (fromHash === viewMonthHash.value) {
        view2.from = from.day;
        view2.includeFrom = true;
      } else {
        view2.from = 1;
      }
      if (toHash === viewMonthHash.value) {
        view2.to = to.day;
        view2.includeTo = true;
      } else {
        view2.to = daysInMonth.value;
      }
      return view2;
    });
    const viewMonthHash = computed(() => getMonthHash(viewModel.value));
    const selectionDaysMap = computed(() => {
      const map = {};
      if (props2.options === void 0) {
        for (let i = 1; i <= daysInMonth.value; i++) {
          map[i] = true;
        }
        return map;
      }
      const fn = typeof props2.options === "function" ? props2.options : (date) => props2.options.includes(date);
      for (let i = 1; i <= daysInMonth.value; i++) {
        const dayHash = viewMonthHash.value + "/" + pad(i);
        map[i] = fn(dayHash);
      }
      return map;
    });
    const eventDaysMap = computed(() => {
      const map = {};
      if (props2.events === void 0) {
        for (let i = 1; i <= daysInMonth.value; i++) {
          map[i] = false;
        }
      } else {
        const fn = typeof props2.events === "function" ? props2.events : (date) => props2.events.includes(date);
        for (let i = 1; i <= daysInMonth.value; i++) {
          const dayHash = viewMonthHash.value + "/" + pad(i);
          map[i] = fn(dayHash) === true && evtColor.value(dayHash);
        }
      }
      return map;
    });
    const viewDays = computed(() => {
      let date, endDay;
      const { year: year2, month } = viewModel.value;
      if (props2.calendar !== "persian") {
        date = new Date(year2, month - 1, 1);
        endDay = new Date(year2, month - 1, 0).getDate();
      } else {
        const gDate = toGregorian(year2, month, 1);
        date = new Date(gDate.gy, gDate.gm - 1, gDate.gd);
        let prevJM = month - 1;
        let prevJY = year2;
        if (prevJM === 0) {
          prevJM = 12;
          prevJY--;
        }
        endDay = jalaaliMonthLength(prevJY, prevJM);
      }
      return {
        days: date.getDay() - computedFirstDayOfWeek.value - 1,
        endDay
      };
    });
    const days = computed(() => {
      const res = [];
      const { days: days2, endDay } = viewDays.value;
      const len = days2 < 0 ? days2 + 7 : days2;
      if (len < 6) {
        for (let i = endDay - len; i <= endDay; i++) {
          res.push({ i, fill: true });
        }
      }
      const index = res.length;
      for (let i = 1; i <= daysInMonth.value; i++) {
        const day = { i, event: eventDaysMap.value[i], classes: [] };
        if (selectionDaysMap.value[i] === true) {
          day.in = true;
          day.flat = true;
        }
        res.push(day);
      }
      if (daysMap.value[viewMonthHash.value] !== void 0) {
        daysMap.value[viewMonthHash.value].forEach((day) => {
          const i = index + day - 1;
          Object.assign(res[i], {
            selected: true,
            unelevated: true,
            flat: false,
            color: computedColor.value,
            textColor: computedTextColor.value
          });
        });
      }
      if (rangeMap.value[viewMonthHash.value] !== void 0) {
        rangeMap.value[viewMonthHash.value].forEach((entry) => {
          if (entry.from !== void 0) {
            const from = index + entry.from - 1;
            const to = index + (entry.to || daysInMonth.value) - 1;
            for (let day = from; day <= to; day++) {
              Object.assign(res[day], {
                range: entry.range,
                unelevated: true,
                color: computedColor.value,
                textColor: computedTextColor.value
              });
            }
            Object.assign(res[from], {
              rangeFrom: true,
              flat: false
            });
            entry.to !== void 0 && Object.assign(res[to], {
              rangeTo: true,
              flat: false
            });
          } else if (entry.to !== void 0) {
            const to = index + entry.to - 1;
            for (let day = index; day <= to; day++) {
              Object.assign(res[day], {
                range: entry.range,
                unelevated: true,
                color: computedColor.value,
                textColor: computedTextColor.value
              });
            }
            Object.assign(res[to], {
              flat: false,
              rangeTo: true
            });
          } else {
            const to = index + daysInMonth.value - 1;
            for (let day = index; day <= to; day++) {
              Object.assign(res[day], {
                range: entry.range,
                unelevated: true,
                color: computedColor.value,
                textColor: computedTextColor.value
              });
            }
          }
        });
      }
      if (rangeView.value !== void 0) {
        const from = index + rangeView.value.from - 1;
        const to = index + rangeView.value.to - 1;
        for (let day = from; day <= to; day++) {
          res[day].color = computedColor.value;
          res[day].editRange = true;
        }
        if (rangeView.value.includeFrom === true) {
          res[from].editRangeFrom = true;
        }
        if (rangeView.value.includeTo === true) {
          res[to].editRangeTo = true;
        }
      }
      if (viewModel.value.year === today.value.year && viewModel.value.month === today.value.month) {
        res[index + today.value.day - 1].today = true;
      }
      const left = res.length % 7;
      if (left > 0) {
        const afterDays = 7 - left;
        for (let i = 1; i <= afterDays; i++) {
          res.push({ i, fill: true });
        }
      }
      res.forEach((day) => {
        let cls = "q-date__calendar-item ";
        if (day.fill === true) {
          cls += "q-date__calendar-item--fill";
        } else {
          cls += `q-date__calendar-item--${day.in === true ? "in" : "out"}`;
          if (day.range !== void 0) {
            cls += ` q-date__range${day.rangeTo === true ? "-to" : day.rangeFrom === true ? "-from" : ""}`;
          }
          if (day.editRange === true) {
            cls += ` q-date__edit-range${day.editRangeFrom === true ? "-from" : ""}${day.editRangeTo === true ? "-to" : ""}`;
          }
          if (day.range !== void 0 || day.editRange === true) {
            cls += ` text-${day.color}`;
          }
        }
        day.classes = cls;
      });
      return res;
    });
    const attributes = computed(() => props2.disable === true ? { "aria-disabled": "true" } : {});
    watch(() => props2.modelValue, (v2) => {
      if (lastEmitValue === v2) {
        lastEmitValue = 0;
      } else {
        const model = getViewModel(innerMask.value, innerLocale.value);
        updateViewModel(model.year, model.month, model);
      }
    });
    watch(view, () => {
      if (blurTargetRef.value !== null && proxy.$el.contains(document.activeElement) === true) {
        blurTargetRef.value.focus();
      }
    });
    watch(() => viewModel.value.year + "|" + viewModel.value.month, () => {
      emit2("navigation", { year: viewModel.value.year, month: viewModel.value.month });
    });
    watch(mask, (val) => {
      updateValue(val, innerLocale.value, "mask");
      innerMask.value = val;
    });
    watch(locale, (val) => {
      updateValue(innerMask.value, val, "locale");
      innerLocale.value = val;
    });
    function setToday() {
      const { year: year2, month, day } = today.value;
      const date = {
        // contains more props than needed (hour, minute, second, millisecond)
        // but those aren't used in the processing of this "date" variable
        ...viewModel.value,
        // overwriting with today's date
        year: year2,
        month,
        day
      };
      const monthMap = daysMap.value[getMonthHash(date)];
      if (monthMap === void 0 || monthMap.includes(date.day) === false) {
        addToModel(date);
      }
      setCalendarTo(date.year, date.month);
    }
    function setView(viewMode) {
      if (viewIsValid(viewMode) === true) {
        view.value = viewMode;
      }
    }
    function offsetCalendar(type, descending) {
      if (["month", "year"].includes(type)) {
        const fn = type === "month" ? goToMonth : goToYear;
        fn(descending === true ? -1 : 1);
      }
    }
    function setCalendarTo(year2, month) {
      view.value = "Calendar";
      updateViewModel(year2, month);
    }
    function setEditingRange(from, to) {
      if (props2.range === false || !from) {
        editRange.value = null;
        return;
      }
      const init2 = Object.assign({ ...viewModel.value }, from);
      const final = to !== void 0 ? Object.assign({ ...viewModel.value }, to) : init2;
      editRange.value = {
        init: init2,
        initHash: getDayHash(init2),
        final,
        finalHash: getDayHash(final)
      };
      setCalendarTo(init2.year, init2.month);
    }
    function getMask() {
      return props2.calendar === "persian" ? "YYYY/MM/DD" : props2.mask;
    }
    function decodeString(date, mask2, locale2) {
      return __splitDate(
        date,
        mask2,
        locale2,
        props2.calendar,
        {
          hour: 0,
          minute: 0,
          second: 0,
          millisecond: 0
        }
      );
    }
    function getViewModel(mask2, locale2) {
      const model = Array.isArray(props2.modelValue) === true ? props2.modelValue : props2.modelValue ? [props2.modelValue] : [];
      if (model.length === 0) {
        return getDefaultViewModel();
      }
      const target2 = model[model.length - 1];
      const decoded = decodeString(
        target2.from !== void 0 ? target2.from : target2,
        mask2,
        locale2
      );
      return decoded.dateHash === null ? getDefaultViewModel() : decoded;
    }
    function getDefaultViewModel() {
      let year2, month;
      if (props2.defaultYearMonth !== void 0) {
        const d2 = props2.defaultYearMonth.split("/");
        year2 = parseInt(d2[0], 10);
        month = parseInt(d2[1], 10);
      } else {
        const d2 = today.value !== void 0 ? today.value : getCurrentDate();
        year2 = d2.year;
        month = d2.month;
      }
      return {
        year: year2,
        month,
        day: 1,
        hour: 0,
        minute: 0,
        second: 0,
        millisecond: 0,
        dateHash: year2 + "/" + pad(month) + "/01"
      };
    }
    function goToMonth(offset) {
      let year2 = viewModel.value.year;
      let month = Number(viewModel.value.month) + offset;
      if (month === 13) {
        month = 1;
        year2++;
      } else if (month === 0) {
        month = 12;
        year2--;
      }
      updateViewModel(year2, month);
      isImmediate.value === true && emitImmediately("month");
    }
    function goToYear(offset) {
      const year2 = Number(viewModel.value.year) + offset;
      updateViewModel(year2, viewModel.value.month);
      isImmediate.value === true && emitImmediately("year");
    }
    function setYear(year2) {
      updateViewModel(year2, viewModel.value.month);
      view.value = props2.defaultView === "Years" ? "Months" : "Calendar";
      isImmediate.value === true && emitImmediately("year");
    }
    function setMonth(month) {
      updateViewModel(viewModel.value.year, month);
      view.value = "Calendar";
      isImmediate.value === true && emitImmediately("month");
    }
    function toggleDate(date, monthHash) {
      const month = daysMap.value[monthHash];
      const fn = month !== void 0 && month.includes(date.day) === true ? removeFromModel : addToModel;
      fn(date);
    }
    function getShortDate(date) {
      return { year: date.year, month: date.month, day: date.day };
    }
    function updateViewModel(year2, month, time2) {
      if (minNav.value !== null && year2 <= minNav.value.year) {
        if (month < minNav.value.month || year2 < minNav.value.year) {
          month = minNav.value.month;
        }
        year2 = minNav.value.year;
      }
      if (maxNav.value !== null && year2 >= maxNav.value.year) {
        if (month > maxNav.value.month || year2 > maxNav.value.year) {
          month = maxNav.value.month;
        }
        year2 = maxNav.value.year;
      }
      if (time2 !== void 0) {
        const { hour, minute, second, millisecond, timezoneOffset, timeHash } = time2;
        Object.assign(viewModel.value, { hour, minute, second, millisecond, timezoneOffset, timeHash });
      }
      const newHash = year2 + "/" + pad(month) + "/01";
      if (newHash !== viewModel.value.dateHash) {
        monthDirection.value = viewModel.value.dateHash < newHash === ($q.lang.rtl !== true) ? "left" : "right";
        if (year2 !== viewModel.value.year) {
          yearDirection.value = monthDirection.value;
        }
        nextTick$1(() => {
          startYear.value = year2 - year2 % yearsInterval - (year2 < 0 ? yearsInterval : 0);
          Object.assign(viewModel.value, {
            year: year2,
            month,
            day: 1,
            dateHash: newHash
          });
        });
      }
    }
    function emitValue(val, action, date) {
      const value2 = val !== null && val.length === 1 && props2.multiple === false ? val[0] : val;
      lastEmitValue = value2;
      const { reason, details } = getEmitParams(action, date);
      emit2("update:modelValue", value2, reason, details);
    }
    function emitImmediately(reason) {
      const date = daysModel.value[0] !== void 0 && daysModel.value[0].dateHash !== null ? { ...daysModel.value[0] } : { ...viewModel.value };
      nextTick$1(() => {
        date.year = viewModel.value.year;
        date.month = viewModel.value.month;
        const maxDay = props2.calendar !== "persian" ? new Date(date.year, date.month, 0).getDate() : jalaaliMonthLength(date.year, date.month);
        date.day = Math.min(Math.max(1, date.day), maxDay);
        const value2 = encodeEntry(date);
        lastEmitValue = value2;
        const { details } = getEmitParams("", date);
        emit2("update:modelValue", value2, reason, details);
      });
    }
    function getEmitParams(action, date) {
      return date.from !== void 0 ? {
        reason: `${action}-range`,
        details: {
          ...getShortDate(date.target),
          from: getShortDate(date.from),
          to: getShortDate(date.to)
        }
      } : {
        reason: `${action}-day`,
        details: getShortDate(date)
      };
    }
    function encodeEntry(date, mask2, locale2) {
      return date.from !== void 0 ? { from: encodeObjectFn.value(date.from, mask2, locale2), to: encodeObjectFn.value(date.to, mask2, locale2) } : encodeObjectFn.value(date, mask2, locale2);
    }
    function addToModel(date) {
      let value2;
      if (props2.multiple === true) {
        if (date.from !== void 0) {
          const fromHash = getDayHash(date.from);
          const toHash = getDayHash(date.to);
          const days2 = daysModel.value.filter((day) => day.dateHash < fromHash || day.dateHash > toHash);
          const ranges = rangeModel.value.filter(({ from, to }) => to.dateHash < fromHash || from.dateHash > toHash);
          value2 = days2.concat(ranges).concat(date).map((entry) => encodeEntry(entry));
        } else {
          const model = normalizedModel.value.slice();
          model.push(encodeEntry(date));
          value2 = model;
        }
      } else {
        value2 = encodeEntry(date);
      }
      emitValue(value2, "add", date);
    }
    function removeFromModel(date) {
      if (props2.noUnset === true) {
        return;
      }
      let model = null;
      if (props2.multiple === true && Array.isArray(props2.modelValue) === true) {
        const val = encodeEntry(date);
        if (date.from !== void 0) {
          model = props2.modelValue.filter(
            (date2) => date2.from !== void 0 ? date2.from !== val.from && date2.to !== val.to : true
          );
        } else {
          model = props2.modelValue.filter((date2) => date2 !== val);
        }
        if (model.length === 0) {
          model = null;
        }
      }
      emitValue(model, "remove", date);
    }
    function updateValue(mask2, locale2, reason) {
      const model = daysModel.value.concat(rangeModel.value).map((entry) => encodeEntry(entry, mask2, locale2)).filter((entry) => {
        return entry.from !== void 0 ? entry.from.dateHash !== null && entry.to.dateHash !== null : entry.dateHash !== null;
      });
      emit2("update:modelValue", (props2.multiple === true ? model : model[0]) || null, reason);
    }
    function getHeader() {
      if (props2.minimal === true) return;
      return h$1("div", {
        class: "q-date__header " + headerClass.value
      }, [
        h$1("div", {
          class: "relative-position"
        }, [
          h$1(Transition, {
            name: "q-transition--fade"
          }, () => h$1("div", {
            key: "h-yr-" + headerSubtitle.value,
            class: "q-date__header-subtitle q-date__header-link " + (view.value === "Years" ? "q-date__header-link--active" : "cursor-pointer"),
            tabindex: tabindex.value,
            ...getCache("vY", {
              onClick() {
                view.value = "Years";
              },
              onKeyup(e2) {
                e2.keyCode === 13 && (view.value = "Years");
              }
            })
          }, [headerSubtitle.value]))
        ]),
        h$1("div", {
          class: "q-date__header-title relative-position flex no-wrap"
        }, [
          h$1("div", {
            class: "relative-position col"
          }, [
            h$1(Transition, {
              name: "q-transition--fade"
            }, () => h$1("div", {
              key: "h-sub" + headerTitle.value,
              class: "q-date__header-title-label q-date__header-link " + (view.value === "Calendar" ? "q-date__header-link--active" : "cursor-pointer"),
              tabindex: tabindex.value,
              ...getCache("vC", {
                onClick() {
                  view.value = "Calendar";
                },
                onKeyup(e2) {
                  e2.keyCode === 13 && (view.value = "Calendar");
                }
              })
            }, [headerTitle.value]))
          ]),
          props2.todayBtn === true ? h$1(QBtn, {
            class: "q-date__header-today self-start",
            icon: $q.iconSet.datetime.today,
            flat: true,
            size: "sm",
            round: true,
            tabindex: tabindex.value,
            onClick: setToday
          }) : null
        ])
      ]);
    }
    function getNavigation({ label, type, key, dir, goTo, boundaries, cls }) {
      return [
        h$1("div", {
          class: "row items-center q-date__arrow"
        }, [
          h$1(QBtn, {
            round: true,
            dense: true,
            size: "sm",
            flat: true,
            icon: dateArrow.value[0],
            tabindex: tabindex.value,
            disable: boundaries.prev === false,
            ...getCache("go-#" + type, { onClick() {
              goTo(-1);
            } })
          })
        ]),
        h$1("div", {
          class: "relative-position overflow-hidden flex flex-center" + cls
        }, [
          h$1(Transition, {
            name: "q-transition--jump-" + dir
          }, () => h$1("div", { key }, [
            h$1(QBtn, {
              flat: true,
              dense: true,
              noCaps: true,
              label,
              tabindex: tabindex.value,
              ...getCache("view#" + type, { onClick: () => {
                view.value = type;
              } })
            })
          ]))
        ]),
        h$1("div", {
          class: "row items-center q-date__arrow"
        }, [
          h$1(QBtn, {
            round: true,
            dense: true,
            size: "sm",
            flat: true,
            icon: dateArrow.value[1],
            tabindex: tabindex.value,
            disable: boundaries.next === false,
            ...getCache("go+#" + type, { onClick() {
              goTo(1);
            } })
          })
        ])
      ];
    }
    const renderViews = {
      Calendar: () => [
        h$1("div", {
          key: "calendar-view",
          class: "q-date__view q-date__calendar"
        }, [
          h$1("div", {
            class: "q-date__navigation row items-center no-wrap"
          }, getNavigation({
            label: innerLocale.value.months[viewModel.value.month - 1],
            type: "Months",
            key: viewModel.value.month,
            dir: monthDirection.value,
            goTo: goToMonth,
            boundaries: navBoundaries.value.month,
            cls: " col"
          }).concat(getNavigation({
            label: viewModel.value.year,
            type: "Years",
            key: viewModel.value.year,
            dir: yearDirection.value,
            goTo: goToYear,
            boundaries: navBoundaries.value.year,
            cls: ""
          }))),
          h$1("div", {
            class: "q-date__calendar-weekdays row items-center no-wrap"
          }, daysOfWeek.value.map((day) => h$1("div", { class: "q-date__calendar-item" }, [h$1("div", day)]))),
          h$1("div", {
            class: "q-date__calendar-days-container relative-position overflow-hidden"
          }, [
            h$1(Transition, {
              name: "q-transition--slide-" + monthDirection.value
            }, () => h$1("div", {
              key: viewMonthHash.value,
              class: "q-date__calendar-days fit"
            }, days.value.map((day) => h$1("div", { class: day.classes }, [
              day.in === true ? h$1(
                QBtn,
                {
                  class: day.today === true ? "q-date__today" : "",
                  dense: true,
                  flat: day.flat,
                  unelevated: day.unelevated,
                  color: day.color,
                  textColor: day.textColor,
                  label: day.i,
                  tabindex: tabindex.value,
                  ...getCache("day#" + day.i, {
                    onClick: () => {
                      onDayClick(day.i);
                    },
                    onMouseover: () => {
                      onDayMouseover(day.i);
                    }
                  })
                },
                day.event !== false ? () => h$1("div", { class: "q-date__event bg-" + day.event }) : null
              ) : h$1("div", "" + day.i)
            ]))))
          ])
        ])
      ],
      Months() {
        const currentYear = viewModel.value.year === today.value.year;
        const isDisabled = (month) => {
          return minNav.value !== null && viewModel.value.year === minNav.value.year && minNav.value.month > month || maxNav.value !== null && viewModel.value.year === maxNav.value.year && maxNav.value.month < month;
        };
        const content2 = innerLocale.value.monthsShort.map((month, i) => {
          const active = viewModel.value.month === i + 1;
          return h$1("div", {
            class: "q-date__months-item flex flex-center"
          }, [
            h$1(QBtn, {
              class: currentYear === true && today.value.month === i + 1 ? "q-date__today" : null,
              flat: active !== true,
              label: month,
              unelevated: active,
              color: active === true ? computedColor.value : null,
              textColor: active === true ? computedTextColor.value : null,
              tabindex: tabindex.value,
              disable: isDisabled(i + 1),
              ...getCache("month#" + i, { onClick: () => {
                setMonth(i + 1);
              } })
            })
          ]);
        });
        props2.yearsInMonthView === true && content2.unshift(
          h$1("div", { class: "row no-wrap full-width" }, [
            getNavigation({
              label: viewModel.value.year,
              type: "Years",
              key: viewModel.value.year,
              dir: yearDirection.value,
              goTo: goToYear,
              boundaries: navBoundaries.value.year,
              cls: " col"
            })
          ])
        );
        return h$1("div", {
          key: "months-view",
          class: "q-date__view q-date__months flex flex-center"
        }, content2);
      },
      Years() {
        const start = startYear.value, stop2 = start + yearsInterval, years = [];
        const isDisabled = (year2) => {
          return minNav.value !== null && minNav.value.year > year2 || maxNav.value !== null && maxNav.value.year < year2;
        };
        for (let i = start; i <= stop2; i++) {
          const active = viewModel.value.year === i;
          years.push(
            h$1("div", {
              class: "q-date__years-item flex flex-center"
            }, [
              h$1(QBtn, {
                key: "yr" + i,
                class: today.value.year === i ? "q-date__today" : null,
                flat: !active,
                label: i,
                dense: true,
                unelevated: active,
                color: active === true ? computedColor.value : null,
                textColor: active === true ? computedTextColor.value : null,
                tabindex: tabindex.value,
                disable: isDisabled(i),
                ...getCache("yr#" + i, { onClick: () => {
                  setYear(i);
                } })
              })
            ])
          );
        }
        return h$1("div", {
          class: "q-date__view q-date__years flex flex-center"
        }, [
          h$1("div", {
            class: "col-auto"
          }, [
            h$1(QBtn, {
              round: true,
              dense: true,
              flat: true,
              icon: dateArrow.value[0],
              tabindex: tabindex.value,
              disable: isDisabled(start),
              ...getCache("y-", { onClick: () => {
                startYear.value -= yearsInterval;
              } })
            })
          ]),
          h$1("div", {
            class: "q-date__years-content col self-stretch row items-center"
          }, years),
          h$1("div", {
            class: "col-auto"
          }, [
            h$1(QBtn, {
              round: true,
              dense: true,
              flat: true,
              icon: dateArrow.value[1],
              tabindex: tabindex.value,
              disable: isDisabled(stop2),
              ...getCache("y+", { onClick: () => {
                startYear.value += yearsInterval;
              } })
            })
          ])
        ]);
      }
    };
    function onDayClick(dayIndex) {
      const day = { ...viewModel.value, day: dayIndex };
      if (props2.range === false) {
        toggleDate(day, viewMonthHash.value);
        return;
      }
      if (editRange.value === null) {
        const dayProps = days.value.find((day2) => day2.fill !== true && day2.i === dayIndex);
        if (props2.noUnset !== true && dayProps.range !== void 0) {
          removeFromModel({ target: day, from: dayProps.range.from, to: dayProps.range.to });
          return;
        }
        if (dayProps.selected === true) {
          removeFromModel(day);
          return;
        }
        const initHash = getDayHash(day);
        editRange.value = {
          init: day,
          initHash,
          final: day,
          finalHash: initHash
        };
        emit2("rangeStart", getShortDate(day));
      } else {
        const initHash = editRange.value.initHash, finalHash = getDayHash(day), payload = initHash <= finalHash ? { from: editRange.value.init, to: day } : { from: day, to: editRange.value.init };
        editRange.value = null;
        addToModel(initHash === finalHash ? day : { target: day, ...payload });
        emit2("rangeEnd", {
          from: getShortDate(payload.from),
          to: getShortDate(payload.to)
        });
      }
    }
    function onDayMouseover(dayIndex) {
      if (editRange.value !== null) {
        const final = { ...viewModel.value, day: dayIndex };
        Object.assign(editRange.value, {
          final,
          finalHash: getDayHash(final)
        });
      }
    }
    Object.assign(proxy, {
      setToday,
      setView,
      offsetCalendar,
      setCalendarTo,
      setEditingRange
    });
    return () => {
      const content2 = [
        h$1("div", {
          class: "q-date__content col relative-position"
        }, [
          h$1(Transition, {
            name: "q-transition--fade"
          }, renderViews[view.value])
        ])
      ];
      const def2 = hSlot(slots.default);
      def2 !== void 0 && content2.push(
        h$1("div", { class: "q-date__actions" }, def2)
      );
      if (props2.name !== void 0 && props2.disable !== true) {
        injectFormInput(content2, "push");
      }
      return h$1("div", {
        class: classes.value,
        ...attributes.value
      }, [
        getHeader(),
        h$1("div", {
          ref: blurTargetRef,
          class: "q-date__main col column",
          tabindex: -1
        }, content2)
      ]);
    };
  }
});
const QPopupProxy = createComponent({
  name: "QPopupProxy",
  props: {
    ...useAnchorProps,
    breakpoint: {
      type: [String, Number],
      default: 450
    }
  },
  emits: ["show", "hide"],
  setup(props2, { slots, emit: emit2, attrs }) {
    const { proxy } = getCurrentInstance();
    const { $q } = proxy;
    const showing = ref(false);
    const popupRef = ref(null);
    const breakpoint = computed(() => parseInt(props2.breakpoint, 10));
    const { canShow } = useAnchor({ showing });
    function getType2() {
      return $q.screen.width < breakpoint.value || $q.screen.height < breakpoint.value ? "dialog" : "menu";
    }
    const type = ref(getType2());
    const popupProps = computed(
      () => type.value === "menu" ? { maxHeight: "99vh" } : {}
    );
    watch(() => getType2(), (val) => {
      if (showing.value !== true) {
        type.value = val;
      }
    });
    function onShow(evt) {
      showing.value = true;
      emit2("show", evt);
    }
    function onHide(evt) {
      showing.value = false;
      type.value = getType2();
      emit2("hide", evt);
    }
    Object.assign(proxy, {
      show(evt) {
        canShow(evt) === true && popupRef.value.show(evt);
      },
      hide(evt) {
        popupRef.value.hide(evt);
      },
      toggle(evt) {
        popupRef.value.toggle(evt);
      }
    });
    injectProp(proxy, "currentComponent", () => ({
      type: type.value,
      ref: popupRef.value
    }));
    return () => {
      const data = {
        ref: popupRef,
        ...popupProps.value,
        ...attrs,
        onShow,
        onHide
      };
      let component;
      if (type.value === "dialog") {
        component = QDialog;
      } else {
        component = QMenu;
        Object.assign(data, {
          target: props2.target,
          contextMenu: props2.contextMenu,
          noParentEvent: true,
          separateClosePopup: true
        });
      }
      return h$1(component, data, slots.default);
    };
  }
});
function getDepth(value2) {
  if (value2 === false) {
    return 0;
  }
  if (value2 === true || value2 === void 0) {
    return 1;
  }
  const depth = parseInt(value2, 10);
  return isNaN(depth) ? 0 : depth;
}
const ClosePopup = createDirective(
  {
    name: "close-popup",
    beforeMount(el, { value: value2 }) {
      const ctx = {
        depth: getDepth(value2),
        handler(evt) {
          ctx.depth !== 0 && setTimeout(() => {
            const proxy = getPortalProxy(el);
            if (proxy !== void 0) {
              closePortals(proxy, evt, ctx.depth);
            }
          });
        },
        handlerKey(evt) {
          isKeyCode(evt, 13) === true && ctx.handler(evt);
        }
      };
      el.__qclosepopup = ctx;
      el.addEventListener("click", ctx.handler);
      el.addEventListener("keyup", ctx.handlerKey);
    },
    updated(el, { value: value2, oldValue }) {
      if (value2 !== oldValue) {
        el.__qclosepopup.depth = getDepth(value2);
      }
    },
    beforeUnmount(el) {
      const ctx = el.__qclosepopup;
      el.removeEventListener("click", ctx.handler);
      el.removeEventListener("keyup", ctx.handlerKey);
      delete el.__qclosepopup;
    }
  }
);
const PACKET_TYPES = /* @__PURE__ */ Object.create(null);
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
const PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
Object.keys(PACKET_TYPES).forEach((key) => {
  PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
const ERROR_PACKET = { type: "error", data: "parser error" };
const withNativeBlob$1 = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
const withNativeArrayBuffer$2 = typeof ArrayBuffer === "function";
const isView$1 = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
};
const encodePacket = ({ type, data }, supportsBinary, callback) => {
  if (withNativeBlob$1 && data instanceof Blob) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(data, callback);
    }
  } else if (withNativeArrayBuffer$2 && (data instanceof ArrayBuffer || isView$1(data))) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(new Blob([data]), callback);
    }
  }
  return callback(PACKET_TYPES[type] + (data || ""));
};
const encodeBlobAsBase64 = (data, callback) => {
  const fileReader = new FileReader();
  fileReader.onload = function() {
    const content2 = fileReader.result.split(",")[1];
    callback("b" + (content2 || ""));
  };
  return fileReader.readAsDataURL(data);
};
function toArray(data) {
  if (data instanceof Uint8Array) {
    return data;
  } else if (data instanceof ArrayBuffer) {
    return new Uint8Array(data);
  } else {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
  }
}
let TEXT_ENCODER;
function encodePacketToBinary(packet, callback) {
  if (withNativeBlob$1 && packet.data instanceof Blob) {
    return packet.data.arrayBuffer().then(toArray).then(callback);
  } else if (withNativeArrayBuffer$2 && (packet.data instanceof ArrayBuffer || isView$1(packet.data))) {
    return callback(toArray(packet.data));
  }
  encodePacket(packet, false, (encoded) => {
    if (!TEXT_ENCODER) {
      TEXT_ENCODER = new TextEncoder();
    }
    callback(TEXT_ENCODER.encode(encoded));
  });
}
const chars$4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
const lookup$5 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (let i = 0; i < chars$4.length; i++) {
  lookup$5[chars$4.charCodeAt(i)] = i;
}
const decode$3 = (base642) => {
  let bufferLength = base642.length * 0.75, len = base642.length, i, p2 = 0, encoded1, encoded2, encoded3, encoded4;
  if (base642[base642.length - 1] === "=") {
    bufferLength--;
    if (base642[base642.length - 2] === "=") {
      bufferLength--;
    }
  }
  const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
  for (i = 0; i < len; i += 4) {
    encoded1 = lookup$5[base642.charCodeAt(i)];
    encoded2 = lookup$5[base642.charCodeAt(i + 1)];
    encoded3 = lookup$5[base642.charCodeAt(i + 2)];
    encoded4 = lookup$5[base642.charCodeAt(i + 3)];
    bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return arraybuffer;
};
const withNativeArrayBuffer$1 = typeof ArrayBuffer === "function";
const decodePacket = (encodedPacket, binaryType) => {
  if (typeof encodedPacket !== "string") {
    return {
      type: "message",
      data: mapBinary(encodedPacket, binaryType)
    };
  }
  const type = encodedPacket.charAt(0);
  if (type === "b") {
    return {
      type: "message",
      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
    };
  }
  const packetType = PACKET_TYPES_REVERSE[type];
  if (!packetType) {
    return ERROR_PACKET;
  }
  return encodedPacket.length > 1 ? {
    type: PACKET_TYPES_REVERSE[type],
    data: encodedPacket.substring(1)
  } : {
    type: PACKET_TYPES_REVERSE[type]
  };
};
const decodeBase64Packet = (data, binaryType) => {
  if (withNativeArrayBuffer$1) {
    const decoded = decode$3(data);
    return mapBinary(decoded, binaryType);
  } else {
    return { base64: true, data };
  }
};
const mapBinary = (data, binaryType) => {
  switch (binaryType) {
    case "blob":
      if (data instanceof Blob) {
        return data;
      } else {
        return new Blob([data]);
      }
    case "arraybuffer":
    default:
      if (data instanceof ArrayBuffer) {
        return data;
      } else {
        return data.buffer;
      }
  }
};
const SEPARATOR = String.fromCharCode(30);
const encodePayload = (packets, callback) => {
  const length = packets.length;
  const encodedPackets = new Array(length);
  let count = 0;
  packets.forEach((packet, i) => {
    encodePacket(packet, false, (encodedPacket) => {
      encodedPackets[i] = encodedPacket;
      if (++count === length) {
        callback(encodedPackets.join(SEPARATOR));
      }
    });
  });
};
const decodePayload = (encodedPayload, binaryType) => {
  const encodedPackets = encodedPayload.split(SEPARATOR);
  const packets = [];
  for (let i = 0; i < encodedPackets.length; i++) {
    const decodedPacket = decodePacket(encodedPackets[i], binaryType);
    packets.push(decodedPacket);
    if (decodedPacket.type === "error") {
      break;
    }
  }
  return packets;
};
function createPacketEncoderStream() {
  return new TransformStream({
    transform(packet, controller) {
      encodePacketToBinary(packet, (encodedPacket) => {
        const payloadLength = encodedPacket.length;
        let header;
        if (payloadLength < 126) {
          header = new Uint8Array(1);
          new DataView(header.buffer).setUint8(0, payloadLength);
        } else if (payloadLength < 65536) {
          header = new Uint8Array(3);
          const view = new DataView(header.buffer);
          view.setUint8(0, 126);
          view.setUint16(1, payloadLength);
        } else {
          header = new Uint8Array(9);
          const view = new DataView(header.buffer);
          view.setUint8(0, 127);
          view.setBigUint64(1, BigInt(payloadLength));
        }
        if (packet.data && typeof packet.data !== "string") {
          header[0] |= 128;
        }
        controller.enqueue(header);
        controller.enqueue(encodedPacket);
      });
    }
  });
}
let TEXT_DECODER;
function totalLength(chunks) {
  return chunks.reduce((acc, chunk) => acc + chunk.length, 0);
}
function concatChunks(chunks, size2) {
  if (chunks[0].length === size2) {
    return chunks.shift();
  }
  const buffer = new Uint8Array(size2);
  let j2 = 0;
  for (let i = 0; i < size2; i++) {
    buffer[i] = chunks[0][j2++];
    if (j2 === chunks[0].length) {
      chunks.shift();
      j2 = 0;
    }
  }
  if (chunks.length && j2 < chunks[0].length) {
    chunks[0] = chunks[0].slice(j2);
  }
  return buffer;
}
function createPacketDecoderStream(maxPayload, binaryType) {
  if (!TEXT_DECODER) {
    TEXT_DECODER = new TextDecoder();
  }
  const chunks = [];
  let state = 0;
  let expectedLength = -1;
  let isBinary2 = false;
  return new TransformStream({
    transform(chunk, controller) {
      chunks.push(chunk);
      while (true) {
        if (state === 0) {
          if (totalLength(chunks) < 1) {
            break;
          }
          const header = concatChunks(chunks, 1);
          isBinary2 = (header[0] & 128) === 128;
          expectedLength = header[0] & 127;
          if (expectedLength < 126) {
            state = 3;
          } else if (expectedLength === 126) {
            state = 1;
          } else {
            state = 2;
          }
        } else if (state === 1) {
          if (totalLength(chunks) < 2) {
            break;
          }
          const headerArray = concatChunks(chunks, 2);
          expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
          state = 3;
        } else if (state === 2) {
          if (totalLength(chunks) < 8) {
            break;
          }
          const headerArray = concatChunks(chunks, 8);
          const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
          const n2 = view.getUint32(0);
          if (n2 > Math.pow(2, 53 - 32) - 1) {
            controller.enqueue(ERROR_PACKET);
            break;
          }
          expectedLength = n2 * Math.pow(2, 32) + view.getUint32(4);
          state = 3;
        } else {
          if (totalLength(chunks) < expectedLength) {
            break;
          }
          const data = concatChunks(chunks, expectedLength);
          controller.enqueue(decodePacket(isBinary2 ? data : TEXT_DECODER.decode(data), binaryType));
          state = 0;
        }
        if (expectedLength === 0 || expectedLength > maxPayload) {
          controller.enqueue(ERROR_PACKET);
          break;
        }
      }
    }
  });
}
const protocol$1 = 4;
function Emitter(obj) {
  if (obj) return mixin(obj);
}
function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}
Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
  return this;
};
Emitter.prototype.once = function(event, fn) {
  function on2() {
    this.off(event, on2);
    fn.apply(this, arguments);
  }
  on2.fn = fn;
  this.on(event, on2);
  return this;
};
Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }
  var callbacks = this._callbacks["$" + event];
  if (!callbacks) return this;
  if (1 == arguments.length) {
    delete this._callbacks["$" + event];
    return this;
  }
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  if (callbacks.length === 0) {
    delete this._callbacks["$" + event];
  }
  return this;
};
Emitter.prototype.emit = function(event) {
  this._callbacks = this._callbacks || {};
  var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }
  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }
  return this;
};
Emitter.prototype.emitReserved = Emitter.prototype.emit;
Emitter.prototype.listeners = function(event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks["$" + event] || [];
};
Emitter.prototype.hasListeners = function(event) {
  return !!this.listeners(event).length;
};
const nextTick = (() => {
  const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
  if (isPromiseAvailable) {
    return (cb) => Promise.resolve().then(cb);
  } else {
    return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
  }
})();
const globalThisShim = (() => {
  if (typeof self !== "undefined") {
    return self;
  } else if (typeof window !== "undefined") {
    return window;
  } else {
    return Function("return this")();
  }
})();
const defaultBinaryType = "arraybuffer";
function createCookieJar() {
}
function pick(obj, ...attr) {
  return attr.reduce((acc, k2) => {
    if (obj.hasOwnProperty(k2)) {
      acc[k2] = obj[k2];
    }
    return acc;
  }, {});
}
const NATIVE_SET_TIMEOUT = globalThisShim.setTimeout;
const NATIVE_CLEAR_TIMEOUT = globalThisShim.clearTimeout;
function installTimerFunctions(obj, opts) {
  if (opts.useNativeTimers) {
    obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim);
    obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim);
  } else {
    obj.setTimeoutFn = globalThisShim.setTimeout.bind(globalThisShim);
    obj.clearTimeoutFn = globalThisShim.clearTimeout.bind(globalThisShim);
  }
}
const BASE64_OVERHEAD = 1.33;
function byteLength(obj) {
  if (typeof obj === "string") {
    return utf8Length(obj);
  }
  return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
}
function utf8Length(str) {
  let c2 = 0, length = 0;
  for (let i = 0, l2 = str.length; i < l2; i++) {
    c2 = str.charCodeAt(i);
    if (c2 < 128) {
      length += 1;
    } else if (c2 < 2048) {
      length += 2;
    } else if (c2 < 55296 || c2 >= 57344) {
      length += 3;
    } else {
      i++;
      length += 4;
    }
  }
  return length;
}
function randomString() {
  return Date.now().toString(36).substring(3) + Math.random().toString(36).substring(2, 5);
}
function encode(obj) {
  let str = "";
  for (let i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length)
        str += "&";
      str += encodeURIComponent(i) + "=" + encodeURIComponent(obj[i]);
    }
  }
  return str;
}
function decode$2(qs) {
  let qry = {};
  let pairs = qs.split("&");
  for (let i = 0, l2 = pairs.length; i < l2; i++) {
    let pair = pairs[i].split("=");
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
}
class TransportError extends Error {
  constructor(reason, description, context) {
    super(reason);
    this.description = description;
    this.context = context;
    this.type = "TransportError";
  }
}
class Transport extends Emitter {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  constructor(opts) {
    super();
    this.writable = false;
    installTimerFunctions(this, opts);
    this.opts = opts;
    this.query = opts.query;
    this.socket = opts.socket;
    this.supportsBinary = !opts.forceBase64;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  onError(reason, description, context) {
    super.emitReserved("error", new TransportError(reason, description, context));
    return this;
  }
  /**
   * Opens the transport.
   */
  open() {
    this.readyState = "opening";
    this.doOpen();
    return this;
  }
  /**
   * Closes the transport.
   */
  close() {
    if (this.readyState === "opening" || this.readyState === "open") {
      this.doClose();
      this.onClose();
    }
    return this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   */
  send(packets) {
    if (this.readyState === "open") {
      this.write(packets);
    }
  }
  /**
   * Called upon open
   *
   * @protected
   */
  onOpen() {
    this.readyState = "open";
    this.writable = true;
    super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @protected
   */
  onData(data) {
    const packet = decodePacket(data, this.socket.binaryType);
    this.onPacket(packet);
  }
  /**
   * Called with a decoded packet.
   *
   * @protected
   */
  onPacket(packet) {
    super.emitReserved("packet", packet);
  }
  /**
   * Called upon close.
   *
   * @protected
   */
  onClose(details) {
    this.readyState = "closed";
    super.emitReserved("close", details);
  }
  /**
   * Pauses the transport, in order not to lose packets during an upgrade.
   *
   * @param onPause
   */
  pause(onPause) {
  }
  createUri(schema, query = {}) {
    return schema + "://" + this._hostname() + this._port() + this.opts.path + this._query(query);
  }
  _hostname() {
    const hostname = this.opts.hostname;
    return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
  }
  _port() {
    if (this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80)) {
      return ":" + this.opts.port;
    } else {
      return "";
    }
  }
  _query(query) {
    const encodedQuery = encode(query);
    return encodedQuery.length ? "?" + encodedQuery : "";
  }
}
class Polling extends Transport {
  constructor() {
    super(...arguments);
    this._polling = false;
  }
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @protected
   */
  doOpen() {
    this._poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
   * @package
   */
  pause(onPause) {
    this.readyState = "pausing";
    const pause = () => {
      this.readyState = "paused";
      onPause();
    };
    if (this._polling || !this.writable) {
      let total = 0;
      if (this._polling) {
        total++;
        this.once("pollComplete", function() {
          --total || pause();
        });
      }
      if (!this.writable) {
        total++;
        this.once("drain", function() {
          --total || pause();
        });
      }
    } else {
      pause();
    }
  }
  /**
   * Starts polling cycle.
   *
   * @private
   */
  _poll() {
    this._polling = true;
    this.doPoll();
    this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @protected
   */
  onData(data) {
    const callback = (packet) => {
      if ("opening" === this.readyState && packet.type === "open") {
        this.onOpen();
      }
      if ("close" === packet.type) {
        this.onClose({ description: "transport closed by the server" });
        return false;
      }
      this.onPacket(packet);
    };
    decodePayload(data, this.socket.binaryType).forEach(callback);
    if ("closed" !== this.readyState) {
      this._polling = false;
      this.emitReserved("pollComplete");
      if ("open" === this.readyState) {
        this._poll();
      }
    }
  }
  /**
   * For polling, send a close packet.
   *
   * @protected
   */
  doClose() {
    const close = () => {
      this.write([{ type: "close" }]);
    };
    if ("open" === this.readyState) {
      close();
    } else {
      this.once("open", close);
    }
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} packets - data packets
   * @protected
   */
  write(packets) {
    this.writable = false;
    encodePayload(packets, (data) => {
      this.doWrite(data, () => {
        this.writable = true;
        this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const schema = this.opts.secure ? "https" : "http";
    const query = this.query || {};
    if (false !== this.opts.timestampRequests) {
      query[this.opts.timestampParam] = randomString();
    }
    if (!this.supportsBinary && !query.sid) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
}
let value$1 = false;
try {
  value$1 = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
} catch (err) {
}
const hasCORS = value$1;
function empty() {
}
class BaseXHR extends Polling {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  constructor(opts) {
    super(opts);
    if (typeof location !== "undefined") {
      const isSSL = "https:" === location.protocol;
      let port = location.port;
      if (!port) {
        port = isSSL ? "443" : "80";
      }
      this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
    }
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  doWrite(data, fn) {
    const req = this.request({
      method: "POST",
      data
    });
    req.on("success", fn);
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr post error", xhrStatus, context);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @private
   */
  doPoll() {
    const req = this.request();
    req.on("data", this.onData.bind(this));
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr poll error", xhrStatus, context);
    });
    this.pollXhr = req;
  }
}
let Request$1 = class Request2 extends Emitter {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  constructor(createRequest, uri, opts) {
    super();
    this.createRequest = createRequest;
    installTimerFunctions(this, opts);
    this._opts = opts;
    this._method = opts.method || "GET";
    this._uri = uri;
    this._data = void 0 !== opts.data ? opts.data : null;
    this._create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  _create() {
    var _a2;
    const opts = pick(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    opts.xdomain = !!this._opts.xd;
    const xhr = this._xhr = this.createRequest(opts);
    try {
      xhr.open(this._method, this._uri, true);
      try {
        if (this._opts.extraHeaders) {
          xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
          for (let i in this._opts.extraHeaders) {
            if (this._opts.extraHeaders.hasOwnProperty(i)) {
              xhr.setRequestHeader(i, this._opts.extraHeaders[i]);
            }
          }
        }
      } catch (e2) {
      }
      if ("POST" === this._method) {
        try {
          xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch (e2) {
        }
      }
      try {
        xhr.setRequestHeader("Accept", "*/*");
      } catch (e2) {
      }
      (_a2 = this._opts.cookieJar) === null || _a2 === void 0 ? void 0 : _a2.addCookies(xhr);
      if ("withCredentials" in xhr) {
        xhr.withCredentials = this._opts.withCredentials;
      }
      if (this._opts.requestTimeout) {
        xhr.timeout = this._opts.requestTimeout;
      }
      xhr.onreadystatechange = () => {
        var _a3;
        if (xhr.readyState === 3) {
          (_a3 = this._opts.cookieJar) === null || _a3 === void 0 ? void 0 : _a3.parseCookies(
            // @ts-ignore
            xhr.getResponseHeader("set-cookie")
          );
        }
        if (4 !== xhr.readyState)
          return;
        if (200 === xhr.status || 1223 === xhr.status) {
          this._onLoad();
        } else {
          this.setTimeoutFn(() => {
            this._onError(typeof xhr.status === "number" ? xhr.status : 0);
          }, 0);
        }
      };
      xhr.send(this._data);
    } catch (e2) {
      this.setTimeoutFn(() => {
        this._onError(e2);
      }, 0);
      return;
    }
    if (typeof document !== "undefined") {
      this._index = Request2.requestsCount++;
      Request2.requests[this._index] = this;
    }
  }
  /**
   * Called upon error.
   *
   * @private
   */
  _onError(err) {
    this.emitReserved("error", err, this._xhr);
    this._cleanup(true);
  }
  /**
   * Cleans up house.
   *
   * @private
   */
  _cleanup(fromError) {
    if ("undefined" === typeof this._xhr || null === this._xhr) {
      return;
    }
    this._xhr.onreadystatechange = empty;
    if (fromError) {
      try {
        this._xhr.abort();
      } catch (e2) {
      }
    }
    if (typeof document !== "undefined") {
      delete Request2.requests[this._index];
    }
    this._xhr = null;
  }
  /**
   * Called upon load.
   *
   * @private
   */
  _onLoad() {
    const data = this._xhr.responseText;
    if (data !== null) {
      this.emitReserved("data", data);
      this.emitReserved("success");
      this._cleanup();
    }
  }
  /**
   * Aborts the request.
   *
   * @package
   */
  abort() {
    this._cleanup();
  }
};
Request$1.requestsCount = 0;
Request$1.requests = {};
if (typeof document !== "undefined") {
  if (typeof attachEvent === "function") {
    attachEvent("onunload", unloadHandler);
  } else if (typeof addEventListener === "function") {
    const terminationEvent = "onpagehide" in globalThisShim ? "pagehide" : "unload";
    addEventListener(terminationEvent, unloadHandler, false);
  }
}
function unloadHandler() {
  for (let i in Request$1.requests) {
    if (Request$1.requests.hasOwnProperty(i)) {
      Request$1.requests[i].abort();
    }
  }
}
const hasXHR2 = function() {
  const xhr = newRequest({
    xdomain: false
  });
  return xhr && xhr.responseType !== null;
}();
class XHR extends BaseXHR {
  constructor(opts) {
    super(opts);
    const forceBase64 = opts && opts.forceBase64;
    this.supportsBinary = hasXHR2 && !forceBase64;
  }
  request(opts = {}) {
    Object.assign(opts, { xd: this.xd }, this.opts);
    return new Request$1(newRequest, this.uri(), opts);
  }
}
function newRequest(opts) {
  const xdomain = opts.xdomain;
  try {
    if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e2) {
  }
  if (!xdomain) {
    try {
      return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch (e2) {
    }
  }
}
const isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
class BaseWS extends Transport {
  get name() {
    return "websocket";
  }
  doOpen() {
    const uri = this.uri();
    const protocols = this.opts.protocols;
    const opts = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    if (this.opts.extraHeaders) {
      opts.headers = this.opts.extraHeaders;
    }
    try {
      this.ws = this.createSocket(uri, protocols, opts);
    } catch (err) {
      return this.emitReserved("error", err);
    }
    this.ws.binaryType = this.socket.binaryType;
    this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      if (this.opts.autoUnref) {
        this.ws._socket.unref();
      }
      this.onOpen();
    };
    this.ws.onclose = (closeEvent) => this.onClose({
      description: "websocket connection closed",
      context: closeEvent
    });
    this.ws.onmessage = (ev) => this.onData(ev.data);
    this.ws.onerror = (e2) => this.onError("websocket error", e2);
  }
  write(packets) {
    this.writable = false;
    for (let i = 0; i < packets.length; i++) {
      const packet = packets[i];
      const lastPacket = i === packets.length - 1;
      encodePacket(packet, this.supportsBinary, (data) => {
        try {
          this.doWrite(packet, data);
        } catch (e2) {
        }
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    if (typeof this.ws !== "undefined") {
      this.ws.onerror = () => {
      };
      this.ws.close();
      this.ws = null;
    }
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const schema = this.opts.secure ? "wss" : "ws";
    const query = this.query || {};
    if (this.opts.timestampRequests) {
      query[this.opts.timestampParam] = randomString();
    }
    if (!this.supportsBinary) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
}
const WebSocketCtor = globalThisShim.WebSocket || globalThisShim.MozWebSocket;
class WS extends BaseWS {
  createSocket(uri, protocols, opts) {
    return !isReactNative ? protocols ? new WebSocketCtor(uri, protocols) : new WebSocketCtor(uri) : new WebSocketCtor(uri, protocols, opts);
  }
  doWrite(_packet, data) {
    this.ws.send(data);
  }
}
class WT extends Transport {
  get name() {
    return "webtransport";
  }
  doOpen() {
    try {
      this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
    } catch (err) {
      return this.emitReserved("error", err);
    }
    this._transport.closed.then(() => {
      this.onClose();
    }).catch((err) => {
      this.onError("webtransport error", err);
    });
    this._transport.ready.then(() => {
      this._transport.createBidirectionalStream().then((stream) => {
        const decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType);
        const reader = stream.readable.pipeThrough(decoderStream).getReader();
        const encoderStream = createPacketEncoderStream();
        encoderStream.readable.pipeTo(stream.writable);
        this._writer = encoderStream.writable.getWriter();
        const read = () => {
          reader.read().then(({ done, value: value2 }) => {
            if (done) {
              return;
            }
            this.onPacket(value2);
            read();
          }).catch((err) => {
          });
        };
        read();
        const packet = { type: "open" };
        if (this.query.sid) {
          packet.data = `{"sid":"${this.query.sid}"}`;
        }
        this._writer.write(packet).then(() => this.onOpen());
      });
    });
  }
  write(packets) {
    this.writable = false;
    for (let i = 0; i < packets.length; i++) {
      const packet = packets[i];
      const lastPacket = i === packets.length - 1;
      this._writer.write(packet).then(() => {
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    var _a2;
    (_a2 = this._transport) === null || _a2 === void 0 ? void 0 : _a2.close();
  }
}
const transports = {
  websocket: WS,
  webtransport: WT,
  polling: XHR
};
const re$1 = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
const parts = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function parse$1(str) {
  if (str.length > 8e3) {
    throw "URI too long";
  }
  const src = str, b2 = str.indexOf("["), e2 = str.indexOf("]");
  if (b2 != -1 && e2 != -1) {
    str = str.substring(0, b2) + str.substring(b2, e2).replace(/:/g, ";") + str.substring(e2, str.length);
  }
  let m2 = re$1.exec(str || ""), uri = {}, i = 14;
  while (i--) {
    uri[parts[i]] = m2[i] || "";
  }
  if (b2 != -1 && e2 != -1) {
    uri.source = src;
    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
    uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
    uri.ipv6uri = true;
  }
  uri.pathNames = pathNames(uri, uri["path"]);
  uri.queryKey = queryKey(uri, uri["query"]);
  return uri;
}
function pathNames(obj, path) {
  const regx = /\/{2,9}/g, names = path.replace(regx, "/").split("/");
  if (path.slice(0, 1) == "/" || path.length === 0) {
    names.splice(0, 1);
  }
  if (path.slice(-1) == "/") {
    names.splice(names.length - 1, 1);
  }
  return names;
}
function queryKey(uri, query) {
  const data = {};
  query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
    if ($1) {
      data[$1] = $2;
    }
  });
  return data;
}
const withEventListeners = typeof addEventListener === "function" && typeof removeEventListener === "function";
const OFFLINE_EVENT_LISTENERS = [];
if (withEventListeners) {
  addEventListener("offline", () => {
    OFFLINE_EVENT_LISTENERS.forEach((listener) => listener());
  }, false);
}
class SocketWithoutUpgrade extends Emitter {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  constructor(uri, opts) {
    super();
    this.binaryType = defaultBinaryType;
    this.writeBuffer = [];
    this._prevBufferLen = 0;
    this._pingInterval = -1;
    this._pingTimeout = -1;
    this._maxPayload = -1;
    this._pingTimeoutTime = Infinity;
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = null;
    }
    if (uri) {
      const parsedUri = parse$1(uri);
      opts.hostname = parsedUri.host;
      opts.secure = parsedUri.protocol === "https" || parsedUri.protocol === "wss";
      opts.port = parsedUri.port;
      if (parsedUri.query)
        opts.query = parsedUri.query;
    } else if (opts.host) {
      opts.hostname = parse$1(opts.host).host;
    }
    installTimerFunctions(this, opts);
    this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
    if (opts.hostname && !opts.port) {
      opts.port = this.secure ? "443" : "80";
    }
    this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
    this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? "443" : "80");
    this.transports = [];
    this._transportsByName = {};
    opts.transports.forEach((t2) => {
      const transportName = t2.prototype.name;
      this.transports.push(transportName);
      this._transportsByName[transportName] = t2;
    });
    this.opts = Object.assign({
      path: "/engine.io",
      agent: false,
      withCredentials: false,
      upgrade: true,
      timestampParam: "t",
      rememberUpgrade: false,
      addTrailingSlash: true,
      rejectUnauthorized: true,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: false
    }, opts);
    this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : "");
    if (typeof this.opts.query === "string") {
      this.opts.query = decode$2(this.opts.query);
    }
    if (withEventListeners) {
      if (this.opts.closeOnBeforeunload) {
        this._beforeunloadEventListener = () => {
          if (this.transport) {
            this.transport.removeAllListeners();
            this.transport.close();
          }
        };
        addEventListener("beforeunload", this._beforeunloadEventListener, false);
      }
      if (this.hostname !== "localhost") {
        this._offlineEventListener = () => {
          this._onClose("transport close", {
            description: "network connection lost"
          });
        };
        OFFLINE_EVENT_LISTENERS.push(this._offlineEventListener);
      }
    }
    if (this.opts.withCredentials) {
      this._cookieJar = createCookieJar();
    }
    this._open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  createTransport(name) {
    const query = Object.assign({}, this.opts.query);
    query.EIO = protocol$1;
    query.transport = name;
    if (this.id)
      query.sid = this.id;
    const opts = Object.assign({}, this.opts, {
      query,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[name]);
    return new this._transportsByName[name](opts);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @private
   */
  _open() {
    if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    }
    const transportName = this.opts.rememberUpgrade && SocketWithoutUpgrade.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1 ? "websocket" : this.transports[0];
    this.readyState = "opening";
    const transport = this.createTransport(transportName);
    transport.open();
    this.setTransport(transport);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @private
   */
  setTransport(transport) {
    if (this.transport) {
      this.transport.removeAllListeners();
    }
    this.transport = transport;
    transport.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", (reason) => this._onClose("transport close", reason));
  }
  /**
   * Called when connection is deemed open.
   *
   * @private
   */
  onOpen() {
    this.readyState = "open";
    SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === this.transport.name;
    this.emitReserved("open");
    this.flush();
  }
  /**
   * Handles a packet.
   *
   * @private
   */
  _onPacket(packet) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.emitReserved("packet", packet);
      this.emitReserved("heartbeat");
      switch (packet.type) {
        case "open":
          this.onHandshake(JSON.parse(packet.data));
          break;
        case "ping":
          this._sendPacket("pong");
          this.emitReserved("ping");
          this.emitReserved("pong");
          this._resetPingTimeout();
          break;
        case "error":
          const err = new Error("server error");
          err.code = packet.data;
          this._onError(err);
          break;
        case "message":
          this.emitReserved("data", packet.data);
          this.emitReserved("message", packet.data);
          break;
      }
    }
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @private
   */
  onHandshake(data) {
    this.emitReserved("handshake", data);
    this.id = data.sid;
    this.transport.query.sid = data.sid;
    this._pingInterval = data.pingInterval;
    this._pingTimeout = data.pingTimeout;
    this._maxPayload = data.maxPayload;
    this.onOpen();
    if ("closed" === this.readyState)
      return;
    this._resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @private
   */
  _resetPingTimeout() {
    this.clearTimeoutFn(this._pingTimeoutTimer);
    const delay = this._pingInterval + this._pingTimeout;
    this._pingTimeoutTime = Date.now() + delay;
    this._pingTimeoutTimer = this.setTimeoutFn(() => {
      this._onClose("ping timeout");
    }, delay);
    if (this.opts.autoUnref) {
      this._pingTimeoutTimer.unref();
    }
  }
  /**
   * Called on `drain` event
   *
   * @private
   */
  _onDrain() {
    this.writeBuffer.splice(0, this._prevBufferLen);
    this._prevBufferLen = 0;
    if (0 === this.writeBuffer.length) {
      this.emitReserved("drain");
    } else {
      this.flush();
    }
  }
  /**
   * Flush write buffers.
   *
   * @private
   */
  flush() {
    if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const packets = this._getWritablePackets();
      this.transport.send(packets);
      this._prevBufferLen = packets.length;
      this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  _getWritablePackets() {
    const shouldCheckPayloadSize = this._maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
    if (!shouldCheckPayloadSize) {
      return this.writeBuffer;
    }
    let payloadSize = 1;
    for (let i = 0; i < this.writeBuffer.length; i++) {
      const data = this.writeBuffer[i].data;
      if (data) {
        payloadSize += byteLength(data);
      }
      if (i > 0 && payloadSize > this._maxPayload) {
        return this.writeBuffer.slice(0, i);
      }
      payloadSize += 2;
    }
    return this.writeBuffer;
  }
  /**
   * Checks whether the heartbeat timer has expired but the socket has not yet been notified.
   *
   * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
   * `write()` method then the message would not be buffered by the Socket.IO client.
   *
   * @return {boolean}
   * @private
   */
  /* private */
  _hasPingExpired() {
    if (!this._pingTimeoutTime)
      return true;
    const hasExpired = Date.now() > this._pingTimeoutTime;
    if (hasExpired) {
      this._pingTimeoutTime = 0;
      nextTick(() => {
        this._onClose("ping timeout");
      }, this.setTimeoutFn);
    }
    return hasExpired;
  }
  /**
   * Sends a message.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  write(msg, options, fn) {
    this._sendPacket("message", msg, options, fn);
    return this;
  }
  /**
   * Sends a message. Alias of {@link Socket#write}.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  send(msg, options, fn) {
    this._sendPacket("message", msg, options, fn);
    return this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type: packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @private
   */
  _sendPacket(type, data, options, fn) {
    if ("function" === typeof data) {
      fn = data;
      data = void 0;
    }
    if ("function" === typeof options) {
      fn = options;
      options = null;
    }
    if ("closing" === this.readyState || "closed" === this.readyState) {
      return;
    }
    options = options || {};
    options.compress = false !== options.compress;
    const packet = {
      type,
      data,
      options
    };
    this.emitReserved("packetCreate", packet);
    this.writeBuffer.push(packet);
    if (fn)
      this.once("flush", fn);
    this.flush();
  }
  /**
   * Closes the connection.
   */
  close() {
    const close = () => {
      this._onClose("forced close");
      this.transport.close();
    };
    const cleanupAndClose = () => {
      this.off("upgrade", cleanupAndClose);
      this.off("upgradeError", cleanupAndClose);
      close();
    };
    const waitForUpgrade = () => {
      this.once("upgrade", cleanupAndClose);
      this.once("upgradeError", cleanupAndClose);
    };
    if ("opening" === this.readyState || "open" === this.readyState) {
      this.readyState = "closing";
      if (this.writeBuffer.length) {
        this.once("drain", () => {
          if (this.upgrading) {
            waitForUpgrade();
          } else {
            close();
          }
        });
      } else if (this.upgrading) {
        waitForUpgrade();
      } else {
        close();
      }
    }
    return this;
  }
  /**
   * Called upon transport error
   *
   * @private
   */
  _onError(err) {
    SocketWithoutUpgrade.priorWebsocketSuccess = false;
    if (this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === "opening") {
      this.transports.shift();
      return this._open();
    }
    this.emitReserved("error", err);
    this._onClose("transport error", err);
  }
  /**
   * Called upon transport close.
   *
   * @private
   */
  _onClose(reason, description) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.clearTimeoutFn(this._pingTimeoutTimer);
      this.transport.removeAllListeners("close");
      this.transport.close();
      this.transport.removeAllListeners();
      if (withEventListeners) {
        if (this._beforeunloadEventListener) {
          removeEventListener("beforeunload", this._beforeunloadEventListener, false);
        }
        if (this._offlineEventListener) {
          const i = OFFLINE_EVENT_LISTENERS.indexOf(this._offlineEventListener);
          if (i !== -1) {
            OFFLINE_EVENT_LISTENERS.splice(i, 1);
          }
        }
      }
      this.readyState = "closed";
      this.id = null;
      this.emitReserved("close", reason, description);
      this.writeBuffer = [];
      this._prevBufferLen = 0;
    }
  }
}
SocketWithoutUpgrade.protocol = protocol$1;
class SocketWithUpgrade extends SocketWithoutUpgrade {
  constructor() {
    super(...arguments);
    this._upgrades = [];
  }
  onOpen() {
    super.onOpen();
    if ("open" === this.readyState && this.opts.upgrade) {
      for (let i = 0; i < this._upgrades.length; i++) {
        this._probe(this._upgrades[i]);
      }
    }
  }
  /**
   * Probes a transport.
   *
   * @param {String} name - transport name
   * @private
   */
  _probe(name) {
    let transport = this.createTransport(name);
    let failed = false;
    SocketWithoutUpgrade.priorWebsocketSuccess = false;
    const onTransportOpen = () => {
      if (failed)
        return;
      transport.send([{ type: "ping", data: "probe" }]);
      transport.once("packet", (msg) => {
        if (failed)
          return;
        if ("pong" === msg.type && "probe" === msg.data) {
          this.upgrading = true;
          this.emitReserved("upgrading", transport);
          if (!transport)
            return;
          SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === transport.name;
          this.transport.pause(() => {
            if (failed)
              return;
            if ("closed" === this.readyState)
              return;
            cleanup();
            this.setTransport(transport);
            transport.send([{ type: "upgrade" }]);
            this.emitReserved("upgrade", transport);
            transport = null;
            this.upgrading = false;
            this.flush();
          });
        } else {
          const err = new Error("probe error");
          err.transport = transport.name;
          this.emitReserved("upgradeError", err);
        }
      });
    };
    function freezeTransport() {
      if (failed)
        return;
      failed = true;
      cleanup();
      transport.close();
      transport = null;
    }
    const onerror = (err) => {
      const error = new Error("probe error: " + err);
      error.transport = transport.name;
      freezeTransport();
      this.emitReserved("upgradeError", error);
    };
    function onTransportClose() {
      onerror("transport closed");
    }
    function onclose() {
      onerror("socket closed");
    }
    function onupgrade(to) {
      if (transport && to.name !== transport.name) {
        freezeTransport();
      }
    }
    const cleanup = () => {
      transport.removeListener("open", onTransportOpen);
      transport.removeListener("error", onerror);
      transport.removeListener("close", onTransportClose);
      this.off("close", onclose);
      this.off("upgrading", onupgrade);
    };
    transport.once("open", onTransportOpen);
    transport.once("error", onerror);
    transport.once("close", onTransportClose);
    this.once("close", onclose);
    this.once("upgrading", onupgrade);
    if (this._upgrades.indexOf("webtransport") !== -1 && name !== "webtransport") {
      this.setTimeoutFn(() => {
        if (!failed) {
          transport.open();
        }
      }, 200);
    } else {
      transport.open();
    }
  }
  onHandshake(data) {
    this._upgrades = this._filterUpgrades(data.upgrades);
    super.onHandshake(data);
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} upgrades - server upgrades
   * @private
   */
  _filterUpgrades(upgrades) {
    const filteredUpgrades = [];
    for (let i = 0; i < upgrades.length; i++) {
      if (~this.transports.indexOf(upgrades[i]))
        filteredUpgrades.push(upgrades[i]);
    }
    return filteredUpgrades;
  }
}
let Socket$1 = class Socket extends SocketWithUpgrade {
  constructor(uri, opts = {}) {
    const o2 = typeof uri === "object" ? uri : opts;
    if (!o2.transports || o2.transports && typeof o2.transports[0] === "string") {
      o2.transports = (o2.transports || ["polling", "websocket", "webtransport"]).map((transportName) => transports[transportName]).filter((t2) => !!t2);
    }
    super(uri, o2);
  }
};
function url(uri, path = "", loc) {
  let obj = uri;
  loc = loc || typeof location !== "undefined" && location;
  if (null == uri)
    uri = loc.protocol + "//" + loc.host;
  if (typeof uri === "string") {
    if ("/" === uri.charAt(0)) {
      if ("/" === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }
    if (!/^(https?|wss?):\/\//.test(uri)) {
      if ("undefined" !== typeof loc) {
        uri = loc.protocol + "//" + uri;
      } else {
        uri = "https://" + uri;
      }
    }
    obj = parse$1(uri);
  }
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = "80";
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = "443";
    }
  }
  obj.path = obj.path || "/";
  const ipv6 = obj.host.indexOf(":") !== -1;
  const host = ipv6 ? "[" + obj.host + "]" : obj.host;
  obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
  obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
  return obj;
}
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
const isView = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};
const toString2 = Object.prototype.toString;
const withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString2.call(Blob) === "[object BlobConstructor]";
const withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString2.call(File) === "[object FileConstructor]";
function isBinary(obj) {
  return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
}
function hasBinary(obj, toJSON2) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  if (Array.isArray(obj)) {
    for (let i = 0, l2 = obj.length; i < l2; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }
    return false;
  }
  if (isBinary(obj)) {
    return true;
  }
  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }
  return false;
}
function deconstructPacket(packet) {
  const buffers = [];
  const packetData = packet.data;
  const pack2 = packet;
  pack2.data = _deconstructPacket(packetData, buffers);
  pack2.attachments = buffers.length;
  return { packet: pack2, buffers };
}
function _deconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (isBinary(data)) {
    const placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (Array.isArray(data)) {
    const newData = new Array(data.length);
    for (let i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers);
    }
    return newData;
  } else if (typeof data === "object" && !(data instanceof Date)) {
    const newData = {};
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        newData[key] = _deconstructPacket(data[key], buffers);
      }
    }
    return newData;
  }
  return data;
}
function reconstructPacket(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  delete packet.attachments;
  return packet;
}
function _reconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (data && data._placeholder === true) {
    const isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
    if (isIndexValid) {
      return buffers[data.num];
    } else {
      throw new Error("illegal attachments");
    }
  } else if (Array.isArray(data)) {
    for (let i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers);
    }
  } else if (typeof data === "object") {
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        data[key] = _reconstructPacket(data[key], buffers);
      }
    }
  }
  return data;
}
const RESERVED_EVENTS$1 = [
  "connect",
  "connect_error",
  "disconnect",
  "disconnecting",
  "newListener",
  "removeListener"
  // used by the Node.js EventEmitter
];
const protocol = 5;
var PacketType;
(function(PacketType2) {
  PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
  PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
  PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
  PacketType2[PacketType2["ACK"] = 3] = "ACK";
  PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
  PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
  PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
class Encoder {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  constructor(replacer2) {
    this.replacer = replacer2;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  encode(obj) {
    if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
      if (hasBinary(obj)) {
        return this.encodeAsBinary({
          type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
          nsp: obj.nsp,
          data: obj.data,
          id: obj.id
        });
      }
    }
    return [this.encodeAsString(obj)];
  }
  /**
   * Encode packet as string.
   */
  encodeAsString(obj) {
    let str = "" + obj.type;
    if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
      str += obj.attachments + "-";
    }
    if (obj.nsp && "/" !== obj.nsp) {
      str += obj.nsp + ",";
    }
    if (null != obj.id) {
      str += obj.id;
    }
    if (null != obj.data) {
      str += JSON.stringify(obj.data, this.replacer);
    }
    return str;
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   */
  encodeAsBinary(obj) {
    const deconstruction = deconstructPacket(obj);
    const pack2 = this.encodeAsString(deconstruction.packet);
    const buffers = deconstruction.buffers;
    buffers.unshift(pack2);
    return buffers;
  }
}
function isObject(value2) {
  return Object.prototype.toString.call(value2) === "[object Object]";
}
class Decoder extends Emitter {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  constructor(reviver) {
    super();
    this.reviver = reviver;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  add(obj) {
    let packet;
    if (typeof obj === "string") {
      if (this.reconstructor) {
        throw new Error("got plaintext data when reconstructing a packet");
      }
      packet = this.decodeString(obj);
      const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
      if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
        packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
        this.reconstructor = new BinaryReconstructor(packet);
        if (packet.attachments === 0) {
          super.emitReserved("decoded", packet);
        }
      } else {
        super.emitReserved("decoded", packet);
      }
    } else if (isBinary(obj) || obj.base64) {
      if (!this.reconstructor) {
        throw new Error("got binary data when not reconstructing a packet");
      } else {
        packet = this.reconstructor.takeBinaryData(obj);
        if (packet) {
          this.reconstructor = null;
          super.emitReserved("decoded", packet);
        }
      }
    } else {
      throw new Error("Unknown type: " + obj);
    }
  }
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   */
  decodeString(str) {
    let i = 0;
    const p2 = {
      type: Number(str.charAt(0))
    };
    if (PacketType[p2.type] === void 0) {
      throw new Error("unknown packet type " + p2.type);
    }
    if (p2.type === PacketType.BINARY_EVENT || p2.type === PacketType.BINARY_ACK) {
      const start = i + 1;
      while (str.charAt(++i) !== "-" && i != str.length) {
      }
      const buf2 = str.substring(start, i);
      if (buf2 != Number(buf2) || str.charAt(i) !== "-") {
        throw new Error("Illegal attachments");
      }
      p2.attachments = Number(buf2);
    }
    if ("/" === str.charAt(i + 1)) {
      const start = i + 1;
      while (++i) {
        const c2 = str.charAt(i);
        if ("," === c2)
          break;
        if (i === str.length)
          break;
      }
      p2.nsp = str.substring(start, i);
    } else {
      p2.nsp = "/";
    }
    const next = str.charAt(i + 1);
    if ("" !== next && Number(next) == next) {
      const start = i + 1;
      while (++i) {
        const c2 = str.charAt(i);
        if (null == c2 || Number(c2) != c2) {
          --i;
          break;
        }
        if (i === str.length)
          break;
      }
      p2.id = Number(str.substring(start, i + 1));
    }
    if (str.charAt(++i)) {
      const payload = this.tryParse(str.substr(i));
      if (Decoder.isPayloadValid(p2.type, payload)) {
        p2.data = payload;
      } else {
        throw new Error("invalid payload");
      }
    }
    return p2;
  }
  tryParse(str) {
    try {
      return JSON.parse(str, this.reviver);
    } catch (e2) {
      return false;
    }
  }
  static isPayloadValid(type, payload) {
    switch (type) {
      case PacketType.CONNECT:
        return isObject(payload);
      case PacketType.DISCONNECT:
        return payload === void 0;
      case PacketType.CONNECT_ERROR:
        return typeof payload === "string" || isObject(payload);
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        return Array.isArray(payload) && (typeof payload[0] === "number" || typeof payload[0] === "string" && RESERVED_EVENTS$1.indexOf(payload[0]) === -1);
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        return Array.isArray(payload);
    }
  }
  /**
   * Deallocates a parser's resources
   */
  destroy() {
    if (this.reconstructor) {
      this.reconstructor.finishedReconstruction();
      this.reconstructor = null;
    }
  }
}
class BinaryReconstructor {
  constructor(packet) {
    this.packet = packet;
    this.buffers = [];
    this.reconPack = packet;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  takeBinaryData(binData) {
    this.buffers.push(binData);
    if (this.buffers.length === this.reconPack.attachments) {
      const packet = reconstructPacket(this.reconPack, this.buffers);
      this.finishedReconstruction();
      return packet;
    }
    return null;
  }
  /**
   * Cleans up binary packet reconstruction variables.
   */
  finishedReconstruction() {
    this.reconPack = null;
    this.buffers = [];
  }
}
const parser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Decoder,
  Encoder,
  get PacketType() {
    return PacketType;
  },
  protocol
}, Symbol.toStringTag, { value: "Module" }));
function on(obj, ev, fn) {
  obj.on(ev, fn);
  return function subDestroy() {
    obj.off(ev, fn);
  };
}
const RESERVED_EVENTS = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
class Socket2 extends Emitter {
  /**
   * `Socket` constructor.
   */
  constructor(io, nsp, opts) {
    super();
    this.connected = false;
    this.recovered = false;
    this.receiveBuffer = [];
    this.sendBuffer = [];
    this._queue = [];
    this._queueSeq = 0;
    this.ids = 0;
    this.acks = {};
    this.flags = {};
    this.io = io;
    this.nsp = nsp;
    if (opts && opts.auth) {
      this.auth = opts.auth;
    }
    this._opts = Object.assign({}, opts);
    if (this.io._autoConnect)
      this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const io = this.io;
    this.subs = [
      on(io, "open", this.onopen.bind(this)),
      on(io, "packet", this.onpacket.bind(this)),
      on(io, "error", this.onerror.bind(this)),
      on(io, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    if (this.connected)
      return this;
    this.subEvents();
    if (!this.io["_reconnecting"])
      this.io.open();
    if ("open" === this.io._readyState)
      this.onopen();
    return this;
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...args) {
    args.unshift("message");
    this.emit.apply(this, args);
    return this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(ev, ...args) {
    var _a2, _b2, _c;
    if (RESERVED_EVENTS.hasOwnProperty(ev)) {
      throw new Error('"' + ev.toString() + '" is a reserved event name');
    }
    args.unshift(ev);
    if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
      this._addToQueue(args);
      return this;
    }
    const packet = {
      type: PacketType.EVENT,
      data: args
    };
    packet.options = {};
    packet.options.compress = this.flags.compress !== false;
    if ("function" === typeof args[args.length - 1]) {
      const id2 = this.ids++;
      const ack = args.pop();
      this._registerAckCallback(id2, ack);
      packet.id = id2;
    }
    const isTransportWritable = (_b2 = (_a2 = this.io.engine) === null || _a2 === void 0 ? void 0 : _a2.transport) === null || _b2 === void 0 ? void 0 : _b2.writable;
    const isConnected = this.connected && !((_c = this.io.engine) === null || _c === void 0 ? void 0 : _c._hasPingExpired());
    const discardPacket = this.flags.volatile && !isTransportWritable;
    if (discardPacket) ;
    else if (isConnected) {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    } else {
      this.sendBuffer.push(packet);
    }
    this.flags = {};
    return this;
  }
  /**
   * @private
   */
  _registerAckCallback(id2, ack) {
    var _a2;
    const timeout2 = (_a2 = this.flags.timeout) !== null && _a2 !== void 0 ? _a2 : this._opts.ackTimeout;
    if (timeout2 === void 0) {
      this.acks[id2] = ack;
      return;
    }
    const timer = this.io.setTimeoutFn(() => {
      delete this.acks[id2];
      for (let i = 0; i < this.sendBuffer.length; i++) {
        if (this.sendBuffer[i].id === id2) {
          this.sendBuffer.splice(i, 1);
        }
      }
      ack.call(this, new Error("operation has timed out"));
    }, timeout2);
    const fn = (...args) => {
      this.io.clearTimeoutFn(timer);
      ack.apply(this, args);
    };
    fn.withError = true;
    this.acks[id2] = fn;
  }
  /**
   * Emits an event and waits for an acknowledgement
   *
   * @example
   * // without timeout
   * const response = await socket.emitWithAck("hello", "world");
   *
   * // with a specific timeout
   * try {
   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
   * } catch (err) {
   *   // the server did not acknowledge the event in the given delay
   * }
   *
   * @return a Promise that will be fulfilled when the server acknowledges the event
   */
  emitWithAck(ev, ...args) {
    return new Promise((resolve2, reject) => {
      const fn = (arg1, arg2) => {
        return arg1 ? reject(arg1) : resolve2(arg2);
      };
      fn.withError = true;
      args.push(fn);
      this.emit(ev, ...args);
    });
  }
  /**
   * Add the packet to the queue.
   * @param args
   * @private
   */
  _addToQueue(args) {
    let ack;
    if (typeof args[args.length - 1] === "function") {
      ack = args.pop();
    }
    const packet = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: false,
      args,
      flags: Object.assign({ fromQueue: true }, this.flags)
    };
    args.push((err, ...responseArgs) => {
      if (packet !== this._queue[0]) {
        return;
      }
      const hasError = err !== null;
      if (hasError) {
        if (packet.tryCount > this._opts.retries) {
          this._queue.shift();
          if (ack) {
            ack(err);
          }
        }
      } else {
        this._queue.shift();
        if (ack) {
          ack(null, ...responseArgs);
        }
      }
      packet.pending = false;
      return this._drainQueue();
    });
    this._queue.push(packet);
    this._drainQueue();
  }
  /**
   * Send the first packet of the queue, and wait for an acknowledgement from the server.
   * @param force - whether to resend a packet that has not been acknowledged yet
   *
   * @private
   */
  _drainQueue(force = false) {
    if (!this.connected || this._queue.length === 0) {
      return;
    }
    const packet = this._queue[0];
    if (packet.pending && !force) {
      return;
    }
    packet.pending = true;
    packet.tryCount++;
    this.flags = packet.flags;
    this.emit.apply(this, packet.args);
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(packet) {
    packet.nsp = this.nsp;
    this.io._packet(packet);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    if (typeof this.auth == "function") {
      this.auth((data) => {
        this._sendConnectPacket(data);
      });
    } else {
      this._sendConnectPacket(this.auth);
    }
  }
  /**
   * Sends a CONNECT packet to initiate the Socket.IO session.
   *
   * @param data
   * @private
   */
  _sendConnectPacket(data) {
    this.packet({
      type: PacketType.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data) : data
    });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(err) {
    if (!this.connected) {
      this.emitReserved("connect_error", err);
    }
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(reason, description) {
    this.connected = false;
    delete this.id;
    this.emitReserved("disconnect", reason, description);
    this._clearAcks();
  }
  /**
   * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
   * the server.
   *
   * @private
   */
  _clearAcks() {
    Object.keys(this.acks).forEach((id2) => {
      const isBuffered = this.sendBuffer.some((packet) => String(packet.id) === id2);
      if (!isBuffered) {
        const ack = this.acks[id2];
        delete this.acks[id2];
        if (ack.withError) {
          ack.call(this, new Error("socket has been disconnected"));
        }
      }
    });
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(packet) {
    const sameNamespace = packet.nsp === this.nsp;
    if (!sameNamespace)
      return;
    switch (packet.type) {
      case PacketType.CONNECT:
        if (packet.data && packet.data.sid) {
          this.onconnect(packet.data.sid, packet.data.pid);
        } else {
          this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
        }
        break;
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        this.onevent(packet);
        break;
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        this.onack(packet);
        break;
      case PacketType.DISCONNECT:
        this.ondisconnect();
        break;
      case PacketType.CONNECT_ERROR:
        this.destroy();
        const err = new Error(packet.data.message);
        err.data = packet.data.data;
        this.emitReserved("connect_error", err);
        break;
    }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(packet) {
    const args = packet.data || [];
    if (null != packet.id) {
      args.push(this.ack(packet.id));
    }
    if (this.connected) {
      this.emitEvent(args);
    } else {
      this.receiveBuffer.push(Object.freeze(args));
    }
  }
  emitEvent(args) {
    if (this._anyListeners && this._anyListeners.length) {
      const listeners = this._anyListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, args);
      }
    }
    super.emit.apply(this, args);
    if (this._pid && args.length && typeof args[args.length - 1] === "string") {
      this._lastOffset = args[args.length - 1];
    }
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(id2) {
    const self2 = this;
    let sent = false;
    return function(...args) {
      if (sent)
        return;
      sent = true;
      self2.packet({
        type: PacketType.ACK,
        id: id2,
        data: args
      });
    };
  }
  /**
   * Called upon a server acknowledgement.
   *
   * @param packet
   * @private
   */
  onack(packet) {
    const ack = this.acks[packet.id];
    if (typeof ack !== "function") {
      return;
    }
    delete this.acks[packet.id];
    if (ack.withError) {
      packet.data.unshift(null);
    }
    ack.apply(this, packet.data);
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(id2, pid) {
    this.id = id2;
    this.recovered = pid && this._pid === pid;
    this._pid = pid;
    this.connected = true;
    this.emitBuffered();
    this.emitReserved("connect");
    this._drainQueue(true);
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((args) => this.emitEvent(args));
    this.receiveBuffer = [];
    this.sendBuffer.forEach((packet) => {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    });
    this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    this.destroy();
    this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    if (this.subs) {
      this.subs.forEach((subDestroy) => subDestroy());
      this.subs = void 0;
    }
    this.io["_destroy"](this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    if (this.connected) {
      this.packet({ type: PacketType.DISCONNECT });
    }
    this.destroy();
    if (this.connected) {
      this.onclose("io client disconnect");
    }
    return this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(compress) {
    this.flags.compress = compress;
    return this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    this.flags.volatile = true;
    return this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(timeout2) {
    this.flags.timeout = timeout2;
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.push(listener);
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.unshift(listener);
    return this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(listener) {
    if (!this._anyListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyListeners;
      for (let i = 0; i < listeners.length; i++) {
        if (listener === listeners[i]) {
          listeners.splice(i, 1);
          return this;
        }
      }
    } else {
      this._anyListeners = [];
    }
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.push(listener);
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.unshift(listener);
    return this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(listener) {
    if (!this._anyOutgoingListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyOutgoingListeners;
      for (let i = 0; i < listeners.length; i++) {
        if (listener === listeners[i]) {
          listeners.splice(i, 1);
          return this;
        }
      }
    } else {
      this._anyOutgoingListeners = [];
    }
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(packet) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const listeners = this._anyOutgoingListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, packet.data);
      }
    }
  }
}
function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 1e4;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}
Backoff.prototype.duration = function() {
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand = Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};
Backoff.prototype.reset = function() {
  this.attempts = 0;
};
Backoff.prototype.setMin = function(min) {
  this.ms = min;
};
Backoff.prototype.setMax = function(max2) {
  this.max = max2;
};
Backoff.prototype.setJitter = function(jitter) {
  this.jitter = jitter;
};
class Manager extends Emitter {
  constructor(uri, opts) {
    var _a2;
    super();
    this.nsps = {};
    this.subs = [];
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = void 0;
    }
    opts = opts || {};
    opts.path = opts.path || "/socket.io";
    this.opts = opts;
    installTimerFunctions(this, opts);
    this.reconnection(opts.reconnection !== false);
    this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
    this.reconnectionDelay(opts.reconnectionDelay || 1e3);
    this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
    this.randomizationFactor((_a2 = opts.randomizationFactor) !== null && _a2 !== void 0 ? _a2 : 0.5);
    this.backoff = new Backoff({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    });
    this.timeout(null == opts.timeout ? 2e4 : opts.timeout);
    this._readyState = "closed";
    this.uri = uri;
    const _parser = opts.parser || parser;
    this.encoder = new _parser.Encoder();
    this.decoder = new _parser.Decoder();
    this._autoConnect = opts.autoConnect !== false;
    if (this._autoConnect)
      this.open();
  }
  reconnection(v2) {
    if (!arguments.length)
      return this._reconnection;
    this._reconnection = !!v2;
    if (!v2) {
      this.skipReconnect = true;
    }
    return this;
  }
  reconnectionAttempts(v2) {
    if (v2 === void 0)
      return this._reconnectionAttempts;
    this._reconnectionAttempts = v2;
    return this;
  }
  reconnectionDelay(v2) {
    var _a2;
    if (v2 === void 0)
      return this._reconnectionDelay;
    this._reconnectionDelay = v2;
    (_a2 = this.backoff) === null || _a2 === void 0 ? void 0 : _a2.setMin(v2);
    return this;
  }
  randomizationFactor(v2) {
    var _a2;
    if (v2 === void 0)
      return this._randomizationFactor;
    this._randomizationFactor = v2;
    (_a2 = this.backoff) === null || _a2 === void 0 ? void 0 : _a2.setJitter(v2);
    return this;
  }
  reconnectionDelayMax(v2) {
    var _a2;
    if (v2 === void 0)
      return this._reconnectionDelayMax;
    this._reconnectionDelayMax = v2;
    (_a2 = this.backoff) === null || _a2 === void 0 ? void 0 : _a2.setMax(v2);
    return this;
  }
  timeout(v2) {
    if (!arguments.length)
      return this._timeout;
    this._timeout = v2;
    return this;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
      this.reconnect();
    }
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(fn) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new Socket$1(this.uri, this.opts);
    const socket2 = this.engine;
    const self2 = this;
    this._readyState = "opening";
    this.skipReconnect = false;
    const openSubDestroy = on(socket2, "open", function() {
      self2.onopen();
      fn && fn();
    });
    const onError = (err) => {
      this.cleanup();
      this._readyState = "closed";
      this.emitReserved("error", err);
      if (fn) {
        fn(err);
      } else {
        this.maybeReconnectOnOpen();
      }
    };
    const errorSub = on(socket2, "error", onError);
    if (false !== this._timeout) {
      const timeout2 = this._timeout;
      const timer = this.setTimeoutFn(() => {
        openSubDestroy();
        onError(new Error("timeout"));
        socket2.close();
      }, timeout2);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer);
      });
    }
    this.subs.push(openSubDestroy);
    this.subs.push(errorSub);
    return this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(fn) {
    return this.open(fn);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    this.cleanup();
    this._readyState = "open";
    this.emitReserved("open");
    const socket2 = this.engine;
    this.subs.push(
      on(socket2, "ping", this.onping.bind(this)),
      on(socket2, "data", this.ondata.bind(this)),
      on(socket2, "error", this.onerror.bind(this)),
      on(socket2, "close", this.onclose.bind(this)),
      // @ts-ignore
      on(this.decoder, "decoded", this.ondecoded.bind(this))
    );
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(data) {
    try {
      this.decoder.add(data);
    } catch (e2) {
      this.onclose("parse error", e2);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(packet) {
    nextTick(() => {
      this.emitReserved("packet", packet);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(err) {
    this.emitReserved("error", err);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(nsp, opts) {
    let socket2 = this.nsps[nsp];
    if (!socket2) {
      socket2 = new Socket2(this, nsp, opts);
      this.nsps[nsp] = socket2;
    } else if (this._autoConnect && !socket2.active) {
      socket2.connect();
    }
    return socket2;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(socket2) {
    const nsps = Object.keys(this.nsps);
    for (const nsp of nsps) {
      const socket3 = this.nsps[nsp];
      if (socket3.active) {
        return;
      }
    }
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(packet) {
    const encodedPackets = this.encoder.encode(packet);
    for (let i = 0; i < encodedPackets.length; i++) {
      this.engine.write(encodedPackets[i], packet.options);
    }
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    this.subs.forEach((subDestroy) => subDestroy());
    this.subs.length = 0;
    this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    this.skipReconnect = true;
    this._reconnecting = false;
    this.onclose("forced close");
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called when:
   *
   * - the low-level engine is closed
   * - the parser encountered a badly formatted packet
   * - all sockets are disconnected
   *
   * @private
   */
  onclose(reason, description) {
    var _a2;
    this.cleanup();
    (_a2 = this.engine) === null || _a2 === void 0 ? void 0 : _a2.close();
    this.backoff.reset();
    this._readyState = "closed";
    this.emitReserved("close", reason, description);
    if (this._reconnection && !this.skipReconnect) {
      this.reconnect();
    }
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const self2 = this;
    if (this.backoff.attempts >= this._reconnectionAttempts) {
      this.backoff.reset();
      this.emitReserved("reconnect_failed");
      this._reconnecting = false;
    } else {
      const delay = this.backoff.duration();
      this._reconnecting = true;
      const timer = this.setTimeoutFn(() => {
        if (self2.skipReconnect)
          return;
        this.emitReserved("reconnect_attempt", self2.backoff.attempts);
        if (self2.skipReconnect)
          return;
        self2.open((err) => {
          if (err) {
            self2._reconnecting = false;
            self2.reconnect();
            this.emitReserved("reconnect_error", err);
          } else {
            self2.onreconnect();
          }
        });
      }, delay);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const attempt = this.backoff.attempts;
    this._reconnecting = false;
    this.backoff.reset();
    this.emitReserved("reconnect", attempt);
  }
}
const cache = {};
function lookup$4(uri, opts) {
  if (typeof uri === "object") {
    opts = uri;
    uri = void 0;
  }
  opts = opts || {};
  const parsed = url(uri, opts.path || "/socket.io");
  const source = parsed.source;
  const id2 = parsed.id;
  const path = parsed.path;
  const sameNamespace = cache[id2] && path in cache[id2]["nsps"];
  const newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
  let io;
  if (newConnection) {
    io = new Manager(source, opts);
  } else {
    if (!cache[id2]) {
      cache[id2] = new Manager(source, opts);
    }
    io = cache[id2];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.queryKey;
  }
  return io.socket(parsed.path, opts);
}
Object.assign(lookup$4, {
  Manager,
  Socket: Socket2,
  io: lookup$4,
  connect: lookup$4
});
const socket = lookup$4("https://secadodecafe.online", {
  autoConnect: false
});
socket.on("connect", () => {
  console.log("Conectado al servidor");
});
socket.on("disconnect", (reason) => {
  console.log("Desconectado del servidor", reason);
});
socket.on("connect_error", (error) => {
  console.log("Error de conexión", error);
});
const _withScopeId$9 = (n2) => (pushScopeId("data-v-54da3750"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$b = {
  id: "container",
  class: "col-12"
};
const _hoisted_2$b = { id: "titleFilter" };
const _hoisted_3$b = {
  key: 0,
  class: "col-12 col-sm-4 q-mt-sm"
};
const _hoisted_4$b = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ createBaseVNode("span", { class: "material-symbols-outlined" }, " speed ", -1));
const _hoisted_5$9 = {
  key: 1,
  class: "col-12 col-sm-4 q-mt-sm"
};
const _hoisted_6$8 = { class: "row items-center justify-end" };
const _hoisted_7$8 = { class: "col-12 col-sm-4 q-mt-sm" };
const _hoisted_8$8 = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ createBaseVNode("span", { class: "material-symbols-outlined" }, " drag_indicator ", -1));
const _hoisted_9$8 = { class: "justify-center flex items-start col-12 col-sm-3 q-pb-md" };
const _hoisted_10$8 = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ createBaseVNode("div", { class: "col-12 text-center text-body2 text-grey q-mx-md" }, " Observación: si se encuentran gran volumen de datos, el sistema sacará el promedio de los datos, combinando cierta cantidad de horas. ", -1));
const _sfc_main$b = {
  __name: "TemporalityFilter",
  emits: ["temporality"],
  setup(__props, { emit: __emit }) {
    const useUsers = storeUsers();
    const $q = useQuasar();
    const socketClient = socket.connected ? socket : socket.connect();
    const isWaiting = ref(false);
    onBeforeMount(() => {
      socketClient.on("update", (data) => {
        var _a2;
        if (!data.farm) return;
        if (((_a2 = useUsers.farm) == null ? void 0 : _a2._id) != data.farm) return;
        if (!isWaiting.value) {
          isWaiting.value = true;
          updateReport();
          setTimeout(() => {
            isWaiting.value = false;
          }, 1e4);
        }
      });
    });
    onUnmounted(() => {
      socket.disconnect();
    });
    function updateReport() {
      $q.notify({
        message: "Se han recibido nuevos datos, deseas actualizarlos?",
        color: "primary",
        avatar: "/images/logo-blanco.png",
        position: "top",
        actions: [
          { label: "Actualizar", color: "white", handler: () => sendTemporality() }
        ]
      });
    }
    const options = [
      { label: "Último/s minuto/s", value: "m" },
      { label: "Última/s hora/s", value: "h" },
      { label: "Último/s día/s", value: "d" },
      { label: "Rango de fechas", value: "range" }
    ];
    const valor = ref(6);
    const type = ref({ label: "Última/s hora/s", value: "h" });
    const info = ref();
    const date = ref({ from: "", to: "" });
    const emit2 = __emit;
    const sendTemporality = () => {
      if (type.value.value === "range") {
        emit2("temporality", { type: type.value.value, valor: info.value });
      } else {
        emit2("temporality", { valor: valor.value, type: type.value.value });
      }
    };
    function optionsFn(date2) {
      return date2 <= (/* @__PURE__ */ new Date()).toISOString().slice(0, 10).replace(/-/g, "/");
    }
    const changeDate = () => {
      if (typeof date.value === "object") info.value = `${date.value.from} - ${date.value.to}`;
      else info.value = `${date.value} - ${date.value}`;
    };
    const ruleDate = (val) => {
      if (date.value) {
        return true;
      } else {
        return "El rango de fechas es requerido";
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createBaseVNode("div", _hoisted_1$b, [
          createBaseVNode("span", _hoisted_2$b, [
            createVNode(QIcon, { name: "tune" }),
            createTextVNode(" Filtrar por: ")
          ])
        ]),
        createVNode(QForm, {
          onSubmit: _cache[5] || (_cache[5] = withModifiers(($event) => sendTemporality(), ["prevent", "stop"])),
          ref: "myForm",
          class: "col-11 col-lg-5 row flex justify-center"
        }, {
          default: withCtx(() => [
            type.value.value !== "range" ? (openBlock(), createElementBlock("div", _hoisted_3$b, [
              createVNode(QInput, {
                filled: "",
                class: "full-width q-px-md",
                type: "text",
                modelValue: valor.value,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => valor.value = $event),
                label: "Valor",
                "lazy-rules": "",
                rules: [
                  (val) => val && val.toString().trim().length > 0 || "El campo es requerido"
                ]
              }, {
                prepend: withCtx(() => [
                  _hoisted_4$b
                ]),
                _: 1
              }, 8, ["modelValue", "rules"])
            ])) : createCommentVNode("", true),
            type.value.value == "range" ? (openBlock(), createElementBlock("div", _hoisted_5$9, [
              createVNode(QInput, {
                readonly: "",
                filled: "",
                modelValue: info.value,
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => info.value = $event),
                rules: [ruleDate],
                label: "Rango de fechas",
                "lazy-rules": "",
                class: "full-width q-px-md"
              }, {
                append: withCtx(() => [
                  createVNode(QIcon, {
                    name: "event",
                    class: "cursor-pointer"
                  }, {
                    default: withCtx(() => [
                      createVNode(QPopupProxy, {
                        cover: "",
                        "transition-show": "scale",
                        "transition-hide": "scale"
                      }, {
                        default: withCtx(() => [
                          createVNode(QDate, {
                            modelValue: date.value,
                            "onUpdate:modelValue": [
                              _cache[1] || (_cache[1] = ($event) => date.value = $event),
                              _cache[2] || (_cache[2] = ($event) => changeDate())
                            ],
                            range: "",
                            options: optionsFn
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("div", _hoisted_6$8, [
                                withDirectives(createVNode(QBtn, {
                                  label: "Cerrar",
                                  color: "primary",
                                  flat: ""
                                }, null, 512), [
                                  [ClosePopup]
                                ])
                              ])
                            ]),
                            _: 1
                          }, 8, ["modelValue"])
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }, 8, ["modelValue", "rules"])
            ])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_7$8, [
              createVNode(QSelect, {
                filled: "",
                class: "full-width q-px-md",
                type: "text",
                modelValue: type.value,
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => type.value = $event),
                options,
                label: "Tipo",
                "option-label": (row) => row.label,
                "option-value": (row) => row.value,
                "lazy-rules": "",
                rules: [
                  (val) => val && val.toString().trim().length > 0 || "El campo es requerido"
                ]
              }, {
                prepend: withCtx(() => [
                  _hoisted_8$8
                ]),
                _: 1
              }, 8, ["modelValue", "option-label", "option-value", "rules"])
            ]),
            createBaseVNode("div", _hoisted_9$8, [
              createVNode(QBtn, {
                label: "Filtrar",
                type: "submit",
                class: "q-mt-md q-mb-sm q-mx-sm",
                color: "green-8"
              })
            ])
          ]),
          _: 1
        }, 512),
        _hoisted_10$8
      ], 64);
    };
  }
};
const TemporalityFilter = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["__scopeId", "data-v-54da3750"]]);
const _hoisted_1$a = {
  key: 0,
  id: "chart",
  class: "q-ma-xl"
};
const _hoisted_2$a = {
  key: 1,
  class: "justify-center flex"
};
const _hoisted_3$a = /* @__PURE__ */ createBaseVNode("h5", { class: "read-the-docs" }, "Sin datos para mostrar", -1);
const _hoisted_4$a = [
  _hoisted_3$a
];
const _sfc_main$a = {
  __name: "LineChart",
  props: ["data", "labels", "colors", "title"],
  setup(__props) {
    let series = ref([]);
    let chartOptions = ref({});
    const { data, labels, colors, title } = __props;
    onBeforeMount(async () => {
      await setConfig();
    });
    const setConfig = async () => {
      series.value = data;
      chartOptions.value = {
        chart: {
          height: 350,
          type: "line",
          zoom: {
            enabled: false
          }
        },
        dataLabels: {
          enabled: false
        },
        stroke: {
          curve: "straight"
        },
        title: {
          text: title,
          align: "center"
        },
        labels,
        responsive: [{
          breakpoint: 1e3,
          options: {
            legend: {
              position: "bottom"
            },
            xaxis: {
              tickAmount: 4
            }
          }
        }],
        xaxis: {
          categories: labels,
          labels: {
            rotate: 0,
            hideOverlappingLabels: true,
            style: {
              fontSize: "12px"
            }
          },
          tickAmount: 10
          // min: labels.length>20 ? labels.length-20 : 0,
          // max: labels.length,
        },
        markers: {
          size: 1,
          colors: ["#008ffb"],
          strokeColors: "#008ffb",
          strokeWidth: 2,
          hover: {
            sizeOffset: 3
          }
        }
      };
    };
    return (_ctx, _cache) => {
      const _component_apexchart = resolveComponent("apexchart");
      return __props.data.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_1$a, [
        createVNode(_component_apexchart, {
          type: "line",
          height: "350",
          options: unref(chartOptions),
          series: unref(series)
        }, null, 8, ["options", "series"])
      ])) : (openBlock(), createElementBlock("div", _hoisted_2$a, _hoisted_4$a));
    };
  }
};
const _withScopeId$8 = (n2) => (pushScopeId("data-v-ba6e8d21"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$9 = { class: "row col-12 row justify-center flex" };
const _hoisted_2$9 = { class: "col-12" };
const _hoisted_3$9 = { class: "sensor q-px-md bg-grey-13 rounded-borders" };
const _hoisted_4$9 = { class: "col-12" };
const _hoisted_5$8 = {
  key: 0,
  class: "row justify-center"
};
const _hoisted_6$7 = { class: "col-12 col-md-6" };
const _hoisted_7$7 = { class: "col-12 col-md-6" };
const _hoisted_8$7 = { class: "col-12 col-md-6" };
const _hoisted_9$7 = { class: "col-12 col-md-6" };
const _hoisted_10$7 = {
  key: 1,
  class: "justify-center flex row"
};
const _hoisted_11$5 = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createBaseVNode("h6", { class: "col-12 text-green-10 justify-center text-center flex" }, "No se encontraron datos sobre el Termohigrómetro", -1));
const _hoisted_12$5 = { class: "col-12 justify-center flex" };
const _sfc_main$9 = {
  __name: "Termomanometro",
  setup(__props) {
    const $q = useQuasar();
    let dataTermohigrometro = ref([]);
    let loading = ref(false);
    let battery = ref([]);
    let sensorDb = ref({});
    onBeforeMount(async () => {
      await getData();
    });
    async function getData(type = "h", value2 = 6) {
      loading.value = true;
      const { data, sensor } = await getSensorData("termohigrometro", type, value2);
      sensorDb.value = sensor;
      if (data && data.length > 0) {
        dataTermohigrometro.value = data.map((item) => {
          return {
            name: item.shortDate + "-" + item.hour,
            h: (parseFloat(item == null ? void 0 : item.h) || 0).toFixed(1),
            b: (parseFloat(item == null ? void 0 : item.b) || 0).toFixed(1),
            l: (parseFloat(item == null ? void 0 : item.l) || 0).toFixed(1),
            t: (parseFloat(item == null ? void 0 : item.t) || 0).toFixed(1),
            u: (parseFloat(item == null ? void 0 : item.u) || 0).toFixed(1)
          };
        });
        battery.value = [{ name: "Batería Restante", data }];
      }
      loading.value = false;
    }
    async function dataTemporality({ valor, type }) {
      dataTermohigrometro.value = [];
      await getData(type, valor);
    }
    return (_ctx, _cache) => {
      var _a2;
      return openBlock(), createElementBlock(Fragment, null, [
        createBaseVNode("div", _hoisted_1$9, [
          createBaseVNode("div", _hoisted_2$9, [
            createVNode(_sfc_main$c, { title: "Termohigrómetro" })
          ]),
          createVNode(QPageSticky, {
            position: unref($q).screen.width < 600 ? "bottom" : "top-right",
            offset: [30, 18]
          }, {
            default: withCtx(() => {
              var _a3;
              return [
                createBaseVNode("div", _hoisted_3$9, [
                  createVNode(QIcon, {
                    name: "thermostat",
                    class: "q-pr-sm"
                  }),
                  createTextVNode(" " + toDisplayString((_a3 = unref(sensorDb)) == null ? void 0 : _a3.name), 1)
                ])
              ];
            }),
            _: 1
          }, 8, ["position"]),
          createBaseVNode("div", _hoisted_4$9, [
            createVNode(TemporalityFilter, { onTemporality: dataTemporality })
          ])
        ]),
        unref(dataTermohigrometro).length > 0 || unref(loading) ? (openBlock(), createElementBlock("div", _hoisted_5$8, [
          createBaseVNode("div", _hoisted_6$7, [
            unref(dataTermohigrometro).length > 0 ? (openBlock(), createBlock(LineChartBasic, {
              key: 0,
              data: unref(dataTermohigrometro).map((item) => parseFloat(item.t).toFixed(2)),
              categories: unref(dataTermohigrometro).map((item) => item.name),
              name: "Nivel",
              title: "Temperatura",
              symbolLabel: "°C"
            }, null, 8, ["data", "categories"])) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", _hoisted_7$7, [
            unref(dataTermohigrometro).length > 0 ? (openBlock(), createBlock(LineChartBasic, {
              key: 0,
              data: unref(dataTermohigrometro).map((item) => parseFloat(item.h).toFixed(2)),
              categories: unref(dataTermohigrometro).map((item) => item.name),
              name: "Nivel",
              title: "Humedad",
              symbolLabel: "%"
            }, null, 8, ["data", "categories"])) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", _hoisted_8$7, [
            unref(dataTermohigrometro).length > 0 ? (openBlock(), createBlock(LineChartBasic, {
              key: 0,
              data: unref(dataTermohigrometro).map((item) => item.u),
              categories: unref(dataTermohigrometro).map((item) => item.name),
              name: "Nivel",
              title: "Radiación Ultravioleta",
              symbolLabel: "W/m²"
            }, null, 8, ["data", "categories"])) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", _hoisted_9$7, [
            unref(dataTermohigrometro).length > 0 ? (openBlock(), createBlock(LineChartBasic, {
              key: 0,
              data: unref(dataTermohigrometro).map((item) => item.l),
              categories: unref(dataTermohigrometro).map((item) => item.name),
              name: "Nivel",
              title: "Nivel de Iluminación",
              symbolLabel: "lx"
            }, null, 8, ["data", "categories"])) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", {
            class: normalizeClass(["col-12 justify-md-center justify-center", { "flex": unref($q).screen.width < 600 }])
          }, [
            ((_a2 = unref(dataTermohigrometro)) == null ? void 0 : _a2.length) > 0 ? (openBlock(), createBlock(_sfc_main$a, {
              key: 0,
              data: [{ name: "Batería Restante", data: unref(battery)[0].data.map((item) => parseFloat(item.b)) }],
              labels: unref(battery)[0].data.map((item) => item.hour),
              colors: ["#f3f3f3", "transparent"],
              title: "Batería"
            }, null, 8, ["data", "labels"])) : createCommentVNode("", true)
          ], 2)
        ])) : (openBlock(), createElementBlock("div", _hoisted_10$7, [
          _hoisted_11$5,
          createBaseVNode("div", _hoisted_12$5, [
            createVNode(QIcon, {
              name: "sentiment_very_dissatisfied",
              size: "100px",
              class: "text-green-10 justify-center text-center flex"
            })
          ])
        ])),
        unref(loading) ? (openBlock(), createBlock(Spinner, { key: 2 })) : createCommentVNode("", true)
      ], 64);
    };
  }
};
const Termomanometro = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["__scopeId", "data-v-ba6e8d21"]]);
const _withScopeId$7 = (n2) => (pushScopeId("data-v-16b81ffa"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$8 = { class: "row col-12 row justify-center flex" };
const _hoisted_2$8 = { class: "col-12" };
const _hoisted_3$8 = { class: "sensor q-px-md bg-grey-13 rounded-borders" };
const _hoisted_4$8 = { class: "col-12" };
const _hoisted_5$7 = {
  key: 0,
  class: "row justify-center"
};
const _hoisted_6$6 = { class: "col-12 col-md-6" };
const _hoisted_7$6 = { class: "col-12 col-md-6" };
const _hoisted_8$6 = {
  key: 1,
  class: "justify-center flex row"
};
const _hoisted_9$6 = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createBaseVNode("h6", { class: "col-12 text-green-10 justify-center text-center flex" }, "No se encontraron datos sobre el Termometro", -1));
const _hoisted_10$6 = { class: "col-12 justify-center flex" };
const _sfc_main$8 = {
  __name: "Termometro",
  setup(__props) {
    const $q = useQuasar();
    let dataTermometro = ref([]);
    let battery = ref([]);
    let loading = ref(false);
    let sensorDb = ref({});
    onBeforeMount(async () => {
      await getData();
    });
    const getData = async () => {
      loading.value = true;
      const { data, sensor } = await getSensorData("termometro");
      sensorDb.value = sensor;
      if (data && data.length > 0) {
        dataTermometro.value = data.map((item) => {
          return {
            name: item.shortDate + "-" + item.hour,
            h: (parseFloat(item == null ? void 0 : item.h) || 0).toFixed(1),
            b: (parseFloat(item == null ? void 0 : item.b) || 0).toFixed(1),
            t: (parseFloat(item == null ? void 0 : item.t) || 0).toFixed(1)
          };
        });
        battery.value = [{ name: "Bateria Restante", data }];
      }
      loading.value = false;
    };
    async function dataTemporality({ valor, type }) {
      dataTermometro.value = [];
      await getData();
    }
    return (_ctx, _cache) => {
      var _a2, _b2, _c, _d;
      return openBlock(), createElementBlock(Fragment, null, [
        createBaseVNode("div", _hoisted_1$8, [
          createBaseVNode("div", _hoisted_2$8, [
            createVNode(_sfc_main$c, { title: "Termometro" })
          ]),
          createVNode(QPageSticky, {
            position: unref($q).screen.width < 600 ? "bottom" : "top-right",
            offset: [30, 18]
          }, {
            default: withCtx(() => {
              var _a3;
              return [
                createBaseVNode("div", _hoisted_3$8, [
                  createVNode(QIcon, {
                    name: "thermostat",
                    class: "q-pr-sm"
                  }),
                  createTextVNode(" " + toDisplayString((_a3 = unref(sensorDb)) == null ? void 0 : _a3.name), 1)
                ])
              ];
            }),
            _: 1
          }, 8, ["position"]),
          createBaseVNode("div", _hoisted_4$8, [
            createVNode(TemporalityFilter, { onTemporality: dataTemporality })
          ])
        ]),
        ((_a2 = _ctx.dataTemperature) == null ? void 0 : _a2.length) > 0 || unref(loading) ? (openBlock(), createElementBlock("div", _hoisted_5$7, [
          createBaseVNode("div", _hoisted_6$6, [
            ((_b2 = _ctx.dataTemperature) == null ? void 0 : _b2.length) > 0 ? (openBlock(), createBlock(LineChartBasic, {
              key: 0,
              data: _ctx.dataTemperature.map((item) => parseFloat(item.value).toFixed(2)),
              categories: _ctx.dataTemperature.map((item) => item.name),
              name: "Nivel",
              title: "Temperaturas",
              symbolLabel: "°C"
            }, null, 8, ["data", "categories"])) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", _hoisted_7$6, [
            ((_c = _ctx.dataHumidity) == null ? void 0 : _c.length) > 0 ? (openBlock(), createBlock(LineChartBasic, {
              key: 0,
              data: _ctx.dataHumidity.map((item) => parseFloat(item.value).toFixed(2)),
              categories: _ctx.dataHumidity.map((item) => item.name),
              name: "Nivel",
              title: "Humedad",
              symbolLabel: "%"
            }, null, 8, ["data", "categories"])) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", {
            class: normalizeClass(["col-12 justify-md-center justify-center", { "flex": unref($q).screen.width < 600 }])
          }, [
            ((_d = _ctx.dataHumidity) == null ? void 0 : _d.length) > 0 ? (openBlock(), createBlock(_sfc_main$a, {
              key: 0,
              data: [{ name: "Bateria Restante", data: unref(battery)[0].data.map((item) => parseFloat(item.b)) }],
              labels: unref(battery)[0].data.map((item) => item.hour),
              colors: ["#f3f3f3", "transparent"],
              title: "Bateria"
            }, null, 8, ["data", "labels"])) : createCommentVNode("", true)
          ], 2)
        ])) : (openBlock(), createElementBlock("div", _hoisted_8$6, [
          _hoisted_9$6,
          createBaseVNode("div", _hoisted_10$6, [
            createVNode(QIcon, {
              name: "sentiment_very_dissatisfied",
              size: "100px",
              class: "text-green-10 justify-center text-center flex"
            })
          ])
        ])),
        unref(loading) ? (openBlock(), createBlock(Spinner, { key: 2 })) : createCommentVNode("", true)
      ], 64);
    };
  }
};
const Termometro = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["__scopeId", "data-v-16b81ffa"]]);
const _withScopeId$6 = (n2) => (pushScopeId("data-v-05f9dc42"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$7 = { class: "row col-12 row justify-center flex" };
const _hoisted_2$7 = { class: "col-12" };
const _hoisted_3$7 = { class: "sensor q-px-md bg-grey-13 rounded-borders" };
const _hoisted_4$7 = { class: "col-12" };
const _hoisted_5$6 = {
  key: 0,
  class: "row justify-center"
};
const _hoisted_6$5 = { class: "col-12 col-md-6" };
const _hoisted_7$5 = { class: "col-12 col-md-6" };
const _hoisted_8$5 = {
  key: 1,
  class: "justify-center flex row"
};
const _hoisted_9$5 = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ createBaseVNode("h6", { class: "col-12 text-green-10 justify-center text-center flex" }, "No se encontraron datos sobre la Báscula", -1));
const _hoisted_10$5 = { class: "col-12 justify-center flex" };
const _sfc_main$7 = {
  __name: "Weighing",
  setup(__props) {
    const $q = useQuasar();
    let dataWeighing = ref([]);
    let battery = ref([]);
    let loading = ref(false);
    let sensorDb = ref({});
    onBeforeMount(async () => {
      await getData();
    });
    async function dataTemporality({ valor, type }) {
      dataWeighing.value = [];
      await getData(type, valor);
    }
    async function getData(type = "h", value2 = 6) {
      loading.value = true;
      const { data, sensor } = await getSensorData("bascula", type, value2);
      sensorDb.value = sensor;
      if (data && data.length > 0) {
        dataWeighing.value = data.map((item) => {
          return {
            name: item.shortDate + "-" + item.hour,
            m: (parseFloat(item == null ? void 0 : item.m) || 0).toFixed(1),
            b: (parseFloat(item == null ? void 0 : item.b) || 0).toFixed(1),
            chf: (parseFloat(item == null ? void 0 : item.chf) || 0).toFixed(1)
          };
        });
        battery.value = [{ name: "Batería Restante", data }];
      }
      loading.value = false;
    }
    return (_ctx, _cache) => {
      var _a2;
      return openBlock(), createElementBlock(Fragment, null, [
        createBaseVNode("div", _hoisted_1$7, [
          createBaseVNode("div", _hoisted_2$7, [
            createVNode(_sfc_main$c, { title: "Báscula" })
          ]),
          createVNode(QPageSticky, {
            position: unref($q).screen.width < 600 ? "bottom" : "top-right",
            offset: [30, 18]
          }, {
            default: withCtx(() => {
              var _a3;
              return [
                createBaseVNode("div", _hoisted_3$7, [
                  createVNode(QIcon, {
                    name: "scale",
                    class: "q-pr-sm"
                  }),
                  createTextVNode(" " + toDisplayString((_a3 = unref(sensorDb)) == null ? void 0 : _a3.name), 1)
                ])
              ];
            }),
            _: 1
          }, 8, ["position"]),
          createBaseVNode("div", _hoisted_4$7, [
            createVNode(TemporalityFilter, { onTemporality: dataTemporality })
          ])
        ]),
        unref(dataWeighing).length > 0 || unref(loading) ? (openBlock(), createElementBlock("div", _hoisted_5$6, [
          createBaseVNode("div", _hoisted_6$5, [
            unref(dataWeighing).length > 0 ? (openBlock(), createBlock(LineChartBasic, {
              key: 0,
              data: unref(dataWeighing).map((item) => parseFloat(item.m)),
              categories: unref(dataWeighing).map((item) => item.name),
              name: "Peso",
              title: "Masa",
              symbolLabel: "g"
            }, null, 8, ["data", "categories"])) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", _hoisted_7$5, [
            unref(dataWeighing).length > 0 ? (openBlock(), createBlock(LineChartBasic, {
              key: 0,
              data: unref(dataWeighing).map((item) => parseFloat(item.chf)),
              categories: unref(dataWeighing).map((item) => item.name),
              name: "Humedad",
              title: "Humedad final",
              symbolLabel: "%"
            }, null, 8, ["data", "categories"])) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", {
            class: normalizeClass(["col-12 justify-md-center justify-center", { "flex": unref($q).screen.width < 600 }])
          }, [
            ((_a2 = unref(dataWeighing)) == null ? void 0 : _a2.length) > 0 ? (openBlock(), createBlock(_sfc_main$a, {
              key: 0,
              data: [{ name: "Batería Restante", data: unref(battery)[0].data.map((item) => parseFloat(item.b)) }],
              labels: unref(battery)[0].data.map((item) => item.hour),
              colors: ["#f3f3f3", "transparent"],
              title: "Batería"
            }, null, 8, ["data", "labels"])) : createCommentVNode("", true)
          ], 2)
        ])) : (openBlock(), createElementBlock("div", _hoisted_8$5, [
          _hoisted_9$5,
          createBaseVNode("div", _hoisted_10$5, [
            createVNode(QIcon, {
              name: "sentiment_very_dissatisfied",
              size: "100px",
              class: "text-green-10 justify-center text-center flex"
            })
          ])
        ])),
        unref(loading) ? (openBlock(), createBlock(Spinner, { key: 2 })) : createCommentVNode("", true)
      ], 64);
    };
  }
};
const Weighing = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["__scopeId", "data-v-05f9dc42"]]);
const alignValues$1 = ["top", "middle", "bottom"];
const QBadge = createComponent({
  name: "QBadge",
  props: {
    color: String,
    textColor: String,
    floating: Boolean,
    transparent: Boolean,
    multiLine: Boolean,
    outline: Boolean,
    rounded: Boolean,
    label: [Number, String],
    align: {
      type: String,
      validator: (v2) => alignValues$1.includes(v2)
    }
  },
  setup(props2, { slots }) {
    const style = computed(() => {
      return props2.align !== void 0 ? { verticalAlign: props2.align } : null;
    });
    const classes = computed(() => {
      const text = props2.outline === true ? props2.color || props2.textColor : props2.textColor;
      return `q-badge flex inline items-center no-wrap q-badge--${props2.multiLine === true ? "multi" : "single"}-line` + (props2.outline === true ? " q-badge--outline" : props2.color !== void 0 ? ` bg-${props2.color}` : "") + (text !== void 0 ? ` text-${text}` : "") + (props2.floating === true ? " q-badge--floating" : "") + (props2.rounded === true ? " q-badge--rounded" : "") + (props2.transparent === true ? " q-badge--transparent" : "");
    });
    return () => h$1("div", {
      class: classes.value,
      style: style.value,
      role: "status",
      "aria-label": props2.label
    }, hMergeSlot(slots.default, props2.label !== void 0 ? [props2.label] : []));
  }
});
const QTd = createComponent({
  name: "QTd",
  props: {
    props: Object,
    autoWidth: Boolean,
    noHover: Boolean
  },
  setup(props2, { slots }) {
    const vm2 = getCurrentInstance();
    const classes = computed(
      () => "q-td" + (props2.autoWidth === true ? " q-table--col-auto-width" : "") + (props2.noHover === true ? " q-td--no-hover" : "") + " "
    );
    return () => {
      if (props2.props === void 0) {
        return h$1("td", { class: classes.value }, hSlot(slots.default));
      }
      const name = vm2.vnode.key;
      const col = (props2.props.colsMap !== void 0 ? props2.props.colsMap[name] : null) || props2.props.col;
      if (col === void 0) return;
      const { row } = props2.props;
      return h$1("td", {
        class: classes.value + col.__tdClass(row),
        style: col.__tdStyle(row)
      }, hSlot(slots.default));
    };
  }
});
const QTh = createComponent({
  name: "QTh",
  props: {
    props: Object,
    autoWidth: Boolean
  },
  emits: ["click"],
  setup(props2, { slots, emit: emit2 }) {
    const vm2 = getCurrentInstance();
    const { proxy: { $q } } = vm2;
    const onClick = (evt) => {
      emit2("click", evt);
    };
    return () => {
      if (props2.props === void 0) {
        return h$1("th", {
          class: props2.autoWidth === true ? "q-table--col-auto-width" : "",
          onClick
        }, hSlot(slots.default));
      }
      let col, child;
      const name = vm2.vnode.key;
      if (name) {
        col = props2.props.colsMap[name];
        if (col === void 0) return;
      } else {
        col = props2.props.col;
      }
      if (col.sortable === true) {
        const action = col.align === "right" ? "unshift" : "push";
        child = hUniqueSlot(slots.default, []);
        child[action](
          h$1(QIcon, {
            class: col.__iconClass,
            name: $q.iconSet.table.arrowUp
          })
        );
      } else {
        child = hSlot(slots.default);
      }
      const data = {
        class: col.__thClass + (props2.autoWidth === true ? " q-table--col-auto-width" : ""),
        style: col.headerStyle,
        onClick: (evt) => {
          col.sortable === true && props2.props.sort(col);
          onClick(evt);
        }
      };
      return h$1("th", data, child);
    };
  }
});
const separatorValues = ["horizontal", "vertical", "cell", "none"];
const QMarkupTable = createComponent({
  name: "QMarkupTable",
  props: {
    ...useDarkProps,
    dense: Boolean,
    flat: Boolean,
    bordered: Boolean,
    square: Boolean,
    wrapCells: Boolean,
    separator: {
      type: String,
      default: "horizontal",
      validator: (v2) => separatorValues.includes(v2)
    }
  },
  setup(props2, { slots }) {
    const vm2 = getCurrentInstance();
    const isDark = useDark(props2, vm2.proxy.$q);
    const classes = computed(
      () => `q-markup-table q-table__container q-table__card q-table--${props2.separator}-separator` + (isDark.value === true ? " q-table--dark q-table__card--dark q-dark" : "") + (props2.dense === true ? " q-table--dense" : "") + (props2.flat === true ? " q-table--flat" : "") + (props2.bordered === true ? " q-table--bordered" : "") + (props2.square === true ? " q-table--square" : "") + (props2.wrapCells === false ? " q-table--no-wrap" : "")
    );
    return () => h$1("div", {
      class: classes.value
    }, [
      h$1("table", { class: "q-table" }, hSlot(slots.default))
    ]);
  }
});
function getTableMiddle(props2, content2) {
  return h$1("div", props2, [
    h$1("table", { class: "q-table" }, content2)
  ]);
}
const comps = {
  list: QList,
  table: QMarkupTable
};
const typeOptions = ["list", "table", "__qtable"];
const QVirtualScroll = createComponent({
  name: "QVirtualScroll",
  props: {
    ...useVirtualScrollProps,
    type: {
      type: String,
      default: "list",
      validator: (v2) => typeOptions.includes(v2)
    },
    items: {
      type: Array,
      default: () => []
    },
    itemsFn: Function,
    itemsSize: Number,
    scrollTarget: scrollTargetProp
  },
  setup(props2, { slots, attrs }) {
    let localScrollTarget;
    const rootRef = ref(null);
    const virtualScrollLength = computed(() => props2.itemsSize >= 0 && props2.itemsFn !== void 0 ? parseInt(props2.itemsSize, 10) : Array.isArray(props2.items) ? props2.items.length : 0);
    const {
      virtualScrollSliceRange,
      localResetVirtualScroll,
      padVirtualScroll,
      onVirtualScrollEvt
    } = useVirtualScroll({
      virtualScrollLength,
      getVirtualScrollTarget,
      getVirtualScrollEl
    });
    const virtualScrollScope = computed(() => {
      if (virtualScrollLength.value === 0) {
        return [];
      }
      const mapFn = (item, i) => ({
        index: virtualScrollSliceRange.value.from + i,
        item
      });
      return props2.itemsFn === void 0 ? props2.items.slice(virtualScrollSliceRange.value.from, virtualScrollSliceRange.value.to).map(mapFn) : props2.itemsFn(virtualScrollSliceRange.value.from, virtualScrollSliceRange.value.to - virtualScrollSliceRange.value.from).map(mapFn);
    });
    const classes = computed(
      () => "q-virtual-scroll q-virtual-scroll" + (props2.virtualScrollHorizontal === true ? "--horizontal" : "--vertical") + (props2.scrollTarget !== void 0 ? "" : " scroll")
    );
    const attributes = computed(() => props2.scrollTarget !== void 0 ? {} : { tabindex: 0 });
    watch(virtualScrollLength, () => {
      localResetVirtualScroll();
    });
    watch(() => props2.scrollTarget, () => {
      unconfigureScrollTarget();
      configureScrollTarget();
    });
    function getVirtualScrollEl() {
      return rootRef.value.$el || rootRef.value;
    }
    function getVirtualScrollTarget() {
      return localScrollTarget;
    }
    function configureScrollTarget() {
      localScrollTarget = getScrollTarget(getVirtualScrollEl(), props2.scrollTarget);
      localScrollTarget.addEventListener("scroll", onVirtualScrollEvt, listenOpts.passive);
    }
    function unconfigureScrollTarget() {
      if (localScrollTarget !== void 0) {
        localScrollTarget.removeEventListener("scroll", onVirtualScrollEvt, listenOpts.passive);
        localScrollTarget = void 0;
      }
    }
    function __getVirtualChildren() {
      let child = padVirtualScroll(
        props2.type === "list" ? "div" : "tbody",
        virtualScrollScope.value.map(slots.default)
      );
      if (slots.before !== void 0) {
        child = slots.before().concat(child);
      }
      return hMergeSlot(slots.after, child);
    }
    onBeforeMount(() => {
      localResetVirtualScroll();
    });
    onMounted(() => {
      configureScrollTarget();
    });
    onActivated(() => {
      configureScrollTarget();
    });
    onDeactivated(() => {
      unconfigureScrollTarget();
    });
    onBeforeUnmount(() => {
      unconfigureScrollTarget();
    });
    return () => {
      if (slots.default === void 0) {
        console.error("QVirtualScroll: default scoped slot is required for rendering");
        return;
      }
      return props2.type === "__qtable" ? getTableMiddle(
        { ref: rootRef, class: "q-table__middle " + classes.value },
        __getVirtualChildren()
      ) : h$1(comps[props2.type], {
        ...attrs,
        ref: rootRef,
        class: [attrs.class, classes.value],
        ...attributes.value
      }, __getVirtualChildren);
    };
  }
});
const defaultSizes = {
  xs: 2,
  sm: 4,
  md: 6,
  lg: 10,
  xl: 14
};
function width(val, reverse, $q) {
  return {
    transform: reverse === true ? `translateX(${$q.lang.rtl === true ? "-" : ""}100%) scale3d(${-val},1,1)` : `scale3d(${val},1,1)`
  };
}
const QLinearProgress = createComponent({
  name: "QLinearProgress",
  props: {
    ...useDarkProps,
    ...useSizeProps,
    value: {
      type: Number,
      default: 0
    },
    buffer: Number,
    color: String,
    trackColor: String,
    reverse: Boolean,
    stripe: Boolean,
    indeterminate: Boolean,
    query: Boolean,
    rounded: Boolean,
    animationSpeed: {
      type: [String, Number],
      default: 2100
    },
    instantFeedback: Boolean
  },
  setup(props2, { slots }) {
    const { proxy } = getCurrentInstance();
    const isDark = useDark(props2, proxy.$q);
    const sizeStyle = useSize(props2, defaultSizes);
    const motion = computed(() => props2.indeterminate === true || props2.query === true);
    const widthReverse = computed(() => props2.reverse !== props2.query);
    const style = computed(() => ({
      ...sizeStyle.value !== null ? sizeStyle.value : {},
      "--q-linear-progress-speed": `${props2.animationSpeed}ms`
    }));
    const classes = computed(
      () => "q-linear-progress" + (props2.color !== void 0 ? ` text-${props2.color}` : "") + (props2.reverse === true || props2.query === true ? " q-linear-progress--reverse" : "") + (props2.rounded === true ? " rounded-borders" : "")
    );
    const trackStyle = computed(() => width(props2.buffer !== void 0 ? props2.buffer : 1, widthReverse.value, proxy.$q));
    const transitionSuffix = computed(() => `with${props2.instantFeedback === true ? "out" : ""}-transition`);
    const trackClass = computed(
      () => `q-linear-progress__track absolute-full q-linear-progress__track--${transitionSuffix.value} q-linear-progress__track--${isDark.value === true ? "dark" : "light"}` + (props2.trackColor !== void 0 ? ` bg-${props2.trackColor}` : "")
    );
    const modelStyle = computed(() => width(motion.value === true ? 1 : props2.value, widthReverse.value, proxy.$q));
    const modelClass = computed(
      () => `q-linear-progress__model absolute-full q-linear-progress__model--${transitionSuffix.value} q-linear-progress__model--${motion.value === true ? "in" : ""}determinate`
    );
    const stripeStyle = computed(() => ({ width: `${props2.value * 100}%` }));
    const stripeClass = computed(
      () => `q-linear-progress__stripe absolute-${props2.reverse === true ? "right" : "left"} q-linear-progress__stripe--${transitionSuffix.value}`
    );
    return () => {
      const child = [
        h$1("div", {
          class: trackClass.value,
          style: trackStyle.value
        }),
        h$1("div", {
          class: modelClass.value,
          style: modelStyle.value
        })
      ];
      props2.stripe === true && motion.value === false && child.push(
        h$1("div", {
          class: stripeClass.value,
          style: stripeStyle.value
        })
      );
      return h$1("div", {
        class: classes.value,
        style: style.value,
        role: "progressbar",
        "aria-valuemin": 0,
        "aria-valuemax": 1,
        "aria-valuenow": props2.indeterminate === true ? void 0 : props2.value
      }, hMergeSlot(slots.default, child));
    };
  }
});
let counter = 0;
const useFullscreenProps = {
  fullscreen: Boolean,
  noRouteFullscreenExit: Boolean
};
const useFullscreenEmits = ["update:fullscreen", "fullscreen"];
function useFullscreen() {
  const vm2 = getCurrentInstance();
  const { props: props2, emit: emit2, proxy } = vm2;
  let historyEntry, fullscreenFillerNode, container;
  const inFullscreen = ref(false);
  vmHasRouter(vm2) === true && watch(() => proxy.$route.fullPath, () => {
    props2.noRouteFullscreenExit !== true && exitFullscreen();
  });
  watch(() => props2.fullscreen, (v2) => {
    if (inFullscreen.value !== v2) {
      toggleFullscreen();
    }
  });
  watch(inFullscreen, (v2) => {
    emit2("update:fullscreen", v2);
    emit2("fullscreen", v2);
  });
  function toggleFullscreen() {
    if (inFullscreen.value === true) {
      exitFullscreen();
    } else {
      setFullscreen();
    }
  }
  function setFullscreen() {
    if (inFullscreen.value === true) {
      return;
    }
    inFullscreen.value = true;
    container = proxy.$el.parentNode;
    container.replaceChild(fullscreenFillerNode, proxy.$el);
    document.body.appendChild(proxy.$el);
    counter++;
    if (counter === 1) {
      document.body.classList.add("q-body--fullscreen-mixin");
    }
    historyEntry = {
      handler: exitFullscreen
    };
    History.add(historyEntry);
  }
  function exitFullscreen() {
    if (inFullscreen.value !== true) {
      return;
    }
    if (historyEntry !== void 0) {
      History.remove(historyEntry);
      historyEntry = void 0;
    }
    container.replaceChild(proxy.$el, fullscreenFillerNode);
    inFullscreen.value = false;
    counter = Math.max(0, counter - 1);
    if (counter === 0) {
      document.body.classList.remove("q-body--fullscreen-mixin");
      if (proxy.$el.scrollIntoView !== void 0) {
        setTimeout(() => {
          proxy.$el.scrollIntoView();
        });
      }
    }
  }
  onBeforeMount(() => {
    fullscreenFillerNode = document.createElement("span");
  });
  onMounted(() => {
    props2.fullscreen === true && setFullscreen();
  });
  onBeforeUnmount(exitFullscreen);
  Object.assign(proxy, {
    toggleFullscreen,
    setFullscreen,
    exitFullscreen
  });
  return {
    inFullscreen,
    toggleFullscreen
  };
}
function sortDate(a2, b2) {
  return new Date(a2) - new Date(b2);
}
const useTableSortProps = {
  sortMethod: Function,
  binaryStateSort: Boolean,
  columnSortOrder: {
    type: String,
    validator: (v2) => v2 === "ad" || v2 === "da",
    default: "ad"
  }
};
function useTableSort(props2, computedPagination, colList, setPagination) {
  const columnToSort = computed(() => {
    const { sortBy } = computedPagination.value;
    return sortBy ? colList.value.find((def2) => def2.name === sortBy) || null : null;
  });
  const computedSortMethod = computed(() => props2.sortMethod !== void 0 ? props2.sortMethod : (data, sortBy, descending) => {
    const col = colList.value.find((def2) => def2.name === sortBy);
    if (col === void 0 || col.field === void 0) {
      return data;
    }
    const dir = descending === true ? -1 : 1, val = typeof col.field === "function" ? (v2) => col.field(v2) : (v2) => v2[col.field];
    return data.sort((a2, b2) => {
      let A2 = val(a2), B3 = val(b2);
      if (col.rawSort !== void 0) {
        return col.rawSort(A2, B3, a2, b2) * dir;
      }
      if (A2 === null || A2 === void 0) {
        return -1 * dir;
      }
      if (B3 === null || B3 === void 0) {
        return 1 * dir;
      }
      if (col.sort !== void 0) {
        return col.sort(A2, B3, a2, b2) * dir;
      }
      if (isNumber$1(A2) === true && isNumber$1(B3) === true) {
        return (A2 - B3) * dir;
      }
      if (isDate$1(A2) === true && isDate$1(B3) === true) {
        return sortDate(A2, B3) * dir;
      }
      if (typeof A2 === "boolean" && typeof B3 === "boolean") {
        return (A2 - B3) * dir;
      }
      [A2, B3] = [A2, B3].map((s2) => (s2 + "").toLocaleString().toLowerCase());
      return A2 < B3 ? -1 * dir : A2 === B3 ? 0 : dir;
    });
  });
  function sort(col) {
    let sortOrder = props2.columnSortOrder;
    if (isObject$3(col) === true) {
      if (col.sortOrder) {
        sortOrder = col.sortOrder;
      }
      col = col.name;
    } else {
      const def2 = colList.value.find((def3) => def3.name === col);
      if (def2 !== void 0 && def2.sortOrder) {
        sortOrder = def2.sortOrder;
      }
    }
    let { sortBy, descending } = computedPagination.value;
    if (sortBy !== col) {
      sortBy = col;
      descending = sortOrder === "da";
    } else if (props2.binaryStateSort === true) {
      descending = !descending;
    } else if (descending === true) {
      if (sortOrder === "ad") {
        sortBy = null;
      } else {
        descending = false;
      }
    } else {
      if (sortOrder === "ad") {
        descending = true;
      } else {
        sortBy = null;
      }
    }
    setPagination({ sortBy, descending, page: 1 });
  }
  return {
    columnToSort,
    computedSortMethod,
    sort
  };
}
const useTableFilterProps = {
  filter: [String, Object],
  filterMethod: Function
};
function useTableFilter(props2, setPagination) {
  const computedFilterMethod = computed(() => props2.filterMethod !== void 0 ? props2.filterMethod : (rows, terms, cols, cellValue) => {
    const lowerTerms = terms ? terms.toLowerCase() : "";
    return rows.filter(
      (row) => cols.some((col) => {
        const val = cellValue(col, row) + "";
        const haystack = val === "undefined" || val === "null" ? "" : val.toLowerCase();
        return haystack.indexOf(lowerTerms) !== -1;
      })
    );
  });
  watch(
    () => props2.filter,
    () => {
      nextTick$1(() => {
        setPagination({ page: 1 }, true);
      });
    },
    { deep: true }
  );
  return { computedFilterMethod };
}
function samePagination(oldPag, newPag) {
  for (const prop in newPag) {
    if (newPag[prop] !== oldPag[prop]) {
      return false;
    }
  }
  return true;
}
function fixPagination(p2) {
  if (p2.page < 1) {
    p2.page = 1;
  }
  if (p2.rowsPerPage !== void 0 && p2.rowsPerPage < 1) {
    p2.rowsPerPage = 0;
  }
  return p2;
}
const useTablePaginationProps = {
  pagination: Object,
  rowsPerPageOptions: {
    type: Array,
    default: () => [5, 7, 10, 15, 20, 25, 50, 0]
  },
  "onUpdate:pagination": [Function, Array]
};
function useTablePaginationState(vm2, getCellValue) {
  const { props: props2, emit: emit2 } = vm2;
  const innerPagination = ref(
    Object.assign({
      sortBy: null,
      descending: false,
      page: 1,
      rowsPerPage: props2.rowsPerPageOptions.length !== 0 ? props2.rowsPerPageOptions[0] : 5
    }, props2.pagination)
  );
  const computedPagination = computed(() => {
    const pag = props2["onUpdate:pagination"] !== void 0 ? { ...innerPagination.value, ...props2.pagination } : innerPagination.value;
    return fixPagination(pag);
  });
  const isServerSide = computed(() => computedPagination.value.rowsNumber !== void 0);
  function sendServerRequest(pagination) {
    requestServerInteraction({
      pagination,
      filter: props2.filter
    });
  }
  function requestServerInteraction(prop = {}) {
    nextTick$1(() => {
      emit2("request", {
        pagination: prop.pagination || computedPagination.value,
        filter: prop.filter || props2.filter,
        getCellValue
      });
    });
  }
  function setPagination(val, forceServerRequest) {
    const newPagination = fixPagination({
      ...computedPagination.value,
      ...val
    });
    if (samePagination(computedPagination.value, newPagination) === true) {
      if (isServerSide.value === true && forceServerRequest === true) {
        sendServerRequest(newPagination);
      }
      return;
    }
    if (isServerSide.value === true) {
      sendServerRequest(newPagination);
      return;
    }
    if (props2.pagination !== void 0 && props2["onUpdate:pagination"] !== void 0) {
      emit2("update:pagination", newPagination);
    } else {
      innerPagination.value = newPagination;
    }
  }
  return {
    innerPagination,
    computedPagination,
    isServerSide,
    requestServerInteraction,
    setPagination
  };
}
function useTablePagination(vm2, innerPagination, computedPagination, isServerSide, setPagination, filteredSortedRowsNumber) {
  const { props: props2, emit: emit2, proxy: { $q } } = vm2;
  const computedRowsNumber = computed(() => isServerSide.value === true ? computedPagination.value.rowsNumber || 0 : filteredSortedRowsNumber.value);
  const firstRowIndex = computed(() => {
    const { page, rowsPerPage } = computedPagination.value;
    return (page - 1) * rowsPerPage;
  });
  const lastRowIndex = computed(() => {
    const { page, rowsPerPage } = computedPagination.value;
    return page * rowsPerPage;
  });
  const isFirstPage = computed(() => computedPagination.value.page === 1);
  const pagesNumber = computed(() => computedPagination.value.rowsPerPage === 0 ? 1 : Math.max(
    1,
    Math.ceil(computedRowsNumber.value / computedPagination.value.rowsPerPage)
  ));
  const isLastPage = computed(() => lastRowIndex.value === 0 ? true : computedPagination.value.page >= pagesNumber.value);
  const computedRowsPerPageOptions = computed(() => {
    const opts = props2.rowsPerPageOptions.includes(innerPagination.value.rowsPerPage) ? props2.rowsPerPageOptions : [innerPagination.value.rowsPerPage].concat(props2.rowsPerPageOptions);
    return opts.map((count) => ({
      label: count === 0 ? $q.lang.table.allRows : "" + count,
      value: count
    }));
  });
  watch(pagesNumber, (lastPage2, oldLastPage) => {
    if (lastPage2 === oldLastPage) {
      return;
    }
    const currentPage = computedPagination.value.page;
    if (lastPage2 && !currentPage) {
      setPagination({ page: 1 });
    } else if (lastPage2 < currentPage) {
      setPagination({ page: lastPage2 });
    }
  });
  function firstPage() {
    setPagination({ page: 1 });
  }
  function prevPage() {
    const { page } = computedPagination.value;
    if (page > 1) {
      setPagination({ page: page - 1 });
    }
  }
  function nextPage() {
    const { page, rowsPerPage } = computedPagination.value;
    if (lastRowIndex.value > 0 && page * rowsPerPage < computedRowsNumber.value) {
      setPagination({ page: page + 1 });
    }
  }
  function lastPage() {
    setPagination({ page: pagesNumber.value });
  }
  if (props2["onUpdate:pagination"] !== void 0) {
    emit2("update:pagination", { ...computedPagination.value });
  }
  return {
    firstRowIndex,
    lastRowIndex,
    isFirstPage,
    isLastPage,
    pagesNumber,
    computedRowsPerPageOptions,
    computedRowsNumber,
    firstPage,
    prevPage,
    nextPage,
    lastPage
  };
}
const useTableRowSelectionProps = {
  selection: {
    type: String,
    default: "none",
    validator: (v2) => ["single", "multiple", "none"].includes(v2)
  },
  selected: {
    type: Array,
    default: () => []
  }
};
const useTableRowSelectionEmits = ["update:selected", "selection"];
function useTableRowSelection(props2, emit2, computedRows, getRowKey) {
  const selectedKeys = computed(() => {
    const keys = {};
    props2.selected.map(getRowKey.value).forEach((key) => {
      keys[key] = true;
    });
    return keys;
  });
  const hasSelectionMode = computed(() => {
    return props2.selection !== "none";
  });
  const singleSelection = computed(() => {
    return props2.selection === "single";
  });
  const multipleSelection = computed(() => {
    return props2.selection === "multiple";
  });
  const allRowsSelected = computed(
    () => computedRows.value.length !== 0 && computedRows.value.every(
      (row) => selectedKeys.value[getRowKey.value(row)] === true
    )
  );
  const someRowsSelected = computed(
    () => allRowsSelected.value !== true && computedRows.value.some((row) => selectedKeys.value[getRowKey.value(row)] === true)
  );
  const rowsSelectedNumber = computed(() => props2.selected.length);
  function isRowSelected(key) {
    return selectedKeys.value[key] === true;
  }
  function clearSelection2() {
    emit2("update:selected", []);
  }
  function updateSelection(keys, rows, added, evt) {
    emit2("selection", { rows, added, keys, evt });
    const payload = singleSelection.value === true ? added === true ? rows : [] : added === true ? props2.selected.concat(rows) : props2.selected.filter(
      (row) => keys.includes(getRowKey.value(row)) === false
    );
    emit2("update:selected", payload);
  }
  return {
    hasSelectionMode,
    singleSelection,
    multipleSelection,
    allRowsSelected,
    someRowsSelected,
    rowsSelectedNumber,
    isRowSelected,
    clearSelection: clearSelection2,
    updateSelection
  };
}
function getVal(val) {
  return Array.isArray(val) ? val.slice() : [];
}
const useTableRowExpandProps = {
  expanded: Array
  // v-model:expanded
};
const useTableRowExpandEmits = ["update:expanded"];
function useTableRowExpand(props2, emit2) {
  const innerExpanded = ref(getVal(props2.expanded));
  watch(() => props2.expanded, (val) => {
    innerExpanded.value = getVal(val);
  });
  function isRowExpanded(key) {
    return innerExpanded.value.includes(key);
  }
  function setExpanded(val) {
    if (props2.expanded !== void 0) {
      emit2("update:expanded", val);
    } else {
      innerExpanded.value = val;
    }
  }
  function updateExpanded(key, add2) {
    const target2 = innerExpanded.value.slice();
    const index = target2.indexOf(key);
    if (add2 === true) {
      if (index === -1) {
        target2.push(key);
        setExpanded(target2);
      }
    } else if (index !== -1) {
      target2.splice(index, 1);
      setExpanded(target2);
    }
  }
  return {
    isRowExpanded,
    setExpanded,
    updateExpanded
  };
}
const useTableColumnSelectionProps = {
  visibleColumns: Array
};
function useTableColumnSelection(props2, computedPagination, hasSelectionMode) {
  const colList = computed(() => {
    if (props2.columns !== void 0) {
      return props2.columns;
    }
    const row = props2.rows[0];
    return row !== void 0 ? Object.keys(row).map((name) => ({
      name,
      label: name.toUpperCase(),
      field: name,
      align: isNumber$1(row[name]) ? "right" : "left",
      sortable: true
    })) : [];
  });
  const computedCols = computed(() => {
    const { sortBy, descending } = computedPagination.value;
    const cols = props2.visibleColumns !== void 0 ? colList.value.filter((col) => col.required === true || props2.visibleColumns.includes(col.name) === true) : colList.value;
    return cols.map((col) => {
      const align = col.align || "right";
      const alignClass = `text-${align}`;
      return {
        ...col,
        align,
        __iconClass: `q-table__sort-icon q-table__sort-icon--${align}`,
        __thClass: alignClass + (col.headerClasses !== void 0 ? " " + col.headerClasses : "") + (col.sortable === true ? " sortable" : "") + (col.name === sortBy ? ` sorted ${descending === true ? "sort-desc" : ""}` : ""),
        __tdStyle: col.style !== void 0 ? typeof col.style !== "function" ? () => col.style : col.style : () => null,
        __tdClass: col.classes !== void 0 ? typeof col.classes !== "function" ? () => alignClass + " " + col.classes : (row) => alignClass + " " + col.classes(row) : () => alignClass
      };
    });
  });
  const computedColsMap = computed(() => {
    const names = {};
    computedCols.value.forEach((col) => {
      names[col.name] = col;
    });
    return names;
  });
  const computedColspan = computed(() => {
    return props2.tableColspan !== void 0 ? props2.tableColspan : computedCols.value.length + (hasSelectionMode.value === true ? 1 : 0);
  });
  return {
    colList,
    computedCols,
    computedColsMap,
    computedColspan
  };
}
const bottomClass = "q-table__bottom row items-center";
const virtScrollPassthroughProps = {};
commonVirtScrollPropsList.forEach((p2) => {
  virtScrollPassthroughProps[p2] = {};
});
const QTable = createComponent({
  name: "QTable",
  props: {
    rows: {
      type: Array,
      required: true
    },
    rowKey: {
      type: [String, Function],
      default: "id"
    },
    columns: Array,
    loading: Boolean,
    iconFirstPage: String,
    iconPrevPage: String,
    iconNextPage: String,
    iconLastPage: String,
    title: String,
    hideHeader: Boolean,
    grid: Boolean,
    gridHeader: Boolean,
    dense: Boolean,
    flat: Boolean,
    bordered: Boolean,
    square: Boolean,
    separator: {
      type: String,
      default: "horizontal",
      validator: (v2) => ["horizontal", "vertical", "cell", "none"].includes(v2)
    },
    wrapCells: Boolean,
    virtualScroll: Boolean,
    virtualScrollTarget: {},
    ...virtScrollPassthroughProps,
    noDataLabel: String,
    noResultsLabel: String,
    loadingLabel: String,
    selectedRowsLabel: Function,
    rowsPerPageLabel: String,
    paginationLabel: Function,
    color: {
      type: String,
      default: "grey-8"
    },
    titleClass: [String, Array, Object],
    tableStyle: [String, Array, Object],
    tableClass: [String, Array, Object],
    tableHeaderStyle: [String, Array, Object],
    tableHeaderClass: [String, Array, Object],
    cardContainerClass: [String, Array, Object],
    cardContainerStyle: [String, Array, Object],
    cardStyle: [String, Array, Object],
    cardClass: [String, Array, Object],
    hideBottom: Boolean,
    hideSelectedBanner: Boolean,
    hideNoData: Boolean,
    hidePagination: Boolean,
    onRowClick: Function,
    onRowDblclick: Function,
    onRowContextmenu: Function,
    ...useDarkProps,
    ...useFullscreenProps,
    ...useTableColumnSelectionProps,
    ...useTableFilterProps,
    ...useTablePaginationProps,
    ...useTableRowExpandProps,
    ...useTableRowSelectionProps,
    ...useTableSortProps
  },
  emits: [
    "request",
    "virtualScroll",
    ...useFullscreenEmits,
    ...useTableRowExpandEmits,
    ...useTableRowSelectionEmits
  ],
  setup(props2, { slots, emit: emit2 }) {
    const vm2 = getCurrentInstance();
    const { proxy: { $q } } = vm2;
    const isDark = useDark(props2, $q);
    const { inFullscreen, toggleFullscreen } = useFullscreen();
    const getRowKey = computed(() => typeof props2.rowKey === "function" ? props2.rowKey : (row) => row[props2.rowKey]);
    const rootRef = ref(null);
    const virtScrollRef = ref(null);
    const hasVirtScroll = computed(() => props2.grid !== true && props2.virtualScroll === true);
    const cardDefaultClass = computed(
      () => " q-table__card" + (isDark.value === true ? " q-table__card--dark q-dark" : "") + (props2.square === true ? " q-table--square" : "") + (props2.flat === true ? " q-table--flat" : "") + (props2.bordered === true ? " q-table--bordered" : "")
    );
    const __containerClass = computed(
      () => `q-table__container q-table--${props2.separator}-separator column no-wrap` + (props2.grid === true ? " q-table--grid" : cardDefaultClass.value) + (isDark.value === true ? " q-table--dark" : "") + (props2.dense === true ? " q-table--dense" : "") + (props2.wrapCells === false ? " q-table--no-wrap" : "") + (inFullscreen.value === true ? " fullscreen scroll" : "")
    );
    const containerClass = computed(
      () => __containerClass.value + (props2.loading === true ? " q-table--loading" : "")
    );
    watch(
      () => props2.tableStyle + props2.tableClass + props2.tableHeaderStyle + props2.tableHeaderClass + __containerClass.value,
      () => {
        hasVirtScroll.value === true && virtScrollRef.value !== null && virtScrollRef.value.reset();
      }
    );
    const {
      innerPagination,
      computedPagination,
      isServerSide,
      requestServerInteraction,
      setPagination
    } = useTablePaginationState(vm2, getCellValue);
    const { computedFilterMethod } = useTableFilter(props2, setPagination);
    const { isRowExpanded, setExpanded, updateExpanded } = useTableRowExpand(props2, emit2);
    const filteredSortedRows = computed(() => {
      let rows = props2.rows;
      if (isServerSide.value === true || rows.length === 0) {
        return rows;
      }
      const { sortBy, descending } = computedPagination.value;
      if (props2.filter) {
        rows = computedFilterMethod.value(rows, props2.filter, computedCols.value, getCellValue);
      }
      if (columnToSort.value !== null) {
        rows = computedSortMethod.value(
          props2.rows === rows ? rows.slice() : rows,
          sortBy,
          descending
        );
      }
      return rows;
    });
    const filteredSortedRowsNumber = computed(() => filteredSortedRows.value.length);
    const computedRows = computed(() => {
      let rows = filteredSortedRows.value;
      if (isServerSide.value === true) {
        return rows;
      }
      const { rowsPerPage } = computedPagination.value;
      if (rowsPerPage !== 0) {
        if (firstRowIndex.value === 0 && props2.rows !== rows) {
          if (rows.length > lastRowIndex.value) {
            rows = rows.slice(0, lastRowIndex.value);
          }
        } else {
          rows = rows.slice(firstRowIndex.value, lastRowIndex.value);
        }
      }
      return rows;
    });
    const {
      hasSelectionMode,
      singleSelection,
      multipleSelection,
      allRowsSelected,
      someRowsSelected,
      rowsSelectedNumber,
      isRowSelected,
      clearSelection: clearSelection2,
      updateSelection
    } = useTableRowSelection(props2, emit2, computedRows, getRowKey);
    const { colList, computedCols, computedColsMap, computedColspan } = useTableColumnSelection(props2, computedPagination, hasSelectionMode);
    const { columnToSort, computedSortMethod, sort } = useTableSort(props2, computedPagination, colList, setPagination);
    const {
      firstRowIndex,
      lastRowIndex,
      isFirstPage,
      isLastPage,
      pagesNumber,
      computedRowsPerPageOptions,
      computedRowsNumber,
      firstPage,
      prevPage,
      nextPage,
      lastPage
    } = useTablePagination(vm2, innerPagination, computedPagination, isServerSide, setPagination, filteredSortedRowsNumber);
    const nothingToDisplay = computed(() => computedRows.value.length === 0);
    const virtProps = computed(() => {
      const acc = {};
      commonVirtScrollPropsList.forEach((p2) => {
        acc[p2] = props2[p2];
      });
      if (acc.virtualScrollItemSize === void 0) {
        acc.virtualScrollItemSize = props2.dense === true ? 28 : 48;
      }
      return acc;
    });
    function resetVirtualScroll() {
      hasVirtScroll.value === true && virtScrollRef.value.reset();
    }
    function getBody() {
      if (props2.grid === true) {
        return getGridBody();
      }
      const header = props2.hideHeader !== true ? getTHead : null;
      if (hasVirtScroll.value === true) {
        const topRow = slots["top-row"];
        const bottomRow = slots["bottom-row"];
        const virtSlots = {
          default: (props3) => getTBodyTR(props3.item, slots.body, props3.index)
        };
        if (topRow !== void 0) {
          const topContent = h$1("tbody", topRow({ cols: computedCols.value }));
          virtSlots.before = header === null ? () => topContent : () => [header()].concat(topContent);
        } else if (header !== null) {
          virtSlots.before = header;
        }
        if (bottomRow !== void 0) {
          virtSlots.after = () => h$1("tbody", bottomRow({ cols: computedCols.value }));
        }
        return h$1(QVirtualScroll, {
          ref: virtScrollRef,
          class: props2.tableClass,
          style: props2.tableStyle,
          ...virtProps.value,
          scrollTarget: props2.virtualScrollTarget,
          items: computedRows.value,
          type: "__qtable",
          tableColspan: computedColspan.value,
          onVirtualScroll: onVScroll
        }, virtSlots);
      }
      const child = [
        getTBody()
      ];
      if (header !== null) {
        child.unshift(header());
      }
      return getTableMiddle({
        class: ["q-table__middle scroll", props2.tableClass],
        style: props2.tableStyle
      }, child);
    }
    function scrollTo(toIndex, edge) {
      if (virtScrollRef.value !== null) {
        virtScrollRef.value.scrollTo(toIndex, edge);
        return;
      }
      toIndex = parseInt(toIndex, 10);
      const rowEl = rootRef.value.querySelector(`tbody tr:nth-of-type(${toIndex + 1})`);
      if (rowEl !== null) {
        const scrollTarget = rootRef.value.querySelector(".q-table__middle.scroll");
        const offsetTop = rowEl.offsetTop - props2.virtualScrollStickySizeStart;
        const direction2 = offsetTop < scrollTarget.scrollTop ? "decrease" : "increase";
        scrollTarget.scrollTop = offsetTop;
        emit2("virtualScroll", {
          index: toIndex,
          from: 0,
          to: innerPagination.value.rowsPerPage - 1,
          direction: direction2
        });
      }
    }
    function onVScroll(info) {
      emit2("virtualScroll", info);
    }
    function getProgress() {
      return [
        h$1(QLinearProgress, {
          class: "q-table__linear-progress",
          color: props2.color,
          dark: isDark.value,
          indeterminate: true,
          trackColor: "transparent"
        })
      ];
    }
    function getTBodyTR(row, bodySlot, pageIndex) {
      const key = getRowKey.value(row), selected = isRowSelected(key);
      if (bodySlot !== void 0) {
        return bodySlot(
          getBodyScope({
            key,
            row,
            pageIndex,
            __trClass: selected ? "selected" : ""
          })
        );
      }
      const bodyCell = slots["body-cell"], child = computedCols.value.map((col) => {
        const bodyCellCol = slots[`body-cell-${col.name}`], slot = bodyCellCol !== void 0 ? bodyCellCol : bodyCell;
        return slot !== void 0 ? slot(getBodyCellScope({ key, row, pageIndex, col })) : h$1("td", {
          class: col.__tdClass(row),
          style: col.__tdStyle(row)
        }, getCellValue(col, row));
      });
      if (hasSelectionMode.value === true) {
        const slot = slots["body-selection"];
        const content2 = slot !== void 0 ? slot(getBodySelectionScope({ key, row, pageIndex })) : [
          h$1(QCheckbox, {
            modelValue: selected,
            color: props2.color,
            dark: isDark.value,
            dense: props2.dense,
            "onUpdate:modelValue": (adding, evt) => {
              updateSelection([key], [row], adding, evt);
            }
          })
        ];
        child.unshift(
          h$1("td", { class: "q-table--col-auto-width" }, content2)
        );
      }
      const data = { key, class: { selected } };
      if (props2.onRowClick !== void 0) {
        data.class["cursor-pointer"] = true;
        data.onClick = (evt) => {
          emit2("rowClick", evt, row, pageIndex);
        };
      }
      if (props2.onRowDblclick !== void 0) {
        data.class["cursor-pointer"] = true;
        data.onDblclick = (evt) => {
          emit2("rowDblclick", evt, row, pageIndex);
        };
      }
      if (props2.onRowContextmenu !== void 0) {
        data.class["cursor-pointer"] = true;
        data.onContextmenu = (evt) => {
          emit2("rowContextmenu", evt, row, pageIndex);
        };
      }
      return h$1("tr", data, child);
    }
    function getTBody() {
      const body = slots.body, topRow = slots["top-row"], bottomRow = slots["bottom-row"];
      let child = computedRows.value.map(
        (row, pageIndex) => getTBodyTR(row, body, pageIndex)
      );
      if (topRow !== void 0) {
        child = topRow({ cols: computedCols.value }).concat(child);
      }
      if (bottomRow !== void 0) {
        child = child.concat(bottomRow({ cols: computedCols.value }));
      }
      return h$1("tbody", child);
    }
    function getBodyScope(data) {
      injectBodyCommonScope(data);
      data.cols = data.cols.map(
        (col) => injectProp({ ...col }, "value", () => getCellValue(col, data.row))
      );
      return data;
    }
    function getBodyCellScope(data) {
      injectBodyCommonScope(data);
      injectProp(data, "value", () => getCellValue(data.col, data.row));
      return data;
    }
    function getBodySelectionScope(data) {
      injectBodyCommonScope(data);
      return data;
    }
    function injectBodyCommonScope(data) {
      Object.assign(data, {
        cols: computedCols.value,
        colsMap: computedColsMap.value,
        sort,
        rowIndex: firstRowIndex.value + data.pageIndex,
        color: props2.color,
        dark: isDark.value,
        dense: props2.dense
      });
      hasSelectionMode.value === true && injectProp(
        data,
        "selected",
        () => isRowSelected(data.key),
        (adding, evt) => {
          updateSelection([data.key], [data.row], adding, evt);
        }
      );
      injectProp(
        data,
        "expand",
        () => isRowExpanded(data.key),
        (adding) => {
          updateExpanded(data.key, adding);
        }
      );
    }
    function getCellValue(col, row) {
      const val = typeof col.field === "function" ? col.field(row) : row[col.field];
      return col.format !== void 0 ? col.format(val, row) : val;
    }
    const marginalsScope = computed(() => ({
      pagination: computedPagination.value,
      pagesNumber: pagesNumber.value,
      isFirstPage: isFirstPage.value,
      isLastPage: isLastPage.value,
      firstPage,
      prevPage,
      nextPage,
      lastPage,
      inFullscreen: inFullscreen.value,
      toggleFullscreen
    }));
    function getTopDiv() {
      const top = slots.top, topLeft = slots["top-left"], topRight = slots["top-right"], topSelection = slots["top-selection"], hasSelection = hasSelectionMode.value === true && topSelection !== void 0 && rowsSelectedNumber.value > 0, topClass = "q-table__top relative-position row items-center";
      if (top !== void 0) {
        return h$1("div", { class: topClass }, [top(marginalsScope.value)]);
      }
      let child;
      if (hasSelection === true) {
        child = topSelection(marginalsScope.value).slice();
      } else {
        child = [];
        if (topLeft !== void 0) {
          child.push(
            h$1("div", { class: "q-table__control" }, [
              topLeft(marginalsScope.value)
            ])
          );
        } else if (props2.title) {
          child.push(
            h$1("div", { class: "q-table__control" }, [
              h$1("div", {
                class: ["q-table__title", props2.titleClass]
              }, props2.title)
            ])
          );
        }
      }
      if (topRight !== void 0) {
        child.push(
          h$1("div", { class: "q-table__separator col" })
        );
        child.push(
          h$1("div", { class: "q-table__control" }, [
            topRight(marginalsScope.value)
          ])
        );
      }
      if (child.length === 0) {
        return;
      }
      return h$1("div", { class: topClass }, child);
    }
    const headerSelectedValue = computed(() => someRowsSelected.value === true ? null : allRowsSelected.value);
    function getTHead() {
      const child = getTHeadTR();
      if (props2.loading === true && slots.loading === void 0) {
        child.push(
          h$1("tr", { class: "q-table__progress" }, [
            h$1("th", {
              class: "relative-position",
              colspan: computedColspan.value
            }, getProgress())
          ])
        );
      }
      return h$1("thead", child);
    }
    function getTHeadTR() {
      const header = slots.header, headerCell = slots["header-cell"];
      if (header !== void 0) {
        return header(
          getHeaderScope({ header: true })
        ).slice();
      }
      const child = computedCols.value.map((col) => {
        const headerCellCol = slots[`header-cell-${col.name}`], slot = headerCellCol !== void 0 ? headerCellCol : headerCell, props3 = getHeaderScope({ col });
        return slot !== void 0 ? slot(props3) : h$1(QTh, {
          key: col.name,
          props: props3
        }, () => col.label);
      });
      if (singleSelection.value === true && props2.grid !== true) {
        child.unshift(
          h$1("th", { class: "q-table--col-auto-width" }, " ")
        );
      } else if (multipleSelection.value === true) {
        const slot = slots["header-selection"];
        const content2 = slot !== void 0 ? slot(getHeaderScope({})) : [
          h$1(QCheckbox, {
            color: props2.color,
            modelValue: headerSelectedValue.value,
            dark: isDark.value,
            dense: props2.dense,
            "onUpdate:modelValue": onMultipleSelectionSet
          })
        ];
        child.unshift(
          h$1("th", { class: "q-table--col-auto-width" }, content2)
        );
      }
      return [
        h$1("tr", {
          class: props2.tableHeaderClass,
          style: props2.tableHeaderStyle
        }, child)
      ];
    }
    function getHeaderScope(data) {
      Object.assign(data, {
        cols: computedCols.value,
        sort,
        colsMap: computedColsMap.value,
        color: props2.color,
        dark: isDark.value,
        dense: props2.dense
      });
      if (multipleSelection.value === true) {
        injectProp(
          data,
          "selected",
          () => headerSelectedValue.value,
          onMultipleSelectionSet
        );
      }
      return data;
    }
    function onMultipleSelectionSet(val) {
      if (someRowsSelected.value === true) {
        val = false;
      }
      updateSelection(
        computedRows.value.map(getRowKey.value),
        computedRows.value,
        val
      );
    }
    const navIcon = computed(() => {
      const ico = [
        props2.iconFirstPage || $q.iconSet.table.firstPage,
        props2.iconPrevPage || $q.iconSet.table.prevPage,
        props2.iconNextPage || $q.iconSet.table.nextPage,
        props2.iconLastPage || $q.iconSet.table.lastPage
      ];
      return $q.lang.rtl === true ? ico.reverse() : ico;
    });
    function getBottomDiv() {
      if (props2.hideBottom === true) {
        return;
      }
      if (nothingToDisplay.value === true) {
        if (props2.hideNoData === true) {
          return;
        }
        const message = props2.loading === true ? props2.loadingLabel || $q.lang.table.loading : props2.filter ? props2.noResultsLabel || $q.lang.table.noResults : props2.noDataLabel || $q.lang.table.noData;
        const noData = slots["no-data"];
        const children = noData !== void 0 ? [noData({ message, icon: $q.iconSet.table.warning, filter: props2.filter })] : [
          h$1(QIcon, {
            class: "q-table__bottom-nodata-icon",
            name: $q.iconSet.table.warning
          }),
          message
        ];
        return h$1("div", { class: bottomClass + " q-table__bottom--nodata" }, children);
      }
      const bottom = slots.bottom;
      if (bottom !== void 0) {
        return h$1("div", { class: bottomClass }, [bottom(marginalsScope.value)]);
      }
      const child = props2.hideSelectedBanner !== true && hasSelectionMode.value === true && rowsSelectedNumber.value > 0 ? [
        h$1("div", { class: "q-table__control" }, [
          h$1("div", [
            (props2.selectedRowsLabel || $q.lang.table.selectedRecords)(rowsSelectedNumber.value)
          ])
        ])
      ] : [];
      if (props2.hidePagination !== true) {
        return h$1("div", {
          class: bottomClass + " justify-end"
        }, getPaginationDiv(child));
      }
      if (child.length !== 0) {
        return h$1("div", { class: bottomClass }, child);
      }
    }
    function onPagSelection(pag) {
      setPagination({
        page: 1,
        rowsPerPage: pag.value
      });
    }
    function getPaginationDiv(child) {
      let control;
      const { rowsPerPage } = computedPagination.value, paginationLabel = props2.paginationLabel || $q.lang.table.pagination, paginationSlot = slots.pagination, hasOpts = props2.rowsPerPageOptions.length > 1;
      child.push(
        h$1("div", { class: "q-table__separator col" })
      );
      if (hasOpts === true) {
        child.push(
          h$1("div", { class: "q-table__control" }, [
            h$1("span", { class: "q-table__bottom-item" }, [
              props2.rowsPerPageLabel || $q.lang.table.recordsPerPage
            ]),
            h$1(QSelect, {
              class: "q-table__select inline q-table__bottom-item",
              color: props2.color,
              modelValue: rowsPerPage,
              options: computedRowsPerPageOptions.value,
              displayValue: rowsPerPage === 0 ? $q.lang.table.allRows : rowsPerPage,
              dark: isDark.value,
              borderless: true,
              dense: true,
              optionsDense: true,
              optionsCover: true,
              "onUpdate:modelValue": onPagSelection
            })
          ])
        );
      }
      if (paginationSlot !== void 0) {
        control = paginationSlot(marginalsScope.value);
      } else {
        control = [
          h$1("span", rowsPerPage !== 0 ? { class: "q-table__bottom-item" } : {}, [
            rowsPerPage ? paginationLabel(firstRowIndex.value + 1, Math.min(lastRowIndex.value, computedRowsNumber.value), computedRowsNumber.value) : paginationLabel(1, filteredSortedRowsNumber.value, computedRowsNumber.value)
          ])
        ];
        if (rowsPerPage !== 0 && pagesNumber.value > 1) {
          const btnProps = {
            color: props2.color,
            round: true,
            dense: true,
            flat: true
          };
          if (props2.dense === true) {
            btnProps.size = "sm";
          }
          pagesNumber.value > 2 && control.push(
            h$1(QBtn, {
              key: "pgFirst",
              ...btnProps,
              icon: navIcon.value[0],
              disable: isFirstPage.value,
              onClick: firstPage
            })
          );
          control.push(
            h$1(QBtn, {
              key: "pgPrev",
              ...btnProps,
              icon: navIcon.value[1],
              disable: isFirstPage.value,
              onClick: prevPage
            }),
            h$1(QBtn, {
              key: "pgNext",
              ...btnProps,
              icon: navIcon.value[2],
              disable: isLastPage.value,
              onClick: nextPage
            })
          );
          pagesNumber.value > 2 && control.push(
            h$1(QBtn, {
              key: "pgLast",
              ...btnProps,
              icon: navIcon.value[3],
              disable: isLastPage.value,
              onClick: lastPage
            })
          );
        }
      }
      child.push(
        h$1("div", { class: "q-table__control" }, control)
      );
      return child;
    }
    function getGridHeader() {
      const child = props2.gridHeader === true ? [
        h$1("table", { class: "q-table" }, [
          getTHead()
        ])
      ] : props2.loading === true && slots.loading === void 0 ? getProgress() : void 0;
      return h$1("div", { class: "q-table__middle" }, child);
    }
    function getGridBody() {
      const item = slots.item !== void 0 ? slots.item : (scope) => {
        const child = scope.cols.map(
          (col) => h$1("div", { class: "q-table__grid-item-row" }, [
            h$1("div", { class: "q-table__grid-item-title" }, [col.label]),
            h$1("div", { class: "q-table__grid-item-value" }, [col.value])
          ])
        );
        if (hasSelectionMode.value === true) {
          const slot = slots["body-selection"];
          const content2 = slot !== void 0 ? slot(scope) : [
            h$1(QCheckbox, {
              modelValue: scope.selected,
              color: props2.color,
              dark: isDark.value,
              dense: props2.dense,
              "onUpdate:modelValue": (adding, evt) => {
                updateSelection([scope.key], [scope.row], adding, evt);
              }
            })
          ];
          child.unshift(
            h$1("div", { class: "q-table__grid-item-row" }, content2),
            h$1(QSeparator, { dark: isDark.value })
          );
        }
        const data = {
          class: [
            "q-table__grid-item-card" + cardDefaultClass.value,
            props2.cardClass
          ],
          style: props2.cardStyle
        };
        if (props2.onRowClick !== void 0 || props2.onRowDblclick !== void 0) {
          data.class[0] += " cursor-pointer";
          if (props2.onRowClick !== void 0) {
            data.onClick = (evt) => {
              emit2("RowClick", evt, scope.row, scope.pageIndex);
            };
          }
          if (props2.onRowDblclick !== void 0) {
            data.onDblclick = (evt) => {
              emit2("RowDblclick", evt, scope.row, scope.pageIndex);
            };
          }
        }
        return h$1("div", {
          class: "q-table__grid-item col-xs-12 col-sm-6 col-md-4 col-lg-3" + (scope.selected === true ? " q-table__grid-item--selected" : "")
        }, [
          h$1("div", data, child)
        ]);
      };
      return h$1("div", {
        class: [
          "q-table__grid-content row",
          props2.cardContainerClass
        ],
        style: props2.cardContainerStyle
      }, computedRows.value.map((row, pageIndex) => {
        return item(getBodyScope({
          key: getRowKey.value(row),
          row,
          pageIndex
        }));
      }));
    }
    Object.assign(vm2.proxy, {
      requestServerInteraction,
      setPagination,
      firstPage,
      prevPage,
      nextPage,
      lastPage,
      isRowSelected,
      clearSelection: clearSelection2,
      isRowExpanded,
      setExpanded,
      sort,
      resetVirtualScroll,
      scrollTo,
      getCellValue
    });
    injectMultipleProps(vm2.proxy, {
      filteredSortedRows: () => filteredSortedRows.value,
      computedRows: () => computedRows.value,
      computedRowsNumber: () => computedRowsNumber.value
    });
    return () => {
      const child = [getTopDiv()];
      const data = { ref: rootRef, class: containerClass.value };
      if (props2.grid === true) {
        child.push(getGridHeader());
      } else {
        Object.assign(data, {
          class: [data.class, props2.cardClass],
          style: props2.cardStyle
        });
      }
      child.push(
        getBody(),
        getBottomDiv()
      );
      if (props2.loading === true && slots.loading !== void 0) {
        child.push(
          slots.loading()
        );
      }
      return h$1("div", data, child);
    };
  }
});
const svg = [
  h$1("g", {
    transform: "translate(1 1)",
    "stroke-width": "2",
    fill: "none",
    "fill-rule": "evenodd"
  }, [
    h$1("circle", {
      "stroke-opacity": ".5",
      cx: "18",
      cy: "18",
      r: "18"
    }),
    h$1("path", {
      d: "M36 18c0-9.94-8.06-18-18-18"
    }, [
      h$1("animateTransform", {
        attributeName: "transform",
        type: "rotate",
        from: "0 18 18",
        to: "360 18 18",
        dur: "1s",
        repeatCount: "indefinite"
      })
    ])
  ])
];
const QSpinnerOval = createComponent({
  name: "QSpinnerOval",
  props: useSpinnerProps,
  setup(props2) {
    const { cSize, classes } = useSpinner(props2);
    return () => h$1("svg", {
      class: classes.value,
      stroke: "currentColor",
      width: cSize.value,
      height: cSize.value,
      viewBox: "0 0 38 38",
      xmlns: "http://www.w3.org/2000/svg"
    }, svg);
  }
});
const getFarmsApi = async () => {
  try {
    const response = await axiosInstance.get(`/farms`);
    console.log(response);
    return response.data;
  } catch (error) {
    console.error(error);
    const message = error.response.data.message || "Error al obtener las fincas";
    notifyErrorRequest$1(message);
  }
};
const createFarmApi = async (dataFarm) => {
  try {
    const response = await axiosInstance.post(`/farms/create`, dataFarm);
    console.log(response);
    return response;
  } catch (error) {
    console.error(error);
    const message = error.response.data.message || "Error al crear la finca";
    notifyErrorRequest$1(message);
  }
};
const updateFarmApi = async (dataFarm) => {
  try {
    const response = await axiosInstance.put(`/farms/update`, dataFarm);
    console.log(response);
    return response;
  } catch (error) {
    console.error(error);
    const message = error.response.data.message || "Error al actualizar la finca";
    notifyErrorRequest$1(message);
  }
};
const _withScopeId$5 = (n2) => (pushScopeId("data-v-0a9730ee"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$6 = { class: "q-my-xl" };
const _hoisted_2$6 = { class: "row" };
const _hoisted_3$6 = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createBaseVNode("div", { class: "col-1" }, null, -1));
const _hoisted_4$6 = { class: "col-10" };
const _hoisted_5$5 = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createBaseVNode("span", {
  class: "material-symbols-outlined q-mr-sm",
  style: { "font-size": "20px" }
}, " add_circle ", -1));
const _hoisted_6$4 = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createBaseVNode("div", { class: "col-1" }, null, -1));
const _hoisted_7$4 = { class: "row q-mt-md justify-center" };
const _hoisted_8$4 = { class: "col-11 q-mb-lg" };
const _hoisted_9$4 = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createBaseVNode("span", {
  class: "material-symbols-outlined",
  style: { "font-size": "18px" }
}, " check ", -1));
const _hoisted_10$4 = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createBaseVNode("span", {
  class: "material-symbols-outlined",
  style: { "font-size": "18px" }
}, " close ", -1));
const _hoisted_11$4 = { class: "q-mt-sm q-mb-sm text-white text-center text-weight-bold" };
const _hoisted_12$4 = { class: "q-pa-md" };
const _hoisted_13$4 = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createBaseVNode("span", { class: "material-symbols-outlined" }, " person ", -1));
const _hoisted_14$4 = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createBaseVNode("span", { class: "material-symbols-outlined" }, " phone ", -1));
const _hoisted_15$4 = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createBaseVNode("span", { class: "material-symbols-outlined" }, " mail ", -1));
const _hoisted_16$3 = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createBaseVNode("span", { class: "material-symbols-outlined" }, " drag_indicator ", -1));
const _hoisted_17$3 = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createBaseVNode("span", { class: "material-symbols-outlined" }, " location_city ", -1));
const _hoisted_18$2 = { class: "justify-center flex" };
const _hoisted_19$2 = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createBaseVNode("span", {
  class: "material-symbols-outlined q-mr-sm",
  style: { "font-size": "23px" }
}, " cancel ", -1));
const _sfc_main$6 = {
  __name: "Users",
  setup(__props) {
    useQuasar();
    let index = ref();
    let prompt = ref(false);
    let edit = ref(false);
    let form = ref({
      username: "",
      role: "",
      email: "",
      phone: "",
      password: "",
      farms: null,
      status: true
    });
    let optionsFarm = ref([]);
    let isPwd = ref(true);
    let loading = ref(false);
    let optionsRole = ref([
      {
        label: "ADMINISTRADOR",
        value: "ADMIN"
      },
      {
        label: "USUARIO",
        value: "USER"
      }
    ]);
    let columns = ref([
      {
        name: "nombre",
        label: "NOMBRE",
        field: "username",
        align: "center",
        sortable: true
      },
      {
        name: "correo",
        label: "CORREO",
        field: "email",
        align: "center",
        sortable: true
      },
      {
        name: "phone",
        label: "TELÉFONO",
        field: "phone",
        align: "center",
        sortable: true
      },
      {
        name: "rol",
        label: "ROL",
        field: "role",
        align: "center",
        sortable: true
      },
      {
        name: "farms",
        label: "FINCAS",
        field: (row) => {
          var _a2;
          return (_a2 = row.farms) == null ? void 0 : _a2.map((farm) => farm.name).join(", ");
        },
        align: "center",
        sortable: true
      },
      {
        name: "status",
        label: "ESTADO",
        field: (row) => row.status == false ? "Inactivo" : "Activo",
        align: "center",
        sortable: true
      },
      { name: "options", label: "OPCIONES", align: "center" }
    ]);
    let rows = ref([]);
    onBeforeMount(async () => {
      await getUsers();
      await getFarms();
    });
    function showInfo(data) {
      index.value = data._id;
      form.value.username = data.username;
      const role = optionsRole.value.find((role2) => role2.value == data.role);
      form.value.role = {
        label: role.label,
        value: role.value
      };
      form.value.email = data.email;
      form.value.phone = data.phone;
      form.value.password = data.password;
      form.value.farms = data.farms.map((farm) => {
        return {
          label: `${farm.codeFarm} - ${farm.name}`,
          value: farm._id
        };
      });
      edit.value = true;
      prompt.value = true;
      loading.value = false;
    }
    async function activeInactive(idUser) {
      index.value = idUser;
      const data = rows.value.find((row) => row._id == idUser);
      data.status = !data.status;
      console.log(data.farms.map((farm) => farm._id));
      data.farms = data.farms.map((farm) => {
        return {
          label: `${farm.codeFarm} - ${farm.name}`,
          value: farm._id
        };
      });
      form.value = data;
      await putUser();
    }
    const getUsers = async () => {
      const data = await getUsersApi();
      if ((data == null ? void 0 : data.data.length) > 0) {
        rows.value = data.data;
      }
    };
    const getFarms = async () => {
      const data = await getFarmsApi();
      if ((data == null ? void 0 : data.data.length) > 0) {
        optionsFarm.value = data.data.map((farm) => {
          return {
            label: `${farm.codeFarm} - ${farm.name}`,
            value: farm._id
          };
        });
      }
    };
    const clearForm = () => {
      form.value = {
        username: "",
        role: "",
        email: "",
        phone: "",
        password: "",
        farms: null,
        status: true
      };
    };
    async function postUsers() {
      var _a2;
      loading.value = true;
      await createUserApi({
        ...form.value,
        role: form.value.role.value,
        farms: (_a2 = form.value.farms) == null ? void 0 : _a2.map((farm) => farm.value)
      }).then(async (res) => {
        if (res && res.status < 299) {
          prompt.value = false;
          edit.value = false;
          clearForm();
          await getUsers();
        }
      });
      loading.value = false;
    }
    async function putUser() {
      var _a2;
      loading.value = true;
      console.log(form.value);
      await updateUserApi({
        ...form.value,
        id: index.value,
        role: form.value.role.value,
        farms: (_a2 = form.value.farms) == null ? void 0 : _a2.map((farm) => farm.value)
      }).then(async (res) => {
        if (res && res.status < 299) {
          clearForm();
          prompt.value = false;
          edit.value = false;
          await getUsers();
        }
      });
      loading.value = false;
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$6, [
        createVNode(_sfc_main$c, { title: "Usuarios" }),
        createBaseVNode("div", _hoisted_2$6, [
          _hoisted_3$6,
          createBaseVNode("div", _hoisted_4$6, [
            createVNode(QBtn, {
              class: "bg-green-9 text-white",
              onClick: _cache[0] || (_cache[0] = ($event) => (clearForm(), isRef(prompt) ? prompt.value = true : prompt = true, isRef(edit) ? edit.value = false : edit = false))
            }, {
              default: withCtx(() => [
                _hoisted_5$5,
                createTextVNode(" Crear ")
              ]),
              _: 1
            })
          ]),
          _hoisted_6$4
        ]),
        createBaseVNode("div", _hoisted_7$4, [
          createBaseVNode("div", _hoisted_8$4, [
            createVNode(QTable, {
              flat: "",
              bordered: "",
              "no-data-label": "Sin registros aún",
              rows: unref(rows),
              columns: unref(columns),
              "row-key": "index",
              class: "q-mx-md my-sticky-header-table",
              "rows-per-page-label": "Numero de documentos",
              "rows-per-page-options": [10, 20, 30, 40, 50, 0],
              pagination: {
                rowsPerPage: 50
              }
            }, {
              "body-cell-status": withCtx((props2) => [
                createVNode(QTd, { props: props2 }, {
                  default: withCtx(() => [
                    createBaseVNode("div", null, [
                      props2.value === "Activo" ? (openBlock(), createBlock(QBadge, {
                        key: 0,
                        class: "bg-green-10"
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(props2.value), 1)
                        ]),
                        _: 2
                      }, 1024)) : (openBlock(), createBlock(QBadge, {
                        key: 1,
                        class: "bg-red"
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(props2.value), 1)
                        ]),
                        _: 2
                      }, 1024))
                    ])
                  ]),
                  _: 2
                }, 1032, ["props"])
              ]),
              "body-cell-options": withCtx((props2) => [
                createVNode(QTd, { props: props2 }, {
                  default: withCtx(() => [
                    createBaseVNode("div", null, [
                      createVNode(QBtn, {
                        round: "",
                        icon: "edit",
                        class: "q-mx-md",
                        size: "xs",
                        color: "green-10",
                        onClick: ($event) => showInfo(props2.row)
                      }, null, 8, ["onClick"]),
                      props2.row.status ? (openBlock(), createBlock(QBtn, {
                        key: 0,
                        round: "",
                        size: "xs",
                        color: "green-10",
                        onClick: ($event) => activeInactive(props2.row._id)
                      }, {
                        default: withCtx(() => [
                          _hoisted_9$4
                        ]),
                        _: 2
                      }, 1032, ["onClick"])) : (openBlock(), createBlock(QBtn, {
                        key: 1,
                        round: "",
                        size: "xs",
                        color: "red",
                        onClick: ($event) => activeInactive(props2.row._id)
                      }, {
                        default: withCtx(() => [
                          _hoisted_10$4
                        ]),
                        _: 2
                      }, 1032, ["onClick"]))
                    ])
                  ]),
                  _: 2
                }, 1032, ["props"])
              ]),
              _: 1
            }, 8, ["rows", "columns"])
          ])
        ]),
        createVNode(QDialog, {
          modelValue: unref(prompt),
          "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => isRef(prompt) ? prompt.value = $event : prompt = $event)
        }, {
          default: withCtx(() => [
            createVNode(QCard, null, {
              default: withCtx(() => [
                createVNode(QCardSection, { class: "bg-green-9 q-px-lg" }, {
                  default: withCtx(() => [
                    createBaseVNode("h5", _hoisted_11$4, toDisplayString(unref(edit) ? "MODIFICA LA INFORMACIÓN" : "DILIGENCIA LA INFORMACIÓN"), 1)
                  ]),
                  _: 1
                }),
                createBaseVNode("div", _hoisted_12$4, [
                  createVNode(QForm, {
                    onSubmit: _cache[8] || (_cache[8] = withModifiers(($event) => unref(edit) ? putUser() : postUsers(), ["prevent", "stop"])),
                    novalidate: ""
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("div", null, [
                        createVNode(QInput, {
                          filled: "",
                          type: "text",
                          modelValue: unref(form).username,
                          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(form).username = $event),
                          label: "Nombre",
                          "lazy-rules": "",
                          rules: [
                            (val) => val && val.trim().length > 0 || "El campo es requerido"
                          ]
                        }, {
                          prepend: withCtx(() => [
                            _hoisted_13$4
                          ]),
                          _: 1
                        }, 8, ["modelValue", "rules"]),
                        createVNode(QInput, {
                          filled: "",
                          type: "number",
                          modelValue: unref(form).phone,
                          "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => unref(form).phone = $event),
                          label: "Teléfono",
                          "lazy-rules": "",
                          rules: [
                            (val) => val && val.trim().length > 0 || "El campo es requerido"
                          ]
                        }, {
                          prepend: withCtx(() => [
                            _hoisted_14$4
                          ]),
                          _: 1
                        }, 8, ["modelValue", "rules"]),
                        createVNode(QInput, {
                          filled: "",
                          type: "email",
                          modelValue: unref(form).email,
                          "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => unref(form).email = $event),
                          label: "Correo electrónico",
                          "lazy-rules": "",
                          rules: [
                            (val) => val && val.trim().length > 0 || "El campo es requerido"
                          ]
                        }, {
                          prepend: withCtx(() => [
                            _hoisted_15$4
                          ]),
                          _: 1
                        }, 8, ["modelValue", "rules"]),
                        createVNode(QSelect, {
                          filled: "",
                          type: "text",
                          modelValue: unref(form).role,
                          "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => unref(form).role = $event),
                          options: unref(optionsRole),
                          label: "Rol",
                          "option-label": (row) => row.label,
                          "option-value": (row) => row.value,
                          "lazy-rules": "",
                          rules: [
                            (val) => val && val.toString().trim().length > 0 || "El campo es requerido"
                          ]
                        }, {
                          prepend: withCtx(() => [
                            _hoisted_16$3
                          ]),
                          _: 1
                        }, 8, ["modelValue", "options", "option-label", "option-value", "rules"]),
                        unref(form).role.value == "USER" ? (openBlock(), createBlock(QSelect, {
                          key: 0,
                          filled: "",
                          modelValue: unref(form).farms,
                          "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => unref(form).farms = $event),
                          multiple: "",
                          options: unref(optionsFarm),
                          "options-dense": "",
                          "use-chips": "",
                          "use-input": "",
                          label: "Fincas",
                          "input-debounce": "0",
                          "lazy-rules": "",
                          rules: [
                            (val) => val && val.toString().trim().length > 0 || "El campo es requerido"
                          ]
                        }, {
                          prepend: withCtx(() => [
                            _hoisted_17$3
                          ]),
                          _: 1
                        }, 8, ["modelValue", "options", "rules"])) : createCommentVNode("", true),
                        createVNode(QInput, {
                          filled: "",
                          modelValue: unref(form).password,
                          "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => unref(form).password = $event),
                          label: "Contraseña",
                          type: unref(isPwd) ? "password" : "text",
                          "lazy-rules": "",
                          rules: [
                            (val) => val && val.trim().length > 5 || "Mínimo 5 caracteres"
                          ]
                        }, {
                          append: withCtx(() => [
                            createVNode(QIcon, {
                              name: unref(isPwd) ? "visibility_off" : "visibility",
                              class: "cursor-pointer",
                              onClick: _cache[6] || (_cache[6] = ($event) => isRef(isPwd) ? isPwd.value = !unref(isPwd) : isPwd = !unref(isPwd))
                            }, null, 8, ["name"])
                          ]),
                          _: 1
                        }, 8, ["modelValue", "type", "rules"]),
                        createBaseVNode("div", _hoisted_18$2, [
                          createVNode(QBtn, {
                            icon: "save_as",
                            label: "GUARDAR",
                            type: "submit",
                            class: "q-mt-md q-mb-sm q-mx-sm save_as",
                            loading: unref(loading)
                          }, {
                            loading: withCtx(() => [
                              createVNode(QSpinnerOval, {
                                color: "white",
                                size: "1em"
                              })
                            ]),
                            _: 1
                          }, 8, ["loading"]),
                          withDirectives((openBlock(), createBlock(QBtn, {
                            type: "button",
                            class: "q-mt-md q-mb-sm q-mx-sm",
                            to: ""
                          }, {
                            default: withCtx(() => [
                              _hoisted_19$2,
                              createTextVNode("CERRAR")
                            ]),
                            _: 1
                          })), [
                            [ClosePopup]
                          ])
                        ])
                      ])
                    ]),
                    _: 1
                  })
                ])
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["modelValue"])
      ]);
    };
  }
};
const Users = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["__scopeId", "data-v-0a9730ee"]]);
const _withScopeId$4 = (n2) => (pushScopeId("data-v-13da343c"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$5 = { class: "q-my-xl" };
const _hoisted_2$5 = { class: "row q-mt-lg" };
const _hoisted_3$5 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createBaseVNode("div", { class: "col-1" }, null, -1));
const _hoisted_4$5 = { class: "col-10" };
const _hoisted_5$4 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createBaseVNode("span", {
  class: "material-symbols-outlined q-mr-sm",
  style: { "font-size": "20px" }
}, " add_circle ", -1));
const _hoisted_6$3 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createBaseVNode("div", { class: "col-1" }, null, -1));
const _hoisted_7$3 = { class: "row q-mt-md justify-center" };
const _hoisted_8$3 = { class: "col-11 q-mb-lg" };
const _hoisted_9$3 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createBaseVNode("span", {
  class: "material-symbols-outlined",
  style: { "font-size": "18px" }
}, " check ", -1));
const _hoisted_10$3 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createBaseVNode("span", {
  class: "material-symbols-outlined",
  style: { "font-size": "18px" }
}, " close ", -1));
const _hoisted_11$3 = { class: "q-mt-sm q-mb-sm text-white text-center text-weight-bold" };
const _hoisted_12$3 = { class: "q-pa-md" };
const _hoisted_13$3 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createBaseVNode("span", { class: "material-symbols-outlined" }, " person ", -1));
const _hoisted_14$3 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createBaseVNode("span", { class: "material-symbols-outlined" }, " person ", -1));
const _hoisted_15$3 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createBaseVNode("span", { class: "material-symbols-outlined" }, " code ", -1));
const _hoisted_16$2 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createBaseVNode("span", { class: "material-symbols-outlined" }, " location_city ", -1));
const _hoisted_17$2 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createBaseVNode("span", { class: "material-symbols-outlined" }, " location_city ", -1));
const _hoisted_18$1 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createBaseVNode("span", { class: "material-symbols-outlined" }, " home ", -1));
const _hoisted_19$1 = { class: "justify-center flex" };
const _hoisted_20$1 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createBaseVNode("span", {
  class: "material-symbols-outlined q-mr-sm",
  style: { "font-size": "23px" }
}, " cancel ", -1));
const _sfc_main$5 = {
  __name: "Farms",
  setup(__props) {
    useQuasar();
    let index = ref();
    let prompt = ref(false);
    let edit = ref(false);
    let form = ref({
      name: "",
      owner: "",
      city: "",
      department: "",
      address: "",
      codeFarm: "",
      status: 0
    });
    let loading = ref(false);
    let columns = ref([
      {
        name: "owner",
        label: "PROPIETARIO",
        field: "owner",
        align: "center",
        sortable: true
      },
      {
        name: "name",
        label: "FINCA",
        field: "name",
        align: "center",
        sortable: true
      },
      {
        name: "city",
        label: "CIUDAD",
        field: "city",
        align: "center",
        sortable: true
      },
      {
        name: "department",
        label: "DEPARTAMENTO",
        field: "department",
        align: "center",
        sortable: true
      },
      {
        name: "address",
        label: "DIRECCIÓN",
        field: "address",
        align: "center",
        sortable: true
      },
      {
        name: "codeFarm",
        label: "código",
        field: "codeFarm",
        align: "center",
        sortable: true
      },
      {
        name: "status",
        label: "ESTADO",
        field: (row) => row.status == false ? "Inactivo" : "Activo",
        align: "center",
        sortable: true
      },
      { name: "options", label: "OPCIONES", align: "center" }
    ]);
    let rows = ref([]);
    onBeforeMount(async () => {
      await getFarms();
    });
    function showInfo(data) {
      index.value = data._id;
      form.value = data;
      edit.value = true;
      prompt.value = true;
      loading.value = false;
    }
    async function activeInactive(idFarm) {
      index.value = idFarm;
      const data = rows.value.find((item) => item._id == idFarm);
      console.log(data);
      data.status = !data.status;
      console.log(data);
      form.value = data;
      await putFarm();
    }
    const getFarms = async () => {
      const data = await getFarmsApi();
      if ((data == null ? void 0 : data.data.length) > 0) {
        console.log(data.data);
        rows.value = data.data;
      }
    };
    const clearForm = () => {
      form.value = {
        name: "",
        owner: "",
        city: "",
        department: "",
        address: "",
        codeFarm: "",
        status: true
      };
    };
    async function postFarm() {
      loading.value = true;
      await createFarmApi(form.value).then(async (res) => {
        console.log(res);
        if (res && res.status < 299) {
          prompt.value = false;
          edit.value = false;
          clearForm();
          await getFarms();
        }
      });
      loading.value = false;
    }
    async function putFarm() {
      loading.value = true;
      console.log(form.value);
      await updateFarmApi({ ...form.value, id: index.value }).then(async (res) => {
        if (res && res.status < 299) {
          clearForm();
          prompt.value = false;
          edit.value = false;
          await getFarms();
        }
      });
      loading.value = false;
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$5, [
        createVNode(_sfc_main$c, { title: "Fincas" }),
        createBaseVNode("div", _hoisted_2$5, [
          _hoisted_3$5,
          createBaseVNode("div", _hoisted_4$5, [
            createVNode(QBtn, {
              class: "bg-green-9 text-white",
              onClick: _cache[0] || (_cache[0] = ($event) => (clearForm(), isRef(prompt) ? prompt.value = true : prompt = true, isRef(edit) ? edit.value = false : edit = false))
            }, {
              default: withCtx(() => [
                _hoisted_5$4,
                createTextVNode(" Crear ")
              ]),
              _: 1
            })
          ]),
          _hoisted_6$3
        ]),
        createBaseVNode("div", _hoisted_7$3, [
          createBaseVNode("div", _hoisted_8$3, [
            createVNode(QTable, {
              flat: "",
              bordered: "",
              "no-data-label": "Sin registros aún",
              rows: unref(rows),
              columns: unref(columns),
              "row-key": "index",
              class: "q-mx-md my-sticky-header-table",
              "rows-per-page-label": "Numero de documentos",
              "rows-per-page-options": [10, 20, 30, 40, 50, 0],
              pagination: {
                rowsPerPage: 50
              }
            }, {
              "body-cell-status": withCtx((props2) => [
                createVNode(QTd, { props: props2 }, {
                  default: withCtx(() => [
                    createBaseVNode("div", null, [
                      props2.value === "Activo" ? (openBlock(), createBlock(QBadge, {
                        key: 0,
                        class: "bg-green-10"
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(props2.value), 1)
                        ]),
                        _: 2
                      }, 1024)) : (openBlock(), createBlock(QBadge, {
                        key: 1,
                        class: "bg-red"
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(props2.value), 1)
                        ]),
                        _: 2
                      }, 1024))
                    ])
                  ]),
                  _: 2
                }, 1032, ["props"])
              ]),
              "body-cell-options": withCtx((props2) => [
                createVNode(QTd, { props: props2 }, {
                  default: withCtx(() => [
                    createBaseVNode("div", null, [
                      createVNode(QBtn, {
                        round: "",
                        icon: "edit",
                        class: "q-mx-md",
                        size: "xs",
                        color: "green-10",
                        onClick: ($event) => showInfo(props2.row)
                      }, null, 8, ["onClick"]),
                      props2.row.status ? (openBlock(), createBlock(QBtn, {
                        key: 0,
                        round: "",
                        size: "xs",
                        color: "green-10",
                        onClick: ($event) => activeInactive(props2.row._id)
                      }, {
                        default: withCtx(() => [
                          _hoisted_9$3
                        ]),
                        _: 2
                      }, 1032, ["onClick"])) : (openBlock(), createBlock(QBtn, {
                        key: 1,
                        round: "",
                        size: "xs",
                        color: "red",
                        onClick: ($event) => activeInactive(props2.row._id)
                      }, {
                        default: withCtx(() => [
                          _hoisted_10$3
                        ]),
                        _: 2
                      }, 1032, ["onClick"]))
                    ])
                  ]),
                  _: 2
                }, 1032, ["props"])
              ]),
              _: 1
            }, 8, ["rows", "columns"])
          ])
        ]),
        createVNode(QDialog, {
          modelValue: unref(prompt),
          "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => isRef(prompt) ? prompt.value = $event : prompt = $event)
        }, {
          default: withCtx(() => [
            createVNode(QCard, null, {
              default: withCtx(() => [
                createVNode(QCardSection, { class: "bg-green-9 q-px-lg" }, {
                  default: withCtx(() => [
                    createBaseVNode("h5", _hoisted_11$3, toDisplayString(unref(edit) ? "MODIFICA LA INFORMACIÓN" : "DILIGENCIA LA INFORMACIÓN"), 1)
                  ]),
                  _: 1
                }),
                createBaseVNode("div", _hoisted_12$3, [
                  createVNode(QForm, {
                    onSubmit: _cache[7] || (_cache[7] = withModifiers(($event) => unref(edit) ? putFarm() : postFarm(), ["prevent", "stop"])),
                    novalidate: ""
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("div", null, [
                        createVNode(QInput, {
                          filled: "",
                          type: "text",
                          modelValue: unref(form).name,
                          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(form).name = $event),
                          label: "Nombre de la finca",
                          "lazy-rules": "",
                          rules: [
                            (val) => val && val.trim().length > 0 || "El campo es requerido"
                          ]
                        }, {
                          prepend: withCtx(() => [
                            _hoisted_13$3
                          ]),
                          _: 1
                        }, 8, ["modelValue", "rules"]),
                        createVNode(QInput, {
                          filled: "",
                          type: "text",
                          modelValue: unref(form).owner,
                          "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => unref(form).owner = $event),
                          label: "Nombre del propietario",
                          "lazy-rules": "",
                          rules: [
                            (val) => val && val.trim().length > 0 || "El campo es requerido"
                          ]
                        }, {
                          prepend: withCtx(() => [
                            _hoisted_14$3
                          ]),
                          _: 1
                        }, 8, ["modelValue", "rules"]),
                        createVNode(QInput, {
                          filled: "",
                          type: "text",
                          modelValue: unref(form).codeFarm,
                          "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => unref(form).codeFarm = $event),
                          label: "Código de la finca",
                          "lazy-rules": "",
                          rules: [
                            (val) => val && val.trim().length > 0 || "El campo es requerido"
                          ]
                        }, {
                          prepend: withCtx(() => [
                            _hoisted_15$3
                          ]),
                          _: 1
                        }, 8, ["modelValue", "rules"]),
                        createVNode(QInput, {
                          filled: "",
                          type: "text",
                          modelValue: unref(form).department,
                          "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => unref(form).department = $event),
                          label: "Departamento",
                          "lazy-rules": "",
                          rules: [
                            (val) => val && val.trim().length > 0 || "El campo es requerido"
                          ]
                        }, {
                          prepend: withCtx(() => [
                            _hoisted_16$2
                          ]),
                          _: 1
                        }, 8, ["modelValue", "rules"]),
                        createVNode(QInput, {
                          filled: "",
                          type: "email",
                          modelValue: unref(form).city,
                          "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => unref(form).city = $event),
                          label: "Ciudad",
                          "lazy-rules": "",
                          rules: [
                            (val) => val && val.trim().length > 0 || "El campo es requerido"
                          ]
                        }, {
                          prepend: withCtx(() => [
                            _hoisted_17$2
                          ]),
                          _: 1
                        }, 8, ["modelValue", "rules"]),
                        createVNode(QInput, {
                          filled: "",
                          type: "text",
                          modelValue: unref(form).address,
                          "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => unref(form).address = $event),
                          label: "Dirección",
                          "lazy-rules": "",
                          rules: [
                            (val) => val && val.trim().length > 0 || "El campo es requerido"
                          ]
                        }, {
                          prepend: withCtx(() => [
                            _hoisted_18$1
                          ]),
                          _: 1
                        }, 8, ["modelValue", "rules"]),
                        createBaseVNode("div", _hoisted_19$1, [
                          createVNode(QBtn, {
                            icon: "save_as",
                            label: "GUARDAR",
                            type: "submit",
                            class: "q-mt-md q-mb-sm q-mx-sm save_as",
                            loading: unref(loading)
                          }, {
                            loading: withCtx(() => [
                              createVNode(QSpinnerOval, {
                                color: "white",
                                size: "1em"
                              })
                            ]),
                            _: 1
                          }, 8, ["loading"]),
                          withDirectives((openBlock(), createBlock(QBtn, {
                            type: "button",
                            class: "q-mt-md q-mb-sm q-mx-sm",
                            to: ""
                          }, {
                            default: withCtx(() => [
                              _hoisted_20$1,
                              createTextVNode("CERRAR")
                            ]),
                            _: 1
                          })), [
                            [ClosePopup]
                          ])
                        ])
                      ])
                    ]),
                    _: 1
                  })
                ])
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["modelValue"])
      ]);
    };
  }
};
const Farms = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["__scopeId", "data-v-13da343c"]]);
const forgotPassword = async (email) => {
  try {
    const response = await axiosInstance.get(
      `/users/forgot-password/${email}`
    );
    return response.data;
  } catch (error) {
    console.error(error);
    const message = error.response.data.error || "Error al recuperar contraseña";
    notifyErrorRequest$1(message);
    throw new Error(message);
  }
};
const putNewPassword = async ({ email, password }, token2) => {
  try {
    const response = await axiosInstance.put(
      `/users/new-password`,
      {
        email,
        password
      },
      {
        headers: {
          token_temp: token2
        }
      }
    );
    return response.data;
  } catch (error) {
    console.error(error);
    const message = error.response.data.error || "Error al crear nueva contraseña";
    notifyErrorRequest$1(message);
    throw new Error(message);
  }
};
const _withScopeId$3 = (n2) => (pushScopeId("data-v-e3ffffe3"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$4 = { id: "login" };
const _hoisted_2$4 = { class: "login-card" };
const _hoisted_3$4 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("div", { class: "logo-container" }, [
  /* @__PURE__ */ createBaseVNode("img", {
    src: _imports_0,
    alt: "Logo",
    class: "logo"
  })
], -1));
const _hoisted_4$4 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("span", { id: "msg" }, "Por favor, digite su correo para el proceso de recuperación de contraseña.", -1));
const _hoisted_5$3 = { id: "contBtnLogin" };
const _sfc_main$4 = {
  __name: "ForgotPassword",
  setup(__props) {
    const loadBtn = ref(false);
    const email = ref("");
    const router2 = useRouter();
    const $q = useQuasar();
    async function onSubmit() {
      loadBtn.value = true;
      try {
        const response = await forgotPassword(email.value);
        console.log(response);
        $q.dialog({
          title: "Recuperación de contraseña enviada",
          message: response.msg,
          persistent: true
        }).onOk(() => {
          router2.push("/");
        });
      } catch (error) {
        console.log(error);
      } finally {
        loadBtn.value = false;
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$4, [
        createBaseVNode("div", _hoisted_2$4, [
          _hoisted_3$4,
          _hoisted_4$4,
          createVNode(QForm, {
            onSubmit,
            class: "q-gutter-md"
          }, {
            default: withCtx(() => [
              createVNode(QInput, {
                color: "white",
                "label-color": "dark",
                outlined: "",
                type: "email",
                modelValue: email.value,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => email.value = $event),
                label: "Correo electrónico *",
                "lazy-rules": "",
                rules: [
                  (val) => val && val.length > 0 || "Correo electrónico requerido",
                  (val) => /.+@.+\..+/.test(val) || "Correo electrónico inválido"
                ],
                "bg-color": "white"
              }, null, 8, ["modelValue", "rules"]),
              createBaseVNode("div", _hoisted_5$3, [
                createVNode(QBtn, {
                  label: "Recuperar contraseña",
                  type: "submit",
                  color: "primary",
                  loading: loadBtn.value
                }, null, 8, ["loading"])
              ])
            ]),
            _: 1
          })
        ])
      ]);
    };
  }
};
const ForgotPassword = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["__scopeId", "data-v-e3ffffe3"]]);
const _withScopeId$2 = (n2) => (pushScopeId("data-v-2a074ea5"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$3 = { id: "login" };
const _hoisted_2$3 = { class: "login-card" };
const _hoisted_3$3 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", { class: "logo-container" }, [
  /* @__PURE__ */ createBaseVNode("img", {
    src: _imports_0,
    alt: "Logo",
    class: "logo"
  })
], -1));
const _hoisted_4$3 = { id: "contBtnLogin" };
const _sfc_main$3 = {
  __name: "NewPassword",
  setup(__props) {
    const router2 = useRouter();
    const route = useRoute();
    const $q = useQuasar();
    const form = ref({
      email: localStorage.getItem("email"),
      password: ""
    });
    const confirmPassword = ref("");
    const loadBtn = ref(false);
    async function onSubmit() {
      try {
        const token2 = route.params.token;
        loadBtn.value = true;
        const response = await putNewPassword(form.value, token2);
        console.log(response);
        $q.dialog({
          title: "¡¡Contraseña actualizada con éxito!!",
          message: "Por favor inicie sesión",
          persistent: true
        }).onOk(() => {
          localStorage.removeItem("token_temp");
          router2.push("/");
        });
      } catch (error) {
        console.log(error);
      } finally {
        loadBtn.value = false;
      }
    }
    const seePassword = ref(false);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$3, [
        createBaseVNode("div", _hoisted_2$3, [
          _hoisted_3$3,
          createVNode(QForm, {
            onSubmit,
            class: "q-gutter-md"
          }, {
            default: withCtx(() => [
              createVNode(QInput, {
                color: "white",
                "label-color": "dark",
                outlined: "",
                type: seePassword.value ? "text" : "password",
                modelValue: form.value.password,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => form.value.password = $event),
                label: "Contraseña *",
                "lazy-rules": "",
                rules: [
                  (val) => val !== null && val !== "" || "Contraseña requerida",
                  (val) => val.length > 5 || "La contraseña debe tener al menos 6 caracteres",
                  (val) => val.length < 20 || "La contraseña no debe tener más de 20 caracteres",
                  (val) => /[a-z]/.test(val) || "La contraseña debe tener al menos una letra minúscula",
                  (val) => /[A-Z]/.test(val) || "La contraseña debe tener al menos una letra mayúscula",
                  (val) => /\d/.test(val) || "La contraseña debe tener al menos un número",
                  (val) => /\W/.test(val) || "La contraseña debe tener al menos un caracter especial"
                ],
                "bg-color": "white"
              }, null, 8, ["type", "modelValue", "rules"]),
              createVNode(QInput, {
                color: "white",
                "label-color": "dark",
                outlined: "",
                type: seePassword.value ? "text" : "password",
                modelValue: confirmPassword.value,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => confirmPassword.value = $event),
                label: "Confimar contraseña *",
                "lazy-rules": "",
                rules: [
                  (val) => val !== null && val !== "" || "Confirme su contraseña",
                  (val) => val === form.value.password || "Las contraseñas no coinciden"
                ],
                "bg-color": "white"
              }, null, 8, ["type", "modelValue", "rules"]),
              createVNode(QCheckbox, {
                size: "xs",
                dark: "",
                modelValue: seePassword.value,
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => seePassword.value = $event),
                label: "Mostrar contraseña",
                id: "checkbox"
              }, null, 8, ["modelValue"]),
              createBaseVNode("div", _hoisted_4$3, [
                createVNode(QBtn, {
                  label: "Cambiar contraseña",
                  type: "submit",
                  color: "primary",
                  loading: loadBtn.value
                }, null, 8, ["loading"])
              ])
            ]),
            _: 1
          })
        ])
      ]);
    };
  }
};
const NewPassword = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__scopeId", "data-v-2a074ea5"]]);
let id = 0;
const useTabEmits = ["click", "keydown"];
const useTabProps = {
  icon: String,
  label: [Number, String],
  alert: [Boolean, String],
  alertIcon: String,
  name: {
    type: [Number, String],
    default: () => `t_${id++}`
  },
  noCaps: Boolean,
  tabindex: [String, Number],
  disable: Boolean,
  contentClass: String,
  ripple: {
    type: [Boolean, Object],
    default: true
  }
};
function useTab(props2, slots, emit2, routeData) {
  const $tabs = inject(tabsKey, emptyRenderFn);
  if ($tabs === emptyRenderFn) {
    console.error("QTab/QRouteTab component needs to be child of QTabs");
    return emptyRenderFn;
  }
  const { proxy } = getCurrentInstance();
  const blurTargetRef = ref(null);
  const rootRef = ref(null);
  const tabIndicatorRef = ref(null);
  const ripple = computed(() => props2.disable === true || props2.ripple === false ? false : Object.assign(
    { keyCodes: [13, 32], early: true },
    props2.ripple === true ? {} : props2.ripple
  ));
  const isActive = computed(() => $tabs.currentModel.value === props2.name);
  const classes = computed(
    () => "q-tab relative-position self-stretch flex flex-center text-center" + (isActive.value === true ? " q-tab--active" + ($tabs.tabProps.value.activeClass ? " " + $tabs.tabProps.value.activeClass : "") + ($tabs.tabProps.value.activeColor ? ` text-${$tabs.tabProps.value.activeColor}` : "") + ($tabs.tabProps.value.activeBgColor ? ` bg-${$tabs.tabProps.value.activeBgColor}` : "") : " q-tab--inactive") + (props2.icon && props2.label && $tabs.tabProps.value.inlineLabel === false ? " q-tab--full" : "") + (props2.noCaps === true || $tabs.tabProps.value.noCaps === true ? " q-tab--no-caps" : "") + (props2.disable === true ? " disabled" : " q-focusable q-hoverable cursor-pointer")
  );
  const innerClass = computed(
    () => "q-tab__content self-stretch flex-center relative-position q-anchor--skip non-selectable " + ($tabs.tabProps.value.inlineLabel === true ? "row no-wrap q-tab__content--inline" : "column") + (props2.contentClass !== void 0 ? ` ${props2.contentClass}` : "")
  );
  const tabIndex = computed(() => props2.disable === true || $tabs.hasFocus.value === true || isActive.value === false && $tabs.hasActiveTab.value === true ? -1 : props2.tabindex || 0);
  function onClick(e2, keyboard) {
    if (keyboard !== true && blurTargetRef.value !== null) {
      blurTargetRef.value.focus();
    }
    if (props2.disable === true) {
      return;
    }
    {
      $tabs.updateModel({ name: props2.name });
      emit2("click", e2);
      return;
    }
  }
  function onKeydown2(e2) {
    if (isKeyCode(e2, [13, 32])) {
      onClick(e2, true);
    } else if (shouldIgnoreKey(e2) !== true && e2.keyCode >= 35 && e2.keyCode <= 40 && e2.altKey !== true && e2.metaKey !== true) {
      $tabs.onKbdNavigate(e2.keyCode, proxy.$el) === true && stopAndPrevent(e2);
    }
    emit2("keydown", e2);
  }
  function getContent() {
    const narrow = $tabs.tabProps.value.narrowIndicator, content2 = [], indicator = h$1("div", {
      ref: tabIndicatorRef,
      class: [
        "q-tab__indicator",
        $tabs.tabProps.value.indicatorClass
      ]
    });
    props2.icon !== void 0 && content2.push(
      h$1(QIcon, {
        class: "q-tab__icon",
        name: props2.icon
      })
    );
    props2.label !== void 0 && content2.push(
      h$1("div", { class: "q-tab__label" }, props2.label)
    );
    props2.alert !== false && content2.push(
      props2.alertIcon !== void 0 ? h$1(QIcon, {
        class: "q-tab__alert-icon",
        color: props2.alert !== true ? props2.alert : void 0,
        name: props2.alertIcon
      }) : h$1("div", {
        class: "q-tab__alert" + (props2.alert !== true ? ` text-${props2.alert}` : "")
      })
    );
    narrow === true && content2.push(indicator);
    const node = [
      h$1("div", { class: "q-focus-helper", tabindex: -1, ref: blurTargetRef }),
      h$1("div", { class: innerClass.value }, hMergeSlot(slots.default, content2))
    ];
    narrow === false && node.push(indicator);
    return node;
  }
  const tabData = {
    name: computed(() => props2.name),
    rootRef,
    tabIndicatorRef,
    routeData
  };
  onBeforeUnmount(() => {
    $tabs.unregisterTab(tabData);
  });
  onMounted(() => {
    $tabs.registerTab(tabData);
  });
  function renderTab(tag, customData) {
    const data = {
      ref: rootRef,
      class: classes.value,
      tabindex: tabIndex.value,
      role: "tab",
      "aria-selected": isActive.value === true ? "true" : "false",
      "aria-disabled": props2.disable === true ? "true" : void 0,
      onClick,
      onKeydown: onKeydown2,
      ...customData
    };
    return withDirectives(
      h$1(tag, data, getContent()),
      [[Ripple, ripple.value]]
    );
  }
  return { renderTab, $tabs };
}
const QTab = createComponent({
  name: "QTab",
  props: useTabProps,
  emits: useTabEmits,
  setup(props2, { slots, emit: emit2 }) {
    const { renderTab } = useTab(props2, slots, emit2);
    return () => renderTab("div");
  }
});
function getIndicatorClass(color2, top, vertical) {
  const pos = vertical === true ? ["left", "right"] : ["top", "bottom"];
  return `absolute-${top === true ? pos[0] : pos[1]}${color2 ? ` text-${color2}` : ""}`;
}
const alignValues = ["left", "center", "right", "justify"];
const QTabs = createComponent({
  name: "QTabs",
  props: {
    modelValue: [Number, String],
    align: {
      type: String,
      default: "center",
      validator: (v2) => alignValues.includes(v2)
    },
    breakpoint: {
      type: [String, Number],
      default: 600
    },
    vertical: Boolean,
    shrink: Boolean,
    stretch: Boolean,
    activeClass: String,
    activeColor: String,
    activeBgColor: String,
    indicatorColor: String,
    leftIcon: String,
    rightIcon: String,
    outsideArrows: Boolean,
    mobileArrows: Boolean,
    switchIndicator: Boolean,
    narrowIndicator: Boolean,
    inlineLabel: Boolean,
    noCaps: Boolean,
    dense: Boolean,
    contentClass: String,
    "onUpdate:modelValue": [Function, Array]
  },
  setup(props2, { slots, emit: emit2 }) {
    const { proxy } = getCurrentInstance();
    const { $q } = proxy;
    const { registerTick: registerScrollTick } = useTick();
    const { registerTick: registerUpdateArrowsTick } = useTick();
    const { registerTick: registerAnimateTick } = useTick();
    const { registerTimeout: registerFocusTimeout, removeTimeout: removeFocusTimeout } = useTimeout();
    const { registerTimeout: registerScrollToTabTimeout, removeTimeout: removeScrollToTabTimeout } = useTimeout();
    const rootRef = ref(null);
    const contentRef = ref(null);
    const currentModel = ref(props2.modelValue);
    const scrollable = ref(false);
    const leftArrow = ref(true);
    const rightArrow = ref(false);
    const justify = ref(false);
    const tabDataList = [];
    const tabDataListLen = ref(0);
    const hasFocus = ref(false);
    let animateTimer = null, scrollTimer = null, unwatchRoute;
    const tabProps = computed(() => ({
      activeClass: props2.activeClass,
      activeColor: props2.activeColor,
      activeBgColor: props2.activeBgColor,
      indicatorClass: getIndicatorClass(
        props2.indicatorColor,
        props2.switchIndicator,
        props2.vertical
      ),
      narrowIndicator: props2.narrowIndicator,
      inlineLabel: props2.inlineLabel,
      noCaps: props2.noCaps
    }));
    const hasActiveTab = computed(() => {
      const len = tabDataListLen.value;
      const val = currentModel.value;
      for (let i = 0; i < len; i++) {
        if (tabDataList[i].name.value === val) {
          return true;
        }
      }
      return false;
    });
    const alignClass = computed(() => {
      const align = scrollable.value === true ? "left" : justify.value === true ? "justify" : props2.align;
      return `q-tabs__content--align-${align}`;
    });
    const classes = computed(
      () => `q-tabs row no-wrap items-center q-tabs--${scrollable.value === true ? "" : "not-"}scrollable q-tabs--${props2.vertical === true ? "vertical" : "horizontal"} q-tabs__arrows--${props2.outsideArrows === true ? "outside" : "inside"} q-tabs--mobile-with${props2.mobileArrows === true ? "" : "out"}-arrows` + (props2.dense === true ? " q-tabs--dense" : "") + (props2.shrink === true ? " col-shrink" : "") + (props2.stretch === true ? " self-stretch" : "")
    );
    const innerClass = computed(
      () => "q-tabs__content scroll--mobile row no-wrap items-center self-stretch hide-scrollbar relative-position " + alignClass.value + (props2.contentClass !== void 0 ? ` ${props2.contentClass}` : "")
    );
    const domProps = computed(() => props2.vertical === true ? { container: "height", content: "offsetHeight", scroll: "scrollHeight" } : { container: "width", content: "offsetWidth", scroll: "scrollWidth" });
    const isRTL = computed(() => props2.vertical !== true && $q.lang.rtl === true);
    const rtlPosCorrection = computed(() => rtlHasScrollBug === false && isRTL.value === true);
    watch(isRTL, updateArrows);
    watch(() => props2.modelValue, (name) => {
      updateModel({ name, setCurrent: true, skipEmit: true });
    });
    watch(() => props2.outsideArrows, recalculateScroll);
    function updateModel({ name, setCurrent, skipEmit }) {
      if (currentModel.value !== name) {
        if (skipEmit !== true && props2["onUpdate:modelValue"] !== void 0) {
          emit2("update:modelValue", name);
        }
        if (setCurrent === true || props2["onUpdate:modelValue"] === void 0) {
          animate(currentModel.value, name);
          currentModel.value = name;
        }
      }
    }
    function recalculateScroll() {
      registerScrollTick(() => {
        updateContainer({
          width: rootRef.value.offsetWidth,
          height: rootRef.value.offsetHeight
        });
      });
    }
    function updateContainer(domSize) {
      if (domProps.value === void 0 || contentRef.value === null) return;
      const size2 = domSize[domProps.value.container], scrollSize = Math.min(
        contentRef.value[domProps.value.scroll],
        Array.prototype.reduce.call(
          contentRef.value.children,
          (acc, el) => acc + (el[domProps.value.content] || 0),
          0
        )
      ), scroll = size2 > 0 && scrollSize > size2;
      scrollable.value = scroll;
      scroll === true && registerUpdateArrowsTick(updateArrows);
      justify.value = size2 < parseInt(props2.breakpoint, 10);
    }
    function animate(oldName, newName) {
      const oldTab = oldName !== void 0 && oldName !== null && oldName !== "" ? tabDataList.find((tab) => tab.name.value === oldName) : null, newTab = newName !== void 0 && newName !== null && newName !== "" ? tabDataList.find((tab) => tab.name.value === newName) : null;
      if (oldTab && newTab) {
        const oldEl = oldTab.tabIndicatorRef.value, newEl = newTab.tabIndicatorRef.value;
        if (animateTimer !== null) {
          clearTimeout(animateTimer);
          animateTimer = null;
        }
        oldEl.style.transition = "none";
        oldEl.style.transform = "none";
        newEl.style.transition = "none";
        newEl.style.transform = "none";
        const oldPos = oldEl.getBoundingClientRect(), newPos = newEl.getBoundingClientRect();
        newEl.style.transform = props2.vertical === true ? `translate3d(0,${oldPos.top - newPos.top}px,0) scale3d(1,${newPos.height ? oldPos.height / newPos.height : 1},1)` : `translate3d(${oldPos.left - newPos.left}px,0,0) scale3d(${newPos.width ? oldPos.width / newPos.width : 1},1,1)`;
        registerAnimateTick(() => {
          animateTimer = setTimeout(() => {
            animateTimer = null;
            newEl.style.transition = "transform .25s cubic-bezier(.4, 0, .2, 1)";
            newEl.style.transform = "none";
          }, 70);
        });
      }
      if (newTab && scrollable.value === true) {
        scrollToTabEl(newTab.rootRef.value);
      }
    }
    function scrollToTabEl(el) {
      const { left, width: width2, top, height } = contentRef.value.getBoundingClientRect(), newPos = el.getBoundingClientRect();
      let offset = props2.vertical === true ? newPos.top - top : newPos.left - left;
      if (offset < 0) {
        contentRef.value[props2.vertical === true ? "scrollTop" : "scrollLeft"] += Math.floor(offset);
        updateArrows();
        return;
      }
      offset += props2.vertical === true ? newPos.height - height : newPos.width - width2;
      if (offset > 0) {
        contentRef.value[props2.vertical === true ? "scrollTop" : "scrollLeft"] += Math.ceil(offset);
        updateArrows();
      }
    }
    function updateArrows() {
      const content2 = contentRef.value;
      if (content2 === null) return;
      const rect = content2.getBoundingClientRect(), pos = props2.vertical === true ? content2.scrollTop : Math.abs(content2.scrollLeft);
      if (isRTL.value === true) {
        leftArrow.value = Math.ceil(pos + rect.width) < content2.scrollWidth - 1;
        rightArrow.value = pos > 0;
      } else {
        leftArrow.value = pos > 0;
        rightArrow.value = props2.vertical === true ? Math.ceil(pos + rect.height) < content2.scrollHeight : Math.ceil(pos + rect.width) < content2.scrollWidth;
      }
    }
    function animScrollTo(value2) {
      scrollTimer !== null && clearInterval(scrollTimer);
      scrollTimer = setInterval(() => {
        if (scrollTowards(value2) === true) {
          stopAnimScroll();
        }
      }, 5);
    }
    function scrollToStart() {
      animScrollTo(rtlPosCorrection.value === true ? Number.MAX_SAFE_INTEGER : 0);
    }
    function scrollToEnd() {
      animScrollTo(rtlPosCorrection.value === true ? 0 : Number.MAX_SAFE_INTEGER);
    }
    function stopAnimScroll() {
      if (scrollTimer !== null) {
        clearInterval(scrollTimer);
        scrollTimer = null;
      }
    }
    function onKbdNavigate(keyCode, fromEl) {
      const tabs = Array.prototype.filter.call(
        contentRef.value.children,
        (el) => el === fromEl || el.matches && el.matches(".q-tab.q-focusable") === true
      );
      const len = tabs.length;
      if (len === 0) return;
      if (keyCode === 36) {
        scrollToTabEl(tabs[0]);
        tabs[0].focus();
        return true;
      }
      if (keyCode === 35) {
        scrollToTabEl(tabs[len - 1]);
        tabs[len - 1].focus();
        return true;
      }
      const dirPrev = keyCode === (props2.vertical === true ? 38 : 37);
      const dirNext = keyCode === (props2.vertical === true ? 40 : 39);
      const dir = dirPrev === true ? -1 : dirNext === true ? 1 : void 0;
      if (dir !== void 0) {
        const rtlDir = isRTL.value === true ? -1 : 1;
        const index = tabs.indexOf(fromEl) + dir * rtlDir;
        if (index >= 0 && index < len) {
          scrollToTabEl(tabs[index]);
          tabs[index].focus({ preventScroll: true });
        }
        return true;
      }
    }
    const posFn = computed(() => rtlPosCorrection.value === true ? { get: (content2) => Math.abs(content2.scrollLeft), set: (content2, pos) => {
      content2.scrollLeft = -pos;
    } } : props2.vertical === true ? { get: (content2) => content2.scrollTop, set: (content2, pos) => {
      content2.scrollTop = pos;
    } } : { get: (content2) => content2.scrollLeft, set: (content2, pos) => {
      content2.scrollLeft = pos;
    } });
    function scrollTowards(value2) {
      const content2 = contentRef.value, { get: get2, set: set2 } = posFn.value;
      let done = false, pos = get2(content2);
      const direction2 = value2 < pos ? -1 : 1;
      pos += direction2 * 5;
      if (pos < 0) {
        done = true;
        pos = 0;
      } else if (direction2 === -1 && pos <= value2 || direction2 === 1 && pos >= value2) {
        done = true;
        pos = value2;
      }
      set2(content2, pos);
      updateArrows();
      return done;
    }
    function hasQueryIncluded(targetQuery, matchingQuery) {
      for (const key in targetQuery) {
        if (targetQuery[key] !== matchingQuery[key]) {
          return false;
        }
      }
      return true;
    }
    function updateActiveRoute() {
      let name = null, bestScore = { matchedLen: 0, queryDiff: 9999, hrefLen: 0 };
      const list = tabDataList.filter((tab) => tab.routeData !== void 0 && tab.routeData.hasRouterLink.value === true);
      const { hash: currentHash, query: currentQuery } = proxy.$route;
      const currentQueryLen = Object.keys(currentQuery).length;
      for (const tab of list) {
        const exact = tab.routeData.exact.value === true;
        if (tab.routeData[exact === true ? "linkIsExactActive" : "linkIsActive"].value !== true) {
          continue;
        }
        const { hash, query, matched, href: href2 } = tab.routeData.resolvedLink.value;
        const queryLen = Object.keys(query).length;
        if (exact === true) {
          if (hash !== currentHash) {
            continue;
          }
          if (queryLen !== currentQueryLen || hasQueryIncluded(currentQuery, query) === false) {
            continue;
          }
          name = tab.name.value;
          break;
        }
        if (hash !== "" && hash !== currentHash) {
          continue;
        }
        if (queryLen !== 0 && hasQueryIncluded(query, currentQuery) === false) {
          continue;
        }
        const newScore = {
          matchedLen: matched.length,
          queryDiff: currentQueryLen - queryLen,
          hrefLen: href2.length - hash.length
        };
        if (newScore.matchedLen > bestScore.matchedLen) {
          name = tab.name.value;
          bestScore = newScore;
          continue;
        } else if (newScore.matchedLen !== bestScore.matchedLen) {
          continue;
        }
        if (newScore.queryDiff < bestScore.queryDiff) {
          name = tab.name.value;
          bestScore = newScore;
        } else if (newScore.queryDiff !== bestScore.queryDiff) {
          continue;
        }
        if (newScore.hrefLen > bestScore.hrefLen) {
          name = tab.name.value;
          bestScore = newScore;
        }
      }
      if (name === null && tabDataList.some((tab) => tab.routeData === void 0 && tab.name.value === currentModel.value) === true) {
        return;
      }
      updateModel({ name, setCurrent: true });
    }
    function onFocusin(e2) {
      removeFocusTimeout();
      if (hasFocus.value !== true && rootRef.value !== null && e2.target && typeof e2.target.closest === "function") {
        const tab = e2.target.closest(".q-tab");
        if (tab && rootRef.value.contains(tab) === true) {
          hasFocus.value = true;
          scrollable.value === true && scrollToTabEl(tab);
        }
      }
    }
    function onFocusout() {
      registerFocusTimeout(() => {
        hasFocus.value = false;
      }, 30);
    }
    function verifyRouteModel() {
      if ($tabs.avoidRouteWatcher === false) {
        registerScrollToTabTimeout(updateActiveRoute);
      } else {
        removeScrollToTabTimeout();
      }
    }
    function watchRoute() {
      if (unwatchRoute === void 0) {
        const unwatch = watch(() => proxy.$route.fullPath, verifyRouteModel);
        unwatchRoute = () => {
          unwatch();
          unwatchRoute = void 0;
        };
      }
    }
    function registerTab(tabData) {
      tabDataList.push(tabData);
      tabDataListLen.value++;
      recalculateScroll();
      if (tabData.routeData === void 0 || proxy.$route === void 0) {
        registerScrollToTabTimeout(() => {
          if (scrollable.value === true) {
            const value2 = currentModel.value;
            const newTab = value2 !== void 0 && value2 !== null && value2 !== "" ? tabDataList.find((tab) => tab.name.value === value2) : null;
            newTab && scrollToTabEl(newTab.rootRef.value);
          }
        });
      } else {
        watchRoute();
        if (tabData.routeData.hasRouterLink.value === true) {
          verifyRouteModel();
        }
      }
    }
    function unregisterTab(tabData) {
      tabDataList.splice(tabDataList.indexOf(tabData), 1);
      tabDataListLen.value--;
      recalculateScroll();
      if (unwatchRoute !== void 0 && tabData.routeData !== void 0) {
        if (tabDataList.every((tab) => tab.routeData === void 0) === true) {
          unwatchRoute();
        }
        verifyRouteModel();
      }
    }
    const $tabs = {
      currentModel,
      tabProps,
      hasFocus,
      hasActiveTab,
      registerTab,
      unregisterTab,
      verifyRouteModel,
      updateModel,
      onKbdNavigate,
      avoidRouteWatcher: false
      // false | string (uid)
    };
    provide(tabsKey, $tabs);
    function cleanup() {
      animateTimer !== null && clearTimeout(animateTimer);
      stopAnimScroll();
      unwatchRoute !== void 0 && unwatchRoute();
    }
    let hadRouteWatcher;
    onBeforeUnmount(cleanup);
    onDeactivated(() => {
      hadRouteWatcher = unwatchRoute !== void 0;
      cleanup();
    });
    onActivated(() => {
      hadRouteWatcher === true && watchRoute();
      recalculateScroll();
    });
    return () => {
      return h$1("div", {
        ref: rootRef,
        class: classes.value,
        role: "tablist",
        onFocusin,
        onFocusout
      }, [
        h$1(QResizeObserver, { onResize: updateContainer }),
        h$1("div", {
          ref: contentRef,
          class: innerClass.value,
          onScroll: updateArrows
        }, hSlot(slots.default)),
        h$1(QIcon, {
          class: "q-tabs__arrow q-tabs__arrow--left absolute q-tab__icon" + (leftArrow.value === true ? "" : " q-tabs__arrow--faded"),
          name: props2.leftIcon || $q.iconSet.tabs[props2.vertical === true ? "up" : "left"],
          onMousedownPassive: scrollToStart,
          onTouchstartPassive: scrollToStart,
          onMouseupPassive: stopAnimScroll,
          onMouseleavePassive: stopAnimScroll,
          onTouchendPassive: stopAnimScroll
        }),
        h$1(QIcon, {
          class: "q-tabs__arrow q-tabs__arrow--right absolute q-tab__icon" + (rightArrow.value === true ? "" : " q-tabs__arrow--faded"),
          name: props2.rightIcon || $q.iconSet.tabs[props2.vertical === true ? "down" : "right"],
          onMousedownPassive: scrollToEnd,
          onTouchstartPassive: scrollToEnd,
          onMouseupPassive: stopAnimScroll,
          onMouseleavePassive: stopAnimScroll,
          onTouchendPassive: stopAnimScroll
        })
      ]);
    };
  }
});
const QTooltip = createComponent({
  name: "QTooltip",
  inheritAttrs: false,
  props: {
    ...useAnchorStaticProps,
    ...useModelToggleProps,
    ...useTransitionProps,
    maxHeight: {
      type: String,
      default: null
    },
    maxWidth: {
      type: String,
      default: null
    },
    transitionShow: {
      ...useTransitionProps.transitionShow,
      default: "jump-down"
    },
    transitionHide: {
      ...useTransitionProps.transitionHide,
      default: "jump-up"
    },
    anchor: {
      type: String,
      default: "bottom middle",
      validator: validatePosition
    },
    self: {
      type: String,
      default: "top middle",
      validator: validatePosition
    },
    offset: {
      type: Array,
      default: () => [14, 14],
      validator: validateOffset
    },
    scrollTarget: scrollTargetProp,
    delay: {
      type: Number,
      default: 0
    },
    hideDelay: {
      type: Number,
      default: 0
    },
    persistent: Boolean
  },
  emits: [
    ...useModelToggleEmits
  ],
  setup(props2, { slots, emit: emit2, attrs }) {
    let unwatchPosition, observer;
    const vm2 = getCurrentInstance();
    const { proxy: { $q } } = vm2;
    const innerRef = ref(null);
    const showing = ref(false);
    const anchorOrigin = computed(() => parsePosition(props2.anchor, $q.lang.rtl));
    const selfOrigin = computed(() => parsePosition(props2.self, $q.lang.rtl));
    const hideOnRouteChange = computed(() => props2.persistent !== true);
    const { registerTick, removeTick } = useTick();
    const { registerTimeout } = useTimeout();
    const { transitionProps, transitionStyle } = useTransition(props2);
    const { localScrollTarget, changeScrollEvent, unconfigureScrollTarget } = useScrollTarget(props2, configureScrollTarget);
    const { anchorEl, canShow, anchorEvents } = useAnchor({ showing, configureAnchorEl });
    const { show, hide } = useModelToggle({
      showing,
      canShow,
      handleShow,
      handleHide,
      hideOnRouteChange,
      processOnMount: true
    });
    Object.assign(anchorEvents, { delayShow, delayHide });
    const { showPortal, hidePortal, renderPortal } = usePortal(vm2, innerRef, renderPortalContent, "tooltip");
    if ($q.platform.is.mobile === true) {
      const clickOutsideProps = {
        anchorEl,
        innerRef,
        onClickOutside(e2) {
          hide(e2);
          if (e2.target.classList.contains("q-dialog__backdrop")) {
            stopAndPrevent(e2);
          }
          return true;
        }
      };
      const hasClickOutside = computed(
        () => (
          // it doesn't has external model
          // (null is the default value)
          props2.modelValue === null && props2.persistent !== true && showing.value === true
        )
      );
      watch(hasClickOutside, (val) => {
        const fn = val === true ? addClickOutside : removeClickOutside;
        fn(clickOutsideProps);
      });
      onBeforeUnmount(() => {
        removeClickOutside(clickOutsideProps);
      });
    }
    function handleShow(evt) {
      showPortal();
      registerTick(() => {
        observer = new MutationObserver(() => updatePosition());
        observer.observe(innerRef.value, { attributes: false, childList: true, characterData: true, subtree: true });
        updatePosition();
        configureScrollTarget();
      });
      if (unwatchPosition === void 0) {
        unwatchPosition = watch(
          () => $q.screen.width + "|" + $q.screen.height + "|" + props2.self + "|" + props2.anchor + "|" + $q.lang.rtl,
          updatePosition
        );
      }
      registerTimeout(() => {
        showPortal(true);
        emit2("show", evt);
      }, props2.transitionDuration);
    }
    function handleHide(evt) {
      removeTick();
      hidePortal();
      anchorCleanup();
      registerTimeout(() => {
        hidePortal(true);
        emit2("hide", evt);
      }, props2.transitionDuration);
    }
    function anchorCleanup() {
      if (observer !== void 0) {
        observer.disconnect();
        observer = void 0;
      }
      if (unwatchPosition !== void 0) {
        unwatchPosition();
        unwatchPosition = void 0;
      }
      unconfigureScrollTarget();
      cleanEvt(anchorEvents, "tooltipTemp");
    }
    function updatePosition() {
      setPosition({
        targetEl: innerRef.value,
        offset: props2.offset,
        anchorEl: anchorEl.value,
        anchorOrigin: anchorOrigin.value,
        selfOrigin: selfOrigin.value,
        maxHeight: props2.maxHeight,
        maxWidth: props2.maxWidth
      });
    }
    function delayShow(evt) {
      if ($q.platform.is.mobile === true) {
        clearSelection();
        document.body.classList.add("non-selectable");
        const target2 = anchorEl.value;
        const evts = ["touchmove", "touchcancel", "touchend", "click"].map((e2) => [target2, e2, "delayHide", "passiveCapture"]);
        addEvt(anchorEvents, "tooltipTemp", evts);
      }
      registerTimeout(() => {
        show(evt);
      }, props2.delay);
    }
    function delayHide(evt) {
      if ($q.platform.is.mobile === true) {
        cleanEvt(anchorEvents, "tooltipTemp");
        clearSelection();
        setTimeout(() => {
          document.body.classList.remove("non-selectable");
        }, 10);
      }
      registerTimeout(() => {
        hide(evt);
      }, props2.hideDelay);
    }
    function configureAnchorEl() {
      if (props2.noParentEvent === true || anchorEl.value === null) return;
      const evts = $q.platform.is.mobile === true ? [
        [anchorEl.value, "touchstart", "delayShow", "passive"]
      ] : [
        [anchorEl.value, "mouseenter", "delayShow", "passive"],
        [anchorEl.value, "mouseleave", "delayHide", "passive"]
      ];
      addEvt(anchorEvents, "anchor", evts);
    }
    function configureScrollTarget() {
      if (anchorEl.value !== null || props2.scrollTarget !== void 0) {
        localScrollTarget.value = getScrollTarget(anchorEl.value, props2.scrollTarget);
        const fn = props2.noParentEvent === true ? updatePosition : hide;
        changeScrollEvent(localScrollTarget.value, fn);
      }
    }
    function getTooltipContent() {
      return showing.value === true ? h$1("div", {
        ...attrs,
        ref: innerRef,
        class: [
          "q-tooltip q-tooltip--style q-position-engine no-pointer-events",
          attrs.class
        ],
        style: [
          attrs.style,
          transitionStyle.value
        ],
        role: "tooltip"
      }, hSlot(slots.default)) : null;
    }
    function renderPortalContent() {
      return h$1(Transition, transitionProps.value, getTooltipContent);
    }
    onBeforeUnmount(anchorCleanup);
    Object.assign(vm2.proxy, { updatePosition });
    return renderPortal;
  }
});
function parseArg(arg) {
  const data = [0.06, 6, 50];
  if (typeof arg === "string" && arg.length) {
    arg.split(":").forEach((val, index) => {
      const v2 = parseFloat(val);
      v2 && (data[index] = v2);
    });
  }
  return data;
}
const TouchSwipe = createDirective(
  {
    name: "touch-swipe",
    beforeMount(el, { value: value2, arg, modifiers }) {
      if (modifiers.mouse !== true && client.has.touch !== true) {
        return;
      }
      const mouseCapture = modifiers.mouseCapture === true ? "Capture" : "";
      const ctx = {
        handler: value2,
        sensitivity: parseArg(arg),
        direction: getModifierDirections(modifiers),
        noop: noop$3,
        mouseStart(evt) {
          if (shouldStart(evt, ctx) && leftClick(evt)) {
            addEvt(ctx, "temp", [
              [document, "mousemove", "move", `notPassive${mouseCapture}`],
              [document, "mouseup", "end", "notPassiveCapture"]
            ]);
            ctx.start(evt, true);
          }
        },
        touchStart(evt) {
          if (shouldStart(evt, ctx)) {
            const target2 = evt.target;
            addEvt(ctx, "temp", [
              [target2, "touchmove", "move", "notPassiveCapture"],
              [target2, "touchcancel", "end", "notPassiveCapture"],
              [target2, "touchend", "end", "notPassiveCapture"]
            ]);
            ctx.start(evt);
          }
        },
        start(evt, mouseEvent) {
          client.is.firefox === true && preventDraggable(el, true);
          const pos = position$1(evt);
          ctx.event = {
            x: pos.left,
            y: pos.top,
            time: Date.now(),
            mouse: mouseEvent === true,
            dir: false
          };
        },
        move(evt) {
          if (ctx.event === void 0) {
            return;
          }
          if (ctx.event.dir !== false) {
            stopAndPrevent(evt);
            return;
          }
          const time2 = Date.now() - ctx.event.time;
          if (time2 === 0) {
            return;
          }
          const pos = position$1(evt), distX = pos.left - ctx.event.x, absX = Math.abs(distX), distY = pos.top - ctx.event.y, absY = Math.abs(distY);
          if (ctx.event.mouse !== true) {
            if (absX < ctx.sensitivity[1] && absY < ctx.sensitivity[1]) {
              ctx.end(evt);
              return;
            }
          } else if (window.getSelection().toString() !== "") {
            ctx.end(evt);
            return;
          } else if (absX < ctx.sensitivity[2] && absY < ctx.sensitivity[2]) {
            return;
          }
          const velX = absX / time2, velY = absY / time2;
          if (ctx.direction.vertical === true && absX < absY && absX < 100 && velY > ctx.sensitivity[0]) {
            ctx.event.dir = distY < 0 ? "up" : "down";
          }
          if (ctx.direction.horizontal === true && absX > absY && absY < 100 && velX > ctx.sensitivity[0]) {
            ctx.event.dir = distX < 0 ? "left" : "right";
          }
          if (ctx.direction.up === true && absX < absY && distY < 0 && absX < 100 && velY > ctx.sensitivity[0]) {
            ctx.event.dir = "up";
          }
          if (ctx.direction.down === true && absX < absY && distY > 0 && absX < 100 && velY > ctx.sensitivity[0]) {
            ctx.event.dir = "down";
          }
          if (ctx.direction.left === true && absX > absY && distX < 0 && absY < 100 && velX > ctx.sensitivity[0]) {
            ctx.event.dir = "left";
          }
          if (ctx.direction.right === true && absX > absY && distX > 0 && absY < 100 && velX > ctx.sensitivity[0]) {
            ctx.event.dir = "right";
          }
          if (ctx.event.dir !== false) {
            stopAndPrevent(evt);
            if (ctx.event.mouse === true) {
              document.body.classList.add("no-pointer-events--children");
              document.body.classList.add("non-selectable");
              clearSelection();
              ctx.styleCleanup = (withDelay) => {
                ctx.styleCleanup = void 0;
                document.body.classList.remove("non-selectable");
                const remove2 = () => {
                  document.body.classList.remove("no-pointer-events--children");
                };
                if (withDelay === true) {
                  setTimeout(remove2, 50);
                } else {
                  remove2();
                }
              };
            }
            ctx.handler({
              evt,
              touch: ctx.event.mouse !== true,
              mouse: ctx.event.mouse,
              direction: ctx.event.dir,
              duration: time2,
              distance: {
                x: absX,
                y: absY
              }
            });
          } else {
            ctx.end(evt);
          }
        },
        end(evt) {
          if (ctx.event === void 0) {
            return;
          }
          cleanEvt(ctx, "temp");
          client.is.firefox === true && preventDraggable(el, false);
          ctx.styleCleanup !== void 0 && ctx.styleCleanup(true);
          evt !== void 0 && ctx.event.dir !== false && stopAndPrevent(evt);
          ctx.event = void 0;
        }
      };
      el.__qtouchswipe = ctx;
      if (modifiers.mouse === true) {
        const capture = modifiers.mouseCapture === true || modifiers.mousecapture === true ? "Capture" : "";
        addEvt(ctx, "main", [
          [el, "mousedown", "mouseStart", `passive${capture}`]
        ]);
      }
      client.has.touch === true && addEvt(ctx, "main", [
        [el, "touchstart", "touchStart", `passive${modifiers.capture === true ? "Capture" : ""}`],
        [el, "touchmove", "noop", "notPassiveCapture"]
        // cannot be passive (ex: iOS scroll)
      ]);
    },
    updated(el, bindings) {
      const ctx = el.__qtouchswipe;
      if (ctx !== void 0) {
        if (bindings.oldValue !== bindings.value) {
          typeof bindings.value !== "function" && ctx.end();
          ctx.handler = bindings.value;
        }
        ctx.direction = getModifierDirections(bindings.modifiers);
      }
    },
    beforeUnmount(el) {
      const ctx = el.__qtouchswipe;
      if (ctx !== void 0) {
        cleanEvt(ctx, "main");
        cleanEvt(ctx, "temp");
        client.is.firefox === true && preventDraggable(el, false);
        ctx.styleCleanup !== void 0 && ctx.styleCleanup();
        delete el.__qtouchswipe;
      }
    }
  }
);
const usePanelChildProps = {
  name: { required: true },
  disable: Boolean
};
const PanelWrapper = {
  setup(_2, { slots }) {
    return () => h$1("div", {
      class: "q-panel scroll",
      role: "tabpanel"
    }, hSlot(slots.default));
  }
};
const usePanelProps = {
  modelValue: {
    required: true
  },
  animated: Boolean,
  infinite: Boolean,
  swipeable: Boolean,
  vertical: Boolean,
  transitionPrev: String,
  transitionNext: String,
  transitionDuration: {
    type: [String, Number],
    default: 300
  },
  keepAlive: Boolean,
  keepAliveInclude: [String, Array, RegExp],
  keepAliveExclude: [String, Array, RegExp],
  keepAliveMax: Number
};
const usePanelEmits = ["update:modelValue", "beforeTransition", "transition"];
function usePanel() {
  const { props: props2, emit: emit2, proxy } = getCurrentInstance();
  const { getCache } = useRenderCache();
  let panels, forcedPanelTransition;
  const panelIndex = ref(null);
  const panelTransition = ref(null);
  function onSwipe(evt) {
    const dir = props2.vertical === true ? "up" : "left";
    goToPanelByOffset((proxy.$q.lang.rtl === true ? -1 : 1) * (evt.direction === dir ? 1 : -1));
  }
  const panelDirectives = computed(() => {
    return [[
      TouchSwipe,
      onSwipe,
      void 0,
      {
        horizontal: props2.vertical !== true,
        vertical: props2.vertical,
        mouse: true
      }
    ]];
  });
  const transitionPrev = computed(
    () => props2.transitionPrev || `slide-${props2.vertical === true ? "down" : "right"}`
  );
  const transitionNext = computed(
    () => props2.transitionNext || `slide-${props2.vertical === true ? "up" : "left"}`
  );
  const transitionStyle = computed(
    () => `--q-transition-duration: ${props2.transitionDuration}ms`
  );
  const contentKey = computed(() => typeof props2.modelValue === "string" || typeof props2.modelValue === "number" ? props2.modelValue : String(props2.modelValue));
  const keepAliveProps = computed(() => ({
    include: props2.keepAliveInclude,
    exclude: props2.keepAliveExclude,
    max: props2.keepAliveMax
  }));
  const needsUniqueKeepAliveWrapper = computed(
    () => props2.keepAliveInclude !== void 0 || props2.keepAliveExclude !== void 0
  );
  watch(() => props2.modelValue, (newVal, oldVal) => {
    const index = isValidPanelName(newVal) === true ? getPanelIndex(newVal) : -1;
    if (forcedPanelTransition !== true) {
      updatePanelTransition(
        index === -1 ? 0 : index < getPanelIndex(oldVal) ? -1 : 1
      );
    }
    if (panelIndex.value !== index) {
      panelIndex.value = index;
      emit2("beforeTransition", newVal, oldVal);
      nextTick$1(() => {
        emit2("transition", newVal, oldVal);
      });
    }
  });
  function nextPanel() {
    goToPanelByOffset(1);
  }
  function previousPanel() {
    goToPanelByOffset(-1);
  }
  function goToPanel(name) {
    emit2("update:modelValue", name);
  }
  function isValidPanelName(name) {
    return name !== void 0 && name !== null && name !== "";
  }
  function getPanelIndex(name) {
    return panels.findIndex((panel) => {
      return panel.props.name === name && panel.props.disable !== "" && panel.props.disable !== true;
    });
  }
  function getEnabledPanels() {
    return panels.filter((panel) => {
      return panel.props.disable !== "" && panel.props.disable !== true;
    });
  }
  function updatePanelTransition(direction2) {
    const val = direction2 !== 0 && props2.animated === true && panelIndex.value !== -1 ? "q-transition--" + (direction2 === -1 ? transitionPrev.value : transitionNext.value) : null;
    if (panelTransition.value !== val) {
      panelTransition.value = val;
    }
  }
  function goToPanelByOffset(direction2, startIndex = panelIndex.value) {
    let index = startIndex + direction2;
    while (index !== -1 && index < panels.length) {
      const opt = panels[index];
      if (opt !== void 0 && opt.props.disable !== "" && opt.props.disable !== true) {
        updatePanelTransition(direction2);
        forcedPanelTransition = true;
        emit2("update:modelValue", opt.props.name);
        setTimeout(() => {
          forcedPanelTransition = false;
        });
        return;
      }
      index += direction2;
    }
    if (props2.infinite === true && panels.length !== 0 && startIndex !== -1 && startIndex !== panels.length) {
      goToPanelByOffset(direction2, direction2 === -1 ? panels.length : -1);
    }
  }
  function updatePanelIndex() {
    const index = getPanelIndex(props2.modelValue);
    if (panelIndex.value !== index) {
      panelIndex.value = index;
    }
    return true;
  }
  function getPanelContentChild() {
    const panel = isValidPanelName(props2.modelValue) === true && updatePanelIndex() && panels[panelIndex.value];
    return props2.keepAlive === true ? [
      h$1(KeepAlive, keepAliveProps.value, [
        h$1(
          needsUniqueKeepAliveWrapper.value === true ? getCache(contentKey.value, () => ({ ...PanelWrapper, name: contentKey.value })) : PanelWrapper,
          { key: contentKey.value, style: transitionStyle.value },
          () => panel
        )
      ])
    ] : [
      h$1("div", {
        class: "q-panel scroll",
        style: transitionStyle.value,
        key: contentKey.value,
        role: "tabpanel"
      }, [panel])
    ];
  }
  function getPanelContent() {
    if (panels.length === 0) {
      return;
    }
    return props2.animated === true ? [h$1(Transition, { name: panelTransition.value }, getPanelContentChild)] : getPanelContentChild();
  }
  function updatePanelsList(slots) {
    panels = getNormalizedVNodes(
      hSlot(slots.default, [])
    ).filter(
      (panel) => panel.props !== null && panel.props.slot === void 0 && isValidPanelName(panel.props.name) === true
    );
    return panels.length;
  }
  function getPanels() {
    return panels;
  }
  Object.assign(proxy, {
    next: nextPanel,
    previous: previousPanel,
    goTo: goToPanel
  });
  return {
    panelIndex,
    panelDirectives,
    updatePanelsList,
    updatePanelIndex,
    getPanelContent,
    getEnabledPanels,
    getPanels,
    isValidPanelName,
    keepAliveProps,
    needsUniqueKeepAliveWrapper,
    goToPanelByOffset,
    goToPanel,
    nextPanel,
    previousPanel
  };
}
const QTabPanel = createComponent({
  name: "QTabPanel",
  props: usePanelChildProps,
  setup(_2, { slots }) {
    return () => h$1("div", { class: "q-tab-panel", role: "tabpanel" }, hSlot(slots.default));
  }
});
const QTabPanels = createComponent({
  name: "QTabPanels",
  props: {
    ...usePanelProps,
    ...useDarkProps
  },
  emits: usePanelEmits,
  setup(props2, { slots }) {
    const vm2 = getCurrentInstance();
    const isDark = useDark(props2, vm2.proxy.$q);
    const { updatePanelsList, getPanelContent, panelDirectives } = usePanel();
    const classes = computed(
      () => "q-tab-panels q-panel-parent" + (isDark.value === true ? " q-tab-panels--dark q-dark" : "")
    );
    return () => {
      updatePanelsList(slots);
      return hDir(
        "div",
        { class: classes.value },
        getPanelContent(),
        "pan",
        props2.swipeable,
        () => panelDirectives.value
      );
    };
  }
});
const _hoisted_1$2 = { class: "justify-center row q-my-lg" };
const _hoisted_2$2 = {
  id: "pdf",
  class: "row items-center justify-center flex col-sm-12 col-md-9 col-lg-7 col-xl-7"
};
const _hoisted_3$2 = { class: "col-12 text-center row" };
const _hoisted_4$2 = { class: "col-12 col-md-6 row justify-center flex" };
const _hoisted_5$2 = { class: "col-9 text-center" };
const _hoisted_6$2 = {
  class: "text-green-9",
  style: { "font-size": "1.5em", "font-weight": "600" }
};
const _hoisted_7$2 = { class: "col-12 col-md-6 justify-center items-center flex" };
const _hoisted_8$2 = { class: "col-12 text-center" };
const _hoisted_9$2 = /* @__PURE__ */ createBaseVNode("p", { style: { "font-size": "1.5em" } }, "Reporte de datos", -1);
const _hoisted_10$2 = { style: { "font-size": "1.3em" } };
const _hoisted_11$2 = { class: "col-12 justify-center flex full-width" };
const _hoisted_12$2 = { class: "header_table bg-green-1" };
const _hoisted_13$2 = { class: "bg-white" };
const _hoisted_14$2 = { key: 0 };
const _hoisted_15$2 = { key: 0 };
const _sfc_main$2 = {
  __name: "Report",
  props: ["dates", "data"],
  setup(__props) {
    const { dates, data } = __props;
    let dataHumedad = ref([]);
    onMounted(() => {
      dataHumedad.value = data.map((month) => {
        return month.data.map((day) => {
          return {
            date: day.date,
            humfinal: day.humfinal
          };
        });
      }).flat();
      console.log(dataHumedad.value);
    });
    let columns = ref([
      {
        name: "date",
        label: "Fecha",
        field: "date",
        align: "center",
        sortable: true,
        type: "string"
      },
      {
        name: "temperature",
        label: "Temperatura final del día",
        field: "temperature",
        align: "center",
        sortable: true,
        type: "number",
        symbol: "°C"
      },
      {
        name: "humidity",
        label: "Humedad final del día",
        field: "humidity",
        align: "center",
        sortable: true,
        type: "number",
        symbol: "%"
      },
      {
        name: "masa",
        label: "Masa",
        field: "masa",
        align: "center",
        sortable: true,
        type: "number",
        symbol: "g"
      },
      {
        name: "humfinal",
        label: "Prom. Humedad final",
        field: "humfinal",
        align: "center",
        sortable: true,
        type: "number",
        symbol: "%"
      }
    ]);
    return (_ctx, _cache) => {
      var _a2, _b2, _c;
      return openBlock(), createElementBlock("div", _hoisted_1$2, [
        createBaseVNode("div", _hoisted_2$2, [
          createBaseVNode("div", _hoisted_3$2, [
            createBaseVNode("div", _hoisted_4$2, [
              createVNode(QImg, {
                class: "col-3 q-mx-lg",
                src: "/images/logo.png",
                style: { "width": "80px", "height": "80px" }
              }),
              createBaseVNode("div", _hoisted_5$2, [
                createBaseVNode("p", _hoisted_6$2, "SENA - " + toDisplayString((_a2 = __props.dates) == null ? void 0 : _a2.farm), 1)
              ])
            ]),
            createBaseVNode("div", _hoisted_7$2, [
              createBaseVNode("div", _hoisted_8$2, [
                _hoisted_9$2,
                createBaseVNode("p", _hoisted_10$2, toDisplayString((_b2 = __props.dates) == null ? void 0 : _b2.start) + " - " + toDisplayString((_c = __props.dates) == null ? void 0 : _c.end), 1)
              ])
            ])
          ]),
          createBaseVNode("div", _hoisted_11$2, [
            createVNode(QMarkupTable, {
              dense: "",
              "wrap-cells": "",
              id: "tableReport"
            }, {
              default: withCtx(() => [
                createBaseVNode("thead", _hoisted_12$2, [
                  createBaseVNode("tr", null, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(columns), (column) => {
                      return openBlock(), createElementBlock("th", {
                        class: "text-center",
                        style: { "font-weight": "bold", "font-size": ".9rem" },
                        key: column.name
                      }, toDisplayString(column.label), 1);
                    }), 128))
                  ])
                ]),
                createBaseVNode("tbody", _hoisted_13$2, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(__props.data, (month) => {
                    return openBlock(), createElementBlock(Fragment, {
                      key: month.nameMonth
                    }, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(month.data, (day) => {
                        return openBlock(), createElementBlock("tr", {
                          key: day.date
                        }, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(columns), (column) => {
                            return openBlock(), createElementBlock("td", {
                              key: column.name,
                              class: "text-center"
                            }, [
                              column.type === "number" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                                createTextVNode(toDisplayString(day[column.field].toFixed(2)) + " ", 1),
                                column.symbol ? (openBlock(), createElementBlock("span", _hoisted_14$2, toDisplayString(column.symbol), 1)) : createCommentVNode("", true)
                              ], 64)) : column.type === "date" ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                                createTextVNode(toDisplayString(new Date(day[column.field]).toLocaleDateString()), 1)
                              ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                                createTextVNode(toDisplayString(day[column.field]) + " ", 1),
                                column.symbol ? (openBlock(), createElementBlock("span", _hoisted_15$2, toDisplayString(column.symbol), 1)) : createCommentVNode("", true)
                              ], 64))
                            ]);
                          }), 128))
                        ]);
                      }), 128))
                    ], 64);
                  }), 128))
                ])
              ]),
              _: 1
            })
          ])
        ])
      ]);
    };
  }
};
const getReportPDF = async ({ farm, fechaA, fechaB }) => {
  console.log(farm, fechaA, fechaB);
  try {
    const response = await axiosInstance.post(
      `/sensors/report`,
      {
        farm,
        dateStart: fechaA,
        dateEnd: fechaB
      }
    );
    console.log(response);
    return response.data;
  } catch (error) {
    console.error(error);
    const message = error.response.data.error || "Error al obtener el reporte";
    notifyErrorRequest$1(message);
    throw new Error(message);
  }
};
const scriptRel = "modulepreload";
const assetsURL = function(dep) {
  return "/" + dep;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (deps && deps.length > 0) {
    document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector(
      "meta[property=csp-nonce]"
    );
    const cspNonce = (cspNonceMeta == null ? void 0 : cspNonceMeta.nonce) || (cspNonceMeta == null ? void 0 : cspNonceMeta.getAttribute("nonce"));
    promise = Promise.all(
      deps.map((dep) => {
        dep = assetsURL(dep);
        if (dep in seen) return;
        seen[dep] = true;
        const isCss = dep.endsWith(".css");
        const cssSelector = isCss ? '[rel="stylesheet"]' : "";
        if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
          return;
        }
        const link = document.createElement("link");
        link.rel = isCss ? "stylesheet" : scriptRel;
        if (!isCss) {
          link.as = "script";
          link.crossOrigin = "";
        }
        link.href = dep;
        if (cspNonce) {
          link.setAttribute("nonce", cspNonce);
        }
        document.head.appendChild(link);
        if (isCss) {
          return new Promise((res, rej) => {
            link.addEventListener("load", res);
            link.addEventListener(
              "error",
              () => rej(new Error(`Unable to preload CSS for ${dep}`))
            );
          });
        }
      })
    );
  }
  return promise.then(() => baseModule()).catch((err) => {
    const e2 = new Event("vite:preloadError", { cancelable: true });
    e2.payload = err;
    window.dispatchEvent(e2);
    if (!e2.defaultPrevented) {
      throw err;
    }
  });
};
function _typeof(o2) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof(o2);
}
var u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;
var fleb = new u8([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]);
var fdeb = new u8([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(eb, start) {
  var b2 = new u16(31);
  for (var i = 0; i < 31; ++i) {
    b2[i] = start += 1 << eb[i - 1];
  }
  var r = new u32(b2[30]);
  for (var i = 1; i < 30; ++i) {
    for (var j2 = b2[i]; j2 < b2[i + 1]; ++j2) {
      r[j2] = j2 - b2[i] << 5 | i;
    }
  }
  return [b2, r];
};
var _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];
var rev = new u16(32768);
for (var i$5 = 0; i$5 < 32768; ++i$5) {
  var x$1 = (i$5 & 43690) >>> 1 | (i$5 & 21845) << 1;
  x$1 = (x$1 & 52428) >>> 2 | (x$1 & 13107) << 2;
  x$1 = (x$1 & 61680) >>> 4 | (x$1 & 3855) << 4;
  rev[i$5] = ((x$1 & 65280) >>> 8 | (x$1 & 255) << 8) >>> 1;
}
var hMap = function(cd, mb, r) {
  var s2 = cd.length;
  var i = 0;
  var l2 = new u16(mb);
  for (; i < s2; ++i)
    ++l2[cd[i] - 1];
  var le2 = new u16(mb);
  for (i = 0; i < mb; ++i) {
    le2[i] = le2[i - 1] + l2[i - 1] << 1;
  }
  var co;
  if (r) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i = 0; i < s2; ++i) {
      if (cd[i]) {
        var sv = i << 4 | cd[i];
        var r_1 = mb - cd[i];
        var v2 = le2[cd[i] - 1]++ << r_1;
        for (var m2 = v2 | (1 << r_1) - 1; v2 <= m2; ++v2) {
          co[rev[v2] >>> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s2);
    for (i = 0; i < s2; ++i)
      co[i] = rev[le2[cd[i] - 1]++] >>> 15 - cd[i];
  }
  return co;
};
var flt = new u8(288);
for (var i$5 = 0; i$5 < 144; ++i$5)
  flt[i$5] = 8;
for (var i$5 = 144; i$5 < 256; ++i$5)
  flt[i$5] = 9;
for (var i$5 = 256; i$5 < 280; ++i$5)
  flt[i$5] = 7;
for (var i$5 = 280; i$5 < 288; ++i$5)
  flt[i$5] = 8;
var fdt = new u8(32);
for (var i$5 = 0; i$5 < 32; ++i$5)
  fdt[i$5] = 5;
var flm = /* @__PURE__ */ hMap(flt, 9, 0), flrm = /* @__PURE__ */ hMap(flt, 9, 1);
var fdm = /* @__PURE__ */ hMap(fdt, 5, 0), fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
var max = function(a2) {
  var m2 = a2[0];
  for (var i = 1; i < a2.length; ++i) {
    if (a2[i] > m2)
      m2 = a2[i];
  }
  return m2;
};
var bits = function(d2, p2, m2) {
  var o2 = p2 / 8 >> 0;
  return (d2[o2] | d2[o2 + 1] << 8) >>> (p2 & 7) & m2;
};
var bits16 = function(d2, p2) {
  var o2 = p2 / 8 >> 0;
  return (d2[o2] | d2[o2 + 1] << 8 | d2[o2 + 2] << 16) >>> (p2 & 7);
};
var shft = function(p2) {
  return (p2 / 8 >> 0) + (p2 & 7 && 1);
};
var slc = function(v2, s2, e2) {
  if (e2 == null || e2 > v2.length)
    e2 = v2.length;
  var n2 = new (v2 instanceof u16 ? u16 : v2 instanceof u32 ? u32 : u8)(e2 - s2);
  n2.set(v2.subarray(s2, e2));
  return n2;
};
var inflt = function(dat, buf2, st2) {
  var sl = dat.length;
  var noBuf = !buf2 || st2;
  var noSt = !st2 || st2.i;
  if (!st2)
    st2 = {};
  if (!buf2)
    buf2 = new u8(sl * 3);
  var cbuf = function(l3) {
    var bl = buf2.length;
    if (l3 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l3));
      nbuf.set(buf2);
      buf2 = nbuf;
    }
  };
  var final = st2.f || 0, pos = st2.p || 0, bt2 = st2.b || 0, lm = st2.l, dm = st2.d, lbt = st2.m, dbt = st2.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      st2.f = final = bits(dat, pos, 1);
      var type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s2 = shft(pos) + 4, l2 = dat[s2 - 4] | dat[s2 - 3] << 8, t2 = s2 + l2;
        if (t2 > sl) {
          if (noSt)
            throw "unexpected EOF";
          break;
        }
        if (noBuf)
          cbuf(bt2 + l2);
        buf2.set(dat.subarray(s2, t2), bt2);
        st2.b = bt2 += l2, st2.p = pos = t2 * 8;
        continue;
      } else if (type == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i = 0; i < hcLen; ++i) {
          clt[clim[i]] = bits(dat, pos + i * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max(clt), clbmsk = (1 << clb) - 1;
        if (!noSt && pos + tl * (clb + 7) > tbts)
          break;
        var clm = hMap(clt, clb, 1);
        for (var i = 0; i < tl; ) {
          var r = clm[bits(dat, pos, clbmsk)];
          pos += r & 15;
          var s2 = r >>> 4;
          if (s2 < 16) {
            ldt[i++] = s2;
          } else {
            var c2 = 0, n2 = 0;
            if (s2 == 16)
              n2 = 3 + bits(dat, pos, 3), pos += 2, c2 = ldt[i - 1];
            else if (s2 == 17)
              n2 = 3 + bits(dat, pos, 7), pos += 3;
            else if (s2 == 18)
              n2 = 11 + bits(dat, pos, 127), pos += 7;
            while (n2--)
              ldt[i++] = c2;
          }
        }
        var lt2 = ldt.subarray(0, hLit), dt2 = ldt.subarray(hLit);
        lbt = max(lt2);
        dbt = max(dt2);
        lm = hMap(lt2, lbt, 1);
        dm = hMap(dt2, dbt, 1);
      } else
        throw "invalid block type";
      if (pos > tbts)
        throw "unexpected EOF";
    }
    if (noBuf)
      cbuf(bt2 + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var mxa = lbt + dbt + 18;
    while (noSt || pos + mxa < tbts) {
      var c2 = lm[bits16(dat, pos) & lms], sym = c2 >>> 4;
      pos += c2 & 15;
      if (pos > tbts)
        throw "unexpected EOF";
      if (!c2)
        throw "invalid length/literal";
      if (sym < 256)
        buf2[bt2++] = sym;
      else if (sym == 256) {
        lm = null;
        break;
      } else {
        var add2 = sym - 254;
        if (sym > 264) {
          var i = sym - 257, b2 = fleb[i];
          add2 = bits(dat, pos, (1 << b2) - 1) + fl[i];
          pos += b2;
        }
        var d2 = dm[bits16(dat, pos) & dms], dsym = d2 >>> 4;
        if (!d2)
          throw "invalid distance";
        pos += d2 & 15;
        var dt2 = fd[dsym];
        if (dsym > 3) {
          var b2 = fdeb[dsym];
          dt2 += bits16(dat, pos) & (1 << b2) - 1, pos += b2;
        }
        if (pos > tbts)
          throw "unexpected EOF";
        if (noBuf)
          cbuf(bt2 + 131072);
        var end = bt2 + add2;
        for (; bt2 < end; bt2 += 4) {
          buf2[bt2] = buf2[bt2 - dt2];
          buf2[bt2 + 1] = buf2[bt2 + 1 - dt2];
          buf2[bt2 + 2] = buf2[bt2 + 2 - dt2];
          buf2[bt2 + 3] = buf2[bt2 + 3 - dt2];
        }
        bt2 = end;
      }
    }
    st2.l = lm, st2.p = pos, st2.b = bt2;
    if (lm)
      final = 1, st2.m = lbt, st2.d = dm, st2.n = dbt;
  } while (!final);
  return bt2 == buf2.length ? buf2 : slc(buf2, 0, bt2);
};
var wbits = function(d2, p2, v2) {
  v2 <<= p2 & 7;
  var o2 = p2 / 8 >> 0;
  d2[o2] |= v2;
  d2[o2 + 1] |= v2 >>> 8;
};
var wbits16 = function(d2, p2, v2) {
  v2 <<= p2 & 7;
  var o2 = p2 / 8 >> 0;
  d2[o2] |= v2;
  d2[o2 + 1] |= v2 >>> 8;
  d2[o2 + 2] |= v2 >>> 16;
};
var hTree = function(d2, mb) {
  var t2 = [];
  for (var i = 0; i < d2.length; ++i) {
    if (d2[i])
      t2.push({ s: i, f: d2[i] });
  }
  var s2 = t2.length;
  var t22 = t2.slice();
  if (!s2)
    return [new u8(0), 0];
  if (s2 == 1) {
    var v2 = new u8(t2[0].s + 1);
    v2[t2[0].s] = 1;
    return [v2, 1];
  }
  t2.sort(function(a2, b2) {
    return a2.f - b2.f;
  });
  t2.push({ s: -1, f: 25001 });
  var l2 = t2[0], r = t2[1], i0 = 0, i1 = 1, i2 = 2;
  t2[0] = { s: -1, f: l2.f + r.f, l: l2, r };
  while (i1 != s2 - 1) {
    l2 = t2[t2[i0].f < t2[i2].f ? i0++ : i2++];
    r = t2[i0 != i1 && t2[i0].f < t2[i2].f ? i0++ : i2++];
    t2[i1++] = { s: -1, f: l2.f + r.f, l: l2, r };
  }
  var maxSym = t22[0].s;
  for (var i = 1; i < s2; ++i) {
    if (t22[i].s > maxSym)
      maxSym = t22[i].s;
  }
  var tr = new u16(maxSym + 1);
  var mbt = ln(t2[i1 - 1], tr, 0);
  if (mbt > mb) {
    var i = 0, dt2 = 0;
    var lft = mbt - mb, cst = 1 << lft;
    t22.sort(function(a2, b2) {
      return tr[b2.s] - tr[a2.s] || a2.f - b2.f;
    });
    for (; i < s2; ++i) {
      var i2_1 = t22[i].s;
      if (tr[i2_1] > mb) {
        dt2 += cst - (1 << mbt - tr[i2_1]);
        tr[i2_1] = mb;
      } else
        break;
    }
    dt2 >>>= lft;
    while (dt2 > 0) {
      var i2_2 = t22[i].s;
      if (tr[i2_2] < mb)
        dt2 -= 1 << mb - tr[i2_2]++ - 1;
      else
        ++i;
    }
    for (; i >= 0 && dt2; --i) {
      var i2_3 = t22[i].s;
      if (tr[i2_3] == mb) {
        --tr[i2_3];
        ++dt2;
      }
    }
    mbt = mb;
  }
  return [new u8(tr), mbt];
};
var ln = function(n2, l2, d2) {
  return n2.s == -1 ? Math.max(ln(n2.l, l2, d2 + 1), ln(n2.r, l2, d2 + 1)) : l2[n2.s] = d2;
};
var lc = function(c2) {
  var s2 = c2.length;
  while (s2 && !c2[--s2])
    ;
  var cl = new u16(++s2);
  var cli = 0, cln = c2[0], cls = 1;
  var w2 = function(v2) {
    cl[cli++] = v2;
  };
  for (var i = 1; i <= s2; ++i) {
    if (c2[i] == cln && i != s2)
      ++cls;
    else {
      if (!cln && cls > 2) {
        for (; cls > 138; cls -= 138)
          w2(32754);
        if (cls > 2) {
          w2(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
          cls = 0;
        }
      } else if (cls > 3) {
        w2(cln), --cls;
        for (; cls > 6; cls -= 6)
          w2(8304);
        if (cls > 2)
          w2(cls - 3 << 5 | 8208), cls = 0;
      }
      while (cls--)
        w2(cln);
      cls = 1;
      cln = c2[i];
    }
  }
  return [cl.subarray(0, cli), s2];
};
var clen = function(cf, cl) {
  var l2 = 0;
  for (var i = 0; i < cl.length; ++i)
    l2 += cf[i] * cl[i];
  return l2;
};
var wfblk = function(out, pos, dat) {
  var s2 = dat.length;
  var o2 = shft(pos + 2);
  out[o2] = s2 & 255;
  out[o2 + 1] = s2 >>> 8;
  out[o2 + 2] = out[o2] ^ 255;
  out[o2 + 3] = out[o2 + 1] ^ 255;
  for (var i = 0; i < s2; ++i)
    out[o2 + i + 4] = dat[i];
  return (o2 + 4 + s2) * 8;
};
var wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p2) {
  wbits(out, p2++, final);
  ++lf[256];
  var _a2 = hTree(lf, 15), dlt = _a2[0], mlb = _a2[1];
  var _b2 = hTree(df, 15), ddt = _b2[0], mdb = _b2[1];
  var _c = lc(dlt), lclt = _c[0], nlc = _c[1];
  var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];
  var lcfreq = new u16(19);
  for (var i = 0; i < lclt.length; ++i)
    lcfreq[lclt[i] & 31]++;
  for (var i = 0; i < lcdt.length; ++i)
    lcfreq[lcdt[i] & 31]++;
  var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];
  var nlcc = 19;
  for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
    ;
  var flen = bl + 5 << 3;
  var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
  var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);
  if (flen <= ftlen && flen <= dtlen)
    return wfblk(out, p2, dat.subarray(bs, bs + bl));
  var lm, ll, dm, dl;
  wbits(out, p2, 1 + (dtlen < ftlen)), p2 += 2;
  if (dtlen < ftlen) {
    lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
    var llm = hMap(lct, mlcb, 0);
    wbits(out, p2, nlc - 257);
    wbits(out, p2 + 5, ndc - 1);
    wbits(out, p2 + 10, nlcc - 4);
    p2 += 14;
    for (var i = 0; i < nlcc; ++i)
      wbits(out, p2 + 3 * i, lct[clim[i]]);
    p2 += 3 * nlcc;
    var lcts = [lclt, lcdt];
    for (var it2 = 0; it2 < 2; ++it2) {
      var clct = lcts[it2];
      for (var i = 0; i < clct.length; ++i) {
        var len = clct[i] & 31;
        wbits(out, p2, llm[len]), p2 += lct[len];
        if (len > 15)
          wbits(out, p2, clct[i] >>> 5 & 127), p2 += clct[i] >>> 12;
      }
    }
  } else {
    lm = flm, ll = flt, dm = fdm, dl = fdt;
  }
  for (var i = 0; i < li; ++i) {
    if (syms[i] > 255) {
      var len = syms[i] >>> 18 & 31;
      wbits16(out, p2, lm[len + 257]), p2 += ll[len + 257];
      if (len > 7)
        wbits(out, p2, syms[i] >>> 23 & 31), p2 += fleb[len];
      var dst = syms[i] & 31;
      wbits16(out, p2, dm[dst]), p2 += dl[dst];
      if (dst > 3)
        wbits16(out, p2, syms[i] >>> 5 & 8191), p2 += fdeb[dst];
    } else {
      wbits16(out, p2, lm[syms[i]]), p2 += ll[syms[i]];
    }
  }
  wbits16(out, p2, lm[256]);
  return p2 + ll[256];
};
var deo = /* @__PURE__ */ new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
var dflt = function(dat, lvl, plvl, pre, post, lst) {
  var s2 = dat.length;
  var o2 = new u8(pre + s2 + 5 * (1 + Math.floor(s2 / 7e3)) + post);
  var w2 = o2.subarray(pre, o2.length - post);
  var pos = 0;
  if (!lvl || s2 < 8) {
    for (var i = 0; i <= s2; i += 65535) {
      var e2 = i + 65535;
      if (e2 < s2) {
        pos = wfblk(w2, pos, dat.subarray(i, e2));
      } else {
        w2[i] = lst;
        pos = wfblk(w2, pos, dat.subarray(i, s2));
      }
    }
  } else {
    var opt = deo[lvl - 1];
    var n2 = opt >>> 13, c2 = opt & 8191;
    var msk_1 = (1 << plvl) - 1;
    var prev = new u16(32768), head = new u16(msk_1 + 1);
    var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
    var hsh = function(i2) {
      return (dat[i2] ^ dat[i2 + 1] << bs1_1 ^ dat[i2 + 2] << bs2_1) & msk_1;
    };
    var syms = new u32(25e3);
    var lf = new u16(288), df = new u16(32);
    var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;
    for (; i < s2; ++i) {
      var hv = hsh(i);
      var imod = i & 32767;
      var pimod = head[hv];
      prev[imod] = pimod;
      head[hv] = imod;
      if (wi <= i) {
        var rem = s2 - i;
        if ((lc_1 > 7e3 || li > 24576) && rem > 423) {
          pos = wblk(dat, w2, 0, syms, lf, df, eb, li, bs, i - bs, pos);
          li = lc_1 = eb = 0, bs = i;
          for (var j2 = 0; j2 < 286; ++j2)
            lf[j2] = 0;
          for (var j2 = 0; j2 < 30; ++j2)
            df[j2] = 0;
        }
        var l2 = 2, d2 = 0, ch_1 = c2, dif = imod - pimod & 32767;
        if (rem > 2 && hv == hsh(i - dif)) {
          var maxn = Math.min(n2, rem) - 1;
          var maxd = Math.min(32767, i);
          var ml = Math.min(258, rem);
          while (dif <= maxd && --ch_1 && imod != pimod) {
            if (dat[i + l2] == dat[i + l2 - dif]) {
              var nl = 0;
              for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)
                ;
              if (nl > l2) {
                l2 = nl, d2 = dif;
                if (nl > maxn)
                  break;
                var mmd = Math.min(dif, nl - 2);
                var md = 0;
                for (var j2 = 0; j2 < mmd; ++j2) {
                  var ti2 = i - dif + j2 + 32768 & 32767;
                  var pti = prev[ti2];
                  var cd = ti2 - pti + 32768 & 32767;
                  if (cd > md)
                    md = cd, pimod = ti2;
                }
              }
            }
            imod = pimod, pimod = prev[imod];
            dif += imod - pimod + 32768 & 32767;
          }
        }
        if (d2) {
          syms[li++] = 268435456 | revfl[l2] << 18 | revfd[d2];
          var lin = revfl[l2] & 31, din = revfd[d2] & 31;
          eb += fleb[lin] + fdeb[din];
          ++lf[257 + lin];
          ++df[din];
          wi = i + l2;
          ++lc_1;
        } else {
          syms[li++] = dat[i];
          ++lf[dat[i]];
        }
      }
    }
    pos = wblk(dat, w2, lst, syms, lf, df, eb, li, bs, i - bs, pos);
  }
  return slc(o2, 0, pre + shft(pos) + post);
};
var adler = function() {
  var a2 = 1, b2 = 0;
  return {
    p: function(d2) {
      var n2 = a2, m2 = b2;
      var l2 = d2.length;
      for (var i = 0; i != l2; ) {
        var e2 = Math.min(i + 5552, l2);
        for (; i < e2; ++i)
          n2 += d2[i], m2 += n2;
        n2 %= 65521, m2 %= 65521;
      }
      a2 = n2, b2 = m2;
    },
    d: function() {
      return (a2 >>> 8 << 16 | (b2 & 255) << 8 | b2 >>> 8) + ((a2 & 255) << 23) * 2;
    }
  };
};
var dopt = function(dat, opt, pre, post, st2) {
  return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 12 + opt.mem, pre, post, !st2);
};
var wbytes = function(d2, b2, v2) {
  for (; v2; ++b2)
    d2[b2] = v2, v2 >>>= 8;
};
var zlh = function(c2, o2) {
  var lv = o2.level, fl2 = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
  c2[0] = 120, c2[1] = fl2 << 6 | (fl2 ? 32 - 2 * fl2 : 1);
};
var zlv = function(d2) {
  if ((d2[0] & 15) != 8 || d2[0] >>> 4 > 7 || (d2[0] << 8 | d2[1]) % 31)
    throw "invalid zlib data";
  if (d2[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function zlibSync(data, opts) {
  if (opts === void 0) {
    opts = {};
  }
  var a2 = adler();
  a2.p(data);
  var d2 = dopt(data, opts, 2, 4);
  return zlh(d2, opts), wbytes(d2, d2.length - 4, a2.d()), d2;
}
function unzlibSync(data, out) {
  return inflt((zlv(data), data.subarray(2, -4)), out);
}
var n = /* @__PURE__ */ function() {
  return "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this;
}();
function i$4() {
  n.console && "function" == typeof n.console.log && n.console.log.apply(n.console, arguments);
}
var a$1 = { log: i$4, warn: function(t2) {
  n.console && ("function" == typeof n.console.warn ? n.console.warn.apply(n.console, arguments) : i$4.call(null, arguments));
}, error: function(t2) {
  n.console && ("function" == typeof n.console.error ? n.console.error.apply(n.console, arguments) : i$4(t2));
} };
function o(t2, e2, r) {
  var n2 = new XMLHttpRequest();
  n2.open("GET", t2), n2.responseType = "blob", n2.onload = function() {
    l(n2.response, e2, r);
  }, n2.onerror = function() {
    a$1.error("could not download file");
  }, n2.send();
}
function s(t2) {
  var e2 = new XMLHttpRequest();
  e2.open("HEAD", t2, false);
  try {
    e2.send();
  } catch (t3) {
  }
  return e2.status >= 200 && e2.status <= 299;
}
function c(t2) {
  try {
    t2.dispatchEvent(new MouseEvent("click"));
  } catch (r) {
    var e2 = document.createEvent("MouseEvents");
    e2.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), t2.dispatchEvent(e2);
  }
}
var u$1, h, l = n.saveAs || ("object" !== ("undefined" == typeof window ? "undefined" : _typeof(window)) || window !== n ? function() {
} : "undefined" != typeof HTMLAnchorElement && "download" in HTMLAnchorElement.prototype ? function(t2, e2, r) {
  var i = n.URL || n.webkitURL, a2 = document.createElement("a");
  e2 = e2 || t2.name || "download", a2.download = e2, a2.rel = "noopener", "string" == typeof t2 ? (a2.href = t2, a2.origin !== location.origin ? s(a2.href) ? o(t2, e2, r) : c(a2, a2.target = "_blank") : c(a2)) : (a2.href = i.createObjectURL(t2), setTimeout(function() {
    i.revokeObjectURL(a2.href);
  }, 4e4), setTimeout(function() {
    c(a2);
  }, 0));
} : "msSaveOrOpenBlob" in navigator ? function(e2, r, n2) {
  if (r = r || e2.name || "download", "string" == typeof e2) if (s(e2)) o(e2, r, n2);
  else {
    var i = document.createElement("a");
    i.href = e2, i.target = "_blank", setTimeout(function() {
      c(i);
    });
  }
  else navigator.msSaveOrOpenBlob(function(e3, r2) {
    return void 0 === r2 ? r2 = { autoBom: false } : "object" !== _typeof(r2) && (a$1.warn("Deprecated: Expected third argument to be a object"), r2 = { autoBom: !r2 }), r2.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e3.type) ? new Blob([String.fromCharCode(65279), e3], { type: e3.type }) : e3;
  }(e2, n2), r);
} : function(e2, r, i, a2) {
  if ((a2 = a2 || open("", "_blank")) && (a2.document.title = a2.document.body.innerText = "downloading..."), "string" == typeof e2) return o(e2, r, i);
  var s2 = "application/octet-stream" === e2.type, c2 = /constructor/i.test(n.HTMLElement) || n.safari, u2 = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((u2 || s2 && c2) && "object" === ("undefined" == typeof FileReader ? "undefined" : _typeof(FileReader))) {
    var h2 = new FileReader();
    h2.onloadend = function() {
      var t2 = h2.result;
      t2 = u2 ? t2 : t2.replace(/^data:[^;]*;/, "data:attachment/file;"), a2 ? a2.location.href = t2 : location = t2, a2 = null;
    }, h2.readAsDataURL(e2);
  } else {
    var l2 = n.URL || n.webkitURL, f2 = l2.createObjectURL(e2);
    a2 ? a2.location = f2 : location.href = f2, a2 = null, setTimeout(function() {
      l2.revokeObjectURL(f2);
    }, 4e4);
  }
});
/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
 * @license Use it if you like it
 */
function f$1(t2) {
  var e2;
  t2 = t2 || "", this.ok = false, "#" == t2.charAt(0) && (t2 = t2.substr(1, 6));
  t2 = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32" }[t2 = (t2 = t2.replace(/ /g, "")).toLowerCase()] || t2;
  for (var r = [{ re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function(t3) {
    return [parseInt(t3[1]), parseInt(t3[2]), parseInt(t3[3])];
  } }, { re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function(t3) {
    return [parseInt(t3[1], 16), parseInt(t3[2], 16), parseInt(t3[3], 16)];
  } }, { re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function(t3) {
    return [parseInt(t3[1] + t3[1], 16), parseInt(t3[2] + t3[2], 16), parseInt(t3[3] + t3[3], 16)];
  } }], n2 = 0; n2 < r.length; n2++) {
    var i = r[n2].re, a2 = r[n2].process, o2 = i.exec(t2);
    o2 && (e2 = a2(o2), this.r = e2[0], this.g = e2[1], this.b = e2[2], this.ok = true);
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toHex = function() {
    var t3 = this.r.toString(16), e3 = this.g.toString(16), r2 = this.b.toString(16);
    return 1 == t3.length && (t3 = "0" + t3), 1 == e3.length && (e3 = "0" + e3), 1 == r2.length && (r2 = "0" + r2), "#" + t3 + e3 + r2;
  };
}
/**
 * @license
 * Joseph Myers does not specify a particular license for his work.
 *
 * Author: Joseph Myers
 * Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
 *
 * Modified by: Owen Leong
 */
function d(t2, e2) {
  var r = t2[0], n2 = t2[1], i = t2[2], a2 = t2[3];
  r = g(r, n2, i, a2, e2[0], 7, -680876936), a2 = g(a2, r, n2, i, e2[1], 12, -389564586), i = g(i, a2, r, n2, e2[2], 17, 606105819), n2 = g(n2, i, a2, r, e2[3], 22, -1044525330), r = g(r, n2, i, a2, e2[4], 7, -176418897), a2 = g(a2, r, n2, i, e2[5], 12, 1200080426), i = g(i, a2, r, n2, e2[6], 17, -1473231341), n2 = g(n2, i, a2, r, e2[7], 22, -45705983), r = g(r, n2, i, a2, e2[8], 7, 1770035416), a2 = g(a2, r, n2, i, e2[9], 12, -1958414417), i = g(i, a2, r, n2, e2[10], 17, -42063), n2 = g(n2, i, a2, r, e2[11], 22, -1990404162), r = g(r, n2, i, a2, e2[12], 7, 1804603682), a2 = g(a2, r, n2, i, e2[13], 12, -40341101), i = g(i, a2, r, n2, e2[14], 17, -1502002290), r = m(r, n2 = g(n2, i, a2, r, e2[15], 22, 1236535329), i, a2, e2[1], 5, -165796510), a2 = m(a2, r, n2, i, e2[6], 9, -1069501632), i = m(i, a2, r, n2, e2[11], 14, 643717713), n2 = m(n2, i, a2, r, e2[0], 20, -373897302), r = m(r, n2, i, a2, e2[5], 5, -701558691), a2 = m(a2, r, n2, i, e2[10], 9, 38016083), i = m(i, a2, r, n2, e2[15], 14, -660478335), n2 = m(n2, i, a2, r, e2[4], 20, -405537848), r = m(r, n2, i, a2, e2[9], 5, 568446438), a2 = m(a2, r, n2, i, e2[14], 9, -1019803690), i = m(i, a2, r, n2, e2[3], 14, -187363961), n2 = m(n2, i, a2, r, e2[8], 20, 1163531501), r = m(r, n2, i, a2, e2[13], 5, -1444681467), a2 = m(a2, r, n2, i, e2[2], 9, -51403784), i = m(i, a2, r, n2, e2[7], 14, 1735328473), r = v(r, n2 = m(n2, i, a2, r, e2[12], 20, -1926607734), i, a2, e2[5], 4, -378558), a2 = v(a2, r, n2, i, e2[8], 11, -2022574463), i = v(i, a2, r, n2, e2[11], 16, 1839030562), n2 = v(n2, i, a2, r, e2[14], 23, -35309556), r = v(r, n2, i, a2, e2[1], 4, -1530992060), a2 = v(a2, r, n2, i, e2[4], 11, 1272893353), i = v(i, a2, r, n2, e2[7], 16, -155497632), n2 = v(n2, i, a2, r, e2[10], 23, -1094730640), r = v(r, n2, i, a2, e2[13], 4, 681279174), a2 = v(a2, r, n2, i, e2[0], 11, -358537222), i = v(i, a2, r, n2, e2[3], 16, -722521979), n2 = v(n2, i, a2, r, e2[6], 23, 76029189), r = v(r, n2, i, a2, e2[9], 4, -640364487), a2 = v(a2, r, n2, i, e2[12], 11, -421815835), i = v(i, a2, r, n2, e2[15], 16, 530742520), r = b(r, n2 = v(n2, i, a2, r, e2[2], 23, -995338651), i, a2, e2[0], 6, -198630844), a2 = b(a2, r, n2, i, e2[7], 10, 1126891415), i = b(i, a2, r, n2, e2[14], 15, -1416354905), n2 = b(n2, i, a2, r, e2[5], 21, -57434055), r = b(r, n2, i, a2, e2[12], 6, 1700485571), a2 = b(a2, r, n2, i, e2[3], 10, -1894986606), i = b(i, a2, r, n2, e2[10], 15, -1051523), n2 = b(n2, i, a2, r, e2[1], 21, -2054922799), r = b(r, n2, i, a2, e2[8], 6, 1873313359), a2 = b(a2, r, n2, i, e2[15], 10, -30611744), i = b(i, a2, r, n2, e2[6], 15, -1560198380), n2 = b(n2, i, a2, r, e2[13], 21, 1309151649), r = b(r, n2, i, a2, e2[4], 6, -145523070), a2 = b(a2, r, n2, i, e2[11], 10, -1120210379), i = b(i, a2, r, n2, e2[2], 15, 718787259), n2 = b(n2, i, a2, r, e2[9], 21, -343485551), t2[0] = _(r, t2[0]), t2[1] = _(n2, t2[1]), t2[2] = _(i, t2[2]), t2[3] = _(a2, t2[3]);
}
function p(t2, e2, r, n2, i, a2) {
  return e2 = _(_(e2, t2), _(n2, a2)), _(e2 << i | e2 >>> 32 - i, r);
}
function g(t2, e2, r, n2, i, a2, o2) {
  return p(e2 & r | ~e2 & n2, t2, e2, i, a2, o2);
}
function m(t2, e2, r, n2, i, a2, o2) {
  return p(e2 & n2 | r & ~n2, t2, e2, i, a2, o2);
}
function v(t2, e2, r, n2, i, a2, o2) {
  return p(e2 ^ r ^ n2, t2, e2, i, a2, o2);
}
function b(t2, e2, r, n2, i, a2, o2) {
  return p(r ^ (e2 | ~n2), t2, e2, i, a2, o2);
}
function y(t2) {
  var e2, r = t2.length, n2 = [1732584193, -271733879, -1732584194, 271733878];
  for (e2 = 64; e2 <= t2.length; e2 += 64) d(n2, w(t2.substring(e2 - 64, e2)));
  t2 = t2.substring(e2 - 64);
  var i = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (e2 = 0; e2 < t2.length; e2++) i[e2 >> 2] |= t2.charCodeAt(e2) << (e2 % 4 << 3);
  if (i[e2 >> 2] |= 128 << (e2 % 4 << 3), e2 > 55) for (d(n2, i), e2 = 0; e2 < 16; e2++) i[e2] = 0;
  return i[14] = 8 * r, d(n2, i), n2;
}
function w(t2) {
  var e2, r = [];
  for (e2 = 0; e2 < 64; e2 += 4) r[e2 >> 2] = t2.charCodeAt(e2) + (t2.charCodeAt(e2 + 1) << 8) + (t2.charCodeAt(e2 + 2) << 16) + (t2.charCodeAt(e2 + 3) << 24);
  return r;
}
u$1 = n.atob.bind(n), h = n.btoa.bind(n);
var N = "0123456789abcdef".split("");
function L$1(t2) {
  for (var e2 = "", r = 0; r < 4; r++) e2 += N[t2 >> 8 * r + 4 & 15] + N[t2 >> 8 * r & 15];
  return e2;
}
function A$1(t2) {
  return String.fromCharCode((255 & t2) >> 0, (65280 & t2) >> 8, (16711680 & t2) >> 16, (4278190080 & t2) >> 24);
}
function x(t2) {
  return y(t2).map(A$1).join("");
}
var S = "5d41402abc4b2a76b9719d911017c592" != function(t2) {
  for (var e2 = 0; e2 < t2.length; e2++) t2[e2] = L$1(t2[e2]);
  return t2.join("");
}(y("hello"));
function _(t2, e2) {
  if (S) {
    var r = (65535 & t2) + (65535 & e2);
    return (t2 >> 16) + (e2 >> 16) + (r >> 16) << 16 | 65535 & r;
  }
  return t2 + e2 & 4294967295;
}
/**
 * @license
 * FPDF is released under a permissive license: there is no usage restriction.
 * You may embed it freely in your application (commercial or not), with or
 * without modifications.
 *
 * Reference: http://www.fpdf.org/en/script/script37.php
 */
function P(t2, e2) {
  var r, n2, i, a2;
  if (t2 !== r) {
    for (var o2 = (i = t2, a2 = 1 + (256 / t2.length >> 0), new Array(a2 + 1).join(i)), s2 = [], c2 = 0; c2 < 256; c2++) s2[c2] = c2;
    var u2 = 0;
    for (c2 = 0; c2 < 256; c2++) {
      var h2 = s2[c2];
      u2 = (u2 + h2 + o2.charCodeAt(c2)) % 256, s2[c2] = s2[u2], s2[u2] = h2;
    }
    r = t2, n2 = s2;
  } else s2 = n2;
  var l2 = e2.length, f2 = 0, d2 = 0, p2 = "";
  for (c2 = 0; c2 < l2; c2++) d2 = (d2 + (h2 = s2[f2 = (f2 + 1) % 256])) % 256, s2[f2] = s2[d2], s2[d2] = h2, o2 = s2[(s2[f2] + s2[d2]) % 256], p2 += String.fromCharCode(e2.charCodeAt(c2) ^ o2);
  return p2;
}
/**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 * Author: Owen Leong (@owenl131)
 * Date: 15 Oct 2020
 * References:
 * https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
 * https://github.com/foliojs/pdfkit/blob/master/lib/security.js
 * http://www.fpdf.org/en/script/script37.php
 */
var k = { print: 4, modify: 8, copy: 16, "annot-forms": 32 };
function I(t2, e2, r, n2) {
  this.v = 1, this.r = 2;
  var i = 192;
  t2.forEach(function(t3) {
    if (void 0 !== k.perm) throw new Error("Invalid permission: " + t3);
    i += k[t3];
  }), this.padding = "(¿N^NuAd\0NVÿú\b..\0¶Ðh>/\f©þdSiz";
  var a2 = (e2 + this.padding).substr(0, 32), o2 = (r + this.padding).substr(0, 32);
  this.O = this.processOwnerPassword(a2, o2), this.P = -(1 + (255 ^ i)), this.encryptionKey = x(a2 + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(n2)).substr(0, 5), this.U = P(this.encryptionKey, this.padding);
}
function F$1(t2) {
  if (/[^\u0000-\u00ff]/.test(t2)) throw new Error("Invalid PDF Name Object: " + t2 + ", Only accept ASCII characters.");
  for (var e2 = "", r = t2.length, n2 = 0; n2 < r; n2++) {
    var i = t2.charCodeAt(n2);
    if (i < 33 || 35 === i || 37 === i || 40 === i || 41 === i || 47 === i || 60 === i || 62 === i || 91 === i || 93 === i || 123 === i || 125 === i || i > 126) e2 += "#" + ("0" + i.toString(16)).slice(-2);
    else e2 += t2[n2];
  }
  return e2;
}
function C(e2) {
  if ("object" !== _typeof(e2)) throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
  var r = {};
  this.subscribe = function(t2, e3, n2) {
    if (n2 = n2 || false, "string" != typeof t2 || "function" != typeof e3 || "boolean" != typeof n2) throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
    r.hasOwnProperty(t2) || (r[t2] = {});
    var i = Math.random().toString(35);
    return r[t2][i] = [e3, !!n2], i;
  }, this.unsubscribe = function(t2) {
    for (var e3 in r) if (r[e3][t2]) return delete r[e3][t2], 0 === Object.keys(r[e3]).length && delete r[e3], true;
    return false;
  }, this.publish = function(t2) {
    if (r.hasOwnProperty(t2)) {
      var i = Array.prototype.slice.call(arguments, 1), o2 = [];
      for (var s2 in r[t2]) {
        var c2 = r[t2][s2];
        try {
          c2[0].apply(e2, i);
        } catch (t3) {
          n.console && a$1.error("jsPDF PubSub Error", t3.message, t3);
        }
        c2[1] && o2.push(s2);
      }
      o2.length && o2.forEach(this.unsubscribe);
    }
  }, this.getTopics = function() {
    return r;
  };
}
function j(t2) {
  if (!(this instanceof j)) return new j(t2);
  var e2 = "opacity,stroke-opacity".split(",");
  for (var r in t2) t2.hasOwnProperty(r) && e2.indexOf(r) >= 0 && (this[r] = t2[r]);
  this.id = "", this.objectNumber = -1;
}
function O(t2, e2) {
  this.gState = t2, this.matrix = e2, this.id = "", this.objectNumber = -1;
}
function B(t2, e2, r, n2, i) {
  if (!(this instanceof B)) return new B(t2, e2, r, n2, i);
  this.type = "axial" === t2 ? 2 : 3, this.coords = e2, this.colors = r, O.call(this, n2, i);
}
function M(t2, e2, r, n2, i) {
  if (!(this instanceof M)) return new M(t2, e2, r, n2, i);
  this.boundingBox = t2, this.xStep = e2, this.yStep = r, this.stream = "", this.cloneIndex = 0, O.call(this, n2, i);
}
function E$1(e2) {
  var r, i = "string" == typeof arguments[0] ? arguments[0] : "p", o2 = arguments[1], s2 = arguments[2], c2 = arguments[3], u2 = [], d2 = 1, p2 = 16, g2 = "S", m2 = null;
  "object" === _typeof(e2 = e2 || {}) && (i = e2.orientation, o2 = e2.unit || o2, s2 = e2.format || s2, c2 = e2.compress || e2.compressPdf || c2, null !== (m2 = e2.encryption || null) && (m2.userPassword = m2.userPassword || "", m2.ownerPassword = m2.ownerPassword || "", m2.userPermissions = m2.userPermissions || []), d2 = "number" == typeof e2.userUnit ? Math.abs(e2.userUnit) : 1, void 0 !== e2.precision && (r = e2.precision), void 0 !== e2.floatPrecision && (p2 = e2.floatPrecision), g2 = e2.defaultPathOperation || "S"), u2 = e2.filters || (true === c2 ? ["FlateEncode"] : u2), o2 = o2 || "mm", i = ("" + (i || "P")).toLowerCase();
  var v2 = e2.putOnlyUsedFonts || false, b2 = {}, y2 = { internal: {}, __private__: {} };
  y2.__private__.PubSub = C;
  var w2 = "1.3", N2 = y2.__private__.getPdfVersion = function() {
    return w2;
  };
  y2.__private__.setPdfVersion = function(t2) {
    w2 = t2;
  };
  var L2 = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
  y2.__private__.getPageFormats = function() {
    return L2;
  };
  var A2 = y2.__private__.getPageFormat = function(t2) {
    return L2[t2];
  };
  s2 = s2 || "a4";
  var x2 = { COMPAT: "compat", ADVANCED: "advanced" }, S2 = x2.COMPAT;
  function _2() {
    this.saveGraphicsState(), lt2(new Vt2(_t2, 0, 0, -_t2, 0, Rr() * _t2).toString() + " cm"), this.setFontSize(this.getFontSize() / _t2), g2 = "n", S2 = x2.ADVANCED;
  }
  function P2() {
    this.restoreGraphicsState(), g2 = "S", S2 = x2.COMPAT;
  }
  var k2 = y2.__private__.combineFontStyleAndFontWeight = function(t2, e3) {
    if ("bold" == t2 && "normal" == e3 || "bold" == t2 && 400 == e3 || "normal" == t2 && "italic" == e3 || "bold" == t2 && "italic" == e3) throw new Error("Invalid Combination of fontweight and fontstyle");
    return e3 && (t2 = 400 == e3 || "normal" === e3 ? "italic" === t2 ? "italic" : "normal" : 700 != e3 && "bold" !== e3 || "normal" !== t2 ? (700 == e3 ? "bold" : e3) + "" + t2 : "bold"), t2;
  };
  y2.advancedAPI = function(t2) {
    var e3 = S2 === x2.COMPAT;
    return e3 && _2.call(this), "function" != typeof t2 || (t2(this), e3 && P2.call(this)), this;
  }, y2.compatAPI = function(t2) {
    var e3 = S2 === x2.ADVANCED;
    return e3 && P2.call(this), "function" != typeof t2 || (t2(this), e3 && _2.call(this)), this;
  }, y2.isAdvancedAPI = function() {
    return S2 === x2.ADVANCED;
  };
  var O2, q2 = function(t2) {
    if (S2 !== x2.ADVANCED) throw new Error(t2 + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
  }, D2 = y2.roundToPrecision = y2.__private__.roundToPrecision = function(t2, e3) {
    var n2 = r || e3;
    if (isNaN(t2) || isNaN(n2)) throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
    return t2.toFixed(n2).replace(/0+$/, "");
  };
  O2 = y2.hpf = y2.__private__.hpf = "number" == typeof p2 ? function(t2) {
    if (isNaN(t2)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return D2(t2, p2);
  } : "smart" === p2 ? function(t2) {
    if (isNaN(t2)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return D2(t2, t2 > -1 && t2 < 1 ? 16 : 5);
  } : function(t2) {
    if (isNaN(t2)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return D2(t2, 16);
  };
  var R2 = y2.f2 = y2.__private__.f2 = function(t2) {
    if (isNaN(t2)) throw new Error("Invalid argument passed to jsPDF.f2");
    return D2(t2, 2);
  }, T2 = y2.__private__.f3 = function(t2) {
    if (isNaN(t2)) throw new Error("Invalid argument passed to jsPDF.f3");
    return D2(t2, 3);
  }, U2 = y2.scale = y2.__private__.scale = function(t2) {
    if (isNaN(t2)) throw new Error("Invalid argument passed to jsPDF.scale");
    return S2 === x2.COMPAT ? t2 * _t2 : S2 === x2.ADVANCED ? t2 : void 0;
  }, z2 = function(t2) {
    return S2 === x2.COMPAT ? Rr() - t2 : S2 === x2.ADVANCED ? t2 : void 0;
  }, H4 = function(t2) {
    return U2(z2(t2));
  };
  y2.__private__.setPrecision = y2.setPrecision = function(t2) {
    "number" == typeof parseInt(t2, 10) && (r = parseInt(t2, 10));
  };
  var W2, V2 = "00000000000000000000000000000000", G2 = y2.__private__.getFileId = function() {
    return V2;
  }, Y2 = y2.__private__.setFileId = function(t2) {
    return V2 = void 0 !== t2 && /^[a-fA-F0-9]{32}$/.test(t2) ? t2.toUpperCase() : V2.split("").map(function() {
      return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
    }).join(""), null !== m2 && (Ye = new I(m2.userPermissions, m2.userPassword, m2.ownerPassword, V2)), V2;
  };
  y2.setFileId = function(t2) {
    return Y2(t2), this;
  }, y2.getFileId = function() {
    return G2();
  };
  var J2 = y2.__private__.convertDateToPDFDate = function(t2) {
    var e3 = t2.getTimezoneOffset(), r2 = e3 < 0 ? "+" : "-", n2 = Math.floor(Math.abs(e3 / 60)), i2 = Math.abs(e3 % 60), a2 = [r2, Q2(n2), "'", Q2(i2), "'"].join("");
    return ["D:", t2.getFullYear(), Q2(t2.getMonth() + 1), Q2(t2.getDate()), Q2(t2.getHours()), Q2(t2.getMinutes()), Q2(t2.getSeconds()), a2].join("");
  }, X2 = y2.__private__.convertPDFDateToDate = function(t2) {
    var e3 = parseInt(t2.substr(2, 4), 10), r2 = parseInt(t2.substr(6, 2), 10) - 1, n2 = parseInt(t2.substr(8, 2), 10), i2 = parseInt(t2.substr(10, 2), 10), a2 = parseInt(t2.substr(12, 2), 10), o3 = parseInt(t2.substr(14, 2), 10);
    return new Date(e3, r2, n2, i2, a2, o3, 0);
  }, K2 = y2.__private__.setCreationDate = function(t2) {
    var e3;
    if (void 0 === t2 && (t2 = /* @__PURE__ */ new Date()), t2 instanceof Date) e3 = J2(t2);
    else {
      if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(t2)) throw new Error("Invalid argument passed to jsPDF.setCreationDate");
      e3 = t2;
    }
    return W2 = e3;
  }, Z2 = y2.__private__.getCreationDate = function(t2) {
    var e3 = W2;
    return "jsDate" === t2 && (e3 = X2(W2)), e3;
  };
  y2.setCreationDate = function(t2) {
    return K2(t2), this;
  }, y2.getCreationDate = function(t2) {
    return Z2(t2);
  };
  var $2, Q2 = y2.__private__.padd2 = function(t2) {
    return ("0" + parseInt(t2)).slice(-2);
  }, tt2 = y2.__private__.padd2Hex = function(t2) {
    return ("00" + (t2 = t2.toString())).substr(t2.length);
  }, et2 = 0, rt2 = [], nt2 = [], it2 = 0, at2 = [], ot2 = [], st2 = false, ct2 = nt2, ut2 = function() {
    et2 = 0, it2 = 0, nt2 = [], rt2 = [], at2 = [], Qt2 = Kt2(), te2 = Kt2();
  };
  y2.__private__.setCustomOutputDestination = function(t2) {
    st2 = true, ct2 = t2;
  };
  var ht2 = function(t2) {
    st2 || (ct2 = t2);
  };
  y2.__private__.resetCustomOutputDestination = function() {
    st2 = false, ct2 = nt2;
  };
  var lt2 = y2.__private__.out = function(t2) {
    return t2 = t2.toString(), it2 += t2.length + 1, ct2.push(t2), ct2;
  }, ft2 = y2.__private__.write = function(t2) {
    return lt2(1 === arguments.length ? t2.toString() : Array.prototype.join.call(arguments, " "));
  }, dt2 = y2.__private__.getArrayBuffer = function(t2) {
    for (var e3 = t2.length, r2 = new ArrayBuffer(e3), n2 = new Uint8Array(r2); e3--; ) n2[e3] = t2.charCodeAt(e3);
    return r2;
  }, pt2 = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]];
  y2.__private__.getStandardFonts = function() {
    return pt2;
  };
  var gt2 = e2.fontSize || 16;
  y2.__private__.setFontSize = y2.setFontSize = function(t2) {
    return gt2 = S2 === x2.ADVANCED ? t2 / _t2 : t2, this;
  };
  var mt2, vt2 = y2.__private__.getFontSize = y2.getFontSize = function() {
    return S2 === x2.COMPAT ? gt2 : gt2 * _t2;
  }, bt2 = e2.R2L || false;
  y2.__private__.setR2L = y2.setR2L = function(t2) {
    return bt2 = t2, this;
  }, y2.__private__.getR2L = y2.getR2L = function() {
    return bt2;
  };
  var yt2, wt2 = y2.__private__.setZoomMode = function(t2) {
    var e3 = [void 0, null, "fullwidth", "fullheight", "fullpage", "original"];
    if (/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(t2)) mt2 = t2;
    else if (isNaN(t2)) {
      if (-1 === e3.indexOf(t2)) throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + t2 + '" is not recognized.');
      mt2 = t2;
    } else mt2 = parseInt(t2, 10);
  };
  y2.__private__.getZoomMode = function() {
    return mt2;
  };
  var Nt2, Lt2 = y2.__private__.setPageMode = function(t2) {
    if (-1 == [void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(t2)) throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + t2 + '" is not recognized.');
    yt2 = t2;
  };
  y2.__private__.getPageMode = function() {
    return yt2;
  };
  var At2 = y2.__private__.setLayoutMode = function(t2) {
    if (-1 == [void 0, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(t2)) throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + t2 + '" is not recognized.');
    Nt2 = t2;
  };
  y2.__private__.getLayoutMode = function() {
    return Nt2;
  }, y2.__private__.setDisplayMode = y2.setDisplayMode = function(t2, e3, r2) {
    return wt2(t2), At2(e3), Lt2(r2), this;
  };
  var xt2 = { title: "", subject: "", author: "", keywords: "", creator: "" };
  y2.__private__.getDocumentProperty = function(t2) {
    if (-1 === Object.keys(xt2).indexOf(t2)) throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
    return xt2[t2];
  }, y2.__private__.getDocumentProperties = function() {
    return xt2;
  }, y2.__private__.setDocumentProperties = y2.setProperties = y2.setDocumentProperties = function(t2) {
    for (var e3 in xt2) xt2.hasOwnProperty(e3) && t2[e3] && (xt2[e3] = t2[e3]);
    return this;
  }, y2.__private__.setDocumentProperty = function(t2, e3) {
    if (-1 === Object.keys(xt2).indexOf(t2)) throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
    return xt2[t2] = e3;
  };
  var St, _t2, Pt2, kt2, It2, Ft2 = {}, Ct2 = {}, jt2 = [], Ot2 = {}, Bt2 = {}, Mt2 = {}, Et2 = {}, qt2 = null, Dt2 = 0, Rt2 = [], Tt2 = new C(y2), Ut2 = e2.hotfixes || [], zt2 = {}, Ht2 = {}, Wt2 = [], Vt2 = function t2(e3, r2, n2, i2, a2, o3) {
    if (!(this instanceof t2)) return new t2(e3, r2, n2, i2, a2, o3);
    isNaN(e3) && (e3 = 1), isNaN(r2) && (r2 = 0), isNaN(n2) && (n2 = 0), isNaN(i2) && (i2 = 1), isNaN(a2) && (a2 = 0), isNaN(o3) && (o3 = 0), this._matrix = [e3, r2, n2, i2, a2, o3];
  };
  Object.defineProperty(Vt2.prototype, "sx", { get: function() {
    return this._matrix[0];
  }, set: function(t2) {
    this._matrix[0] = t2;
  } }), Object.defineProperty(Vt2.prototype, "shy", { get: function() {
    return this._matrix[1];
  }, set: function(t2) {
    this._matrix[1] = t2;
  } }), Object.defineProperty(Vt2.prototype, "shx", { get: function() {
    return this._matrix[2];
  }, set: function(t2) {
    this._matrix[2] = t2;
  } }), Object.defineProperty(Vt2.prototype, "sy", { get: function() {
    return this._matrix[3];
  }, set: function(t2) {
    this._matrix[3] = t2;
  } }), Object.defineProperty(Vt2.prototype, "tx", { get: function() {
    return this._matrix[4];
  }, set: function(t2) {
    this._matrix[4] = t2;
  } }), Object.defineProperty(Vt2.prototype, "ty", { get: function() {
    return this._matrix[5];
  }, set: function(t2) {
    this._matrix[5] = t2;
  } }), Object.defineProperty(Vt2.prototype, "a", { get: function() {
    return this._matrix[0];
  }, set: function(t2) {
    this._matrix[0] = t2;
  } }), Object.defineProperty(Vt2.prototype, "b", { get: function() {
    return this._matrix[1];
  }, set: function(t2) {
    this._matrix[1] = t2;
  } }), Object.defineProperty(Vt2.prototype, "c", { get: function() {
    return this._matrix[2];
  }, set: function(t2) {
    this._matrix[2] = t2;
  } }), Object.defineProperty(Vt2.prototype, "d", { get: function() {
    return this._matrix[3];
  }, set: function(t2) {
    this._matrix[3] = t2;
  } }), Object.defineProperty(Vt2.prototype, "e", { get: function() {
    return this._matrix[4];
  }, set: function(t2) {
    this._matrix[4] = t2;
  } }), Object.defineProperty(Vt2.prototype, "f", { get: function() {
    return this._matrix[5];
  }, set: function(t2) {
    this._matrix[5] = t2;
  } }), Object.defineProperty(Vt2.prototype, "rotation", { get: function() {
    return Math.atan2(this.shx, this.sx);
  } }), Object.defineProperty(Vt2.prototype, "scaleX", { get: function() {
    return this.decompose().scale.sx;
  } }), Object.defineProperty(Vt2.prototype, "scaleY", { get: function() {
    return this.decompose().scale.sy;
  } }), Object.defineProperty(Vt2.prototype, "isIdentity", { get: function() {
    return 1 === this.sx && (0 === this.shy && (0 === this.shx && (1 === this.sy && (0 === this.tx && 0 === this.ty))));
  } }), Vt2.prototype.join = function(t2) {
    return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(O2).join(t2);
  }, Vt2.prototype.multiply = function(t2) {
    var e3 = t2.sx * this.sx + t2.shy * this.shx, r2 = t2.sx * this.shy + t2.shy * this.sy, n2 = t2.shx * this.sx + t2.sy * this.shx, i2 = t2.shx * this.shy + t2.sy * this.sy, a2 = t2.tx * this.sx + t2.ty * this.shx + this.tx, o3 = t2.tx * this.shy + t2.ty * this.sy + this.ty;
    return new Vt2(e3, r2, n2, i2, a2, o3);
  }, Vt2.prototype.decompose = function() {
    var t2 = this.sx, e3 = this.shy, r2 = this.shx, n2 = this.sy, i2 = this.tx, a2 = this.ty, o3 = Math.sqrt(t2 * t2 + e3 * e3), s3 = (t2 /= o3) * r2 + (e3 /= o3) * n2;
    r2 -= t2 * s3, n2 -= e3 * s3;
    var c3 = Math.sqrt(r2 * r2 + n2 * n2);
    return s3 /= c3, t2 * (n2 /= c3) < e3 * (r2 /= c3) && (t2 = -t2, e3 = -e3, s3 = -s3, o3 = -o3), { scale: new Vt2(o3, 0, 0, c3, 0, 0), translate: new Vt2(1, 0, 0, 1, i2, a2), rotate: new Vt2(t2, e3, -e3, t2, 0, 0), skew: new Vt2(1, 0, s3, 1, 0, 0) };
  }, Vt2.prototype.toString = function(t2) {
    return this.join(" ");
  }, Vt2.prototype.inversed = function() {
    var t2 = this.sx, e3 = this.shy, r2 = this.shx, n2 = this.sy, i2 = this.tx, a2 = this.ty, o3 = 1 / (t2 * n2 - e3 * r2), s3 = n2 * o3, c3 = -e3 * o3, u3 = -r2 * o3, h2 = t2 * o3;
    return new Vt2(s3, c3, u3, h2, -s3 * i2 - u3 * a2, -c3 * i2 - h2 * a2);
  }, Vt2.prototype.applyToPoint = function(t2) {
    var e3 = t2.x * this.sx + t2.y * this.shx + this.tx, r2 = t2.x * this.shy + t2.y * this.sy + this.ty;
    return new Cr(e3, r2);
  }, Vt2.prototype.applyToRectangle = function(t2) {
    var e3 = this.applyToPoint(t2), r2 = this.applyToPoint(new Cr(t2.x + t2.w, t2.y + t2.h));
    return new jr(e3.x, e3.y, r2.x - e3.x, r2.y - e3.y);
  }, Vt2.prototype.clone = function() {
    var t2 = this.sx, e3 = this.shy, r2 = this.shx, n2 = this.sy, i2 = this.tx, a2 = this.ty;
    return new Vt2(t2, e3, r2, n2, i2, a2);
  }, y2.Matrix = Vt2;
  var Gt2 = y2.matrixMult = function(t2, e3) {
    return e3.multiply(t2);
  }, Yt2 = new Vt2(1, 0, 0, 1, 0, 0);
  y2.unitMatrix = y2.identityMatrix = Yt2;
  var Jt2 = function(t2, e3) {
    if (!Bt2[t2]) {
      var r2 = (e3 instanceof B ? "Sh" : "P") + (Object.keys(Ot2).length + 1).toString(10);
      e3.id = r2, Bt2[t2] = r2, Ot2[r2] = e3, Tt2.publish("addPattern", e3);
    }
  };
  y2.ShadingPattern = B, y2.TilingPattern = M, y2.addShadingPattern = function(t2, e3) {
    return q2("addShadingPattern()"), Jt2(t2, e3), this;
  }, y2.beginTilingPattern = function(t2) {
    q2("beginTilingPattern()"), Br(t2.boundingBox[0], t2.boundingBox[1], t2.boundingBox[2] - t2.boundingBox[0], t2.boundingBox[3] - t2.boundingBox[1], t2.matrix);
  }, y2.endTilingPattern = function(t2, e3) {
    q2("endTilingPattern()"), e3.stream = ot2[$2].join("\n"), Jt2(t2, e3), Tt2.publish("endTilingPattern", e3), Wt2.pop().restore();
  };
  var Xt2 = y2.__private__.newObject = function() {
    var t2 = Kt2();
    return Zt2(t2, true), t2;
  }, Kt2 = y2.__private__.newObjectDeferred = function() {
    return et2++, rt2[et2] = function() {
      return it2;
    }, et2;
  }, Zt2 = function(t2, e3) {
    return e3 = "boolean" == typeof e3 && e3, rt2[t2] = it2, e3 && lt2(t2 + " 0 obj"), t2;
  }, $t2 = y2.__private__.newAdditionalObject = function() {
    var t2 = { objId: Kt2(), content: "" };
    return at2.push(t2), t2;
  }, Qt2 = Kt2(), te2 = Kt2(), ee2 = y2.__private__.decodeColorString = function(t2) {
    var e3 = t2.split(" ");
    if (2 !== e3.length || "g" !== e3[1] && "G" !== e3[1]) {
      if (5 === e3.length && ("k" === e3[4] || "K" === e3[4])) {
        e3 = [(1 - e3[0]) * (1 - e3[3]), (1 - e3[1]) * (1 - e3[3]), (1 - e3[2]) * (1 - e3[3]), "r"];
      }
    } else {
      var r2 = parseFloat(e3[0]);
      e3 = [r2, r2, r2, "r"];
    }
    for (var n2 = "#", i2 = 0; i2 < 3; i2++) n2 += ("0" + Math.floor(255 * parseFloat(e3[i2])).toString(16)).slice(-2);
    return n2;
  }, re2 = y2.__private__.encodeColorString = function(e3) {
    var r2;
    "string" == typeof e3 && (e3 = { ch1: e3 });
    var n2 = e3.ch1, i2 = e3.ch2, a2 = e3.ch3, o3 = e3.ch4, s3 = "draw" === e3.pdfColorType ? ["G", "RG", "K"] : ["g", "rg", "k"];
    if ("string" == typeof n2 && "#" !== n2.charAt(0)) {
      var c3 = new f$1(n2);
      if (c3.ok) n2 = c3.toHex();
      else if (!/^\d*\.?\d*$/.test(n2)) throw new Error('Invalid color "' + n2 + '" passed to jsPDF.encodeColorString.');
    }
    if ("string" == typeof n2 && /^#[0-9A-Fa-f]{3}$/.test(n2) && (n2 = "#" + n2[1] + n2[1] + n2[2] + n2[2] + n2[3] + n2[3]), "string" == typeof n2 && /^#[0-9A-Fa-f]{6}$/.test(n2)) {
      var u3 = parseInt(n2.substr(1), 16);
      n2 = u3 >> 16 & 255, i2 = u3 >> 8 & 255, a2 = 255 & u3;
    }
    if (void 0 === i2 || void 0 === o3 && n2 === i2 && i2 === a2) if ("string" == typeof n2) r2 = n2 + " " + s3[0];
    else switch (e3.precision) {
      case 2:
        r2 = R2(n2 / 255) + " " + s3[0];
        break;
      case 3:
      default:
        r2 = T2(n2 / 255) + " " + s3[0];
    }
    else if (void 0 === o3 || "object" === _typeof(o3)) {
      if (o3 && !isNaN(o3.a) && 0 === o3.a) return r2 = ["1.", "1.", "1.", s3[1]].join(" ");
      if ("string" == typeof n2) r2 = [n2, i2, a2, s3[1]].join(" ");
      else switch (e3.precision) {
        case 2:
          r2 = [R2(n2 / 255), R2(i2 / 255), R2(a2 / 255), s3[1]].join(" ");
          break;
        default:
        case 3:
          r2 = [T2(n2 / 255), T2(i2 / 255), T2(a2 / 255), s3[1]].join(" ");
      }
    } else if ("string" == typeof n2) r2 = [n2, i2, a2, o3, s3[2]].join(" ");
    else switch (e3.precision) {
      case 2:
        r2 = [R2(n2), R2(i2), R2(a2), R2(o3), s3[2]].join(" ");
        break;
      case 3:
      default:
        r2 = [T2(n2), T2(i2), T2(a2), T2(o3), s3[2]].join(" ");
    }
    return r2;
  }, ne2 = y2.__private__.getFilters = function() {
    return u2;
  }, ie2 = y2.__private__.putStream = function(t2) {
    var e3 = (t2 = t2 || {}).data || "", r2 = t2.filters || ne2(), n2 = t2.alreadyAppliedFilters || [], i2 = t2.addLength1 || false, a2 = e3.length, o3 = t2.objectId, s3 = function(t3) {
      return t3;
    };
    if (null !== m2 && void 0 === o3) throw new Error("ObjectId must be passed to putStream for file encryption");
    null !== m2 && (s3 = Ye.encryptor(o3, 0));
    var c3 = {};
    true === r2 && (r2 = ["FlateEncode"]);
    var u3 = t2.additionalKeyValues || [], h2 = (c3 = void 0 !== E$1.API.processDataByFilters ? E$1.API.processDataByFilters(e3, r2) : { data: e3, reverseChain: [] }).reverseChain + (Array.isArray(n2) ? n2.join(" ") : n2.toString());
    if (0 !== c3.data.length && (u3.push({ key: "Length", value: c3.data.length }), true === i2 && u3.push({ key: "Length1", value: a2 })), 0 != h2.length) if (h2.split("/").length - 1 == 1) u3.push({ key: "Filter", value: h2 });
    else {
      u3.push({ key: "Filter", value: "[" + h2 + "]" });
      for (var l2 = 0; l2 < u3.length; l2 += 1) if ("DecodeParms" === u3[l2].key) {
        for (var f2 = [], d3 = 0; d3 < c3.reverseChain.split("/").length - 1; d3 += 1) f2.push("null");
        f2.push(u3[l2].value), u3[l2].value = "[" + f2.join(" ") + "]";
      }
    }
    lt2("<<");
    for (var p3 = 0; p3 < u3.length; p3++) lt2("/" + u3[p3].key + " " + u3[p3].value);
    lt2(">>"), 0 !== c3.data.length && (lt2("stream"), lt2(s3(c3.data)), lt2("endstream"));
  }, ae2 = y2.__private__.putPage = function(t2) {
    var e3 = t2.number, r2 = t2.data, n2 = t2.objId, i2 = t2.contentsObjId;
    Zt2(n2, true), lt2("<</Type /Page"), lt2("/Parent " + t2.rootDictionaryObjId + " 0 R"), lt2("/Resources " + t2.resourceDictionaryObjId + " 0 R"), lt2("/MediaBox [" + parseFloat(O2(t2.mediaBox.bottomLeftX)) + " " + parseFloat(O2(t2.mediaBox.bottomLeftY)) + " " + O2(t2.mediaBox.topRightX) + " " + O2(t2.mediaBox.topRightY) + "]"), null !== t2.cropBox && lt2("/CropBox [" + O2(t2.cropBox.bottomLeftX) + " " + O2(t2.cropBox.bottomLeftY) + " " + O2(t2.cropBox.topRightX) + " " + O2(t2.cropBox.topRightY) + "]"), null !== t2.bleedBox && lt2("/BleedBox [" + O2(t2.bleedBox.bottomLeftX) + " " + O2(t2.bleedBox.bottomLeftY) + " " + O2(t2.bleedBox.topRightX) + " " + O2(t2.bleedBox.topRightY) + "]"), null !== t2.trimBox && lt2("/TrimBox [" + O2(t2.trimBox.bottomLeftX) + " " + O2(t2.trimBox.bottomLeftY) + " " + O2(t2.trimBox.topRightX) + " " + O2(t2.trimBox.topRightY) + "]"), null !== t2.artBox && lt2("/ArtBox [" + O2(t2.artBox.bottomLeftX) + " " + O2(t2.artBox.bottomLeftY) + " " + O2(t2.artBox.topRightX) + " " + O2(t2.artBox.topRightY) + "]"), "number" == typeof t2.userUnit && 1 !== t2.userUnit && lt2("/UserUnit " + t2.userUnit), Tt2.publish("putPage", { objId: n2, pageContext: Rt2[e3], pageNumber: e3, page: r2 }), lt2("/Contents " + i2 + " 0 R"), lt2(">>"), lt2("endobj");
    var a2 = r2.join("\n");
    return S2 === x2.ADVANCED && (a2 += "\nQ"), Zt2(i2, true), ie2({ data: a2, filters: ne2(), objectId: i2 }), lt2("endobj"), n2;
  }, oe2 = y2.__private__.putPages = function() {
    var t2, e3, r2 = [];
    for (t2 = 1; t2 <= Dt2; t2++) Rt2[t2].objId = Kt2(), Rt2[t2].contentsObjId = Kt2();
    for (t2 = 1; t2 <= Dt2; t2++) r2.push(ae2({ number: t2, data: ot2[t2], objId: Rt2[t2].objId, contentsObjId: Rt2[t2].contentsObjId, mediaBox: Rt2[t2].mediaBox, cropBox: Rt2[t2].cropBox, bleedBox: Rt2[t2].bleedBox, trimBox: Rt2[t2].trimBox, artBox: Rt2[t2].artBox, userUnit: Rt2[t2].userUnit, rootDictionaryObjId: Qt2, resourceDictionaryObjId: te2 }));
    Zt2(Qt2, true), lt2("<</Type /Pages");
    var n2 = "/Kids [";
    for (e3 = 0; e3 < Dt2; e3++) n2 += r2[e3] + " 0 R ";
    lt2(n2 + "]"), lt2("/Count " + Dt2), lt2(">>"), lt2("endobj"), Tt2.publish("postPutPages");
  }, se2 = function(t2) {
    Tt2.publish("putFont", { font: t2, out: lt2, newObject: Xt2, putStream: ie2 }), true !== t2.isAlreadyPutted && (t2.objectNumber = Xt2(), lt2("<<"), lt2("/Type /Font"), lt2("/BaseFont /" + F$1(t2.postScriptName)), lt2("/Subtype /Type1"), "string" == typeof t2.encoding && lt2("/Encoding /" + t2.encoding), lt2("/FirstChar 32"), lt2("/LastChar 255"), lt2(">>"), lt2("endobj"));
  }, ce2 = function() {
    for (var t2 in Ft2) Ft2.hasOwnProperty(t2) && (false === v2 || true === v2 && b2.hasOwnProperty(t2)) && se2(Ft2[t2]);
  }, ue2 = function(t2) {
    t2.objectNumber = Xt2();
    var e3 = [];
    e3.push({ key: "Type", value: "/XObject" }), e3.push({ key: "Subtype", value: "/Form" }), e3.push({ key: "BBox", value: "[" + [O2(t2.x), O2(t2.y), O2(t2.x + t2.width), O2(t2.y + t2.height)].join(" ") + "]" }), e3.push({ key: "Matrix", value: "[" + t2.matrix.toString() + "]" });
    var r2 = t2.pages[1].join("\n");
    ie2({ data: r2, additionalKeyValues: e3, objectId: t2.objectNumber }), lt2("endobj");
  }, he2 = function() {
    for (var t2 in zt2) zt2.hasOwnProperty(t2) && ue2(zt2[t2]);
  }, le2 = function(t2, e3) {
    var r2, n2 = [], i2 = 1 / (e3 - 1);
    for (r2 = 0; r2 < 1; r2 += i2) n2.push(r2);
    if (n2.push(1), 0 != t2[0].offset) {
      var a2 = { offset: 0, color: t2[0].color };
      t2.unshift(a2);
    }
    if (1 != t2[t2.length - 1].offset) {
      var o3 = { offset: 1, color: t2[t2.length - 1].color };
      t2.push(o3);
    }
    for (var s3 = "", c3 = 0, u3 = 0; u3 < n2.length; u3++) {
      for (r2 = n2[u3]; r2 > t2[c3 + 1].offset; ) c3++;
      var h2 = t2[c3].offset, l2 = (r2 - h2) / (t2[c3 + 1].offset - h2), f2 = t2[c3].color, d3 = t2[c3 + 1].color;
      s3 += tt2(Math.round((1 - l2) * f2[0] + l2 * d3[0]).toString(16)) + tt2(Math.round((1 - l2) * f2[1] + l2 * d3[1]).toString(16)) + tt2(Math.round((1 - l2) * f2[2] + l2 * d3[2]).toString(16));
    }
    return s3.trim();
  }, fe2 = function(t2, e3) {
    e3 || (e3 = 21);
    var r2 = Xt2(), n2 = le2(t2.colors, e3), i2 = [];
    i2.push({ key: "FunctionType", value: "0" }), i2.push({ key: "Domain", value: "[0.0 1.0]" }), i2.push({ key: "Size", value: "[" + e3 + "]" }), i2.push({ key: "BitsPerSample", value: "8" }), i2.push({ key: "Range", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), i2.push({ key: "Decode", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), ie2({ data: n2, additionalKeyValues: i2, alreadyAppliedFilters: ["/ASCIIHexDecode"], objectId: r2 }), lt2("endobj"), t2.objectNumber = Xt2(), lt2("<< /ShadingType " + t2.type), lt2("/ColorSpace /DeviceRGB");
    var a2 = "/Coords [" + O2(parseFloat(t2.coords[0])) + " " + O2(parseFloat(t2.coords[1])) + " ";
    2 === t2.type ? a2 += O2(parseFloat(t2.coords[2])) + " " + O2(parseFloat(t2.coords[3])) : a2 += O2(parseFloat(t2.coords[2])) + " " + O2(parseFloat(t2.coords[3])) + " " + O2(parseFloat(t2.coords[4])) + " " + O2(parseFloat(t2.coords[5])), lt2(a2 += "]"), t2.matrix && lt2("/Matrix [" + t2.matrix.toString() + "]"), lt2("/Function " + r2 + " 0 R"), lt2("/Extend [true true]"), lt2(">>"), lt2("endobj");
  }, de2 = function(t2, e3) {
    var r2 = Kt2(), n2 = Xt2();
    e3.push({ resourcesOid: r2, objectOid: n2 }), t2.objectNumber = n2;
    var i2 = [];
    i2.push({ key: "Type", value: "/Pattern" }), i2.push({ key: "PatternType", value: "1" }), i2.push({ key: "PaintType", value: "1" }), i2.push({ key: "TilingType", value: "1" }), i2.push({ key: "BBox", value: "[" + t2.boundingBox.map(O2).join(" ") + "]" }), i2.push({ key: "XStep", value: O2(t2.xStep) }), i2.push({ key: "YStep", value: O2(t2.yStep) }), i2.push({ key: "Resources", value: r2 + " 0 R" }), t2.matrix && i2.push({ key: "Matrix", value: "[" + t2.matrix.toString() + "]" }), ie2({ data: t2.stream, additionalKeyValues: i2, objectId: t2.objectNumber }), lt2("endobj");
  }, pe2 = function(t2) {
    var e3;
    for (e3 in Ot2) Ot2.hasOwnProperty(e3) && (Ot2[e3] instanceof B ? fe2(Ot2[e3]) : Ot2[e3] instanceof M && de2(Ot2[e3], t2));
  }, ge2 = function(t2) {
    for (var e3 in t2.objectNumber = Xt2(), lt2("<<"), t2) switch (e3) {
      case "opacity":
        lt2("/ca " + R2(t2[e3]));
        break;
      case "stroke-opacity":
        lt2("/CA " + R2(t2[e3]));
    }
    lt2(">>"), lt2("endobj");
  }, me2 = function() {
    var t2;
    for (t2 in Mt2) Mt2.hasOwnProperty(t2) && ge2(Mt2[t2]);
  }, ve2 = function() {
    for (var t2 in lt2("/XObject <<"), zt2) zt2.hasOwnProperty(t2) && zt2[t2].objectNumber >= 0 && lt2("/" + t2 + " " + zt2[t2].objectNumber + " 0 R");
    Tt2.publish("putXobjectDict"), lt2(">>");
  }, be2 = function() {
    Ye.oid = Xt2(), lt2("<<"), lt2("/Filter /Standard"), lt2("/V " + Ye.v), lt2("/R " + Ye.r), lt2("/U <" + Ye.toHexString(Ye.U) + ">"), lt2("/O <" + Ye.toHexString(Ye.O) + ">"), lt2("/P " + Ye.P), lt2(">>"), lt2("endobj");
  }, ye2 = function() {
    for (var t2 in lt2("/Font <<"), Ft2) Ft2.hasOwnProperty(t2) && (false === v2 || true === v2 && b2.hasOwnProperty(t2)) && lt2("/" + t2 + " " + Ft2[t2].objectNumber + " 0 R");
    lt2(">>");
  }, we2 = function() {
    if (Object.keys(Ot2).length > 0) {
      for (var t2 in lt2("/Shading <<"), Ot2) Ot2.hasOwnProperty(t2) && Ot2[t2] instanceof B && Ot2[t2].objectNumber >= 0 && lt2("/" + t2 + " " + Ot2[t2].objectNumber + " 0 R");
      Tt2.publish("putShadingPatternDict"), lt2(">>");
    }
  }, Ne2 = function(t2) {
    if (Object.keys(Ot2).length > 0) {
      for (var e3 in lt2("/Pattern <<"), Ot2) Ot2.hasOwnProperty(e3) && Ot2[e3] instanceof y2.TilingPattern && Ot2[e3].objectNumber >= 0 && Ot2[e3].objectNumber < t2 && lt2("/" + e3 + " " + Ot2[e3].objectNumber + " 0 R");
      Tt2.publish("putTilingPatternDict"), lt2(">>");
    }
  }, Le2 = function() {
    if (Object.keys(Mt2).length > 0) {
      var t2;
      for (t2 in lt2("/ExtGState <<"), Mt2) Mt2.hasOwnProperty(t2) && Mt2[t2].objectNumber >= 0 && lt2("/" + t2 + " " + Mt2[t2].objectNumber + " 0 R");
      Tt2.publish("putGStateDict"), lt2(">>");
    }
  }, Ae = function(t2) {
    Zt2(t2.resourcesOid, true), lt2("<<"), lt2("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), ye2(), we2(), Ne2(t2.objectOid), Le2(), ve2(), lt2(">>"), lt2("endobj");
  }, xe = function() {
    var t2 = [];
    ce2(), me2(), he2(), pe2(t2), Tt2.publish("putResources"), t2.forEach(Ae), Ae({ resourcesOid: te2, objectOid: Number.MAX_SAFE_INTEGER }), Tt2.publish("postPutResources");
  }, Se = function() {
    Tt2.publish("putAdditionalObjects");
    for (var t2 = 0; t2 < at2.length; t2++) {
      var e3 = at2[t2];
      Zt2(e3.objId, true), lt2(e3.content), lt2("endobj");
    }
    Tt2.publish("postPutAdditionalObjects");
  }, _e = function(t2) {
    Ct2[t2.fontName] = Ct2[t2.fontName] || {}, Ct2[t2.fontName][t2.fontStyle] = t2.id;
  }, Pe = function(t2, e3, r2, n2, i2) {
    var a2 = { id: "F" + (Object.keys(Ft2).length + 1).toString(10), postScriptName: t2, fontName: e3, fontStyle: r2, encoding: n2, isStandardFont: i2 || false, metadata: {} };
    return Tt2.publish("addFont", { font: a2, instance: this }), Ft2[a2.id] = a2, _e(a2), a2.id;
  }, ke = function(t2) {
    for (var e3 = 0, r2 = pt2.length; e3 < r2; e3++) {
      var n2 = Pe.call(this, t2[e3][0], t2[e3][1], t2[e3][2], pt2[e3][3], true);
      false === v2 && (b2[n2] = true);
      var i2 = t2[e3][0].split("-");
      _e({ id: n2, fontName: i2[0], fontStyle: i2[1] || "" });
    }
    Tt2.publish("addFonts", { fonts: Ft2, dictionary: Ct2 });
  }, Ie = function(t2) {
    return t2.foo = function() {
      try {
        return t2.apply(this, arguments);
      } catch (t3) {
        var e3 = t3.stack || "";
        ~e3.indexOf(" at ") && (e3 = e3.split(" at ")[1]);
        var r2 = "Error in function " + e3.split("\n")[0].split("<")[0] + ": " + t3.message;
        if (!n.console) throw new Error(r2);
        n.console.error(r2, t3), n.alert && alert(r2);
      }
    }, t2.foo.bar = t2, t2.foo;
  }, Fe = function(t2, e3) {
    var r2, n2, i2, a2, o3, s3, c3, u3, h2;
    if (i2 = (e3 = e3 || {}).sourceEncoding || "Unicode", o3 = e3.outputEncoding, (e3.autoencode || o3) && Ft2[St].metadata && Ft2[St].metadata[i2] && Ft2[St].metadata[i2].encoding && (a2 = Ft2[St].metadata[i2].encoding, !o3 && Ft2[St].encoding && (o3 = Ft2[St].encoding), !o3 && a2.codePages && (o3 = a2.codePages[0]), "string" == typeof o3 && (o3 = a2[o3]), o3)) {
      for (c3 = false, s3 = [], r2 = 0, n2 = t2.length; r2 < n2; r2++) (u3 = o3[t2.charCodeAt(r2)]) ? s3.push(String.fromCharCode(u3)) : s3.push(t2[r2]), s3[r2].charCodeAt(0) >> 8 && (c3 = true);
      t2 = s3.join("");
    }
    for (r2 = t2.length; void 0 === c3 && 0 !== r2; ) t2.charCodeAt(r2 - 1) >> 8 && (c3 = true), r2--;
    if (!c3) return t2;
    for (s3 = e3.noBOM ? [] : [254, 255], r2 = 0, n2 = t2.length; r2 < n2; r2++) {
      if ((h2 = (u3 = t2.charCodeAt(r2)) >> 8) >> 8) throw new Error("Character at position " + r2 + " of string '" + t2 + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
      s3.push(h2), s3.push(u3 - (h2 << 8));
    }
    return String.fromCharCode.apply(void 0, s3);
  }, Ce = y2.__private__.pdfEscape = y2.pdfEscape = function(t2, e3) {
    return Fe(t2, e3).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
  }, je = y2.__private__.beginPage = function(t2) {
    ot2[++Dt2] = [], Rt2[Dt2] = { objId: 0, contentsObjId: 0, userUnit: Number(d2), artBox: null, bleedBox: null, cropBox: null, trimBox: null, mediaBox: { bottomLeftX: 0, bottomLeftY: 0, topRightX: Number(t2[0]), topRightY: Number(t2[1]) } }, Me(Dt2), ht2(ot2[$2]);
  }, Oe = function(t2, e3) {
    var r2, n2, o3;
    switch (i = e3 || i, "string" == typeof t2 && (r2 = A2(t2.toLowerCase()), Array.isArray(r2) && (n2 = r2[0], o3 = r2[1])), Array.isArray(t2) && (n2 = t2[0] * _t2, o3 = t2[1] * _t2), isNaN(n2) && (n2 = s2[0], o3 = s2[1]), (n2 > 14400 || o3 > 14400) && (a$1.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), n2 = Math.min(14400, n2), o3 = Math.min(14400, o3)), s2 = [n2, o3], i.substr(0, 1)) {
      case "l":
        o3 > n2 && (s2 = [o3, n2]);
        break;
      case "p":
        n2 > o3 && (s2 = [o3, n2]);
    }
    je(s2), pr(fr), lt2(Lr), 0 !== kr && lt2(kr + " J"), 0 !== Ir && lt2(Ir + " j"), Tt2.publish("addPage", { pageNumber: Dt2 });
  }, Be = function(t2) {
    t2 > 0 && t2 <= Dt2 && (ot2.splice(t2, 1), Rt2.splice(t2, 1), Dt2--, $2 > Dt2 && ($2 = Dt2), this.setPage($2));
  }, Me = function(t2) {
    t2 > 0 && t2 <= Dt2 && ($2 = t2);
  }, Ee = y2.__private__.getNumberOfPages = y2.getNumberOfPages = function() {
    return ot2.length - 1;
  }, qe2 = function(t2, e3, r2) {
    var n2, i2 = void 0;
    return r2 = r2 || {}, t2 = void 0 !== t2 ? t2 : Ft2[St].fontName, e3 = void 0 !== e3 ? e3 : Ft2[St].fontStyle, n2 = t2.toLowerCase(), void 0 !== Ct2[n2] && void 0 !== Ct2[n2][e3] ? i2 = Ct2[n2][e3] : void 0 !== Ct2[t2] && void 0 !== Ct2[t2][e3] ? i2 = Ct2[t2][e3] : false === r2.disableWarning && a$1.warn("Unable to look up font label for font '" + t2 + "', '" + e3 + "'. Refer to getFontList() for available fonts."), i2 || r2.noFallback || null == (i2 = Ct2.times[e3]) && (i2 = Ct2.times.normal), i2;
  }, De = y2.__private__.putInfo = function() {
    var t2 = Xt2(), e3 = function(t3) {
      return t3;
    };
    for (var r2 in null !== m2 && (e3 = Ye.encryptor(t2, 0)), lt2("<<"), lt2("/Producer (" + Ce(e3("jsPDF " + E$1.version)) + ")"), xt2) xt2.hasOwnProperty(r2) && xt2[r2] && lt2("/" + r2.substr(0, 1).toUpperCase() + r2.substr(1) + " (" + Ce(e3(xt2[r2])) + ")");
    lt2("/CreationDate (" + Ce(e3(W2)) + ")"), lt2(">>"), lt2("endobj");
  }, Re = y2.__private__.putCatalog = function(t2) {
    var e3 = (t2 = t2 || {}).rootDictionaryObjId || Qt2;
    switch (Xt2(), lt2("<<"), lt2("/Type /Catalog"), lt2("/Pages " + e3 + " 0 R"), mt2 || (mt2 = "fullwidth"), mt2) {
      case "fullwidth":
        lt2("/OpenAction [3 0 R /FitH null]");
        break;
      case "fullheight":
        lt2("/OpenAction [3 0 R /FitV null]");
        break;
      case "fullpage":
        lt2("/OpenAction [3 0 R /Fit]");
        break;
      case "original":
        lt2("/OpenAction [3 0 R /XYZ null null 1]");
        break;
      default:
        var r2 = "" + mt2;
        "%" === r2.substr(r2.length - 1) && (mt2 = parseInt(mt2) / 100), "number" == typeof mt2 && lt2("/OpenAction [3 0 R /XYZ null null " + R2(mt2) + "]");
    }
    switch (Nt2 || (Nt2 = "continuous"), Nt2) {
      case "continuous":
        lt2("/PageLayout /OneColumn");
        break;
      case "single":
        lt2("/PageLayout /SinglePage");
        break;
      case "two":
      case "twoleft":
        lt2("/PageLayout /TwoColumnLeft");
        break;
      case "tworight":
        lt2("/PageLayout /TwoColumnRight");
    }
    yt2 && lt2("/PageMode /" + yt2), Tt2.publish("putCatalog"), lt2(">>"), lt2("endobj");
  }, Te = y2.__private__.putTrailer = function() {
    lt2("trailer"), lt2("<<"), lt2("/Size " + (et2 + 1)), lt2("/Root " + et2 + " 0 R"), lt2("/Info " + (et2 - 1) + " 0 R"), null !== m2 && lt2("/Encrypt " + Ye.oid + " 0 R"), lt2("/ID [ <" + V2 + "> <" + V2 + "> ]"), lt2(">>");
  }, Ue2 = y2.__private__.putHeader = function() {
    lt2("%PDF-" + w2), lt2("%ºß¬à");
  }, ze = y2.__private__.putXRef = function() {
    var t2 = "0000000000";
    lt2("xref"), lt2("0 " + (et2 + 1)), lt2("0000000000 65535 f ");
    for (var e3 = 1; e3 <= et2; e3++) {
      "function" == typeof rt2[e3] ? lt2((t2 + rt2[e3]()).slice(-10) + " 00000 n ") : void 0 !== rt2[e3] ? lt2((t2 + rt2[e3]).slice(-10) + " 00000 n ") : lt2("0000000000 00000 n ");
    }
  }, He = y2.__private__.buildDocument = function() {
    ut2(), ht2(nt2), Tt2.publish("buildDocument"), Ue2(), oe2(), Se(), xe(), null !== m2 && be2(), De(), Re();
    var t2 = it2;
    return ze(), Te(), lt2("startxref"), lt2("" + t2), lt2("%%EOF"), ht2(ot2[$2]), nt2.join("\n");
  }, We = y2.__private__.getBlob = function(t2) {
    return new Blob([dt2(t2)], { type: "application/pdf" });
  }, Ve = y2.output = y2.__private__.output = Ie(function(t2, e3) {
    switch ("string" == typeof (e3 = e3 || {}) ? e3 = { filename: e3 } : e3.filename = e3.filename || "generated.pdf", t2) {
      case void 0:
        return He();
      case "save":
        y2.save(e3.filename);
        break;
      case "arraybuffer":
        return dt2(He());
      case "blob":
        return We(He());
      case "bloburi":
      case "bloburl":
        if (void 0 !== n.URL && "function" == typeof n.URL.createObjectURL) return n.URL && n.URL.createObjectURL(We(He())) || void 0;
        a$1.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
        break;
      case "datauristring":
      case "dataurlstring":
        var r2 = "", i2 = He();
        try {
          r2 = h(i2);
        } catch (t3) {
          r2 = h(unescape(encodeURIComponent(i2)));
        }
        return "data:application/pdf;filename=" + e3.filename + ";base64," + r2;
      case "pdfobjectnewwindow":
        if ("[object Window]" === Object.prototype.toString.call(n)) {
          var o3 = "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js", s3 = ' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';
          e3.pdfObjectUrl && (o3 = e3.pdfObjectUrl, s3 = "");
          var c3 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + o3 + '"' + s3 + '><\/script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(e3) + ");<\/script></body></html>", u3 = n.open();
          return null !== u3 && u3.document.write(c3), u3;
        }
        throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
      case "pdfjsnewwindow":
        if ("[object Window]" === Object.prototype.toString.call(n)) {
          var l2 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (e3.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + e3.filename + '" width="500px" height="400px" /></body></html>', f2 = n.open();
          if (null !== f2) {
            f2.document.write(l2);
            var d3 = this;
            f2.document.documentElement.querySelector("#pdfViewer").onload = function() {
              f2.document.title = e3.filename, f2.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(d3.output("bloburl"));
            };
          }
          return f2;
        }
        throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
      case "dataurlnewwindow":
        if ("[object Window]" !== Object.prototype.toString.call(n)) throw new Error("The option dataurlnewwindow just works in a browser-environment.");
        var p3 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", e3) + '"></iframe></body></html>', g3 = n.open();
        if (null !== g3 && (g3.document.write(p3), g3.document.title = e3.filename), g3 || "undefined" == typeof safari) return g3;
        break;
      case "datauri":
      case "dataurl":
        return n.document.location.href = this.output("datauristring", e3);
      default:
        return null;
    }
  }), Ge = function(t2) {
    return true === Array.isArray(Ut2) && Ut2.indexOf(t2) > -1;
  };
  switch (o2) {
    case "pt":
      _t2 = 1;
      break;
    case "mm":
      _t2 = 72 / 25.4;
      break;
    case "cm":
      _t2 = 72 / 2.54;
      break;
    case "in":
      _t2 = 72;
      break;
    case "px":
      _t2 = 1 == Ge("px_scaling") ? 0.75 : 96 / 72;
      break;
    case "pc":
    case "em":
      _t2 = 12;
      break;
    case "ex":
      _t2 = 6;
      break;
    default:
      if ("number" != typeof o2) throw new Error("Invalid unit: " + o2);
      _t2 = o2;
  }
  var Ye = null;
  K2(), Y2();
  var Je = function(t2) {
    return null !== m2 ? Ye.encryptor(t2, 0) : function(t3) {
      return t3;
    };
  }, Xe = y2.__private__.getPageInfo = y2.getPageInfo = function(t2) {
    if (isNaN(t2) || t2 % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfo");
    return { objId: Rt2[t2].objId, pageNumber: t2, pageContext: Rt2[t2] };
  }, Ke = y2.__private__.getPageInfoByObjId = function(t2) {
    if (isNaN(t2) || t2 % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
    for (var e3 in Rt2) if (Rt2[e3].objId === t2) break;
    return Xe(e3);
  }, Ze = y2.__private__.getCurrentPageInfo = y2.getCurrentPageInfo = function() {
    return { objId: Rt2[$2].objId, pageNumber: $2, pageContext: Rt2[$2] };
  };
  y2.addPage = function() {
    return Oe.apply(this, arguments), this;
  }, y2.setPage = function() {
    return Me.apply(this, arguments), ht2.call(this, ot2[$2]), this;
  }, y2.insertPage = function(t2) {
    return this.addPage(), this.movePage($2, t2), this;
  }, y2.movePage = function(t2, e3) {
    var r2, n2;
    if (t2 > e3) {
      r2 = ot2[t2], n2 = Rt2[t2];
      for (var i2 = t2; i2 > e3; i2--) ot2[i2] = ot2[i2 - 1], Rt2[i2] = Rt2[i2 - 1];
      ot2[e3] = r2, Rt2[e3] = n2, this.setPage(e3);
    } else if (t2 < e3) {
      r2 = ot2[t2], n2 = Rt2[t2];
      for (var a2 = t2; a2 < e3; a2++) ot2[a2] = ot2[a2 + 1], Rt2[a2] = Rt2[a2 + 1];
      ot2[e3] = r2, Rt2[e3] = n2, this.setPage(e3);
    }
    return this;
  }, y2.deletePage = function() {
    return Be.apply(this, arguments), this;
  }, y2.__private__.text = y2.text = function(e3, r2, n2, i2, a2) {
    var o3, s3, c3, u3, h2, l2, f2, d3, p3, g3 = (i2 = i2 || {}).scope || this;
    if ("number" == typeof e3 && "number" == typeof r2 && ("string" == typeof n2 || Array.isArray(n2))) {
      var m3 = n2;
      n2 = r2, r2 = e3, e3 = m3;
    }
    if (arguments[3] instanceof Vt2 == false ? (c3 = arguments[4], u3 = arguments[5], "object" === _typeof(f2 = arguments[3]) && null !== f2 || ("string" == typeof c3 && (u3 = c3, c3 = null), "string" == typeof f2 && (u3 = f2, f2 = null), "number" == typeof f2 && (c3 = f2, f2 = null), i2 = { flags: f2, angle: c3, align: u3 })) : (q2("The transform parameter of text() with a Matrix value"), p3 = a2), isNaN(r2) || isNaN(n2) || null == e3) throw new Error("Invalid arguments passed to jsPDF.text");
    if (0 === e3.length) return g3;
    var v3 = "", y3 = false, w3 = "number" == typeof i2.lineHeightFactor ? i2.lineHeightFactor : lr, N3 = g3.internal.scaleFactor;
    function L3(t2) {
      return t2 = t2.split("	").join(Array(i2.TabLen || 9).join(" ")), Ce(t2, f2);
    }
    function A3(t2) {
      for (var e4, r3 = t2.concat(), n3 = [], i3 = r3.length; i3--; ) "string" == typeof (e4 = r3.shift()) ? n3.push(e4) : Array.isArray(t2) && (1 === e4.length || void 0 === e4[1] && void 0 === e4[2]) ? n3.push(e4[0]) : n3.push([e4[0], e4[1], e4[2]]);
      return n3;
    }
    function _3(t2, e4) {
      var r3;
      if ("string" == typeof t2) r3 = e4(t2)[0];
      else if (Array.isArray(t2)) {
        for (var n3, i3, a3 = t2.concat(), o4 = [], s4 = a3.length; s4--; ) "string" == typeof (n3 = a3.shift()) ? o4.push(e4(n3)[0]) : Array.isArray(n3) && "string" == typeof n3[0] && (i3 = e4(n3[0], n3[1], n3[2]), o4.push([i3[0], i3[1], i3[2]]));
        r3 = o4;
      }
      return r3;
    }
    var P3 = false, k3 = true;
    if ("string" == typeof e3) P3 = true;
    else if (Array.isArray(e3)) {
      var I2 = e3.concat();
      s3 = [];
      for (var F2, C2 = I2.length; C2--; ) ("string" != typeof (F2 = I2.shift()) || Array.isArray(F2) && "string" != typeof F2[0]) && (k3 = false);
      P3 = k3;
    }
    if (false === P3) throw new Error('Type of text must be string or Array. "' + e3 + '" is not recognized.');
    "string" == typeof e3 && (e3 = e3.match(/[\r?\n]/) ? e3.split(/\r\n|\r|\n/g) : [e3]);
    var j2 = gt2 / g3.internal.scaleFactor, B3 = j2 * (w3 - 1);
    switch (i2.baseline) {
      case "bottom":
        n2 -= B3;
        break;
      case "top":
        n2 += j2 - B3;
        break;
      case "hanging":
        n2 += j2 - 2 * B3;
        break;
      case "middle":
        n2 += j2 / 2 - B3;
    }
    if ((l2 = i2.maxWidth || 0) > 0 && ("string" == typeof e3 ? e3 = g3.splitTextToSize(e3, l2) : "[object Array]" === Object.prototype.toString.call(e3) && (e3 = e3.reduce(function(t2, e4) {
      return t2.concat(g3.splitTextToSize(e4, l2));
    }, []))), o3 = { text: e3, x: r2, y: n2, options: i2, mutex: { pdfEscape: Ce, activeFontKey: St, fonts: Ft2, activeFontSize: gt2 } }, Tt2.publish("preProcessText", o3), e3 = o3.text, c3 = (i2 = o3.options).angle, p3 instanceof Vt2 == false && c3 && "number" == typeof c3) {
      c3 *= Math.PI / 180, 0 === i2.rotationDirection && (c3 = -c3), S2 === x2.ADVANCED && (c3 = -c3);
      var M2 = Math.cos(c3), E2 = Math.sin(c3);
      p3 = new Vt2(M2, E2, -E2, M2, 0, 0);
    } else c3 && c3 instanceof Vt2 && (p3 = c3);
    S2 !== x2.ADVANCED || p3 || (p3 = Yt2), void 0 !== (h2 = i2.charSpace || _r) && (v3 += O2(U2(h2)) + " Tc\n", this.setCharSpace(this.getCharSpace() || 0)), void 0 !== (d3 = i2.horizontalScale) && (v3 += O2(100 * d3) + " Tz\n");
    i2.lang;
    var D3 = -1, R3 = void 0 !== i2.renderingMode ? i2.renderingMode : i2.stroke, T3 = g3.internal.getCurrentPageInfo().pageContext;
    switch (R3) {
      case 0:
      case false:
      case "fill":
        D3 = 0;
        break;
      case 1:
      case true:
      case "stroke":
        D3 = 1;
        break;
      case 2:
      case "fillThenStroke":
        D3 = 2;
        break;
      case 3:
      case "invisible":
        D3 = 3;
        break;
      case 4:
      case "fillAndAddForClipping":
        D3 = 4;
        break;
      case 5:
      case "strokeAndAddPathForClipping":
        D3 = 5;
        break;
      case 6:
      case "fillThenStrokeAndAddToPathForClipping":
        D3 = 6;
        break;
      case 7:
      case "addToPathForClipping":
        D3 = 7;
    }
    var z3 = void 0 !== T3.usedRenderingMode ? T3.usedRenderingMode : -1;
    -1 !== D3 ? v3 += D3 + " Tr\n" : -1 !== z3 && (v3 += "0 Tr\n"), -1 !== D3 && (T3.usedRenderingMode = D3), u3 = i2.align || "left";
    var H5, W3 = gt2 * w3, V3 = g3.internal.pageSize.getWidth(), G3 = Ft2[St];
    h2 = i2.charSpace || _r, l2 = i2.maxWidth || 0, f2 = Object.assign({ autoencode: true, noBOM: true }, i2.flags);
    var Y3 = [];
    if ("[object Array]" === Object.prototype.toString.call(e3)) {
      var J3;
      s3 = A3(e3), "left" !== u3 && (H5 = s3.map(function(t2) {
        return g3.getStringUnitWidth(t2, { font: G3, charSpace: h2, fontSize: gt2, doKerning: false }) * gt2 / N3;
      }));
      var X3, K3 = 0;
      if ("right" === u3) {
        r2 -= H5[0], e3 = [], C2 = s3.length;
        for (var Z3 = 0; Z3 < C2; Z3++) 0 === Z3 ? (X3 = br(r2), J3 = yr(n2)) : (X3 = U2(K3 - H5[Z3]), J3 = -W3), e3.push([s3[Z3], X3, J3]), K3 = H5[Z3];
      } else if ("center" === u3) {
        r2 -= H5[0] / 2, e3 = [], C2 = s3.length;
        for (var $3 = 0; $3 < C2; $3++) 0 === $3 ? (X3 = br(r2), J3 = yr(n2)) : (X3 = U2((K3 - H5[$3]) / 2), J3 = -W3), e3.push([s3[$3], X3, J3]), K3 = H5[$3];
      } else if ("left" === u3) {
        e3 = [], C2 = s3.length;
        for (var Q3 = 0; Q3 < C2; Q3++) e3.push(s3[Q3]);
      } else {
        if ("justify" !== u3) throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
        e3 = [], C2 = s3.length, l2 = 0 !== l2 ? l2 : V3;
        for (var tt3 = 0; tt3 < C2; tt3++) J3 = 0 === tt3 ? yr(n2) : -W3, X3 = 0 === tt3 ? br(r2) : 0, tt3 < C2 - 1 ? Y3.push(O2(U2((l2 - H5[tt3]) / (s3[tt3].split(" ").length - 1)))) : Y3.push(0), e3.push([s3[tt3], X3, J3]);
      }
    }
    var et3 = "boolean" == typeof i2.R2L ? i2.R2L : bt2;
    true === et3 && (e3 = _3(e3, function(t2, e4, r3) {
      return [t2.split("").reverse().join(""), e4, r3];
    })), o3 = { text: e3, x: r2, y: n2, options: i2, mutex: { pdfEscape: Ce, activeFontKey: St, fonts: Ft2, activeFontSize: gt2 } }, Tt2.publish("postProcessText", o3), e3 = o3.text, y3 = o3.mutex.isHex || false;
    var rt3 = Ft2[St].encoding;
    "WinAnsiEncoding" !== rt3 && "StandardEncoding" !== rt3 || (e3 = _3(e3, function(t2, e4, r3) {
      return [L3(t2), e4, r3];
    })), s3 = A3(e3), e3 = [];
    for (var nt3, it3, at3, ot3 = 0, st3 = 1, ct3 = Array.isArray(s3[0]) ? st3 : ot3, ut3 = "", ht3 = function(t2, e4, r3) {
      var n3 = "";
      return r3 instanceof Vt2 ? (r3 = "number" == typeof i2.angle ? Gt2(r3, new Vt2(1, 0, 0, 1, t2, e4)) : Gt2(new Vt2(1, 0, 0, 1, t2, e4), r3), S2 === x2.ADVANCED && (r3 = Gt2(new Vt2(1, 0, 0, -1, 0, 0), r3)), n3 = r3.join(" ") + " Tm\n") : n3 = O2(t2) + " " + O2(e4) + " Td\n", n3;
    }, ft3 = 0; ft3 < s3.length; ft3++) {
      switch (ut3 = "", ct3) {
        case st3:
          at3 = (y3 ? "<" : "(") + s3[ft3][0] + (y3 ? ">" : ")"), nt3 = parseFloat(s3[ft3][1]), it3 = parseFloat(s3[ft3][2]);
          break;
        case ot3:
          at3 = (y3 ? "<" : "(") + s3[ft3] + (y3 ? ">" : ")"), nt3 = br(r2), it3 = yr(n2);
      }
      void 0 !== Y3 && void 0 !== Y3[ft3] && (ut3 = Y3[ft3] + " Tw\n"), 0 === ft3 ? e3.push(ut3 + ht3(nt3, it3, p3) + at3) : ct3 === ot3 ? e3.push(ut3 + at3) : ct3 === st3 && e3.push(ut3 + ht3(nt3, it3, p3) + at3);
    }
    e3 = ct3 === ot3 ? e3.join(" Tj\nT* ") : e3.join(" Tj\n"), e3 += " Tj\n";
    var dt3 = "BT\n/";
    return dt3 += St + " " + gt2 + " Tf\n", dt3 += O2(gt2 * w3) + " TL\n", dt3 += xr + "\n", dt3 += v3, dt3 += e3, lt2(dt3 += "ET"), b2[St] = true, g3;
  };
  var $e = y2.__private__.clip = y2.clip = function(t2) {
    return lt2("evenodd" === t2 ? "W*" : "W"), this;
  };
  y2.clipEvenOdd = function() {
    return $e("evenodd");
  }, y2.__private__.discardPath = y2.discardPath = function() {
    return lt2("n"), this;
  };
  var Qe = y2.__private__.isValidStyle = function(t2) {
    var e3 = false;
    return -1 !== [void 0, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"].indexOf(t2) && (e3 = true), e3;
  };
  y2.__private__.setDefaultPathOperation = y2.setDefaultPathOperation = function(t2) {
    return Qe(t2) && (g2 = t2), this;
  };
  var tr = y2.__private__.getStyle = y2.getStyle = function(t2) {
    var e3 = g2;
    switch (t2) {
      case "D":
      case "S":
        e3 = "S";
        break;
      case "F":
        e3 = "f";
        break;
      case "FD":
      case "DF":
        e3 = "B";
        break;
      case "f":
      case "f*":
      case "B":
      case "B*":
        e3 = t2;
    }
    return e3;
  }, er = y2.close = function() {
    return lt2("h"), this;
  };
  y2.stroke = function() {
    return lt2("S"), this;
  }, y2.fill = function(t2) {
    return rr("f", t2), this;
  }, y2.fillEvenOdd = function(t2) {
    return rr("f*", t2), this;
  }, y2.fillStroke = function(t2) {
    return rr("B", t2), this;
  }, y2.fillStrokeEvenOdd = function(t2) {
    return rr("B*", t2), this;
  };
  var rr = function(e3, r2) {
    "object" === _typeof(r2) ? ar(r2, e3) : lt2(e3);
  }, nr = function(t2) {
    null === t2 || S2 === x2.ADVANCED && void 0 === t2 || (t2 = tr(t2), lt2(t2));
  };
  function ir(t2, e3, r2, n2, i2) {
    var a2 = new M(e3 || this.boundingBox, r2 || this.xStep, n2 || this.yStep, this.gState, i2 || this.matrix);
    a2.stream = this.stream;
    var o3 = t2 + "$$" + this.cloneIndex++ + "$$";
    return Jt2(o3, a2), a2;
  }
  var ar = function(t2, e3) {
    var r2 = Bt2[t2.key], n2 = Ot2[r2];
    if (n2 instanceof B) lt2("q"), lt2(or(e3)), n2.gState && y2.setGState(n2.gState), lt2(t2.matrix.toString() + " cm"), lt2("/" + r2 + " sh"), lt2("Q");
    else if (n2 instanceof M) {
      var i2 = new Vt2(1, 0, 0, -1, 0, Rr());
      t2.matrix && (i2 = i2.multiply(t2.matrix || Yt2), r2 = ir.call(n2, t2.key, t2.boundingBox, t2.xStep, t2.yStep, i2).id), lt2("q"), lt2("/Pattern cs"), lt2("/" + r2 + " scn"), n2.gState && y2.setGState(n2.gState), lt2(e3), lt2("Q");
    }
  }, or = function(t2) {
    switch (t2) {
      case "f":
      case "F":
        return "W n";
      case "f*":
        return "W* n";
      case "B":
        return "W S";
      case "B*":
        return "W* S";
      case "S":
        return "W S";
      case "n":
        return "W n";
    }
  }, sr = y2.moveTo = function(t2, e3) {
    return lt2(O2(U2(t2)) + " " + O2(H4(e3)) + " m"), this;
  }, cr = y2.lineTo = function(t2, e3) {
    return lt2(O2(U2(t2)) + " " + O2(H4(e3)) + " l"), this;
  }, ur = y2.curveTo = function(t2, e3, r2, n2, i2, a2) {
    return lt2([O2(U2(t2)), O2(H4(e3)), O2(U2(r2)), O2(H4(n2)), O2(U2(i2)), O2(H4(a2)), "c"].join(" ")), this;
  };
  y2.__private__.line = y2.line = function(t2, e3, r2, n2, i2) {
    if (isNaN(t2) || isNaN(e3) || isNaN(r2) || isNaN(n2) || !Qe(i2)) throw new Error("Invalid arguments passed to jsPDF.line");
    return S2 === x2.COMPAT ? this.lines([[r2 - t2, n2 - e3]], t2, e3, [1, 1], i2 || "S") : this.lines([[r2 - t2, n2 - e3]], t2, e3, [1, 1]).stroke();
  }, y2.__private__.lines = y2.lines = function(t2, e3, r2, n2, i2, a2) {
    var o3, s3, c3, u3, h2, l2, f2, d3, p3, g3, m3, v3;
    if ("number" == typeof t2 && (v3 = r2, r2 = e3, e3 = t2, t2 = v3), n2 = n2 || [1, 1], a2 = a2 || false, isNaN(e3) || isNaN(r2) || !Array.isArray(t2) || !Array.isArray(n2) || !Qe(i2) || "boolean" != typeof a2) throw new Error("Invalid arguments passed to jsPDF.lines");
    for (sr(e3, r2), o3 = n2[0], s3 = n2[1], u3 = t2.length, g3 = e3, m3 = r2, c3 = 0; c3 < u3; c3++) 2 === (h2 = t2[c3]).length ? (g3 = h2[0] * o3 + g3, m3 = h2[1] * s3 + m3, cr(g3, m3)) : (l2 = h2[0] * o3 + g3, f2 = h2[1] * s3 + m3, d3 = h2[2] * o3 + g3, p3 = h2[3] * s3 + m3, g3 = h2[4] * o3 + g3, m3 = h2[5] * s3 + m3, ur(l2, f2, d3, p3, g3, m3));
    return a2 && er(), nr(i2), this;
  }, y2.path = function(t2) {
    for (var e3 = 0; e3 < t2.length; e3++) {
      var r2 = t2[e3], n2 = r2.c;
      switch (r2.op) {
        case "m":
          sr(n2[0], n2[1]);
          break;
        case "l":
          cr(n2[0], n2[1]);
          break;
        case "c":
          ur.apply(this, n2);
          break;
        case "h":
          er();
      }
    }
    return this;
  }, y2.__private__.rect = y2.rect = function(t2, e3, r2, n2, i2) {
    if (isNaN(t2) || isNaN(e3) || isNaN(r2) || isNaN(n2) || !Qe(i2)) throw new Error("Invalid arguments passed to jsPDF.rect");
    return S2 === x2.COMPAT && (n2 = -n2), lt2([O2(U2(t2)), O2(H4(e3)), O2(U2(r2)), O2(U2(n2)), "re"].join(" ")), nr(i2), this;
  }, y2.__private__.triangle = y2.triangle = function(t2, e3, r2, n2, i2, a2, o3) {
    if (isNaN(t2) || isNaN(e3) || isNaN(r2) || isNaN(n2) || isNaN(i2) || isNaN(a2) || !Qe(o3)) throw new Error("Invalid arguments passed to jsPDF.triangle");
    return this.lines([[r2 - t2, n2 - e3], [i2 - r2, a2 - n2], [t2 - i2, e3 - a2]], t2, e3, [1, 1], o3, true), this;
  }, y2.__private__.roundedRect = y2.roundedRect = function(t2, e3, r2, n2, i2, a2, o3) {
    if (isNaN(t2) || isNaN(e3) || isNaN(r2) || isNaN(n2) || isNaN(i2) || isNaN(a2) || !Qe(o3)) throw new Error("Invalid arguments passed to jsPDF.roundedRect");
    var s3 = 4 / 3 * (Math.SQRT2 - 1);
    return i2 = Math.min(i2, 0.5 * r2), a2 = Math.min(a2, 0.5 * n2), this.lines([[r2 - 2 * i2, 0], [i2 * s3, 0, i2, a2 - a2 * s3, i2, a2], [0, n2 - 2 * a2], [0, a2 * s3, -i2 * s3, a2, -i2, a2], [2 * i2 - r2, 0], [-i2 * s3, 0, -i2, -a2 * s3, -i2, -a2], [0, 2 * a2 - n2], [0, -a2 * s3, i2 * s3, -a2, i2, -a2]], t2 + i2, e3, [1, 1], o3, true), this;
  }, y2.__private__.ellipse = y2.ellipse = function(t2, e3, r2, n2, i2) {
    if (isNaN(t2) || isNaN(e3) || isNaN(r2) || isNaN(n2) || !Qe(i2)) throw new Error("Invalid arguments passed to jsPDF.ellipse");
    var a2 = 4 / 3 * (Math.SQRT2 - 1) * r2, o3 = 4 / 3 * (Math.SQRT2 - 1) * n2;
    return sr(t2 + r2, e3), ur(t2 + r2, e3 - o3, t2 + a2, e3 - n2, t2, e3 - n2), ur(t2 - a2, e3 - n2, t2 - r2, e3 - o3, t2 - r2, e3), ur(t2 - r2, e3 + o3, t2 - a2, e3 + n2, t2, e3 + n2), ur(t2 + a2, e3 + n2, t2 + r2, e3 + o3, t2 + r2, e3), nr(i2), this;
  }, y2.__private__.circle = y2.circle = function(t2, e3, r2, n2) {
    if (isNaN(t2) || isNaN(e3) || isNaN(r2) || !Qe(n2)) throw new Error("Invalid arguments passed to jsPDF.circle");
    return this.ellipse(t2, e3, r2, r2, n2);
  }, y2.setFont = function(t2, e3, r2) {
    return r2 && (e3 = k2(e3, r2)), St = qe2(t2, e3, { disableWarning: false }), this;
  };
  var hr = y2.__private__.getFont = y2.getFont = function() {
    return Ft2[qe2.apply(y2, arguments)];
  };
  y2.__private__.getFontList = y2.getFontList = function() {
    var t2, e3, r2 = {};
    for (t2 in Ct2) if (Ct2.hasOwnProperty(t2)) for (e3 in r2[t2] = [], Ct2[t2]) Ct2[t2].hasOwnProperty(e3) && r2[t2].push(e3);
    return r2;
  }, y2.addFont = function(t2, e3, r2, n2, i2) {
    var a2 = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"];
    return arguments[3] && -1 !== a2.indexOf(arguments[3]) ? i2 = arguments[3] : arguments[3] && -1 == a2.indexOf(arguments[3]) && (r2 = k2(r2, n2)), i2 = i2 || "Identity-H", Pe.call(this, t2, e3, r2, i2);
  };
  var lr, fr = e2.lineWidth || 0.200025, dr = y2.__private__.getLineWidth = y2.getLineWidth = function() {
    return fr;
  }, pr = y2.__private__.setLineWidth = y2.setLineWidth = function(t2) {
    return fr = t2, lt2(O2(U2(t2)) + " w"), this;
  };
  y2.__private__.setLineDash = E$1.API.setLineDash = E$1.API.setLineDashPattern = function(t2, e3) {
    if (t2 = t2 || [], e3 = e3 || 0, isNaN(e3) || !Array.isArray(t2)) throw new Error("Invalid arguments passed to jsPDF.setLineDash");
    return t2 = t2.map(function(t3) {
      return O2(U2(t3));
    }).join(" "), e3 = O2(U2(e3)), lt2("[" + t2 + "] " + e3 + " d"), this;
  };
  var gr = y2.__private__.getLineHeight = y2.getLineHeight = function() {
    return gt2 * lr;
  };
  y2.__private__.getLineHeight = y2.getLineHeight = function() {
    return gt2 * lr;
  };
  var mr = y2.__private__.setLineHeightFactor = y2.setLineHeightFactor = function(t2) {
    return "number" == typeof (t2 = t2 || 1.15) && (lr = t2), this;
  }, vr = y2.__private__.getLineHeightFactor = y2.getLineHeightFactor = function() {
    return lr;
  };
  mr(e2.lineHeight);
  var br = y2.__private__.getHorizontalCoordinate = function(t2) {
    return U2(t2);
  }, yr = y2.__private__.getVerticalCoordinate = function(t2) {
    return S2 === x2.ADVANCED ? t2 : Rt2[$2].mediaBox.topRightY - Rt2[$2].mediaBox.bottomLeftY - U2(t2);
  }, wr = y2.__private__.getHorizontalCoordinateString = y2.getHorizontalCoordinateString = function(t2) {
    return O2(br(t2));
  }, Nr = y2.__private__.getVerticalCoordinateString = y2.getVerticalCoordinateString = function(t2) {
    return O2(yr(t2));
  }, Lr = e2.strokeColor || "0 G";
  y2.__private__.getStrokeColor = y2.getDrawColor = function() {
    return ee2(Lr);
  }, y2.__private__.setStrokeColor = y2.setDrawColor = function(t2, e3, r2, n2) {
    return Lr = re2({ ch1: t2, ch2: e3, ch3: r2, ch4: n2, pdfColorType: "draw", precision: 2 }), lt2(Lr), this;
  };
  var Ar = e2.fillColor || "0 g";
  y2.__private__.getFillColor = y2.getFillColor = function() {
    return ee2(Ar);
  }, y2.__private__.setFillColor = y2.setFillColor = function(t2, e3, r2, n2) {
    return Ar = re2({ ch1: t2, ch2: e3, ch3: r2, ch4: n2, pdfColorType: "fill", precision: 2 }), lt2(Ar), this;
  };
  var xr = e2.textColor || "0 g", Sr = y2.__private__.getTextColor = y2.getTextColor = function() {
    return ee2(xr);
  };
  y2.__private__.setTextColor = y2.setTextColor = function(t2, e3, r2, n2) {
    return xr = re2({ ch1: t2, ch2: e3, ch3: r2, ch4: n2, pdfColorType: "text", precision: 3 }), this;
  };
  var _r = e2.charSpace, Pr = y2.__private__.getCharSpace = y2.getCharSpace = function() {
    return parseFloat(_r || 0);
  };
  y2.__private__.setCharSpace = y2.setCharSpace = function(t2) {
    if (isNaN(t2)) throw new Error("Invalid argument passed to jsPDF.setCharSpace");
    return _r = t2, this;
  };
  var kr = 0;
  y2.CapJoinStyles = { 0: 0, butt: 0, but: 0, miter: 0, 1: 1, round: 1, rounded: 1, circle: 1, 2: 2, projecting: 2, project: 2, square: 2, bevel: 2 }, y2.__private__.setLineCap = y2.setLineCap = function(t2) {
    var e3 = y2.CapJoinStyles[t2];
    if (void 0 === e3) throw new Error("Line cap style of '" + t2 + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return kr = e3, lt2(e3 + " J"), this;
  };
  var Ir = 0;
  y2.__private__.setLineJoin = y2.setLineJoin = function(t2) {
    var e3 = y2.CapJoinStyles[t2];
    if (void 0 === e3) throw new Error("Line join style of '" + t2 + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return Ir = e3, lt2(e3 + " j"), this;
  }, y2.__private__.setLineMiterLimit = y2.__private__.setMiterLimit = y2.setLineMiterLimit = y2.setMiterLimit = function(t2) {
    if (t2 = t2 || 0, isNaN(t2)) throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
    return lt2(O2(U2(t2)) + " M"), this;
  }, y2.GState = j, y2.setGState = function(t2) {
    (t2 = "string" == typeof t2 ? Mt2[Et2[t2]] : Fr(null, t2)).equals(qt2) || (lt2("/" + t2.id + " gs"), qt2 = t2);
  };
  var Fr = function(t2, e3) {
    if (!t2 || !Et2[t2]) {
      var r2 = false;
      for (var n2 in Mt2) if (Mt2.hasOwnProperty(n2) && Mt2[n2].equals(e3)) {
        r2 = true;
        break;
      }
      if (r2) e3 = Mt2[n2];
      else {
        var i2 = "GS" + (Object.keys(Mt2).length + 1).toString(10);
        Mt2[i2] = e3, e3.id = i2;
      }
      return t2 && (Et2[t2] = e3.id), Tt2.publish("addGState", e3), e3;
    }
  };
  y2.addGState = function(t2, e3) {
    return Fr(t2, e3), this;
  }, y2.saveGraphicsState = function() {
    return lt2("q"), jt2.push({ key: St, size: gt2, color: xr }), this;
  }, y2.restoreGraphicsState = function() {
    lt2("Q");
    var t2 = jt2.pop();
    return St = t2.key, gt2 = t2.size, xr = t2.color, qt2 = null, this;
  }, y2.setCurrentTransformationMatrix = function(t2) {
    return lt2(t2.toString() + " cm"), this;
  }, y2.comment = function(t2) {
    return lt2("#" + t2), this;
  };
  var Cr = function(t2, e3) {
    var r2 = t2 || 0;
    Object.defineProperty(this, "x", { enumerable: true, get: function() {
      return r2;
    }, set: function(t3) {
      isNaN(t3) || (r2 = parseFloat(t3));
    } });
    var n2 = e3 || 0;
    Object.defineProperty(this, "y", { enumerable: true, get: function() {
      return n2;
    }, set: function(t3) {
      isNaN(t3) || (n2 = parseFloat(t3));
    } });
    var i2 = "pt";
    return Object.defineProperty(this, "type", { enumerable: true, get: function() {
      return i2;
    }, set: function(t3) {
      i2 = t3.toString();
    } }), this;
  }, jr = function(t2, e3, r2, n2) {
    Cr.call(this, t2, e3), this.type = "rect";
    var i2 = r2 || 0;
    Object.defineProperty(this, "w", { enumerable: true, get: function() {
      return i2;
    }, set: function(t3) {
      isNaN(t3) || (i2 = parseFloat(t3));
    } });
    var a2 = n2 || 0;
    return Object.defineProperty(this, "h", { enumerable: true, get: function() {
      return a2;
    }, set: function(t3) {
      isNaN(t3) || (a2 = parseFloat(t3));
    } }), this;
  }, Or = function() {
    this.page = Dt2, this.currentPage = $2, this.pages = ot2.slice(0), this.pagesContext = Rt2.slice(0), this.x = Pt2, this.y = kt2, this.matrix = It2, this.width = qr($2), this.height = Rr($2), this.outputDestination = ct2, this.id = "", this.objectNumber = -1;
  };
  Or.prototype.restore = function() {
    Dt2 = this.page, $2 = this.currentPage, Rt2 = this.pagesContext, ot2 = this.pages, Pt2 = this.x, kt2 = this.y, It2 = this.matrix, Dr($2, this.width), Tr($2, this.height), ct2 = this.outputDestination;
  };
  var Br = function(t2, e3, r2, n2, i2) {
    Wt2.push(new Or()), Dt2 = $2 = 0, ot2 = [], Pt2 = t2, kt2 = e3, It2 = i2, je([r2, n2]);
  }, Mr = function(t2) {
    if (Ht2[t2]) Wt2.pop().restore();
    else {
      var e3 = new Or(), r2 = "Xo" + (Object.keys(zt2).length + 1).toString(10);
      e3.id = r2, Ht2[t2] = r2, zt2[r2] = e3, Tt2.publish("addFormObject", e3), Wt2.pop().restore();
    }
  };
  for (var Er in y2.beginFormObject = function(t2, e3, r2, n2, i2) {
    return Br(t2, e3, r2, n2, i2), this;
  }, y2.endFormObject = function(t2) {
    return Mr(t2), this;
  }, y2.doFormObject = function(t2, e3) {
    var r2 = zt2[Ht2[t2]];
    return lt2("q"), lt2(e3.toString() + " cm"), lt2("/" + r2.id + " Do"), lt2("Q"), this;
  }, y2.getFormObject = function(t2) {
    var e3 = zt2[Ht2[t2]];
    return { x: e3.x, y: e3.y, width: e3.width, height: e3.height, matrix: e3.matrix };
  }, y2.save = function(t2, e3) {
    return t2 = t2 || "generated.pdf", (e3 = e3 || {}).returnPromise = e3.returnPromise || false, false === e3.returnPromise ? (l(We(He()), t2), "function" == typeof l.unload && n.setTimeout && setTimeout(l.unload, 911), this) : new Promise(function(e4, r2) {
      try {
        var i2 = l(We(He()), t2);
        "function" == typeof l.unload && n.setTimeout && setTimeout(l.unload, 911), e4(i2);
      } catch (t3) {
        r2(t3.message);
      }
    });
  }, E$1.API) E$1.API.hasOwnProperty(Er) && ("events" === Er && E$1.API.events.length ? function(t2, e3) {
    var r2, n2, i2;
    for (i2 = e3.length - 1; -1 !== i2; i2--) r2 = e3[i2][0], n2 = e3[i2][1], t2.subscribe.apply(t2, [r2].concat("function" == typeof n2 ? [n2] : n2));
  }(Tt2, E$1.API.events) : y2[Er] = E$1.API[Er]);
  var qr = y2.getPageWidth = function(t2) {
    return (Rt2[t2 = t2 || $2].mediaBox.topRightX - Rt2[t2].mediaBox.bottomLeftX) / _t2;
  }, Dr = y2.setPageWidth = function(t2, e3) {
    Rt2[t2].mediaBox.topRightX = e3 * _t2 + Rt2[t2].mediaBox.bottomLeftX;
  }, Rr = y2.getPageHeight = function(t2) {
    return (Rt2[t2 = t2 || $2].mediaBox.topRightY - Rt2[t2].mediaBox.bottomLeftY) / _t2;
  }, Tr = y2.setPageHeight = function(t2, e3) {
    Rt2[t2].mediaBox.topRightY = e3 * _t2 + Rt2[t2].mediaBox.bottomLeftY;
  };
  return y2.internal = { pdfEscape: Ce, getStyle: tr, getFont: hr, getFontSize: vt2, getCharSpace: Pr, getTextColor: Sr, getLineHeight: gr, getLineHeightFactor: vr, getLineWidth: dr, write: ft2, getHorizontalCoordinate: br, getVerticalCoordinate: yr, getCoordinateString: wr, getVerticalCoordinateString: Nr, collections: {}, newObject: Xt2, newAdditionalObject: $t2, newObjectDeferred: Kt2, newObjectDeferredBegin: Zt2, getFilters: ne2, putStream: ie2, events: Tt2, scaleFactor: _t2, pageSize: { getWidth: function() {
    return qr($2);
  }, setWidth: function(t2) {
    Dr($2, t2);
  }, getHeight: function() {
    return Rr($2);
  }, setHeight: function(t2) {
    Tr($2, t2);
  } }, encryptionOptions: m2, encryption: Ye, getEncryptor: Je, output: Ve, getNumberOfPages: Ee, pages: ot2, out: lt2, f2: R2, f3: T2, getPageInfo: Xe, getPageInfoByObjId: Ke, getCurrentPageInfo: Ze, getPDFVersion: N2, Point: Cr, Rectangle: jr, Matrix: Vt2, hasHotfix: Ge }, Object.defineProperty(y2.internal.pageSize, "width", { get: function() {
    return qr($2);
  }, set: function(t2) {
    Dr($2, t2);
  }, enumerable: true, configurable: true }), Object.defineProperty(y2.internal.pageSize, "height", { get: function() {
    return Rr($2);
  }, set: function(t2) {
    Tr($2, t2);
  }, enumerable: true, configurable: true }), ke.call(y2, pt2), St = "F1", Oe(s2, i), Tt2.publish("initialized"), y2;
}
I.prototype.lsbFirstWord = function(t2) {
  return String.fromCharCode(t2 >> 0 & 255, t2 >> 8 & 255, t2 >> 16 & 255, t2 >> 24 & 255);
}, I.prototype.toHexString = function(t2) {
  return t2.split("").map(function(t3) {
    return ("0" + (255 & t3.charCodeAt(0)).toString(16)).slice(-2);
  }).join("");
}, I.prototype.hexToBytes = function(t2) {
  for (var e2 = [], r = 0; r < t2.length; r += 2) e2.push(String.fromCharCode(parseInt(t2.substr(r, 2), 16)));
  return e2.join("");
}, I.prototype.processOwnerPassword = function(t2, e2) {
  return P(x(e2).substr(0, 5), t2);
}, I.prototype.encryptor = function(t2, e2) {
  var r = x(this.encryptionKey + String.fromCharCode(255 & t2, t2 >> 8 & 255, t2 >> 16 & 255, 255 & e2, e2 >> 8 & 255)).substr(0, 10);
  return function(t3) {
    return P(r, t3);
  };
}, j.prototype.equals = function(e2) {
  var r, n2 = "id,objectNumber,equals";
  if (!e2 || _typeof(e2) !== _typeof(this)) return false;
  var i = 0;
  for (r in this) if (!(n2.indexOf(r) >= 0)) {
    if (this.hasOwnProperty(r) && !e2.hasOwnProperty(r)) return false;
    if (this[r] !== e2[r]) return false;
    i++;
  }
  for (r in e2) e2.hasOwnProperty(r) && n2.indexOf(r) < 0 && i--;
  return 0 === i;
}, E$1.API = { events: [] }, E$1.version = "2.5.1";
var q = E$1.API, D = 1, R = function(t2) {
  return t2.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
}, T$1 = function(t2) {
  return t2.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}, U$1 = function(t2) {
  return t2.toFixed(2);
}, z$1 = function(t2) {
  return t2.toFixed(5);
};
q.__acroform__ = {};
var H = function(t2, e2) {
  t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2;
}, W = function(t2) {
  return t2 * D;
}, V$1 = function(t2) {
  var e2 = new ut(), r = At.internal.getHeight(t2) || 0, n2 = At.internal.getWidth(t2) || 0;
  return e2.BBox = [0, 0, Number(U$1(n2)), Number(U$1(r))], e2;
}, G = q.__acroform__.setBit = function(t2, e2) {
  if (t2 = t2 || 0, e2 = e2 || 0, isNaN(t2) || isNaN(e2)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
  return t2 |= 1 << e2;
}, Y = q.__acroform__.clearBit = function(t2, e2) {
  if (t2 = t2 || 0, e2 = e2 || 0, isNaN(t2) || isNaN(e2)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
  return t2 &= ~(1 << e2);
}, J = q.__acroform__.getBit = function(t2, e2) {
  if (isNaN(t2) || isNaN(e2)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
  return 0 == (t2 & 1 << e2) ? 0 : 1;
}, X = q.__acroform__.getBitForPdf = function(t2, e2) {
  if (isNaN(t2) || isNaN(e2)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
  return J(t2, e2 - 1);
}, K = q.__acroform__.setBitForPdf = function(t2, e2) {
  if (isNaN(t2) || isNaN(e2)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
  return G(t2, e2 - 1);
}, Z$1 = q.__acroform__.clearBitForPdf = function(t2, e2) {
  if (isNaN(t2) || isNaN(e2)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
  return Y(t2, e2 - 1);
}, $ = q.__acroform__.calculateCoordinates = function(t2, e2) {
  var r = e2.internal.getHorizontalCoordinate, n2 = e2.internal.getVerticalCoordinate, i = t2[0], a2 = t2[1], o2 = t2[2], s2 = t2[3], c2 = {};
  return c2.lowerLeft_X = r(i) || 0, c2.lowerLeft_Y = n2(a2 + s2) || 0, c2.upperRight_X = r(i + o2) || 0, c2.upperRight_Y = n2(a2) || 0, [Number(U$1(c2.lowerLeft_X)), Number(U$1(c2.lowerLeft_Y)), Number(U$1(c2.upperRight_X)), Number(U$1(c2.upperRight_Y))];
}, Q = function(t2) {
  if (t2.appearanceStreamContent) return t2.appearanceStreamContent;
  if (t2.V || t2.DV) {
    var e2 = [], r = t2._V || t2.DV, n2 = tt(t2, r), i = t2.scope.internal.getFont(t2.fontName, t2.fontStyle).id;
    e2.push("/Tx BMC"), e2.push("q"), e2.push("BT"), e2.push(t2.scope.__private__.encodeColorString(t2.color)), e2.push("/" + i + " " + U$1(n2.fontSize) + " Tf"), e2.push("1 0 0 1 0 0 Tm"), e2.push(n2.text), e2.push("ET"), e2.push("Q"), e2.push("EMC");
    var a2 = V$1(t2);
    return a2.scope = t2.scope, a2.stream = e2.join("\n"), a2;
  }
}, tt = function(t2, e2) {
  var r = 0 === t2.fontSize ? t2.maxFontSize : t2.fontSize, n2 = { text: "", fontSize: "" }, i = (e2 = ")" == (e2 = "(" == e2.substr(0, 1) ? e2.substr(1) : e2).substr(e2.length - 1) ? e2.substr(0, e2.length - 1) : e2).split(" ");
  i = t2.multiline ? i.map(function(t3) {
    return t3.split("\n");
  }) : i.map(function(t3) {
    return [t3];
  });
  var a2 = r, o2 = At.internal.getHeight(t2) || 0;
  o2 = o2 < 0 ? -o2 : o2;
  var s2 = At.internal.getWidth(t2) || 0;
  s2 = s2 < 0 ? -s2 : s2;
  var c2 = function(e3, r2, n3) {
    if (e3 + 1 < i.length) {
      var a3 = r2 + " " + i[e3 + 1][0];
      return et(a3, t2, n3).width <= s2 - 4;
    }
    return false;
  };
  a2++;
  t: for (; a2 > 0; ) {
    e2 = "", a2--;
    var u2, h2, l2 = et("3", t2, a2).height, f2 = t2.multiline ? o2 - a2 : (o2 - l2) / 2, d2 = f2 += 2, p2 = 0, g2 = 0, m2 = 0;
    if (a2 <= 0) {
      e2 = "(...) Tj\n", e2 += "% Width of Text: " + et(e2, t2, a2 = 12).width + ", FieldWidth:" + s2 + "\n";
      break;
    }
    for (var v2 = "", b2 = 0, y2 = 0; y2 < i.length; y2++) if (i.hasOwnProperty(y2)) {
      var w2 = false;
      if (1 !== i[y2].length && m2 !== i[y2].length - 1) {
        if ((l2 + 2) * (b2 + 2) + 2 > o2) continue t;
        v2 += i[y2][m2], w2 = true, g2 = y2, y2--;
      } else {
        v2 = " " == (v2 += i[y2][m2] + " ").substr(v2.length - 1) ? v2.substr(0, v2.length - 1) : v2;
        var N2 = parseInt(y2), L2 = c2(N2, v2, a2), A2 = y2 >= i.length - 1;
        if (L2 && !A2) {
          v2 += " ", m2 = 0;
          continue;
        }
        if (L2 || A2) {
          if (A2) g2 = N2;
          else if (t2.multiline && (l2 + 2) * (b2 + 2) + 2 > o2) continue t;
        } else {
          if (!t2.multiline) continue t;
          if ((l2 + 2) * (b2 + 2) + 2 > o2) continue t;
          g2 = N2;
        }
      }
      for (var x2 = "", S2 = p2; S2 <= g2; S2++) {
        var _2 = i[S2];
        if (t2.multiline) {
          if (S2 === g2) {
            x2 += _2[m2] + " ", m2 = (m2 + 1) % _2.length;
            continue;
          }
          if (S2 === p2) {
            x2 += _2[_2.length - 1] + " ";
            continue;
          }
        }
        x2 += _2[0] + " ";
      }
      switch (x2 = " " == x2.substr(x2.length - 1) ? x2.substr(0, x2.length - 1) : x2, h2 = et(x2, t2, a2).width, t2.textAlign) {
        case "right":
          u2 = s2 - h2 - 2;
          break;
        case "center":
          u2 = (s2 - h2) / 2;
          break;
        case "left":
        default:
          u2 = 2;
      }
      e2 += U$1(u2) + " " + U$1(d2) + " Td\n", e2 += "(" + R(x2) + ") Tj\n", e2 += -U$1(u2) + " 0 Td\n", d2 = -(a2 + 2), h2 = 0, p2 = w2 ? g2 : g2 + 1, b2++, v2 = "";
    }
    break;
  }
  return n2.text = e2, n2.fontSize = a2, n2;
}, et = function(t2, e2, r) {
  var n2 = e2.scope.internal.getFont(e2.fontName, e2.fontStyle), i = e2.scope.getStringUnitWidth(t2, { font: n2, fontSize: parseFloat(r), charSpace: 0 }) * parseFloat(r);
  return { height: e2.scope.getStringUnitWidth("3", { font: n2, fontSize: parseFloat(r), charSpace: 0 }) * parseFloat(r) * 1.5, width: i };
}, rt = { fields: [], xForms: [], acroFormDictionaryRoot: null, printedOut: false, internal: null, isInitialized: false }, nt = function(t2, e2) {
  var r = { type: "reference", object: t2 };
  void 0 === e2.internal.getPageInfo(t2.page).pageContext.annotations.find(function(t3) {
    return t3.type === r.type && t3.object === r.object;
  }) && e2.internal.getPageInfo(t2.page).pageContext.annotations.push(r);
}, it = function(e2, r) {
  for (var n2 in e2) if (e2.hasOwnProperty(n2)) {
    var i = n2, a2 = e2[n2];
    r.internal.newObjectDeferredBegin(a2.objId, true), "object" === _typeof(a2) && "function" == typeof a2.putStream && a2.putStream(), delete e2[i];
  }
}, at = function(e2, r) {
  if (r.scope = e2, void 0 !== e2.internal && (void 0 === e2.internal.acroformPlugin || false === e2.internal.acroformPlugin.isInitialized)) {
    if (lt.FieldNum = 0, e2.internal.acroformPlugin = JSON.parse(JSON.stringify(rt)), e2.internal.acroformPlugin.acroFormDictionaryRoot) throw new Error("Exception while creating AcroformDictionary");
    D = e2.internal.scaleFactor, e2.internal.acroformPlugin.acroFormDictionaryRoot = new ht(), e2.internal.acroformPlugin.acroFormDictionaryRoot.scope = e2, e2.internal.acroformPlugin.acroFormDictionaryRoot._eventID = e2.internal.events.subscribe("postPutResources", function() {
      !function(t2) {
        t2.internal.events.unsubscribe(t2.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete t2.internal.acroformPlugin.acroFormDictionaryRoot._eventID, t2.internal.acroformPlugin.printedOut = true;
      }(e2);
    }), e2.internal.events.subscribe("buildDocument", function() {
      !function(t2) {
        t2.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
        var e3 = t2.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
        for (var r2 in e3) if (e3.hasOwnProperty(r2)) {
          var n2 = e3[r2];
          n2.objId = void 0, n2.hasAnnotation && nt(n2, t2);
        }
      }(e2);
    }), e2.internal.events.subscribe("putCatalog", function() {
      !function(t2) {
        if (void 0 === t2.internal.acroformPlugin.acroFormDictionaryRoot) throw new Error("putCatalogCallback: Root missing.");
        t2.internal.write("/AcroForm " + t2.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
      }(e2);
    }), e2.internal.events.subscribe("postPutPages", function(r2) {
      !function(e3, r3) {
        var n2 = !e3;
        for (var i in e3 || (r3.internal.newObjectDeferredBegin(r3.internal.acroformPlugin.acroFormDictionaryRoot.objId, true), r3.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), e3 = e3 || r3.internal.acroformPlugin.acroFormDictionaryRoot.Kids) if (e3.hasOwnProperty(i)) {
          var a2 = e3[i], o2 = [], s2 = a2.Rect;
          if (a2.Rect && (a2.Rect = $(a2.Rect, r3)), r3.internal.newObjectDeferredBegin(a2.objId, true), a2.DA = At.createDefaultAppearanceStream(a2), "object" === _typeof(a2) && "function" == typeof a2.getKeyValueListForStream && (o2 = a2.getKeyValueListForStream()), a2.Rect = s2, a2.hasAppearanceStream && !a2.appearanceStreamContent) {
            var c2 = Q(a2);
            o2.push({ key: "AP", value: "<</N " + c2 + ">>" }), r3.internal.acroformPlugin.xForms.push(c2);
          }
          if (a2.appearanceStreamContent) {
            var u2 = "";
            for (var h2 in a2.appearanceStreamContent) if (a2.appearanceStreamContent.hasOwnProperty(h2)) {
              var l2 = a2.appearanceStreamContent[h2];
              if (u2 += "/" + h2 + " ", u2 += "<<", Object.keys(l2).length >= 1 || Array.isArray(l2)) {
                for (var i in l2) if (l2.hasOwnProperty(i)) {
                  var f2 = l2[i];
                  "function" == typeof f2 && (f2 = f2.call(r3, a2)), u2 += "/" + i + " " + f2 + " ", r3.internal.acroformPlugin.xForms.indexOf(f2) >= 0 || r3.internal.acroformPlugin.xForms.push(f2);
                }
              } else "function" == typeof (f2 = l2) && (f2 = f2.call(r3, a2)), u2 += "/" + i + " " + f2, r3.internal.acroformPlugin.xForms.indexOf(f2) >= 0 || r3.internal.acroformPlugin.xForms.push(f2);
              u2 += ">>";
            }
            o2.push({ key: "AP", value: "<<\n" + u2 + ">>" });
          }
          r3.internal.putStream({ additionalKeyValues: o2, objectId: a2.objId }), r3.internal.out("endobj");
        }
        n2 && it(r3.internal.acroformPlugin.xForms, r3);
      }(r2, e2);
    }), e2.internal.acroformPlugin.isInitialized = true;
  }
}, ot = q.__acroform__.arrayToPdfArray = function(e2, r, n2) {
  var i = function(t2) {
    return t2;
  };
  if (Array.isArray(e2)) {
    for (var a2 = "[", o2 = 0; o2 < e2.length; o2++) switch (0 !== o2 && (a2 += " "), _typeof(e2[o2])) {
      case "boolean":
      case "number":
      case "object":
        a2 += e2[o2].toString();
        break;
      case "string":
        "/" !== e2[o2].substr(0, 1) ? (void 0 !== r && n2 && (i = n2.internal.getEncryptor(r)), a2 += "(" + R(i(e2[o2].toString())) + ")") : a2 += e2[o2].toString();
    }
    return a2 += "]";
  }
  throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
};
var st = function(t2, e2, r) {
  var n2 = function(t3) {
    return t3;
  };
  return void 0 !== e2 && r && (n2 = r.internal.getEncryptor(e2)), (t2 = t2 || "").toString(), t2 = "(" + R(n2(t2)) + ")";
}, ct = function() {
  this._objId = void 0, this._scope = void 0, Object.defineProperty(this, "objId", { get: function() {
    if (void 0 === this._objId) {
      if (void 0 === this.scope) return;
      this._objId = this.scope.internal.newObjectDeferred();
    }
    return this._objId;
  }, set: function(t2) {
    this._objId = t2;
  } }), Object.defineProperty(this, "scope", { value: this._scope, writable: true });
};
ct.prototype.toString = function() {
  return this.objId + " 0 R";
}, ct.prototype.putStream = function() {
  var t2 = this.getKeyValueListForStream();
  this.scope.internal.putStream({ data: this.stream, additionalKeyValues: t2, objectId: this.objId }), this.scope.internal.out("endobj");
}, ct.prototype.getKeyValueListForStream = function() {
  var t2 = [], e2 = Object.getOwnPropertyNames(this).filter(function(t3) {
    return "content" != t3 && "appearanceStreamContent" != t3 && "scope" != t3 && "objId" != t3 && "_" != t3.substring(0, 1);
  });
  for (var r in e2) if (false === Object.getOwnPropertyDescriptor(this, e2[r]).configurable) {
    var n2 = e2[r], i = this[n2];
    i && (Array.isArray(i) ? t2.push({ key: n2, value: ot(i, this.objId, this.scope) }) : i instanceof ct ? (i.scope = this.scope, t2.push({ key: n2, value: i.objId + " 0 R" })) : "function" != typeof i && t2.push({ key: n2, value: i }));
  }
  return t2;
};
var ut = function() {
  ct.call(this), Object.defineProperty(this, "Type", { value: "/XObject", configurable: false, writable: true }), Object.defineProperty(this, "Subtype", { value: "/Form", configurable: false, writable: true }), Object.defineProperty(this, "FormType", { value: 1, configurable: false, writable: true });
  var t2, e2 = [];
  Object.defineProperty(this, "BBox", { configurable: false, get: function() {
    return e2;
  }, set: function(t3) {
    e2 = t3;
  } }), Object.defineProperty(this, "Resources", { value: "2 0 R", configurable: false, writable: true }), Object.defineProperty(this, "stream", { enumerable: false, configurable: true, set: function(e3) {
    t2 = e3.trim();
  }, get: function() {
    return t2 || null;
  } });
};
H(ut, ct);
var ht = function() {
  ct.call(this);
  var t2, e2 = [];
  Object.defineProperty(this, "Kids", { enumerable: false, configurable: true, get: function() {
    return e2.length > 0 ? e2 : void 0;
  } }), Object.defineProperty(this, "Fields", { enumerable: false, configurable: false, get: function() {
    return e2;
  } }), Object.defineProperty(this, "DA", { enumerable: false, configurable: false, get: function() {
    if (t2) {
      var e3 = function(t3) {
        return t3;
      };
      return this.scope && (e3 = this.scope.internal.getEncryptor(this.objId)), "(" + R(e3(t2)) + ")";
    }
  }, set: function(e3) {
    t2 = e3;
  } });
};
H(ht, ct);
var lt = function t() {
  ct.call(this);
  var e2 = 4;
  Object.defineProperty(this, "F", { enumerable: false, configurable: false, get: function() {
    return e2;
  }, set: function(t2) {
    if (isNaN(t2)) throw new Error('Invalid value "' + t2 + '" for attribute F supplied.');
    e2 = t2;
  } }), Object.defineProperty(this, "showWhenPrinted", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(e2, 3));
  }, set: function(t2) {
    true === Boolean(t2) ? this.F = K(e2, 3) : this.F = Z$1(e2, 3);
  } });
  var r = 0;
  Object.defineProperty(this, "Ff", { enumerable: false, configurable: false, get: function() {
    return r;
  }, set: function(t2) {
    if (isNaN(t2)) throw new Error('Invalid value "' + t2 + '" for attribute Ff supplied.');
    r = t2;
  } });
  var n2 = [];
  Object.defineProperty(this, "Rect", { enumerable: false, configurable: false, get: function() {
    if (0 !== n2.length) return n2;
  }, set: function(t2) {
    n2 = void 0 !== t2 ? t2 : [];
  } }), Object.defineProperty(this, "x", { enumerable: true, configurable: true, get: function() {
    return !n2 || isNaN(n2[0]) ? 0 : n2[0];
  }, set: function(t2) {
    n2[0] = t2;
  } }), Object.defineProperty(this, "y", { enumerable: true, configurable: true, get: function() {
    return !n2 || isNaN(n2[1]) ? 0 : n2[1];
  }, set: function(t2) {
    n2[1] = t2;
  } }), Object.defineProperty(this, "width", { enumerable: true, configurable: true, get: function() {
    return !n2 || isNaN(n2[2]) ? 0 : n2[2];
  }, set: function(t2) {
    n2[2] = t2;
  } }), Object.defineProperty(this, "height", { enumerable: true, configurable: true, get: function() {
    return !n2 || isNaN(n2[3]) ? 0 : n2[3];
  }, set: function(t2) {
    n2[3] = t2;
  } });
  var i = "";
  Object.defineProperty(this, "FT", { enumerable: true, configurable: false, get: function() {
    return i;
  }, set: function(t2) {
    switch (t2) {
      case "/Btn":
      case "/Tx":
      case "/Ch":
      case "/Sig":
        i = t2;
        break;
      default:
        throw new Error('Invalid value "' + t2 + '" for attribute FT supplied.');
    }
  } });
  var a2 = null;
  Object.defineProperty(this, "T", { enumerable: true, configurable: false, get: function() {
    if (!a2 || a2.length < 1) {
      if (this instanceof yt) return;
      a2 = "FieldObject" + t.FieldNum++;
    }
    var e3 = function(t2) {
      return t2;
    };
    return this.scope && (e3 = this.scope.internal.getEncryptor(this.objId)), "(" + R(e3(a2)) + ")";
  }, set: function(t2) {
    a2 = t2.toString();
  } }), Object.defineProperty(this, "fieldName", { configurable: true, enumerable: true, get: function() {
    return a2;
  }, set: function(t2) {
    a2 = t2;
  } });
  var o2 = "helvetica";
  Object.defineProperty(this, "fontName", { enumerable: true, configurable: true, get: function() {
    return o2;
  }, set: function(t2) {
    o2 = t2;
  } });
  var s2 = "normal";
  Object.defineProperty(this, "fontStyle", { enumerable: true, configurable: true, get: function() {
    return s2;
  }, set: function(t2) {
    s2 = t2;
  } });
  var c2 = 0;
  Object.defineProperty(this, "fontSize", { enumerable: true, configurable: true, get: function() {
    return c2;
  }, set: function(t2) {
    c2 = t2;
  } });
  var u2 = void 0;
  Object.defineProperty(this, "maxFontSize", { enumerable: true, configurable: true, get: function() {
    return void 0 === u2 ? 50 / D : u2;
  }, set: function(t2) {
    u2 = t2;
  } });
  var h2 = "black";
  Object.defineProperty(this, "color", { enumerable: true, configurable: true, get: function() {
    return h2;
  }, set: function(t2) {
    h2 = t2;
  } });
  var l2 = "/F1 0 Tf 0 g";
  Object.defineProperty(this, "DA", { enumerable: true, configurable: false, get: function() {
    if (!(!l2 || this instanceof yt || this instanceof Nt)) return st(l2, this.objId, this.scope);
  }, set: function(t2) {
    t2 = t2.toString(), l2 = t2;
  } });
  var f2 = null;
  Object.defineProperty(this, "DV", { enumerable: false, configurable: false, get: function() {
    if (f2) return this instanceof mt == false ? st(f2, this.objId, this.scope) : f2;
  }, set: function(t2) {
    t2 = t2.toString(), f2 = this instanceof mt == false ? "(" === t2.substr(0, 1) ? T$1(t2.substr(1, t2.length - 2)) : T$1(t2) : t2;
  } }), Object.defineProperty(this, "defaultValue", { enumerable: true, configurable: true, get: function() {
    return this instanceof mt == true ? T$1(f2.substr(1, f2.length - 1)) : f2;
  }, set: function(t2) {
    t2 = t2.toString(), f2 = this instanceof mt == true ? "/" + t2 : t2;
  } });
  var d2 = null;
  Object.defineProperty(this, "_V", { enumerable: false, configurable: false, get: function() {
    if (d2) return d2;
  }, set: function(t2) {
    this.V = t2;
  } }), Object.defineProperty(this, "V", { enumerable: false, configurable: false, get: function() {
    if (d2) return this instanceof mt == false ? st(d2, this.objId, this.scope) : d2;
  }, set: function(t2) {
    t2 = t2.toString(), d2 = this instanceof mt == false ? "(" === t2.substr(0, 1) ? T$1(t2.substr(1, t2.length - 2)) : T$1(t2) : t2;
  } }), Object.defineProperty(this, "value", { enumerable: true, configurable: true, get: function() {
    return this instanceof mt == true ? T$1(d2.substr(1, d2.length - 1)) : d2;
  }, set: function(t2) {
    t2 = t2.toString(), d2 = this instanceof mt == true ? "/" + t2 : t2;
  } }), Object.defineProperty(this, "hasAnnotation", { enumerable: true, configurable: true, get: function() {
    return this.Rect;
  } }), Object.defineProperty(this, "Type", { enumerable: true, configurable: false, get: function() {
    return this.hasAnnotation ? "/Annot" : null;
  } }), Object.defineProperty(this, "Subtype", { enumerable: true, configurable: false, get: function() {
    return this.hasAnnotation ? "/Widget" : null;
  } });
  var p2, g2 = false;
  Object.defineProperty(this, "hasAppearanceStream", { enumerable: true, configurable: true, get: function() {
    return g2;
  }, set: function(t2) {
    t2 = Boolean(t2), g2 = t2;
  } }), Object.defineProperty(this, "page", { enumerable: true, configurable: true, get: function() {
    if (p2) return p2;
  }, set: function(t2) {
    p2 = t2;
  } }), Object.defineProperty(this, "readOnly", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 1));
  }, set: function(t2) {
    true === Boolean(t2) ? this.Ff = K(this.Ff, 1) : this.Ff = Z$1(this.Ff, 1);
  } }), Object.defineProperty(this, "required", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 2));
  }, set: function(t2) {
    true === Boolean(t2) ? this.Ff = K(this.Ff, 2) : this.Ff = Z$1(this.Ff, 2);
  } }), Object.defineProperty(this, "noExport", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 3));
  }, set: function(t2) {
    true === Boolean(t2) ? this.Ff = K(this.Ff, 3) : this.Ff = Z$1(this.Ff, 3);
  } });
  var m2 = null;
  Object.defineProperty(this, "Q", { enumerable: true, configurable: false, get: function() {
    if (null !== m2) return m2;
  }, set: function(t2) {
    if (-1 === [0, 1, 2].indexOf(t2)) throw new Error('Invalid value "' + t2 + '" for attribute Q supplied.');
    m2 = t2;
  } }), Object.defineProperty(this, "textAlign", { get: function() {
    var t2;
    switch (m2) {
      case 0:
      default:
        t2 = "left";
        break;
      case 1:
        t2 = "center";
        break;
      case 2:
        t2 = "right";
    }
    return t2;
  }, configurable: true, enumerable: true, set: function(t2) {
    switch (t2) {
      case "right":
      case 2:
        m2 = 2;
        break;
      case "center":
      case 1:
        m2 = 1;
        break;
      case "left":
      case 0:
      default:
        m2 = 0;
    }
  } });
};
H(lt, ct);
var ft = function() {
  lt.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
  var t2 = 0;
  Object.defineProperty(this, "TI", { enumerable: true, configurable: false, get: function() {
    return t2;
  }, set: function(e3) {
    t2 = e3;
  } }), Object.defineProperty(this, "topIndex", { enumerable: true, configurable: true, get: function() {
    return t2;
  }, set: function(e3) {
    t2 = e3;
  } });
  var e2 = [];
  Object.defineProperty(this, "Opt", { enumerable: true, configurable: false, get: function() {
    return ot(e2, this.objId, this.scope);
  }, set: function(t3) {
    var r, n2;
    n2 = [], "string" == typeof (r = t3) && (n2 = function(t4, e3, r2) {
      r2 || (r2 = 1);
      for (var n3, i = []; n3 = e3.exec(t4); ) i.push(n3[r2]);
      return i;
    }(r, /\((.*?)\)/g)), e2 = n2;
  } }), this.getOptions = function() {
    return e2;
  }, this.setOptions = function(t3) {
    e2 = t3, this.sort && e2.sort();
  }, this.addOption = function(t3) {
    t3 = (t3 = t3 || "").toString(), e2.push(t3), this.sort && e2.sort();
  }, this.removeOption = function(t3, r) {
    for (r = r || false, t3 = (t3 = t3 || "").toString(); -1 !== e2.indexOf(t3) && (e2.splice(e2.indexOf(t3), 1), false !== r); ) ;
  }, Object.defineProperty(this, "combo", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 18));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 18) : this.Ff = Z$1(this.Ff, 18);
  } }), Object.defineProperty(this, "edit", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 19));
  }, set: function(t3) {
    true === this.combo && (true === Boolean(t3) ? this.Ff = K(this.Ff, 19) : this.Ff = Z$1(this.Ff, 19));
  } }), Object.defineProperty(this, "sort", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 20));
  }, set: function(t3) {
    true === Boolean(t3) ? (this.Ff = K(this.Ff, 20), e2.sort()) : this.Ff = Z$1(this.Ff, 20);
  } }), Object.defineProperty(this, "multiSelect", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 22));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 22) : this.Ff = Z$1(this.Ff, 22);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 23));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 23) : this.Ff = Z$1(this.Ff, 23);
  } }), Object.defineProperty(this, "commitOnSelChange", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 27));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 27) : this.Ff = Z$1(this.Ff, 27);
  } }), this.hasAppearanceStream = false;
};
H(ft, lt);
var dt = function() {
  ft.call(this), this.fontName = "helvetica", this.combo = false;
};
H(dt, ft);
var pt = function() {
  dt.call(this), this.combo = true;
};
H(pt, dt);
var gt = function() {
  pt.call(this), this.edit = true;
};
H(gt, pt);
var mt = function() {
  lt.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 15));
  }, set: function(t2) {
    true === Boolean(t2) ? this.Ff = K(this.Ff, 15) : this.Ff = Z$1(this.Ff, 15);
  } }), Object.defineProperty(this, "radio", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 16));
  }, set: function(t2) {
    true === Boolean(t2) ? this.Ff = K(this.Ff, 16) : this.Ff = Z$1(this.Ff, 16);
  } }), Object.defineProperty(this, "pushButton", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 17));
  }, set: function(t2) {
    true === Boolean(t2) ? this.Ff = K(this.Ff, 17) : this.Ff = Z$1(this.Ff, 17);
  } }), Object.defineProperty(this, "radioIsUnison", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 26));
  }, set: function(t2) {
    true === Boolean(t2) ? this.Ff = K(this.Ff, 26) : this.Ff = Z$1(this.Ff, 26);
  } });
  var e2, r = {};
  Object.defineProperty(this, "MK", { enumerable: false, configurable: false, get: function() {
    var t2 = function(t3) {
      return t3;
    };
    if (this.scope && (t2 = this.scope.internal.getEncryptor(this.objId)), 0 !== Object.keys(r).length) {
      var e3, n2 = [];
      for (e3 in n2.push("<<"), r) n2.push("/" + e3 + " (" + R(t2(r[e3])) + ")");
      return n2.push(">>"), n2.join("\n");
    }
  }, set: function(e3) {
    "object" === _typeof(e3) && (r = e3);
  } }), Object.defineProperty(this, "caption", { enumerable: true, configurable: true, get: function() {
    return r.CA || "";
  }, set: function(t2) {
    "string" == typeof t2 && (r.CA = t2);
  } }), Object.defineProperty(this, "AS", { enumerable: false, configurable: false, get: function() {
    return e2;
  }, set: function(t2) {
    e2 = t2;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: true, configurable: true, get: function() {
    return e2.substr(1, e2.length - 1);
  }, set: function(t2) {
    e2 = "/" + t2;
  } });
};
H(mt, lt);
var vt = function() {
  mt.call(this), this.pushButton = true;
};
H(vt, mt);
var bt = function() {
  mt.call(this), this.radio = true, this.pushButton = false;
  var t2 = [];
  Object.defineProperty(this, "Kids", { enumerable: true, configurable: false, get: function() {
    return t2;
  }, set: function(e2) {
    t2 = void 0 !== e2 ? e2 : [];
  } });
};
H(bt, mt);
var yt = function() {
  var e2, r;
  lt.call(this), Object.defineProperty(this, "Parent", { enumerable: false, configurable: false, get: function() {
    return e2;
  }, set: function(t2) {
    e2 = t2;
  } }), Object.defineProperty(this, "optionName", { enumerable: false, configurable: true, get: function() {
    return r;
  }, set: function(t2) {
    r = t2;
  } });
  var n2, i = {};
  Object.defineProperty(this, "MK", { enumerable: false, configurable: false, get: function() {
    var t2 = function(t3) {
      return t3;
    };
    this.scope && (t2 = this.scope.internal.getEncryptor(this.objId));
    var e3, r2 = [];
    for (e3 in r2.push("<<"), i) r2.push("/" + e3 + " (" + R(t2(i[e3])) + ")");
    return r2.push(">>"), r2.join("\n");
  }, set: function(e3) {
    "object" === _typeof(e3) && (i = e3);
  } }), Object.defineProperty(this, "caption", { enumerable: true, configurable: true, get: function() {
    return i.CA || "";
  }, set: function(t2) {
    "string" == typeof t2 && (i.CA = t2);
  } }), Object.defineProperty(this, "AS", { enumerable: false, configurable: false, get: function() {
    return n2;
  }, set: function(t2) {
    n2 = t2;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: true, configurable: true, get: function() {
    return n2.substr(1, n2.length - 1);
  }, set: function(t2) {
    n2 = "/" + t2;
  } }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = At.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
};
H(yt, lt), bt.prototype.setAppearance = function(t2) {
  if (!("createAppearanceStream" in t2) || !("getCA" in t2)) throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
  for (var e2 in this.Kids) if (this.Kids.hasOwnProperty(e2)) {
    var r = this.Kids[e2];
    r.appearanceStreamContent = t2.createAppearanceStream(r.optionName), r.caption = t2.getCA();
  }
}, bt.prototype.createOption = function(t2) {
  var e2 = new yt();
  return e2.Parent = this, e2.optionName = t2, this.Kids.push(e2), xt.call(this.scope, e2), e2;
};
var wt = function() {
  mt.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = At.CheckBox.createAppearanceStream();
};
H(wt, mt);
var Nt = function() {
  lt.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 13));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 13) : this.Ff = Z$1(this.Ff, 13);
  } }), Object.defineProperty(this, "fileSelect", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 21));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 21) : this.Ff = Z$1(this.Ff, 21);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 23));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 23) : this.Ff = Z$1(this.Ff, 23);
  } }), Object.defineProperty(this, "doNotScroll", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 24));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 24) : this.Ff = Z$1(this.Ff, 24);
  } }), Object.defineProperty(this, "comb", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 25));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 25) : this.Ff = Z$1(this.Ff, 25);
  } }), Object.defineProperty(this, "richText", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 26));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 26) : this.Ff = Z$1(this.Ff, 26);
  } });
  var t2 = null;
  Object.defineProperty(this, "MaxLen", { enumerable: true, configurable: false, get: function() {
    return t2;
  }, set: function(e2) {
    t2 = e2;
  } }), Object.defineProperty(this, "maxLength", { enumerable: true, configurable: true, get: function() {
    return t2;
  }, set: function(e2) {
    Number.isInteger(e2) && (t2 = e2);
  } }), Object.defineProperty(this, "hasAppearanceStream", { enumerable: true, configurable: true, get: function() {
    return this.V || this.DV;
  } });
};
H(Nt, lt);
var Lt = function() {
  Nt.call(this), Object.defineProperty(this, "password", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 14));
  }, set: function(t2) {
    true === Boolean(t2) ? this.Ff = K(this.Ff, 14) : this.Ff = Z$1(this.Ff, 14);
  } }), this.password = true;
};
H(Lt, Nt);
var At = { CheckBox: { createAppearanceStream: function() {
  return { N: { On: At.CheckBox.YesNormal }, D: { On: At.CheckBox.YesPushDown, Off: At.CheckBox.OffPushDown } };
}, YesPushDown: function(t2) {
  var e2 = V$1(t2);
  e2.scope = t2.scope;
  var r = [], n2 = t2.scope.internal.getFont(t2.fontName, t2.fontStyle).id, i = t2.scope.__private__.encodeColorString(t2.color), a2 = tt(t2, t2.caption);
  return r.push("0.749023 g"), r.push("0 0 " + U$1(At.internal.getWidth(t2)) + " " + U$1(At.internal.getHeight(t2)) + " re"), r.push("f"), r.push("BMC"), r.push("q"), r.push("0 0 1 rg"), r.push("/" + n2 + " " + U$1(a2.fontSize) + " Tf " + i), r.push("BT"), r.push(a2.text), r.push("ET"), r.push("Q"), r.push("EMC"), e2.stream = r.join("\n"), e2;
}, YesNormal: function(t2) {
  var e2 = V$1(t2);
  e2.scope = t2.scope;
  var r = t2.scope.internal.getFont(t2.fontName, t2.fontStyle).id, n2 = t2.scope.__private__.encodeColorString(t2.color), i = [], a2 = At.internal.getHeight(t2), o2 = At.internal.getWidth(t2), s2 = tt(t2, t2.caption);
  return i.push("1 g"), i.push("0 0 " + U$1(o2) + " " + U$1(a2) + " re"), i.push("f"), i.push("q"), i.push("0 0 1 rg"), i.push("0 0 " + U$1(o2 - 1) + " " + U$1(a2 - 1) + " re"), i.push("W"), i.push("n"), i.push("0 g"), i.push("BT"), i.push("/" + r + " " + U$1(s2.fontSize) + " Tf " + n2), i.push(s2.text), i.push("ET"), i.push("Q"), e2.stream = i.join("\n"), e2;
}, OffPushDown: function(t2) {
  var e2 = V$1(t2);
  e2.scope = t2.scope;
  var r = [];
  return r.push("0.749023 g"), r.push("0 0 " + U$1(At.internal.getWidth(t2)) + " " + U$1(At.internal.getHeight(t2)) + " re"), r.push("f"), e2.stream = r.join("\n"), e2;
} }, RadioButton: { Circle: { createAppearanceStream: function(t2) {
  var e2 = { D: { Off: At.RadioButton.Circle.OffPushDown }, N: {} };
  return e2.N[t2] = At.RadioButton.Circle.YesNormal, e2.D[t2] = At.RadioButton.Circle.YesPushDown, e2;
}, getCA: function() {
  return "l";
}, YesNormal: function(t2) {
  var e2 = V$1(t2);
  e2.scope = t2.scope;
  var r = [], n2 = At.internal.getWidth(t2) <= At.internal.getHeight(t2) ? At.internal.getWidth(t2) / 4 : At.internal.getHeight(t2) / 4;
  n2 = Number((0.9 * n2).toFixed(5));
  var i = At.internal.Bezier_C, a2 = Number((n2 * i).toFixed(5));
  return r.push("q"), r.push("1 0 0 1 " + z$1(At.internal.getWidth(t2) / 2) + " " + z$1(At.internal.getHeight(t2) / 2) + " cm"), r.push(n2 + " 0 m"), r.push(n2 + " " + a2 + " " + a2 + " " + n2 + " 0 " + n2 + " c"), r.push("-" + a2 + " " + n2 + " -" + n2 + " " + a2 + " -" + n2 + " 0 c"), r.push("-" + n2 + " -" + a2 + " -" + a2 + " -" + n2 + " 0 -" + n2 + " c"), r.push(a2 + " -" + n2 + " " + n2 + " -" + a2 + " " + n2 + " 0 c"), r.push("f"), r.push("Q"), e2.stream = r.join("\n"), e2;
}, YesPushDown: function(t2) {
  var e2 = V$1(t2);
  e2.scope = t2.scope;
  var r = [], n2 = At.internal.getWidth(t2) <= At.internal.getHeight(t2) ? At.internal.getWidth(t2) / 4 : At.internal.getHeight(t2) / 4;
  n2 = Number((0.9 * n2).toFixed(5));
  var i = Number((2 * n2).toFixed(5)), a2 = Number((i * At.internal.Bezier_C).toFixed(5)), o2 = Number((n2 * At.internal.Bezier_C).toFixed(5));
  return r.push("0.749023 g"), r.push("q"), r.push("1 0 0 1 " + z$1(At.internal.getWidth(t2) / 2) + " " + z$1(At.internal.getHeight(t2) / 2) + " cm"), r.push(i + " 0 m"), r.push(i + " " + a2 + " " + a2 + " " + i + " 0 " + i + " c"), r.push("-" + a2 + " " + i + " -" + i + " " + a2 + " -" + i + " 0 c"), r.push("-" + i + " -" + a2 + " -" + a2 + " -" + i + " 0 -" + i + " c"), r.push(a2 + " -" + i + " " + i + " -" + a2 + " " + i + " 0 c"), r.push("f"), r.push("Q"), r.push("0 g"), r.push("q"), r.push("1 0 0 1 " + z$1(At.internal.getWidth(t2) / 2) + " " + z$1(At.internal.getHeight(t2) / 2) + " cm"), r.push(n2 + " 0 m"), r.push(n2 + " " + o2 + " " + o2 + " " + n2 + " 0 " + n2 + " c"), r.push("-" + o2 + " " + n2 + " -" + n2 + " " + o2 + " -" + n2 + " 0 c"), r.push("-" + n2 + " -" + o2 + " -" + o2 + " -" + n2 + " 0 -" + n2 + " c"), r.push(o2 + " -" + n2 + " " + n2 + " -" + o2 + " " + n2 + " 0 c"), r.push("f"), r.push("Q"), e2.stream = r.join("\n"), e2;
}, OffPushDown: function(t2) {
  var e2 = V$1(t2);
  e2.scope = t2.scope;
  var r = [], n2 = At.internal.getWidth(t2) <= At.internal.getHeight(t2) ? At.internal.getWidth(t2) / 4 : At.internal.getHeight(t2) / 4;
  n2 = Number((0.9 * n2).toFixed(5));
  var i = Number((2 * n2).toFixed(5)), a2 = Number((i * At.internal.Bezier_C).toFixed(5));
  return r.push("0.749023 g"), r.push("q"), r.push("1 0 0 1 " + z$1(At.internal.getWidth(t2) / 2) + " " + z$1(At.internal.getHeight(t2) / 2) + " cm"), r.push(i + " 0 m"), r.push(i + " " + a2 + " " + a2 + " " + i + " 0 " + i + " c"), r.push("-" + a2 + " " + i + " -" + i + " " + a2 + " -" + i + " 0 c"), r.push("-" + i + " -" + a2 + " -" + a2 + " -" + i + " 0 -" + i + " c"), r.push(a2 + " -" + i + " " + i + " -" + a2 + " " + i + " 0 c"), r.push("f"), r.push("Q"), e2.stream = r.join("\n"), e2;
} }, Cross: { createAppearanceStream: function(t2) {
  var e2 = { D: { Off: At.RadioButton.Cross.OffPushDown }, N: {} };
  return e2.N[t2] = At.RadioButton.Cross.YesNormal, e2.D[t2] = At.RadioButton.Cross.YesPushDown, e2;
}, getCA: function() {
  return "8";
}, YesNormal: function(t2) {
  var e2 = V$1(t2);
  e2.scope = t2.scope;
  var r = [], n2 = At.internal.calculateCross(t2);
  return r.push("q"), r.push("1 1 " + U$1(At.internal.getWidth(t2) - 2) + " " + U$1(At.internal.getHeight(t2) - 2) + " re"), r.push("W"), r.push("n"), r.push(U$1(n2.x1.x) + " " + U$1(n2.x1.y) + " m"), r.push(U$1(n2.x2.x) + " " + U$1(n2.x2.y) + " l"), r.push(U$1(n2.x4.x) + " " + U$1(n2.x4.y) + " m"), r.push(U$1(n2.x3.x) + " " + U$1(n2.x3.y) + " l"), r.push("s"), r.push("Q"), e2.stream = r.join("\n"), e2;
}, YesPushDown: function(t2) {
  var e2 = V$1(t2);
  e2.scope = t2.scope;
  var r = At.internal.calculateCross(t2), n2 = [];
  return n2.push("0.749023 g"), n2.push("0 0 " + U$1(At.internal.getWidth(t2)) + " " + U$1(At.internal.getHeight(t2)) + " re"), n2.push("f"), n2.push("q"), n2.push("1 1 " + U$1(At.internal.getWidth(t2) - 2) + " " + U$1(At.internal.getHeight(t2) - 2) + " re"), n2.push("W"), n2.push("n"), n2.push(U$1(r.x1.x) + " " + U$1(r.x1.y) + " m"), n2.push(U$1(r.x2.x) + " " + U$1(r.x2.y) + " l"), n2.push(U$1(r.x4.x) + " " + U$1(r.x4.y) + " m"), n2.push(U$1(r.x3.x) + " " + U$1(r.x3.y) + " l"), n2.push("s"), n2.push("Q"), e2.stream = n2.join("\n"), e2;
}, OffPushDown: function(t2) {
  var e2 = V$1(t2);
  e2.scope = t2.scope;
  var r = [];
  return r.push("0.749023 g"), r.push("0 0 " + U$1(At.internal.getWidth(t2)) + " " + U$1(At.internal.getHeight(t2)) + " re"), r.push("f"), e2.stream = r.join("\n"), e2;
} } }, createDefaultAppearanceStream: function(t2) {
  var e2 = t2.scope.internal.getFont(t2.fontName, t2.fontStyle).id, r = t2.scope.__private__.encodeColorString(t2.color);
  return "/" + e2 + " " + t2.fontSize + " Tf " + r;
} };
At.internal = { Bezier_C: 0.551915024494, calculateCross: function(t2) {
  var e2 = At.internal.getWidth(t2), r = At.internal.getHeight(t2), n2 = Math.min(e2, r);
  return { x1: { x: (e2 - n2) / 2, y: (r - n2) / 2 + n2 }, x2: { x: (e2 - n2) / 2 + n2, y: (r - n2) / 2 }, x3: { x: (e2 - n2) / 2, y: (r - n2) / 2 }, x4: { x: (e2 - n2) / 2 + n2, y: (r - n2) / 2 + n2 } };
} }, At.internal.getWidth = function(e2) {
  var r = 0;
  return "object" === _typeof(e2) && (r = W(e2.Rect[2])), r;
}, At.internal.getHeight = function(e2) {
  var r = 0;
  return "object" === _typeof(e2) && (r = W(e2.Rect[3])), r;
};
var xt = q.addField = function(t2) {
  if (at(this, t2), !(t2 instanceof lt)) throw new Error("Invalid argument passed to jsPDF.addField.");
  var e2;
  return (e2 = t2).scope.internal.acroformPlugin.printedOut && (e2.scope.internal.acroformPlugin.printedOut = false, e2.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), e2.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(e2), t2.page = t2.scope.internal.getCurrentPageInfo().pageNumber, this;
};
q.AcroFormChoiceField = ft, q.AcroFormListBox = dt, q.AcroFormComboBox = pt, q.AcroFormEditBox = gt, q.AcroFormButton = mt, q.AcroFormPushButton = vt, q.AcroFormRadioButton = bt, q.AcroFormCheckBox = wt, q.AcroFormTextField = Nt, q.AcroFormPasswordField = Lt, q.AcroFormAppearance = At, q.AcroForm = { ChoiceField: ft, ListBox: dt, ComboBox: pt, EditBox: gt, Button: mt, PushButton: vt, RadioButton: bt, CheckBox: wt, TextField: Nt, PasswordField: Lt, Appearance: At }, E$1.AcroForm = { ChoiceField: ft, ListBox: dt, ComboBox: pt, EditBox: gt, Button: mt, PushButton: vt, RadioButton: bt, CheckBox: wt, TextField: Nt, PasswordField: Lt, Appearance: At };
function _t(t2) {
  return t2.reduce(function(t3, e2, r) {
    return t3[e2] = r, t3;
  }, {});
}
!function(e2) {
  e2.__addimage__ = {};
  var r = "UNKNOWN", n2 = { PNG: [[137, 80, 78, 71]], TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]], JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]], JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]], GIF87a: [[71, 73, 70, 56, 55, 97]], GIF89a: [[71, 73, 70, 56, 57, 97]], WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]], BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]] }, i = e2.__addimage__.getImageFileTypeByImageData = function(t2, e3) {
    var i2, a3, o3, s3, c3, u2 = r;
    if ("RGBA" === (e3 = e3 || r) || void 0 !== t2.data && t2.data instanceof Uint8ClampedArray && "height" in t2 && "width" in t2) return "RGBA";
    if (x2(t2)) for (c3 in n2) for (o3 = n2[c3], i2 = 0; i2 < o3.length; i2 += 1) {
      for (s3 = true, a3 = 0; a3 < o3[i2].length; a3 += 1) if (void 0 !== o3[i2][a3] && o3[i2][a3] !== t2[a3]) {
        s3 = false;
        break;
      }
      if (true === s3) {
        u2 = c3;
        break;
      }
    }
    else for (c3 in n2) for (o3 = n2[c3], i2 = 0; i2 < o3.length; i2 += 1) {
      for (s3 = true, a3 = 0; a3 < o3[i2].length; a3 += 1) if (void 0 !== o3[i2][a3] && o3[i2][a3] !== t2.charCodeAt(a3)) {
        s3 = false;
        break;
      }
      if (true === s3) {
        u2 = c3;
        break;
      }
    }
    return u2 === r && e3 !== r && (u2 = e3), u2;
  }, a2 = function t2(e3) {
    for (var r2 = this.internal.write, n3 = this.internal.putStream, i2 = (0, this.internal.getFilters)(); -1 !== i2.indexOf("FlateEncode"); ) i2.splice(i2.indexOf("FlateEncode"), 1);
    e3.objectId = this.internal.newObject();
    var a3 = [];
    if (a3.push({ key: "Type", value: "/XObject" }), a3.push({ key: "Subtype", value: "/Image" }), a3.push({ key: "Width", value: e3.width }), a3.push({ key: "Height", value: e3.height }), e3.colorSpace === b2.INDEXED ? a3.push({ key: "ColorSpace", value: "[/Indexed /DeviceRGB " + (e3.palette.length / 3 - 1) + " " + ("sMask" in e3 && void 0 !== e3.sMask ? e3.objectId + 2 : e3.objectId + 1) + " 0 R]" }) : (a3.push({ key: "ColorSpace", value: "/" + e3.colorSpace }), e3.colorSpace === b2.DEVICE_CMYK && a3.push({ key: "Decode", value: "[1 0 1 0 1 0 1 0]" })), a3.push({ key: "BitsPerComponent", value: e3.bitsPerComponent }), "decodeParameters" in e3 && void 0 !== e3.decodeParameters && a3.push({ key: "DecodeParms", value: "<<" + e3.decodeParameters + ">>" }), "transparency" in e3 && Array.isArray(e3.transparency)) {
      for (var o3 = "", s3 = 0, c3 = e3.transparency.length; s3 < c3; s3++) o3 += e3.transparency[s3] + " " + e3.transparency[s3] + " ";
      a3.push({ key: "Mask", value: "[" + o3 + "]" });
    }
    void 0 !== e3.sMask && a3.push({ key: "SMask", value: e3.objectId + 1 + " 0 R" });
    var u2 = void 0 !== e3.filter ? ["/" + e3.filter] : void 0;
    if (n3({ data: e3.data, additionalKeyValues: a3, alreadyAppliedFilters: u2, objectId: e3.objectId }), r2("endobj"), "sMask" in e3 && void 0 !== e3.sMask) {
      var h3 = "/Predictor " + e3.predictor + " /Colors 1 /BitsPerComponent " + e3.bitsPerComponent + " /Columns " + e3.width, l3 = { width: e3.width, height: e3.height, colorSpace: "DeviceGray", bitsPerComponent: e3.bitsPerComponent, decodeParameters: h3, data: e3.sMask };
      "filter" in e3 && (l3.filter = e3.filter), t2.call(this, l3);
    }
    if (e3.colorSpace === b2.INDEXED) {
      var f3 = this.internal.newObject();
      n3({ data: _2(new Uint8Array(e3.palette)), objectId: f3 }), r2("endobj");
    }
  }, o2 = function() {
    var t2 = this.internal.collections.addImage_images;
    for (var e3 in t2) a2.call(this, t2[e3]);
  }, s2 = function() {
    var t2, e3 = this.internal.collections.addImage_images, r2 = this.internal.write;
    for (var n3 in e3) r2("/I" + (t2 = e3[n3]).index, t2.objectId, "0", "R");
  }, c2 = function() {
    this.internal.collections.addImage_images || (this.internal.collections.addImage_images = {}, this.internal.events.subscribe("putResources", o2), this.internal.events.subscribe("putXobjectDict", s2));
  }, h2 = function() {
    var t2 = this.internal.collections.addImage_images;
    return c2.call(this), t2;
  }, l2 = function() {
    return Object.keys(this.internal.collections.addImage_images).length;
  }, f2 = function(t2) {
    return "function" == typeof e2["process" + t2.toUpperCase()];
  }, d2 = function(e3) {
    return "object" === _typeof(e3) && 1 === e3.nodeType;
  }, p2 = function(t2, r2) {
    if ("IMG" === t2.nodeName && t2.hasAttribute("src")) {
      var n3 = "" + t2.getAttribute("src");
      if (0 === n3.indexOf("data:image/")) return u$1(unescape(n3).split("base64,").pop());
      var i2 = e2.loadFile(n3, true);
      if (void 0 !== i2) return i2;
    }
    if ("CANVAS" === t2.nodeName) {
      if (0 === t2.width || 0 === t2.height) throw new Error("Given canvas must have data. Canvas width: " + t2.width + ", height: " + t2.height);
      var a3;
      switch (r2) {
        case "PNG":
          a3 = "image/png";
          break;
        case "WEBP":
          a3 = "image/webp";
          break;
        case "JPEG":
        case "JPG":
        default:
          a3 = "image/jpeg";
      }
      return u$1(t2.toDataURL(a3, 1).split("base64,").pop());
    }
  }, g2 = function(t2) {
    var e3 = this.internal.collections.addImage_images;
    if (e3) {
      for (var r2 in e3) if (t2 === e3[r2].alias) return e3[r2];
    }
  }, m2 = function(t2, e3, r2) {
    return t2 || e3 || (t2 = -96, e3 = -96), t2 < 0 && (t2 = -1 * r2.width * 72 / t2 / this.internal.scaleFactor), e3 < 0 && (e3 = -1 * r2.height * 72 / e3 / this.internal.scaleFactor), 0 === t2 && (t2 = e3 * r2.width / r2.height), 0 === e3 && (e3 = t2 * r2.height / r2.width), [t2, e3];
  }, v2 = function(t2, e3, r2, n3, i2, a3) {
    var o3 = m2.call(this, r2, n3, i2), s3 = this.internal.getCoordinateString, c3 = this.internal.getVerticalCoordinateString, u2 = h2.call(this);
    if (r2 = o3[0], n3 = o3[1], u2[i2.index] = i2, a3) {
      a3 *= Math.PI / 180;
      var l3 = Math.cos(a3), f3 = Math.sin(a3), d3 = function(t3) {
        return t3.toFixed(4);
      }, p3 = [d3(l3), d3(f3), d3(-1 * f3), d3(l3), 0, 0, "cm"];
    }
    this.internal.write("q"), a3 ? (this.internal.write([1, "0", "0", 1, s3(t2), c3(e3 + n3), "cm"].join(" ")), this.internal.write(p3.join(" ")), this.internal.write([s3(r2), "0", "0", s3(n3), "0", "0", "cm"].join(" "))) : this.internal.write([s3(r2), "0", "0", s3(n3), s3(t2), c3(e3 + n3), "cm"].join(" ")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" ")), this.internal.write("/I" + i2.index + " Do"), this.internal.write("Q");
  }, b2 = e2.color_spaces = { DEVICE_RGB: "DeviceRGB", DEVICE_GRAY: "DeviceGray", DEVICE_CMYK: "DeviceCMYK", CAL_GREY: "CalGray", CAL_RGB: "CalRGB", LAB: "Lab", ICC_BASED: "ICCBased", INDEXED: "Indexed", PATTERN: "Pattern", SEPARATION: "Separation", DEVICE_N: "DeviceN" };
  e2.decode = { DCT_DECODE: "DCTDecode", FLATE_DECODE: "FlateDecode", LZW_DECODE: "LZWDecode", JPX_DECODE: "JPXDecode", JBIG2_DECODE: "JBIG2Decode", ASCII85_DECODE: "ASCII85Decode", ASCII_HEX_DECODE: "ASCIIHexDecode", RUN_LENGTH_DECODE: "RunLengthDecode", CCITT_FAX_DECODE: "CCITTFaxDecode" };
  var y2 = e2.image_compression = { NONE: "NONE", FAST: "FAST", MEDIUM: "MEDIUM", SLOW: "SLOW" }, w2 = e2.__addimage__.sHashCode = function(t2) {
    var e3, r2, n3 = 0;
    if ("string" == typeof t2) for (r2 = t2.length, e3 = 0; e3 < r2; e3++) n3 = (n3 << 5) - n3 + t2.charCodeAt(e3), n3 |= 0;
    else if (x2(t2)) for (r2 = t2.byteLength / 2, e3 = 0; e3 < r2; e3++) n3 = (n3 << 5) - n3 + t2[e3], n3 |= 0;
    return n3;
  }, N2 = e2.__addimage__.validateStringAsBase64 = function(t2) {
    (t2 = t2 || "").toString().trim();
    var e3 = true;
    return 0 === t2.length && (e3 = false), t2.length % 4 != 0 && (e3 = false), false === /^[A-Za-z0-9+/]+$/.test(t2.substr(0, t2.length - 2)) && (e3 = false), false === /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(t2.substr(-2)) && (e3 = false), e3;
  }, L2 = e2.__addimage__.extractImageFromDataUrl = function(t2) {
    var e3 = (t2 = t2 || "").split("base64,"), r2 = null;
    if (2 === e3.length) {
      var n3 = /^data:(\w*\/\w*);*(charset=(?!charset=)[\w=-]*)*;*$/.exec(e3[0]);
      Array.isArray(n3) && (r2 = { mimeType: n3[1], charset: n3[2], data: e3[1] });
    }
    return r2;
  }, A2 = e2.__addimage__.supportsArrayBuffer = function() {
    return "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array;
  };
  e2.__addimage__.isArrayBuffer = function(t2) {
    return A2() && t2 instanceof ArrayBuffer;
  };
  var x2 = e2.__addimage__.isArrayBufferView = function(t2) {
    return A2() && "undefined" != typeof Uint32Array && (t2 instanceof Int8Array || t2 instanceof Uint8Array || "undefined" != typeof Uint8ClampedArray && t2 instanceof Uint8ClampedArray || t2 instanceof Int16Array || t2 instanceof Uint16Array || t2 instanceof Int32Array || t2 instanceof Uint32Array || t2 instanceof Float32Array || t2 instanceof Float64Array);
  }, S2 = e2.__addimage__.binaryStringToUint8Array = function(t2) {
    for (var e3 = t2.length, r2 = new Uint8Array(e3), n3 = 0; n3 < e3; n3++) r2[n3] = t2.charCodeAt(n3);
    return r2;
  }, _2 = e2.__addimage__.arrayBufferToBinaryString = function(t2) {
    for (var e3 = "", r2 = x2(t2) ? t2 : new Uint8Array(t2), n3 = 0; n3 < r2.length; n3 += 8192) e3 += String.fromCharCode.apply(null, r2.subarray(n3, n3 + 8192));
    return e3;
  };
  e2.addImage = function() {
    var e3, n3, i2, a3, o3, s3, u2, h3, l3;
    if ("number" == typeof arguments[1] ? (n3 = r, i2 = arguments[1], a3 = arguments[2], o3 = arguments[3], s3 = arguments[4], u2 = arguments[5], h3 = arguments[6], l3 = arguments[7]) : (n3 = arguments[1], i2 = arguments[2], a3 = arguments[3], o3 = arguments[4], s3 = arguments[5], u2 = arguments[6], h3 = arguments[7], l3 = arguments[8]), "object" === _typeof(e3 = arguments[0]) && !d2(e3) && "imageData" in e3) {
      var f3 = e3;
      e3 = f3.imageData, n3 = f3.format || n3 || r, i2 = f3.x || i2 || 0, a3 = f3.y || a3 || 0, o3 = f3.w || f3.width || o3, s3 = f3.h || f3.height || s3, u2 = f3.alias || u2, h3 = f3.compression || h3, l3 = f3.rotation || f3.angle || l3;
    }
    var p3 = this.internal.getFilters();
    if (void 0 === h3 && -1 !== p3.indexOf("FlateEncode") && (h3 = "SLOW"), isNaN(i2) || isNaN(a3)) throw new Error("Invalid coordinates passed to jsPDF.addImage");
    c2.call(this);
    var g3 = P2.call(this, e3, n3, u2, h3);
    return v2.call(this, i2, a3, o3, s3, g3, l3), this;
  };
  var P2 = function(t2, n3, a3, o3) {
    var s3, c3, u2;
    if ("string" == typeof t2 && i(t2) === r) {
      t2 = unescape(t2);
      var h3 = k2(t2, false);
      ("" !== h3 || void 0 !== (h3 = e2.loadFile(t2, true))) && (t2 = h3);
    }
    if (d2(t2) && (t2 = p2(t2, n3)), n3 = i(t2, n3), !f2(n3)) throw new Error("addImage does not support files of type '" + n3 + "', please ensure that a plugin for '" + n3 + "' support is added.");
    if ((null == (u2 = a3) || 0 === u2.length) && (a3 = function(t3) {
      return "string" == typeof t3 || x2(t3) ? w2(t3) : x2(t3.data) ? w2(t3.data) : null;
    }(t2)), (s3 = g2.call(this, a3)) || (A2() && (t2 instanceof Uint8Array || "RGBA" === n3 || (c3 = t2, t2 = S2(t2))), s3 = this["process" + n3.toUpperCase()](t2, l2.call(this), a3, function(t3) {
      return t3 && "string" == typeof t3 && (t3 = t3.toUpperCase()), t3 in e2.image_compression ? t3 : y2.NONE;
    }(o3), c3)), !s3) throw new Error("An unknown error occurred whilst processing the image.");
    return s3;
  }, k2 = e2.__addimage__.convertBase64ToBinaryString = function(t2, e3) {
    var r2;
    e3 = "boolean" != typeof e3 || e3;
    var n3, i2 = "";
    if ("string" == typeof t2) {
      n3 = null !== (r2 = L2(t2)) ? r2.data : t2;
      try {
        i2 = u$1(n3);
      } catch (t3) {
        if (e3) throw N2(n3) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + t3.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
      }
    }
    return i2;
  };
  e2.getImageProperties = function(t2) {
    var n3, a3, o3 = "";
    if (d2(t2) && (t2 = p2(t2)), "string" == typeof t2 && i(t2) === r && ("" === (o3 = k2(t2, false)) && (o3 = e2.loadFile(t2) || ""), t2 = o3), a3 = i(t2), !f2(a3)) throw new Error("addImage does not support files of type '" + a3 + "', please ensure that a plugin for '" + a3 + "' support is added.");
    if (!A2() || t2 instanceof Uint8Array || (t2 = S2(t2)), !(n3 = this["process" + a3.toUpperCase()](t2))) throw new Error("An unknown error occurred whilst processing the image");
    return n3.fileType = a3, n3;
  };
}(E$1.API), /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  var e2 = function(t3) {
    if (void 0 !== t3 && "" != t3) return true;
  };
  E$1.API.events.push(["addPage", function(t3) {
    this.internal.getPageInfo(t3.pageNumber).pageContext.annotations = [];
  }]), t2.events.push(["putPage", function(t3) {
    for (var r, n2, i, a2 = this.internal.getCoordinateString, o2 = this.internal.getVerticalCoordinateString, s2 = this.internal.getPageInfoByObjId(t3.objId), c2 = t3.pageContext.annotations, u2 = false, h2 = 0; h2 < c2.length && !u2; h2++) switch ((r = c2[h2]).type) {
      case "link":
        (e2(r.options.url) || e2(r.options.pageNumber)) && (u2 = true);
        break;
      case "reference":
      case "text":
      case "freetext":
        u2 = true;
    }
    if (0 != u2) {
      this.internal.write("/Annots [");
      for (var l2 = 0; l2 < c2.length; l2++) {
        r = c2[l2];
        var f2 = this.internal.pdfEscape, d2 = this.internal.getEncryptor(t3.objId);
        switch (r.type) {
          case "reference":
            this.internal.write(" " + r.object.objId + " 0 R ");
            break;
          case "text":
            var p2 = this.internal.newAdditionalObject(), g2 = this.internal.newAdditionalObject(), m2 = this.internal.getEncryptor(p2.objId), v2 = r.title || "Note";
            i = "<</Type /Annot /Subtype /Text " + (n2 = "/Rect [" + a2(r.bounds.x) + " " + o2(r.bounds.y + r.bounds.h) + " " + a2(r.bounds.x + r.bounds.w) + " " + o2(r.bounds.y) + "] ") + "/Contents (" + f2(m2(r.contents)) + ")", i += " /Popup " + g2.objId + " 0 R", i += " /P " + s2.objId + " 0 R", i += " /T (" + f2(m2(v2)) + ") >>", p2.content = i;
            var b2 = p2.objId + " 0 R";
            i = "<</Type /Annot /Subtype /Popup " + (n2 = "/Rect [" + a2(r.bounds.x + 30) + " " + o2(r.bounds.y + r.bounds.h) + " " + a2(r.bounds.x + r.bounds.w + 30) + " " + o2(r.bounds.y) + "] ") + " /Parent " + b2, r.open && (i += " /Open true"), i += " >>", g2.content = i, this.internal.write(p2.objId, "0 R", g2.objId, "0 R");
            break;
          case "freetext":
            n2 = "/Rect [" + a2(r.bounds.x) + " " + o2(r.bounds.y) + " " + a2(r.bounds.x + r.bounds.w) + " " + o2(r.bounds.y + r.bounds.h) + "] ";
            var y2 = r.color || "#000000";
            i = "<</Type /Annot /Subtype /FreeText " + n2 + "/Contents (" + f2(d2(r.contents)) + ")", i += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + y2 + ")", i += " /Border [0 0 0]", i += " >>", this.internal.write(i);
            break;
          case "link":
            if (r.options.name) {
              var w2 = this.annotations._nameMap[r.options.name];
              r.options.pageNumber = w2.page, r.options.top = w2.y;
            } else r.options.top || (r.options.top = 0);
            if (n2 = "/Rect [" + r.finalBounds.x + " " + r.finalBounds.y + " " + r.finalBounds.w + " " + r.finalBounds.h + "] ", i = "", r.options.url) i = "<</Type /Annot /Subtype /Link " + n2 + "/Border [0 0 0] /A <</S /URI /URI (" + f2(d2(r.options.url)) + ") >>";
            else if (r.options.pageNumber) {
              switch (i = "<</Type /Annot /Subtype /Link " + n2 + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(r.options.pageNumber).objId + " 0 R", r.options.magFactor = r.options.magFactor || "XYZ", r.options.magFactor) {
                case "Fit":
                  i += " /Fit]";
                  break;
                case "FitH":
                  i += " /FitH " + r.options.top + "]";
                  break;
                case "FitV":
                  r.options.left = r.options.left || 0, i += " /FitV " + r.options.left + "]";
                  break;
                case "XYZ":
                default:
                  var N2 = o2(r.options.top);
                  r.options.left = r.options.left || 0, void 0 === r.options.zoom && (r.options.zoom = 0), i += " /XYZ " + r.options.left + " " + N2 + " " + r.options.zoom + "]";
              }
            }
            "" != i && (i += " >>", this.internal.write(i));
        }
      }
      this.internal.write("]");
    }
  }]), t2.createAnnotation = function(t3) {
    var e3 = this.internal.getCurrentPageInfo();
    switch (t3.type) {
      case "link":
        this.link(t3.bounds.x, t3.bounds.y, t3.bounds.w, t3.bounds.h, t3);
        break;
      case "text":
      case "freetext":
        e3.pageContext.annotations.push(t3);
    }
  }, t2.link = function(t3, e3, r, n2, i) {
    var a2 = this.internal.getCurrentPageInfo(), o2 = this.internal.getCoordinateString, s2 = this.internal.getVerticalCoordinateString;
    a2.pageContext.annotations.push({ finalBounds: { x: o2(t3), y: s2(e3), w: o2(t3 + r), h: s2(e3 + n2) }, options: i, type: "link" });
  }, t2.textWithLink = function(t3, e3, r, n2) {
    var i, a2, o2 = this.getTextWidth(t3), s2 = this.internal.getLineHeight() / this.internal.scaleFactor;
    if (void 0 !== n2.maxWidth) {
      a2 = n2.maxWidth;
      var c2 = this.splitTextToSize(t3, a2).length;
      i = Math.ceil(s2 * c2);
    } else a2 = o2, i = s2;
    return this.text(t3, e3, r, n2), r += 0.2 * s2, "center" === n2.align && (e3 -= o2 / 2), "right" === n2.align && (e3 -= o2), this.link(e3, r - s2, a2, i, n2), o2;
  }, t2.getTextWidth = function(t3) {
    var e3 = this.internal.getFontSize();
    return this.getStringUnitWidth(t3) * e3 / this.internal.scaleFactor;
  };
}(E$1.API), /**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  var e2 = { 1569: [65152], 1570: [65153, 65154], 1571: [65155, 65156], 1572: [65157, 65158], 1573: [65159, 65160], 1574: [65161, 65162, 65163, 65164], 1575: [65165, 65166], 1576: [65167, 65168, 65169, 65170], 1577: [65171, 65172], 1578: [65173, 65174, 65175, 65176], 1579: [65177, 65178, 65179, 65180], 1580: [65181, 65182, 65183, 65184], 1581: [65185, 65186, 65187, 65188], 1582: [65189, 65190, 65191, 65192], 1583: [65193, 65194], 1584: [65195, 65196], 1585: [65197, 65198], 1586: [65199, 65200], 1587: [65201, 65202, 65203, 65204], 1588: [65205, 65206, 65207, 65208], 1589: [65209, 65210, 65211, 65212], 1590: [65213, 65214, 65215, 65216], 1591: [65217, 65218, 65219, 65220], 1592: [65221, 65222, 65223, 65224], 1593: [65225, 65226, 65227, 65228], 1594: [65229, 65230, 65231, 65232], 1601: [65233, 65234, 65235, 65236], 1602: [65237, 65238, 65239, 65240], 1603: [65241, 65242, 65243, 65244], 1604: [65245, 65246, 65247, 65248], 1605: [65249, 65250, 65251, 65252], 1606: [65253, 65254, 65255, 65256], 1607: [65257, 65258, 65259, 65260], 1608: [65261, 65262], 1609: [65263, 65264, 64488, 64489], 1610: [65265, 65266, 65267, 65268], 1649: [64336, 64337], 1655: [64477], 1657: [64358, 64359, 64360, 64361], 1658: [64350, 64351, 64352, 64353], 1659: [64338, 64339, 64340, 64341], 1662: [64342, 64343, 64344, 64345], 1663: [64354, 64355, 64356, 64357], 1664: [64346, 64347, 64348, 64349], 1667: [64374, 64375, 64376, 64377], 1668: [64370, 64371, 64372, 64373], 1670: [64378, 64379, 64380, 64381], 1671: [64382, 64383, 64384, 64385], 1672: [64392, 64393], 1676: [64388, 64389], 1677: [64386, 64387], 1678: [64390, 64391], 1681: [64396, 64397], 1688: [64394, 64395], 1700: [64362, 64363, 64364, 64365], 1702: [64366, 64367, 64368, 64369], 1705: [64398, 64399, 64400, 64401], 1709: [64467, 64468, 64469, 64470], 1711: [64402, 64403, 64404, 64405], 1713: [64410, 64411, 64412, 64413], 1715: [64406, 64407, 64408, 64409], 1722: [64414, 64415], 1723: [64416, 64417, 64418, 64419], 1726: [64426, 64427, 64428, 64429], 1728: [64420, 64421], 1729: [64422, 64423, 64424, 64425], 1733: [64480, 64481], 1734: [64473, 64474], 1735: [64471, 64472], 1736: [64475, 64476], 1737: [64482, 64483], 1739: [64478, 64479], 1740: [64508, 64509, 64510, 64511], 1744: [64484, 64485, 64486, 64487], 1746: [64430, 64431], 1747: [64432, 64433] }, r = { 65247: { 65154: 65269, 65156: 65271, 65160: 65273, 65166: 65275 }, 65248: { 65154: 65270, 65156: 65272, 65160: 65274, 65166: 65276 }, 65165: { 65247: { 65248: { 65258: 65010 } } }, 1617: { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 } }, n2 = { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 }, i = [1570, 1571, 1573, 1575];
  t2.__arabicParser__ = {};
  var a2 = t2.__arabicParser__.isInArabicSubstitutionA = function(t3) {
    return void 0 !== e2[t3.charCodeAt(0)];
  }, o2 = t2.__arabicParser__.isArabicLetter = function(t3) {
    return "string" == typeof t3 && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(t3);
  }, s2 = t2.__arabicParser__.isArabicEndLetter = function(t3) {
    return o2(t3) && a2(t3) && e2[t3.charCodeAt(0)].length <= 2;
  }, c2 = t2.__arabicParser__.isArabicAlfLetter = function(t3) {
    return o2(t3) && i.indexOf(t3.charCodeAt(0)) >= 0;
  };
  t2.__arabicParser__.arabicLetterHasIsolatedForm = function(t3) {
    return o2(t3) && a2(t3) && e2[t3.charCodeAt(0)].length >= 1;
  };
  var u2 = t2.__arabicParser__.arabicLetterHasFinalForm = function(t3) {
    return o2(t3) && a2(t3) && e2[t3.charCodeAt(0)].length >= 2;
  };
  t2.__arabicParser__.arabicLetterHasInitialForm = function(t3) {
    return o2(t3) && a2(t3) && e2[t3.charCodeAt(0)].length >= 3;
  };
  var h2 = t2.__arabicParser__.arabicLetterHasMedialForm = function(t3) {
    return o2(t3) && a2(t3) && 4 == e2[t3.charCodeAt(0)].length;
  }, l2 = t2.__arabicParser__.resolveLigatures = function(t3) {
    var e3 = 0, n3 = r, i2 = "", a3 = 0;
    for (e3 = 0; e3 < t3.length; e3 += 1) void 0 !== n3[t3.charCodeAt(e3)] ? (a3++, "number" == typeof (n3 = n3[t3.charCodeAt(e3)]) && (i2 += String.fromCharCode(n3), n3 = r, a3 = 0), e3 === t3.length - 1 && (n3 = r, i2 += t3.charAt(e3 - (a3 - 1)), e3 -= a3 - 1, a3 = 0)) : (n3 = r, i2 += t3.charAt(e3 - a3), e3 -= a3, a3 = 0);
    return i2;
  };
  t2.__arabicParser__.isArabicDiacritic = function(t3) {
    return void 0 !== t3 && void 0 !== n2[t3.charCodeAt(0)];
  };
  var f2 = t2.__arabicParser__.getCorrectForm = function(t3, e3, r2) {
    return o2(t3) ? false === a2(t3) ? -1 : !u2(t3) || !o2(e3) && !o2(r2) || !o2(r2) && s2(e3) || s2(t3) && !o2(e3) || s2(t3) && c2(e3) || s2(t3) && s2(e3) ? 0 : h2(t3) && o2(e3) && !s2(e3) && o2(r2) && u2(r2) ? 3 : s2(t3) || !o2(r2) ? 1 : 2 : -1;
  }, d2 = function(t3) {
    var r2 = 0, n3 = 0, i2 = 0, a3 = "", s3 = "", c3 = "", u3 = (t3 = t3 || "").split("\\s+"), h3 = [];
    for (r2 = 0; r2 < u3.length; r2 += 1) {
      for (h3.push(""), n3 = 0; n3 < u3[r2].length; n3 += 1) a3 = u3[r2][n3], s3 = u3[r2][n3 - 1], c3 = u3[r2][n3 + 1], o2(a3) ? (i2 = f2(a3, s3, c3), h3[r2] += -1 !== i2 ? String.fromCharCode(e2[a3.charCodeAt(0)][i2]) : a3) : h3[r2] += a3;
      h3[r2] = l2(h3[r2]);
    }
    return h3.join(" ");
  }, p2 = t2.__arabicParser__.processArabic = t2.processArabic = function() {
    var t3, e3 = "string" == typeof arguments[0] ? arguments[0] : arguments[0].text, r2 = [];
    if (Array.isArray(e3)) {
      var n3 = 0;
      for (r2 = [], n3 = 0; n3 < e3.length; n3 += 1) Array.isArray(e3[n3]) ? r2.push([d2(e3[n3][0]), e3[n3][1], e3[n3][2]]) : r2.push([d2(e3[n3])]);
      t3 = r2;
    } else t3 = d2(e3);
    return "string" == typeof arguments[0] ? t3 : (arguments[0].text = t3, arguments[0]);
  };
  t2.events.push(["preProcessText", p2]);
}(E$1.API), E$1.API.autoPrint = function(t2) {
  var e2;
  switch ((t2 = t2 || {}).variant = t2.variant || "non-conform", t2.variant) {
    case "javascript":
      this.addJS("print({});");
      break;
    case "non-conform":
    default:
      this.internal.events.subscribe("postPutResources", function() {
        e2 = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
      }), this.internal.events.subscribe("putCatalog", function() {
        this.internal.out("/OpenAction " + e2 + " 0 R");
      });
  }
  return this;
}, /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  var e2 = function() {
    var t3 = void 0;
    Object.defineProperty(this, "pdf", { get: function() {
      return t3;
    }, set: function(e4) {
      t3 = e4;
    } });
    var e3 = 150;
    Object.defineProperty(this, "width", { get: function() {
      return e3;
    }, set: function(t4) {
      e3 = isNaN(t4) || false === Number.isInteger(t4) || t4 < 0 ? 150 : t4, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = e3 + 1);
    } });
    var r = 300;
    Object.defineProperty(this, "height", { get: function() {
      return r;
    }, set: function(t4) {
      r = isNaN(t4) || false === Number.isInteger(t4) || t4 < 0 ? 300 : t4, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = r + 1);
    } });
    var n2 = [];
    Object.defineProperty(this, "childNodes", { get: function() {
      return n2;
    }, set: function(t4) {
      n2 = t4;
    } });
    var i = {};
    Object.defineProperty(this, "style", { get: function() {
      return i;
    }, set: function(t4) {
      i = t4;
    } }), Object.defineProperty(this, "parentNode", {});
  };
  e2.prototype.getContext = function(t3, e3) {
    var r;
    if ("2d" !== (t3 = t3 || "2d")) return null;
    for (r in e3) this.pdf.context2d.hasOwnProperty(r) && (this.pdf.context2d[r] = e3[r]);
    return this.pdf.context2d._canvas = this, this.pdf.context2d;
  }, e2.prototype.toDataURL = function() {
    throw new Error("toDataURL is not implemented.");
  }, t2.events.push(["initialized", function() {
    this.canvas = new e2(), this.canvas.pdf = this;
  }]);
}(E$1.API), function(e2) {
  var r = { left: 0, top: 0, bottom: 0, right: 0 }, n2 = false, i = function() {
    void 0 === this.internal.__cell__ && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, r), this.internal.__cell__.margins.width = this.getPageWidth(), a2.call(this));
  }, a2 = function() {
    this.internal.__cell__.lastCell = new o2(), this.internal.__cell__.pages = 1;
  }, o2 = function() {
    var t2 = arguments[0];
    Object.defineProperty(this, "x", { enumerable: true, get: function() {
      return t2;
    }, set: function(e4) {
      t2 = e4;
    } });
    var e3 = arguments[1];
    Object.defineProperty(this, "y", { enumerable: true, get: function() {
      return e3;
    }, set: function(t3) {
      e3 = t3;
    } });
    var r2 = arguments[2];
    Object.defineProperty(this, "width", { enumerable: true, get: function() {
      return r2;
    }, set: function(t3) {
      r2 = t3;
    } });
    var n3 = arguments[3];
    Object.defineProperty(this, "height", { enumerable: true, get: function() {
      return n3;
    }, set: function(t3) {
      n3 = t3;
    } });
    var i2 = arguments[4];
    Object.defineProperty(this, "text", { enumerable: true, get: function() {
      return i2;
    }, set: function(t3) {
      i2 = t3;
    } });
    var a3 = arguments[5];
    Object.defineProperty(this, "lineNumber", { enumerable: true, get: function() {
      return a3;
    }, set: function(t3) {
      a3 = t3;
    } });
    var o3 = arguments[6];
    return Object.defineProperty(this, "align", { enumerable: true, get: function() {
      return o3;
    }, set: function(t3) {
      o3 = t3;
    } }), this;
  };
  o2.prototype.clone = function() {
    return new o2(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
  }, o2.prototype.toArray = function() {
    return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];
  }, e2.setHeaderFunction = function(t2) {
    return i.call(this), this.internal.__cell__.headerFunction = "function" == typeof t2 ? t2 : void 0, this;
  }, e2.getTextDimensions = function(t2, e3) {
    i.call(this);
    var r2 = (e3 = e3 || {}).fontSize || this.getFontSize(), n3 = e3.font || this.getFont(), a3 = e3.scaleFactor || this.internal.scaleFactor, o3 = 0, s3 = 0, c3 = 0, u2 = this;
    if (!Array.isArray(t2) && "string" != typeof t2) {
      if ("number" != typeof t2) throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
      t2 = String(t2);
    }
    var h2 = e3.maxWidth;
    h2 > 0 ? "string" == typeof t2 ? t2 = this.splitTextToSize(t2, h2) : "[object Array]" === Object.prototype.toString.call(t2) && (t2 = t2.reduce(function(t3, e4) {
      return t3.concat(u2.splitTextToSize(e4, h2));
    }, [])) : t2 = Array.isArray(t2) ? t2 : [t2];
    for (var l2 = 0; l2 < t2.length; l2++) o3 < (c3 = this.getStringUnitWidth(t2[l2], { font: n3 }) * r2) && (o3 = c3);
    return 0 !== o3 && (s3 = t2.length), { w: o3 /= a3, h: Math.max((s3 * r2 * this.getLineHeightFactor() - r2 * (this.getLineHeightFactor() - 1)) / a3, 0) };
  }, e2.cellAddPage = function() {
    i.call(this), this.addPage();
    var t2 = this.internal.__cell__.margins || r;
    return this.internal.__cell__.lastCell = new o2(t2.left, t2.top, void 0, void 0), this.internal.__cell__.pages += 1, this;
  };
  var s2 = e2.cell = function() {
    var t2;
    t2 = arguments[0] instanceof o2 ? arguments[0] : new o2(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]), i.call(this);
    var e3 = this.internal.__cell__.lastCell, a3 = this.internal.__cell__.padding, s3 = this.internal.__cell__.margins || r, c3 = this.internal.__cell__.tableHeaderRow, u2 = this.internal.__cell__.printHeaders;
    return void 0 !== e3.lineNumber && (e3.lineNumber === t2.lineNumber ? (t2.x = (e3.x || 0) + (e3.width || 0), t2.y = e3.y || 0) : e3.y + e3.height + t2.height + s3.bottom > this.getPageHeight() ? (this.cellAddPage(), t2.y = s3.top, u2 && c3 && (this.printHeaderRow(t2.lineNumber, true), t2.y += c3[0].height)) : t2.y = e3.y + e3.height || t2.y), void 0 !== t2.text[0] && (this.rect(t2.x, t2.y, t2.width, t2.height, true === n2 ? "FD" : void 0), "right" === t2.align ? this.text(t2.text, t2.x + t2.width - a3, t2.y + a3, { align: "right", baseline: "top" }) : "center" === t2.align ? this.text(t2.text, t2.x + t2.width / 2, t2.y + a3, { align: "center", baseline: "top", maxWidth: t2.width - a3 - a3 }) : this.text(t2.text, t2.x + a3, t2.y + a3, { align: "left", baseline: "top", maxWidth: t2.width - a3 - a3 })), this.internal.__cell__.lastCell = t2, this;
  };
  e2.table = function(e3, n3, u2, h2, l2) {
    if (i.call(this), !u2) throw new Error("No data for PDF table.");
    var f2, d2, p2, g2, m2 = [], v2 = [], b2 = [], y2 = {}, w2 = {}, N2 = [], L2 = [], A2 = (l2 = l2 || {}).autoSize || false, x2 = false !== l2.printHeaders, S2 = l2.css && void 0 !== l2.css["font-size"] ? 16 * l2.css["font-size"] : l2.fontSize || 12, _2 = l2.margins || Object.assign({ width: this.getPageWidth() }, r), P2 = "number" == typeof l2.padding ? l2.padding : 3, k2 = l2.headerBackgroundColor || "#c8c8c8", I2 = l2.headerTextColor || "#000";
    if (a2.call(this), this.internal.__cell__.printHeaders = x2, this.internal.__cell__.margins = _2, this.internal.__cell__.table_font_size = S2, this.internal.__cell__.padding = P2, this.internal.__cell__.headerBackgroundColor = k2, this.internal.__cell__.headerTextColor = I2, this.setFontSize(S2), null == h2) v2 = m2 = Object.keys(u2[0]), b2 = m2.map(function() {
      return "left";
    });
    else if (Array.isArray(h2) && "object" === _typeof(h2[0])) for (m2 = h2.map(function(t2) {
      return t2.name;
    }), v2 = h2.map(function(t2) {
      return t2.prompt || t2.name || "";
    }), b2 = h2.map(function(t2) {
      return t2.align || "left";
    }), f2 = 0; f2 < h2.length; f2 += 1) w2[h2[f2].name] = h2[f2].width * (19.049976 / 25.4);
    else Array.isArray(h2) && "string" == typeof h2[0] && (v2 = m2 = h2, b2 = m2.map(function() {
      return "left";
    }));
    if (A2 || Array.isArray(h2) && "string" == typeof h2[0]) for (f2 = 0; f2 < m2.length; f2 += 1) {
      for (y2[g2 = m2[f2]] = u2.map(function(t2) {
        return t2[g2];
      }), this.setFont(void 0, "bold"), N2.push(this.getTextDimensions(v2[f2], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w), d2 = y2[g2], this.setFont(void 0, "normal"), p2 = 0; p2 < d2.length; p2 += 1) N2.push(this.getTextDimensions(d2[p2], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w);
      w2[g2] = Math.max.apply(null, N2) + P2 + P2, N2 = [];
    }
    if (x2) {
      var F2 = {};
      for (f2 = 0; f2 < m2.length; f2 += 1) F2[m2[f2]] = {}, F2[m2[f2]].text = v2[f2], F2[m2[f2]].align = b2[f2];
      var C2 = c2.call(this, F2, w2);
      L2 = m2.map(function(t2) {
        return new o2(e3, n3, w2[t2], C2, F2[t2].text, void 0, F2[t2].align);
      }), this.setTableHeaderRow(L2), this.printHeaderRow(1, false);
    }
    var j2 = h2.reduce(function(t2, e4) {
      return t2[e4.name] = e4.align, t2;
    }, {});
    for (f2 = 0; f2 < u2.length; f2 += 1) {
      "rowStart" in l2 && l2.rowStart instanceof Function && l2.rowStart({ row: f2, data: u2[f2] }, this);
      var O2 = c2.call(this, u2[f2], w2);
      for (p2 = 0; p2 < m2.length; p2 += 1) {
        var B3 = u2[f2][m2[p2]];
        "cellStart" in l2 && l2.cellStart instanceof Function && l2.cellStart({ row: f2, col: p2, data: B3 }, this), s2.call(this, new o2(e3, n3, w2[m2[p2]], O2, B3, f2 + 2, j2[m2[p2]]));
      }
    }
    return this.internal.__cell__.table_x = e3, this.internal.__cell__.table_y = n3, this;
  };
  var c2 = function(t2, e3) {
    var r2 = this.internal.__cell__.padding, n3 = this.internal.__cell__.table_font_size, i2 = this.internal.scaleFactor;
    return Object.keys(t2).map(function(n4) {
      var i3 = t2[n4];
      return this.splitTextToSize(i3.hasOwnProperty("text") ? i3.text : i3, e3[n4] - r2 - r2);
    }, this).map(function(t3) {
      return this.getLineHeightFactor() * t3.length * n3 / i2 + r2 + r2;
    }, this).reduce(function(t3, e4) {
      return Math.max(t3, e4);
    }, 0);
  };
  e2.setTableHeaderRow = function(t2) {
    i.call(this), this.internal.__cell__.tableHeaderRow = t2;
  }, e2.printHeaderRow = function(t2, e3) {
    if (i.call(this), !this.internal.__cell__.tableHeaderRow) throw new Error("Property tableHeaderRow does not exist.");
    var r2;
    if (n2 = true, "function" == typeof this.internal.__cell__.headerFunction) {
      var a3 = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
      this.internal.__cell__.lastCell = new o2(a3[0], a3[1], a3[2], a3[3], void 0, -1);
    }
    this.setFont(void 0, "bold");
    for (var c3 = [], u2 = 0; u2 < this.internal.__cell__.tableHeaderRow.length; u2 += 1) {
      r2 = this.internal.__cell__.tableHeaderRow[u2].clone(), e3 && (r2.y = this.internal.__cell__.margins.top || 0, c3.push(r2)), r2.lineNumber = t2;
      var h2 = this.getTextColor();
      this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), s2.call(this, r2), this.setTextColor(h2);
    }
    c3.length > 0 && this.setTableHeaderRow(c3), this.setFont(void 0, "normal"), n2 = false;
  };
}(E$1.API);
var Pt = { italic: ["italic", "oblique", "normal"], oblique: ["oblique", "italic", "normal"], normal: ["normal", "oblique", "italic"] }, kt = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"], It = _t(kt), Ft = [100, 200, 300, 400, 500, 600, 700, 800, 900], Ct = _t(Ft);
function jt(t2) {
  var e2 = t2.family.replace(/"|'/g, "").toLowerCase(), r = function(t3) {
    return Pt[t3 = t3 || "normal"] ? t3 : "normal";
  }(t2.style), n2 = function(t3) {
    if (!t3) return 400;
    if ("number" == typeof t3) return t3 >= 100 && t3 <= 900 && t3 % 100 == 0 ? t3 : 400;
    if (/^\d00$/.test(t3)) return parseInt(t3);
    switch (t3) {
      case "bold":
        return 700;
      case "normal":
      default:
        return 400;
    }
  }(t2.weight), i = function(t3) {
    return "number" == typeof It[t3 = t3 || "normal"] ? t3 : "normal";
  }(t2.stretch);
  return { family: e2, style: r, weight: n2, stretch: i, src: t2.src || [], ref: t2.ref || { name: e2, style: [i, r, n2].join(" ") } };
}
function Ot(t2, e2, r, n2) {
  var i;
  for (i = r; i >= 0 && i < e2.length; i += n2) if (t2[e2[i]]) return t2[e2[i]];
  for (i = r; i >= 0 && i < e2.length; i -= n2) if (t2[e2[i]]) return t2[e2[i]];
}
var Bt = { "sans-serif": "helvetica", fixed: "courier", monospace: "courier", terminal: "courier", cursive: "times", fantasy: "times", serif: "times" }, Mt = { caption: "times", icon: "times", menu: "times", "message-box": "times", "small-caption": "times", "status-bar": "times" };
function Et(t2) {
  return [t2.stretch, t2.style, t2.weight, t2.family].join(" ");
}
function qt(t2, e2, r) {
  for (var n2 = (r = r || {}).defaultFontFamily || "times", i = Object.assign({}, Bt, r.genericFontFamilies || {}), a2 = null, o2 = null, s2 = 0; s2 < e2.length; ++s2) if (i[(a2 = jt(e2[s2])).family] && (a2.family = i[a2.family]), t2.hasOwnProperty(a2.family)) {
    o2 = t2[a2.family];
    break;
  }
  if (!(o2 = o2 || t2[n2])) throw new Error("Could not find a font-family for the rule '" + Et(a2) + "' and default family '" + n2 + "'.");
  if (o2 = function(t3, e3) {
    if (e3[t3]) return e3[t3];
    var r2 = It[t3], n3 = r2 <= It.normal ? -1 : 1, i2 = Ot(e3, kt, r2, n3);
    if (!i2) throw new Error("Could not find a matching font-stretch value for " + t3);
    return i2;
  }(a2.stretch, o2), o2 = function(t3, e3) {
    if (e3[t3]) return e3[t3];
    for (var r2 = Pt[t3], n3 = 0; n3 < r2.length; ++n3) if (e3[r2[n3]]) return e3[r2[n3]];
    throw new Error("Could not find a matching font-style for " + t3);
  }(a2.style, o2), !(o2 = function(t3, e3) {
    if (e3[t3]) return e3[t3];
    if (400 === t3 && e3[500]) return e3[500];
    if (500 === t3 && e3[400]) return e3[400];
    var r2 = Ct[t3], n3 = Ot(e3, Ft, r2, t3 < 400 ? -1 : 1);
    if (!n3) throw new Error("Could not find a matching font-weight for value " + t3);
    return n3;
  }(a2.weight, o2))) throw new Error("Failed to resolve a font for the rule '" + Et(a2) + "'.");
  return o2;
}
function Dt(t2) {
  return t2.trimLeft();
}
function Rt(t2, e2) {
  for (var r = 0; r < t2.length; ) {
    if (t2.charAt(r) === e2) return [t2.substring(0, r), t2.substring(r + 1)];
    r += 1;
  }
  return null;
}
function Tt(t2) {
  var e2 = t2.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
  return null === e2 ? null : [e2[0], t2.substring(e2[0].length)];
}
var Ut, zt, Ht, Wt = ["times"];
!function(e2) {
  var r, n2, i, o2, s2, c2, u2, h2, l2, d2 = function(t2) {
    return t2 = t2 || {}, this.isStrokeTransparent = t2.isStrokeTransparent || false, this.strokeOpacity = t2.strokeOpacity || 1, this.strokeStyle = t2.strokeStyle || "#000000", this.fillStyle = t2.fillStyle || "#000000", this.isFillTransparent = t2.isFillTransparent || false, this.fillOpacity = t2.fillOpacity || 1, this.font = t2.font || "10px sans-serif", this.textBaseline = t2.textBaseline || "alphabetic", this.textAlign = t2.textAlign || "left", this.lineWidth = t2.lineWidth || 1, this.lineJoin = t2.lineJoin || "miter", this.lineCap = t2.lineCap || "butt", this.path = t2.path || [], this.transform = void 0 !== t2.transform ? t2.transform.clone() : new h2(), this.globalCompositeOperation = t2.globalCompositeOperation || "normal", this.globalAlpha = t2.globalAlpha || 1, this.clip_path = t2.clip_path || [], this.currentPoint = t2.currentPoint || new c2(), this.miterLimit = t2.miterLimit || 10, this.lastPoint = t2.lastPoint || new c2(), this.lineDashOffset = t2.lineDashOffset || 0, this.lineDash = t2.lineDash || [], this.margin = t2.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = t2.prevPageLastElemOffset || 0, this.ignoreClearRect = "boolean" != typeof t2.ignoreClearRect || t2.ignoreClearRect, this;
  };
  e2.events.push(["initialized", function() {
    this.context2d = new p2(this), r = this.internal.f2, n2 = this.internal.getCoordinateString, i = this.internal.getVerticalCoordinateString, o2 = this.internal.getHorizontalCoordinate, s2 = this.internal.getVerticalCoordinate, c2 = this.internal.Point, u2 = this.internal.Rectangle, h2 = this.internal.Matrix, l2 = new d2();
  }]);
  var p2 = function(t2) {
    Object.defineProperty(this, "canvas", { get: function() {
      return { parentNode: false, style: false };
    } });
    var e3 = t2;
    Object.defineProperty(this, "pdf", { get: function() {
      return e3;
    } });
    var r2 = false;
    Object.defineProperty(this, "pageWrapXEnabled", { get: function() {
      return r2;
    }, set: function(t3) {
      r2 = Boolean(t3);
    } });
    var n3 = false;
    Object.defineProperty(this, "pageWrapYEnabled", { get: function() {
      return n3;
    }, set: function(t3) {
      n3 = Boolean(t3);
    } });
    var i2 = 0;
    Object.defineProperty(this, "posX", { get: function() {
      return i2;
    }, set: function(t3) {
      isNaN(t3) || (i2 = t3);
    } });
    var a2 = 0;
    Object.defineProperty(this, "posY", { get: function() {
      return a2;
    }, set: function(t3) {
      isNaN(t3) || (a2 = t3);
    } }), Object.defineProperty(this, "margin", { get: function() {
      return l2.margin;
    }, set: function(t3) {
      var e4;
      "number" == typeof t3 ? e4 = [t3, t3, t3, t3] : ((e4 = new Array(4))[0] = t3[0], e4[1] = t3.length >= 2 ? t3[1] : e4[0], e4[2] = t3.length >= 3 ? t3[2] : e4[0], e4[3] = t3.length >= 4 ? t3[3] : e4[1]), l2.margin = e4;
    } });
    var o3 = false;
    Object.defineProperty(this, "autoPaging", { get: function() {
      return o3;
    }, set: function(t3) {
      o3 = t3;
    } });
    var s3 = 0;
    Object.defineProperty(this, "lastBreak", { get: function() {
      return s3;
    }, set: function(t3) {
      s3 = t3;
    } });
    var c3 = [];
    Object.defineProperty(this, "pageBreaks", { get: function() {
      return c3;
    }, set: function(t3) {
      c3 = t3;
    } }), Object.defineProperty(this, "ctx", { get: function() {
      return l2;
    }, set: function(t3) {
      t3 instanceof d2 && (l2 = t3);
    } }), Object.defineProperty(this, "path", { get: function() {
      return l2.path;
    }, set: function(t3) {
      l2.path = t3;
    } });
    var u3 = [];
    Object.defineProperty(this, "ctxStack", { get: function() {
      return u3;
    }, set: function(t3) {
      u3 = t3;
    } }), Object.defineProperty(this, "fillStyle", { get: function() {
      return this.ctx.fillStyle;
    }, set: function(t3) {
      var e4;
      e4 = g2(t3), this.ctx.fillStyle = e4.style, this.ctx.isFillTransparent = 0 === e4.a, this.ctx.fillOpacity = e4.a, this.pdf.setFillColor(e4.r, e4.g, e4.b, { a: e4.a }), this.pdf.setTextColor(e4.r, e4.g, e4.b, { a: e4.a });
    } }), Object.defineProperty(this, "strokeStyle", { get: function() {
      return this.ctx.strokeStyle;
    }, set: function(t3) {
      var e4 = g2(t3);
      this.ctx.strokeStyle = e4.style, this.ctx.isStrokeTransparent = 0 === e4.a, this.ctx.strokeOpacity = e4.a, 0 === e4.a ? this.pdf.setDrawColor(255, 255, 255) : (e4.a, this.pdf.setDrawColor(e4.r, e4.g, e4.b));
    } }), Object.defineProperty(this, "lineCap", { get: function() {
      return this.ctx.lineCap;
    }, set: function(t3) {
      -1 !== ["butt", "round", "square"].indexOf(t3) && (this.ctx.lineCap = t3, this.pdf.setLineCap(t3));
    } }), Object.defineProperty(this, "lineWidth", { get: function() {
      return this.ctx.lineWidth;
    }, set: function(t3) {
      isNaN(t3) || (this.ctx.lineWidth = t3, this.pdf.setLineWidth(t3));
    } }), Object.defineProperty(this, "lineJoin", { get: function() {
      return this.ctx.lineJoin;
    }, set: function(t3) {
      -1 !== ["bevel", "round", "miter"].indexOf(t3) && (this.ctx.lineJoin = t3, this.pdf.setLineJoin(t3));
    } }), Object.defineProperty(this, "miterLimit", { get: function() {
      return this.ctx.miterLimit;
    }, set: function(t3) {
      isNaN(t3) || (this.ctx.miterLimit = t3, this.pdf.setMiterLimit(t3));
    } }), Object.defineProperty(this, "textBaseline", { get: function() {
      return this.ctx.textBaseline;
    }, set: function(t3) {
      this.ctx.textBaseline = t3;
    } }), Object.defineProperty(this, "textAlign", { get: function() {
      return this.ctx.textAlign;
    }, set: function(t3) {
      -1 !== ["right", "end", "center", "left", "start"].indexOf(t3) && (this.ctx.textAlign = t3);
    } });
    var h3 = null;
    function f2(t3, e4) {
      if (null === h3) {
        var r3 = function(t4) {
          var e5 = [];
          return Object.keys(t4).forEach(function(r4) {
            t4[r4].forEach(function(t5) {
              var n4 = null;
              switch (t5) {
                case "bold":
                  n4 = { family: r4, weight: "bold" };
                  break;
                case "italic":
                  n4 = { family: r4, style: "italic" };
                  break;
                case "bolditalic":
                  n4 = { family: r4, weight: "bold", style: "italic" };
                  break;
                case "":
                case "normal":
                  n4 = { family: r4 };
              }
              null !== n4 && (n4.ref = { name: r4, style: t5 }, e5.push(n4));
            });
          }), e5;
        }(t3.getFontList());
        h3 = function(t4) {
          for (var e5 = {}, r4 = 0; r4 < t4.length; ++r4) {
            var n4 = jt(t4[r4]), i3 = n4.family, a3 = n4.stretch, o4 = n4.style, s4 = n4.weight;
            e5[i3] = e5[i3] || {}, e5[i3][a3] = e5[i3][a3] || {}, e5[i3][a3][o4] = e5[i3][a3][o4] || {}, e5[i3][a3][o4][s4] = n4;
          }
          return e5;
        }(r3.concat(e4));
      }
      return h3;
    }
    var p3 = null;
    Object.defineProperty(this, "fontFaces", { get: function() {
      return p3;
    }, set: function(t3) {
      h3 = null, p3 = t3;
    } }), Object.defineProperty(this, "font", { get: function() {
      return this.ctx.font;
    }, set: function(t3) {
      var e4;
      if (this.ctx.font = t3, null !== (e4 = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(t3))) {
        var r3 = e4[1], n4 = (e4[2], e4[3]), i3 = e4[4], a3 = (e4[5], e4[6]), o4 = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(i3)[2];
        i3 = "px" === o4 ? Math.floor(parseFloat(i3) * this.pdf.internal.scaleFactor) : "em" === o4 ? Math.floor(parseFloat(i3) * this.pdf.getFontSize()) : Math.floor(parseFloat(i3) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(i3);
        var s4 = function(t4) {
          var e5, r4, n5 = [], i4 = t4.trim();
          if ("" === i4) return Wt;
          if (i4 in Mt) return [Mt[i4]];
          for (; "" !== i4; ) {
            switch (r4 = null, e5 = (i4 = Dt(i4)).charAt(0)) {
              case '"':
              case "'":
                r4 = Rt(i4.substring(1), e5);
                break;
              default:
                r4 = Tt(i4);
            }
            if (null === r4) return Wt;
            if (n5.push(r4[0]), "" !== (i4 = Dt(r4[1])) && "," !== i4.charAt(0)) return Wt;
            i4 = i4.replace(/^,/, "");
          }
          return n5;
        }(a3);
        if (this.fontFaces) {
          var c4 = qt(f2(this.pdf, this.fontFaces), s4.map(function(t4) {
            return { family: t4, stretch: "normal", weight: n4, style: r3 };
          }));
          this.pdf.setFont(c4.ref.name, c4.ref.style);
        } else {
          var u4 = "";
          ("bold" === n4 || parseInt(n4, 10) >= 700 || "bold" === r3) && (u4 = "bold"), "italic" === r3 && (u4 += "italic"), 0 === u4.length && (u4 = "normal");
          for (var h4 = "", l3 = { arial: "Helvetica", Arial: "Helvetica", verdana: "Helvetica", Verdana: "Helvetica", helvetica: "Helvetica", Helvetica: "Helvetica", "sans-serif": "Helvetica", fixed: "Courier", monospace: "Courier", terminal: "Courier", cursive: "Times", fantasy: "Times", serif: "Times" }, d3 = 0; d3 < s4.length; d3++) {
            if (void 0 !== this.pdf.internal.getFont(s4[d3], u4, { noFallback: true, disableWarning: true })) {
              h4 = s4[d3];
              break;
            }
            if ("bolditalic" === u4 && void 0 !== this.pdf.internal.getFont(s4[d3], "bold", { noFallback: true, disableWarning: true })) h4 = s4[d3], u4 = "bold";
            else if (void 0 !== this.pdf.internal.getFont(s4[d3], "normal", { noFallback: true, disableWarning: true })) {
              h4 = s4[d3], u4 = "normal";
              break;
            }
          }
          if ("" === h4) {
            for (var p4 = 0; p4 < s4.length; p4++) if (l3[s4[p4]]) {
              h4 = l3[s4[p4]];
              break;
            }
          }
          h4 = "" === h4 ? "Times" : h4, this.pdf.setFont(h4, u4);
        }
      }
    } }), Object.defineProperty(this, "globalCompositeOperation", { get: function() {
      return this.ctx.globalCompositeOperation;
    }, set: function(t3) {
      this.ctx.globalCompositeOperation = t3;
    } }), Object.defineProperty(this, "globalAlpha", { get: function() {
      return this.ctx.globalAlpha;
    }, set: function(t3) {
      this.ctx.globalAlpha = t3;
    } }), Object.defineProperty(this, "lineDashOffset", { get: function() {
      return this.ctx.lineDashOffset;
    }, set: function(t3) {
      this.ctx.lineDashOffset = t3, T2.call(this);
    } }), Object.defineProperty(this, "lineDash", { get: function() {
      return this.ctx.lineDash;
    }, set: function(t3) {
      this.ctx.lineDash = t3, T2.call(this);
    } }), Object.defineProperty(this, "ignoreClearRect", { get: function() {
      return this.ctx.ignoreClearRect;
    }, set: function(t3) {
      this.ctx.ignoreClearRect = Boolean(t3);
    } });
  };
  p2.prototype.setLineDash = function(t2) {
    this.lineDash = t2;
  }, p2.prototype.getLineDash = function() {
    return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();
  }, p2.prototype.fill = function() {
    A2.call(this, "fill", false);
  }, p2.prototype.stroke = function() {
    A2.call(this, "stroke", false);
  }, p2.prototype.beginPath = function() {
    this.path = [{ type: "begin" }];
  }, p2.prototype.moveTo = function(t2, e3) {
    if (isNaN(t2) || isNaN(e3)) throw a$1.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
    var r2 = this.ctx.transform.applyToPoint(new c2(t2, e3));
    this.path.push({ type: "mt", x: r2.x, y: r2.y }), this.ctx.lastPoint = new c2(t2, e3);
  }, p2.prototype.closePath = function() {
    var e3 = new c2(0, 0), r2 = 0;
    for (r2 = this.path.length - 1; -1 !== r2; r2--) if ("begin" === this.path[r2].type && "object" === _typeof(this.path[r2 + 1]) && "number" == typeof this.path[r2 + 1].x) {
      e3 = new c2(this.path[r2 + 1].x, this.path[r2 + 1].y);
      break;
    }
    this.path.push({ type: "close" }), this.ctx.lastPoint = new c2(e3.x, e3.y);
  }, p2.prototype.lineTo = function(t2, e3) {
    if (isNaN(t2) || isNaN(e3)) throw a$1.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
    var r2 = this.ctx.transform.applyToPoint(new c2(t2, e3));
    this.path.push({ type: "lt", x: r2.x, y: r2.y }), this.ctx.lastPoint = new c2(r2.x, r2.y);
  }, p2.prototype.clip = function() {
    this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), A2.call(this, null, true);
  }, p2.prototype.quadraticCurveTo = function(t2, e3, r2, n3) {
    if (isNaN(r2) || isNaN(n3) || isNaN(t2) || isNaN(e3)) throw a$1.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
    var i2 = this.ctx.transform.applyToPoint(new c2(r2, n3)), o3 = this.ctx.transform.applyToPoint(new c2(t2, e3));
    this.path.push({ type: "qct", x1: o3.x, y1: o3.y, x: i2.x, y: i2.y }), this.ctx.lastPoint = new c2(i2.x, i2.y);
  }, p2.prototype.bezierCurveTo = function(t2, e3, r2, n3, i2, o3) {
    if (isNaN(i2) || isNaN(o3) || isNaN(t2) || isNaN(e3) || isNaN(r2) || isNaN(n3)) throw a$1.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
    var s3 = this.ctx.transform.applyToPoint(new c2(i2, o3)), u3 = this.ctx.transform.applyToPoint(new c2(t2, e3)), h3 = this.ctx.transform.applyToPoint(new c2(r2, n3));
    this.path.push({ type: "bct", x1: u3.x, y1: u3.y, x2: h3.x, y2: h3.y, x: s3.x, y: s3.y }), this.ctx.lastPoint = new c2(s3.x, s3.y);
  }, p2.prototype.arc = function(t2, e3, r2, n3, i2, o3) {
    if (isNaN(t2) || isNaN(e3) || isNaN(r2) || isNaN(n3) || isNaN(i2)) throw a$1.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");
    if (o3 = Boolean(o3), !this.ctx.transform.isIdentity) {
      var s3 = this.ctx.transform.applyToPoint(new c2(t2, e3));
      t2 = s3.x, e3 = s3.y;
      var u3 = this.ctx.transform.applyToPoint(new c2(0, r2)), h3 = this.ctx.transform.applyToPoint(new c2(0, 0));
      r2 = Math.sqrt(Math.pow(u3.x - h3.x, 2) + Math.pow(u3.y - h3.y, 2));
    }
    Math.abs(i2 - n3) >= 2 * Math.PI && (n3 = 0, i2 = 2 * Math.PI), this.path.push({ type: "arc", x: t2, y: e3, radius: r2, startAngle: n3, endAngle: i2, counterclockwise: o3 });
  }, p2.prototype.arcTo = function(t2, e3, r2, n3, i2) {
    throw new Error("arcTo not implemented.");
  }, p2.prototype.rect = function(t2, e3, r2, n3) {
    if (isNaN(t2) || isNaN(e3) || isNaN(r2) || isNaN(n3)) throw a$1.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
    this.moveTo(t2, e3), this.lineTo(t2 + r2, e3), this.lineTo(t2 + r2, e3 + n3), this.lineTo(t2, e3 + n3), this.lineTo(t2, e3), this.lineTo(t2 + r2, e3), this.lineTo(t2, e3);
  }, p2.prototype.fillRect = function(t2, e3, r2, n3) {
    if (isNaN(t2) || isNaN(e3) || isNaN(r2) || isNaN(n3)) throw a$1.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
    if (!m2.call(this)) {
      var i2 = {};
      "butt" !== this.lineCap && (i2.lineCap = this.lineCap, this.lineCap = "butt"), "miter" !== this.lineJoin && (i2.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(t2, e3, r2, n3), this.fill(), i2.hasOwnProperty("lineCap") && (this.lineCap = i2.lineCap), i2.hasOwnProperty("lineJoin") && (this.lineJoin = i2.lineJoin);
    }
  }, p2.prototype.strokeRect = function(t2, e3, r2, n3) {
    if (isNaN(t2) || isNaN(e3) || isNaN(r2) || isNaN(n3)) throw a$1.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
    v2.call(this) || (this.beginPath(), this.rect(t2, e3, r2, n3), this.stroke());
  }, p2.prototype.clearRect = function(t2, e3, r2, n3) {
    if (isNaN(t2) || isNaN(e3) || isNaN(r2) || isNaN(n3)) throw a$1.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
    this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(t2, e3, r2, n3));
  }, p2.prototype.save = function(t2) {
    t2 = "boolean" != typeof t2 || t2;
    for (var e3 = this.pdf.internal.getCurrentPageInfo().pageNumber, r2 = 0; r2 < this.pdf.internal.getNumberOfPages(); r2++) this.pdf.setPage(r2 + 1), this.pdf.internal.out("q");
    if (this.pdf.setPage(e3), t2) {
      this.ctx.fontSize = this.pdf.internal.getFontSize();
      var n3 = new d2(this.ctx);
      this.ctxStack.push(this.ctx), this.ctx = n3;
    }
  }, p2.prototype.restore = function(t2) {
    t2 = "boolean" != typeof t2 || t2;
    for (var e3 = this.pdf.internal.getCurrentPageInfo().pageNumber, r2 = 0; r2 < this.pdf.internal.getNumberOfPages(); r2++) this.pdf.setPage(r2 + 1), this.pdf.internal.out("Q");
    this.pdf.setPage(e3), t2 && 0 !== this.ctxStack.length && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);
  }, p2.prototype.toDataURL = function() {
    throw new Error("toDataUrl not implemented.");
  };
  var g2 = function(t2) {
    var e3, r2, n3, i2;
    if (true === t2.isCanvasGradient && (t2 = t2.getColor()), !t2) return { r: 0, g: 0, b: 0, a: 0, style: t2 };
    if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(t2)) e3 = 0, r2 = 0, n3 = 0, i2 = 0;
    else {
      var a2 = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(t2);
      if (null !== a2) e3 = parseInt(a2[1]), r2 = parseInt(a2[2]), n3 = parseInt(a2[3]), i2 = 1;
      else if (null !== (a2 = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(t2))) e3 = parseInt(a2[1]), r2 = parseInt(a2[2]), n3 = parseInt(a2[3]), i2 = parseFloat(a2[4]);
      else {
        if (i2 = 1, "string" == typeof t2 && "#" !== t2.charAt(0)) {
          var o3 = new f$1(t2);
          t2 = o3.ok ? o3.toHex() : "#000000";
        }
        4 === t2.length ? (e3 = t2.substring(1, 2), e3 += e3, r2 = t2.substring(2, 3), r2 += r2, n3 = t2.substring(3, 4), n3 += n3) : (e3 = t2.substring(1, 3), r2 = t2.substring(3, 5), n3 = t2.substring(5, 7)), e3 = parseInt(e3, 16), r2 = parseInt(r2, 16), n3 = parseInt(n3, 16);
      }
    }
    return { r: e3, g: r2, b: n3, a: i2, style: t2 };
  }, m2 = function() {
    return this.ctx.isFillTransparent || 0 == this.globalAlpha;
  }, v2 = function() {
    return Boolean(this.ctx.isStrokeTransparent || 0 == this.globalAlpha);
  };
  p2.prototype.fillText = function(t2, e3, r2, n3) {
    if (isNaN(e3) || isNaN(r2) || "string" != typeof t2) throw a$1.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");
    if (n3 = isNaN(n3) ? void 0 : n3, !m2.call(this)) {
      var i2 = q2(this.ctx.transform.rotation), o3 = this.ctx.transform.scaleX;
      C2.call(this, { text: t2, x: e3, y: r2, scale: o3, angle: i2, align: this.textAlign, maxWidth: n3 });
    }
  }, p2.prototype.strokeText = function(t2, e3, r2, n3) {
    if (isNaN(e3) || isNaN(r2) || "string" != typeof t2) throw a$1.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
    if (!v2.call(this)) {
      n3 = isNaN(n3) ? void 0 : n3;
      var i2 = q2(this.ctx.transform.rotation), o3 = this.ctx.transform.scaleX;
      C2.call(this, { text: t2, x: e3, y: r2, scale: o3, renderingMode: "stroke", angle: i2, align: this.textAlign, maxWidth: n3 });
    }
  }, p2.prototype.measureText = function(t2) {
    if ("string" != typeof t2) throw a$1.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
    var e3 = this.pdf, r2 = this.pdf.internal.scaleFactor, n3 = e3.internal.getFontSize(), i2 = e3.getStringUnitWidth(t2) * n3 / e3.internal.scaleFactor, o3 = function(t3) {
      var e4 = (t3 = t3 || {}).width || 0;
      return Object.defineProperty(this, "width", { get: function() {
        return e4;
      } }), this;
    };
    return new o3({ width: i2 *= Math.round(96 * r2 / 72 * 1e4) / 1e4 });
  }, p2.prototype.scale = function(t2, e3) {
    if (isNaN(t2) || isNaN(e3)) throw a$1.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
    var r2 = new h2(t2, 0, 0, e3, 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(r2);
  }, p2.prototype.rotate = function(t2) {
    if (isNaN(t2)) throw a$1.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
    var e3 = new h2(Math.cos(t2), Math.sin(t2), -Math.sin(t2), Math.cos(t2), 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(e3);
  }, p2.prototype.translate = function(t2, e3) {
    if (isNaN(t2) || isNaN(e3)) throw a$1.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
    var r2 = new h2(1, 0, 0, 1, t2, e3);
    this.ctx.transform = this.ctx.transform.multiply(r2);
  }, p2.prototype.transform = function(t2, e3, r2, n3, i2, o3) {
    if (isNaN(t2) || isNaN(e3) || isNaN(r2) || isNaN(n3) || isNaN(i2) || isNaN(o3)) throw a$1.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
    var s3 = new h2(t2, e3, r2, n3, i2, o3);
    this.ctx.transform = this.ctx.transform.multiply(s3);
  }, p2.prototype.setTransform = function(t2, e3, r2, n3, i2, a2) {
    t2 = isNaN(t2) ? 1 : t2, e3 = isNaN(e3) ? 0 : e3, r2 = isNaN(r2) ? 0 : r2, n3 = isNaN(n3) ? 1 : n3, i2 = isNaN(i2) ? 0 : i2, a2 = isNaN(a2) ? 0 : a2, this.ctx.transform = new h2(t2, e3, r2, n3, i2, a2);
  };
  var b2 = function() {
    return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
  };
  p2.prototype.drawImage = function(t2, e3, r2, n3, i2, a2, o3, s3, c3) {
    var l3 = this.pdf.getImageProperties(t2), f2 = 1, d3 = 1, p3 = 1, g3 = 1;
    void 0 !== n3 && void 0 !== s3 && (p3 = s3 / n3, g3 = c3 / i2, f2 = l3.width / n3 * s3 / n3, d3 = l3.height / i2 * c3 / i2), void 0 === a2 && (a2 = e3, o3 = r2, e3 = 0, r2 = 0), void 0 !== n3 && void 0 === s3 && (s3 = n3, c3 = i2), void 0 === n3 && void 0 === s3 && (s3 = l3.width, c3 = l3.height);
    for (var m3, v3 = this.ctx.transform.decompose(), w3 = q2(v3.rotate.shx), A3 = new h2(), S3 = (A3 = (A3 = (A3 = A3.multiply(v3.translate)).multiply(v3.skew)).multiply(v3.scale)).applyToRectangle(new u2(a2 - e3 * p3, o3 - r2 * g3, n3 * f2, i2 * d3)), _3 = y2.call(this, S3), P3 = [], k3 = 0; k3 < _3.length; k3 += 1) -1 === P3.indexOf(_3[k3]) && P3.push(_3[k3]);
    if (L2(P3), this.autoPaging) for (var I3 = P3[0], F3 = P3[P3.length - 1], C3 = I3; C3 < F3 + 1; C3++) {
      this.pdf.setPage(C3);
      var j3 = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], O3 = 1 === C3 ? this.posY + this.margin[0] : this.margin[0], B4 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], M3 = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], E3 = 1 === C3 ? 0 : B4 + (C3 - 2) * M3;
      if (0 !== this.ctx.clip_path.length) {
        var D3 = this.path;
        m3 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N2(m3, this.posX + this.margin[3], -E3 + O3 + this.ctx.prevPageLastElemOffset), x2.call(this, "fill", true), this.path = D3;
      }
      var R3 = JSON.parse(JSON.stringify(S3));
      R3 = N2([R3], this.posX + this.margin[3], -E3 + O3 + this.ctx.prevPageLastElemOffset)[0];
      var T3 = (C3 > I3 || C3 < F3) && b2.call(this);
      T3 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], j3, M3, null).clip().discardPath()), this.pdf.addImage(t2, "JPEG", R3.x, R3.y, R3.w, R3.h, null, null, w3), T3 && this.pdf.restoreGraphicsState();
    }
    else this.pdf.addImage(t2, "JPEG", S3.x, S3.y, S3.w, S3.h, null, null, w3);
  };
  var y2 = function(t2, e3, r2) {
    var n3 = [];
    e3 = e3 || this.pdf.internal.pageSize.width, r2 = r2 || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
    var i2 = this.posY + this.ctx.prevPageLastElemOffset;
    switch (t2.type) {
      default:
      case "mt":
      case "lt":
        n3.push(Math.floor((t2.y + i2) / r2) + 1);
        break;
      case "arc":
        n3.push(Math.floor((t2.y + i2 - t2.radius) / r2) + 1), n3.push(Math.floor((t2.y + i2 + t2.radius) / r2) + 1);
        break;
      case "qct":
        var a2 = D2(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t2.x1, t2.y1, t2.x, t2.y);
        n3.push(Math.floor((a2.y + i2) / r2) + 1), n3.push(Math.floor((a2.y + a2.h + i2) / r2) + 1);
        break;
      case "bct":
        var o3 = R2(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t2.x1, t2.y1, t2.x2, t2.y2, t2.x, t2.y);
        n3.push(Math.floor((o3.y + i2) / r2) + 1), n3.push(Math.floor((o3.y + o3.h + i2) / r2) + 1);
        break;
      case "rect":
        n3.push(Math.floor((t2.y + i2) / r2) + 1), n3.push(Math.floor((t2.y + t2.h + i2) / r2) + 1);
    }
    for (var s3 = 0; s3 < n3.length; s3 += 1) for (; this.pdf.internal.getNumberOfPages() < n3[s3]; ) w2.call(this);
    return n3;
  }, w2 = function() {
    var t2 = this.fillStyle, e3 = this.strokeStyle, r2 = this.font, n3 = this.lineCap, i2 = this.lineWidth, a2 = this.lineJoin;
    this.pdf.addPage(), this.fillStyle = t2, this.strokeStyle = e3, this.font = r2, this.lineCap = n3, this.lineWidth = i2, this.lineJoin = a2;
  }, N2 = function(t2, e3, r2) {
    for (var n3 = 0; n3 < t2.length; n3++) switch (t2[n3].type) {
      case "bct":
        t2[n3].x2 += e3, t2[n3].y2 += r2;
      case "qct":
        t2[n3].x1 += e3, t2[n3].y1 += r2;
      case "mt":
      case "lt":
      case "arc":
      default:
        t2[n3].x += e3, t2[n3].y += r2;
    }
    return t2;
  }, L2 = function(t2) {
    return t2.sort(function(t3, e3) {
      return t3 - e3;
    });
  }, A2 = function(t2, e3) {
    for (var r2, n3, i2 = this.fillStyle, a2 = this.strokeStyle, o3 = this.lineCap, s3 = this.lineWidth, c3 = Math.abs(s3 * this.ctx.transform.scaleX), u3 = this.lineJoin, h3 = JSON.parse(JSON.stringify(this.path)), l3 = JSON.parse(JSON.stringify(this.path)), f2 = [], d3 = 0; d3 < l3.length; d3++) if (void 0 !== l3[d3].x) for (var p3 = y2.call(this, l3[d3]), g3 = 0; g3 < p3.length; g3 += 1) -1 === f2.indexOf(p3[g3]) && f2.push(p3[g3]);
    for (var m3 = 0; m3 < f2.length; m3++) for (; this.pdf.internal.getNumberOfPages() < f2[m3]; ) w2.call(this);
    if (L2(f2), this.autoPaging) for (var v3 = f2[0], A3 = f2[f2.length - 1], S3 = v3; S3 < A3 + 1; S3++) {
      this.pdf.setPage(S3), this.fillStyle = i2, this.strokeStyle = a2, this.lineCap = o3, this.lineWidth = c3, this.lineJoin = u3;
      var _3 = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], P3 = 1 === S3 ? this.posY + this.margin[0] : this.margin[0], k3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], I3 = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], F3 = 1 === S3 ? 0 : k3 + (S3 - 2) * I3;
      if (0 !== this.ctx.clip_path.length) {
        var C3 = this.path;
        r2 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N2(r2, this.posX + this.margin[3], -F3 + P3 + this.ctx.prevPageLastElemOffset), x2.call(this, t2, true), this.path = C3;
      }
      if (n3 = JSON.parse(JSON.stringify(h3)), this.path = N2(n3, this.posX + this.margin[3], -F3 + P3 + this.ctx.prevPageLastElemOffset), false === e3 || 0 === S3) {
        var j3 = (S3 > v3 || S3 < A3) && b2.call(this);
        j3 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], _3, I3, null).clip().discardPath()), x2.call(this, t2, e3), j3 && this.pdf.restoreGraphicsState();
      }
      this.lineWidth = s3;
    }
    else this.lineWidth = c3, x2.call(this, t2, e3), this.lineWidth = s3;
    this.path = h3;
  }, x2 = function(t2, e3) {
    if (("stroke" !== t2 || e3 || !v2.call(this)) && ("stroke" === t2 || e3 || !m2.call(this))) {
      for (var r2, n3, i2 = [], a2 = this.path, o3 = 0; o3 < a2.length; o3++) {
        var s3 = a2[o3];
        switch (s3.type) {
          case "begin":
            i2.push({ begin: true });
            break;
          case "close":
            i2.push({ close: true });
            break;
          case "mt":
            i2.push({ start: s3, deltas: [], abs: [] });
            break;
          case "lt":
            var c3 = i2.length;
            if (a2[o3 - 1] && !isNaN(a2[o3 - 1].x) && (r2 = [s3.x - a2[o3 - 1].x, s3.y - a2[o3 - 1].y], c3 > 0)) {
              for (; c3 >= 0; c3--) if (true !== i2[c3 - 1].close && true !== i2[c3 - 1].begin) {
                i2[c3 - 1].deltas.push(r2), i2[c3 - 1].abs.push(s3);
                break;
              }
            }
            break;
          case "bct":
            r2 = [s3.x1 - a2[o3 - 1].x, s3.y1 - a2[o3 - 1].y, s3.x2 - a2[o3 - 1].x, s3.y2 - a2[o3 - 1].y, s3.x - a2[o3 - 1].x, s3.y - a2[o3 - 1].y], i2[i2.length - 1].deltas.push(r2);
            break;
          case "qct":
            var u3 = a2[o3 - 1].x + 2 / 3 * (s3.x1 - a2[o3 - 1].x), h3 = a2[o3 - 1].y + 2 / 3 * (s3.y1 - a2[o3 - 1].y), l3 = s3.x + 2 / 3 * (s3.x1 - s3.x), f2 = s3.y + 2 / 3 * (s3.y1 - s3.y), d3 = s3.x, p3 = s3.y;
            r2 = [u3 - a2[o3 - 1].x, h3 - a2[o3 - 1].y, l3 - a2[o3 - 1].x, f2 - a2[o3 - 1].y, d3 - a2[o3 - 1].x, p3 - a2[o3 - 1].y], i2[i2.length - 1].deltas.push(r2);
            break;
          case "arc":
            i2.push({ deltas: [], abs: [], arc: true }), Array.isArray(i2[i2.length - 1].abs) && i2[i2.length - 1].abs.push(s3);
        }
      }
      n3 = e3 ? null : "stroke" === t2 ? "stroke" : "fill";
      for (var g3 = false, b3 = 0; b3 < i2.length; b3++) if (i2[b3].arc) for (var y3 = i2[b3].abs, w3 = 0; w3 < y3.length; w3++) {
        var N3 = y3[w3];
        "arc" === N3.type ? P2.call(this, N3.x, N3.y, N3.radius, N3.startAngle, N3.endAngle, N3.counterclockwise, void 0, e3, !g3) : j2.call(this, N3.x, N3.y), g3 = true;
      }
      else if (true === i2[b3].close) this.pdf.internal.out("h"), g3 = false;
      else if (true !== i2[b3].begin) {
        var L3 = i2[b3].start.x, A3 = i2[b3].start.y;
        O2.call(this, i2[b3].deltas, L3, A3), g3 = true;
      }
      n3 && k2.call(this, n3), e3 && I2.call(this);
    }
  }, S2 = function(t2) {
    var e3 = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, r2 = e3 * (this.pdf.internal.getLineHeightFactor() - 1);
    switch (this.ctx.textBaseline) {
      case "bottom":
        return t2 - r2;
      case "top":
        return t2 + e3 - r2;
      case "hanging":
        return t2 + e3 - 2 * r2;
      case "middle":
        return t2 + e3 / 2 - r2;
      case "ideographic":
        return t2;
      case "alphabetic":
      default:
        return t2;
    }
  }, _2 = function(t2) {
    return t2 + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);
  };
  p2.prototype.createLinearGradient = function() {
    var t2 = function() {
    };
    return t2.colorStops = [], t2.addColorStop = function(t3, e3) {
      this.colorStops.push([t3, e3]);
    }, t2.getColor = function() {
      return 0 === this.colorStops.length ? "#000000" : this.colorStops[0][1];
    }, t2.isCanvasGradient = true, t2;
  }, p2.prototype.createPattern = function() {
    return this.createLinearGradient();
  }, p2.prototype.createRadialGradient = function() {
    return this.createLinearGradient();
  };
  var P2 = function(t2, e3, r2, n3, i2, a2, o3, s3, c3) {
    for (var u3 = M2.call(this, r2, n3, i2, a2), h3 = 0; h3 < u3.length; h3++) {
      var l3 = u3[h3];
      0 === h3 && (c3 ? F2.call(this, l3.x1 + t2, l3.y1 + e3) : j2.call(this, l3.x1 + t2, l3.y1 + e3)), B3.call(this, t2, e3, l3.x2, l3.y2, l3.x3, l3.y3, l3.x4, l3.y4);
    }
    s3 ? I2.call(this) : k2.call(this, o3);
  }, k2 = function(t2) {
    switch (t2) {
      case "stroke":
        this.pdf.internal.out("S");
        break;
      case "fill":
        this.pdf.internal.out("f");
    }
  }, I2 = function() {
    this.pdf.clip(), this.pdf.discardPath();
  }, F2 = function(t2, e3) {
    this.pdf.internal.out(n2(t2) + " " + i(e3) + " m");
  }, C2 = function(t2) {
    var e3;
    switch (t2.align) {
      case "right":
      case "end":
        e3 = "right";
        break;
      case "center":
        e3 = "center";
        break;
      case "left":
      case "start":
      default:
        e3 = "left";
    }
    var r2 = this.pdf.getTextDimensions(t2.text), n3 = S2.call(this, t2.y), i2 = _2.call(this, n3) - r2.h, a2 = this.ctx.transform.applyToPoint(new c2(t2.x, n3)), o3 = this.ctx.transform.decompose(), s3 = new h2();
    s3 = (s3 = (s3 = s3.multiply(o3.translate)).multiply(o3.skew)).multiply(o3.scale);
    for (var l3, f2, d3, p3 = this.ctx.transform.applyToRectangle(new u2(t2.x, n3, r2.w, r2.h)), g3 = s3.applyToRectangle(new u2(t2.x, i2, r2.w, r2.h)), m3 = y2.call(this, g3), v3 = [], w3 = 0; w3 < m3.length; w3 += 1) -1 === v3.indexOf(m3[w3]) && v3.push(m3[w3]);
    if (L2(v3), this.autoPaging) for (var A3 = v3[0], P3 = v3[v3.length - 1], k3 = A3; k3 < P3 + 1; k3++) {
      this.pdf.setPage(k3);
      var I3 = 1 === k3 ? this.posY + this.margin[0] : this.margin[0], F3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], C3 = this.pdf.internal.pageSize.height - this.margin[2], j3 = C3 - this.margin[0], O3 = this.pdf.internal.pageSize.width - this.margin[1], B4 = O3 - this.margin[3], M3 = 1 === k3 ? 0 : F3 + (k3 - 2) * j3;
      if (0 !== this.ctx.clip_path.length) {
        var E3 = this.path;
        l3 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N2(l3, this.posX + this.margin[3], -1 * M3 + I3), x2.call(this, "fill", true), this.path = E3;
      }
      var q3 = N2([JSON.parse(JSON.stringify(g3))], this.posX + this.margin[3], -M3 + I3 + this.ctx.prevPageLastElemOffset)[0];
      t2.scale >= 0.01 && (f2 = this.pdf.internal.getFontSize(), this.pdf.setFontSize(f2 * t2.scale), d3 = this.lineWidth, this.lineWidth = d3 * t2.scale);
      var D3 = "text" !== this.autoPaging;
      if (D3 || q3.y + q3.h <= C3) {
        if (D3 || q3.y >= I3 && q3.x <= O3) {
          var R3 = D3 ? t2.text : this.pdf.splitTextToSize(t2.text, t2.maxWidth || O3 - q3.x)[0], T3 = N2([JSON.parse(JSON.stringify(p3))], this.posX + this.margin[3], -M3 + I3 + this.ctx.prevPageLastElemOffset)[0], U2 = D3 && (k3 > A3 || k3 < P3) && b2.call(this);
          U2 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], B4, j3, null).clip().discardPath()), this.pdf.text(R3, T3.x, T3.y, { angle: t2.angle, align: e3, renderingMode: t2.renderingMode }), U2 && this.pdf.restoreGraphicsState();
        }
      } else q3.y < C3 && (this.ctx.prevPageLastElemOffset += C3 - q3.y);
      t2.scale >= 0.01 && (this.pdf.setFontSize(f2), this.lineWidth = d3);
    }
    else t2.scale >= 0.01 && (f2 = this.pdf.internal.getFontSize(), this.pdf.setFontSize(f2 * t2.scale), d3 = this.lineWidth, this.lineWidth = d3 * t2.scale), this.pdf.text(t2.text, a2.x + this.posX, a2.y + this.posY, { angle: t2.angle, align: e3, renderingMode: t2.renderingMode, maxWidth: t2.maxWidth }), t2.scale >= 0.01 && (this.pdf.setFontSize(f2), this.lineWidth = d3);
  }, j2 = function(t2, e3, r2, a2) {
    r2 = r2 || 0, a2 = a2 || 0, this.pdf.internal.out(n2(t2 + r2) + " " + i(e3 + a2) + " l");
  }, O2 = function(t2, e3, r2) {
    return this.pdf.lines(t2, e3, r2, null, null);
  }, B3 = function(t2, e3, n3, i2, a2, c3, u3, h3) {
    this.pdf.internal.out([r(o2(n3 + t2)), r(s2(i2 + e3)), r(o2(a2 + t2)), r(s2(c3 + e3)), r(o2(u3 + t2)), r(s2(h3 + e3)), "c"].join(" "));
  }, M2 = function(t2, e3, r2, n3) {
    for (var i2 = 2 * Math.PI, a2 = Math.PI / 2; e3 > r2; ) e3 -= i2;
    var o3 = Math.abs(r2 - e3);
    o3 < i2 && n3 && (o3 = i2 - o3);
    for (var s3 = [], c3 = n3 ? -1 : 1, u3 = e3; o3 > 1e-5; ) {
      var h3 = u3 + c3 * Math.min(o3, a2);
      s3.push(E2.call(this, t2, u3, h3)), o3 -= Math.abs(h3 - u3), u3 = h3;
    }
    return s3;
  }, E2 = function(t2, e3, r2) {
    var n3 = (r2 - e3) / 2, i2 = t2 * Math.cos(n3), a2 = t2 * Math.sin(n3), o3 = i2, s3 = -a2, c3 = o3 * o3 + s3 * s3, u3 = c3 + o3 * i2 + s3 * a2, h3 = 4 / 3 * (Math.sqrt(2 * c3 * u3) - u3) / (o3 * a2 - s3 * i2), l3 = o3 - h3 * s3, f2 = s3 + h3 * o3, d3 = l3, p3 = -f2, g3 = n3 + e3, m3 = Math.cos(g3), v3 = Math.sin(g3);
    return { x1: t2 * Math.cos(e3), y1: t2 * Math.sin(e3), x2: l3 * m3 - f2 * v3, y2: l3 * v3 + f2 * m3, x3: d3 * m3 - p3 * v3, y3: d3 * v3 + p3 * m3, x4: t2 * Math.cos(r2), y4: t2 * Math.sin(r2) };
  }, q2 = function(t2) {
    return 180 * t2 / Math.PI;
  }, D2 = function(t2, e3, r2, n3, i2, a2) {
    var o3 = t2 + 0.5 * (r2 - t2), s3 = e3 + 0.5 * (n3 - e3), c3 = i2 + 0.5 * (r2 - i2), h3 = a2 + 0.5 * (n3 - a2), l3 = Math.min(t2, i2, o3, c3), f2 = Math.max(t2, i2, o3, c3), d3 = Math.min(e3, a2, s3, h3), p3 = Math.max(e3, a2, s3, h3);
    return new u2(l3, d3, f2 - l3, p3 - d3);
  }, R2 = function(t2, e3, r2, n3, i2, a2, o3, s3) {
    var c3, h3, l3, f2, d3, p3, g3, m3, v3, b3, y3, w3, N3, L3, A3 = r2 - t2, x3 = n3 - e3, S3 = i2 - r2, _3 = a2 - n3, P3 = o3 - i2, k3 = s3 - a2;
    for (h3 = 0; h3 < 41; h3++) v3 = (g3 = (l3 = t2 + (c3 = h3 / 40) * A3) + c3 * ((d3 = r2 + c3 * S3) - l3)) + c3 * (d3 + c3 * (i2 + c3 * P3 - d3) - g3), b3 = (m3 = (f2 = e3 + c3 * x3) + c3 * ((p3 = n3 + c3 * _3) - f2)) + c3 * (p3 + c3 * (a2 + c3 * k3 - p3) - m3), 0 == h3 ? (y3 = v3, w3 = b3, N3 = v3, L3 = b3) : (y3 = Math.min(y3, v3), w3 = Math.min(w3, b3), N3 = Math.max(N3, v3), L3 = Math.max(L3, b3));
    return new u2(Math.round(y3), Math.round(w3), Math.round(N3 - y3), Math.round(L3 - w3));
  }, T2 = function() {
    if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) {
      var t2, e3, r2 = (t2 = this.ctx.lineDash, e3 = this.ctx.lineDashOffset, JSON.stringify({ lineDash: t2, lineDashOffset: e3 }));
      this.prevLineDash !== r2 && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = r2);
    }
  };
}(E$1.API), /**
 * @license
 * jsPDF filters PlugIn
 * Copyright (c) 2014 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  var r = function(t3) {
    var e2, r2, n3, i2, a3, o2, s2, c2, u2, h2;
    for (r2 = [], n3 = 0, i2 = (t3 += e2 = "\0\0\0\0".slice(t3.length % 4 || 4)).length; i2 > n3; n3 += 4) 0 !== (a3 = (t3.charCodeAt(n3) << 24) + (t3.charCodeAt(n3 + 1) << 16) + (t3.charCodeAt(n3 + 2) << 8) + t3.charCodeAt(n3 + 3)) ? (o2 = (a3 = ((a3 = ((a3 = ((a3 = (a3 - (h2 = a3 % 85)) / 85) - (u2 = a3 % 85)) / 85) - (c2 = a3 % 85)) / 85) - (s2 = a3 % 85)) / 85) % 85, r2.push(o2 + 33, s2 + 33, c2 + 33, u2 + 33, h2 + 33)) : r2.push(122);
    return function(t4, e3) {
      for (var r3 = e3; r3 > 0; r3--) t4.pop();
    }(r2, e2.length), String.fromCharCode.apply(String, r2) + "~>";
  }, n2 = function(t3) {
    var e2, r2, n3, i2, a3, o2 = String, s2 = "length", c2 = 255, u2 = "charCodeAt", h2 = "slice", l2 = "replace";
    for (t3[h2](-2), t3 = t3[h2](0, -2)[l2](/\s/g, "")[l2]("z", "!!!!!"), n3 = [], i2 = 0, a3 = (t3 += e2 = "uuuuu"[h2](t3[s2] % 5 || 5))[s2]; a3 > i2; i2 += 5) r2 = 52200625 * (t3[u2](i2) - 33) + 614125 * (t3[u2](i2 + 1) - 33) + 7225 * (t3[u2](i2 + 2) - 33) + 85 * (t3[u2](i2 + 3) - 33) + (t3[u2](i2 + 4) - 33), n3.push(c2 & r2 >> 24, c2 & r2 >> 16, c2 & r2 >> 8, c2 & r2);
    return function(t4, e3) {
      for (var r3 = e3; r3 > 0; r3--) t4.pop();
    }(n3, e2[s2]), o2.fromCharCode.apply(o2, n3);
  }, i = function(t3) {
    var e2 = new RegExp(/^([0-9A-Fa-f]{2})+$/);
    if (-1 !== (t3 = t3.replace(/\s/g, "")).indexOf(">") && (t3 = t3.substr(0, t3.indexOf(">"))), t3.length % 2 && (t3 += "0"), false === e2.test(t3)) return "";
    for (var r2 = "", n3 = 0; n3 < t3.length; n3 += 2) r2 += String.fromCharCode("0x" + (t3[n3] + t3[n3 + 1]));
    return r2;
  }, a2 = function(t3) {
    for (var r2 = new Uint8Array(t3.length), n3 = t3.length; n3--; ) r2[n3] = t3.charCodeAt(n3);
    return t3 = (r2 = zlibSync(r2)).reduce(function(t4, e2) {
      return t4 + String.fromCharCode(e2);
    }, "");
  };
  t2.processDataByFilters = function(t3, e2) {
    var o2 = 0, s2 = t3 || "", c2 = [];
    for ("string" == typeof (e2 = e2 || []) && (e2 = [e2]), o2 = 0; o2 < e2.length; o2 += 1) switch (e2[o2]) {
      case "ASCII85Decode":
      case "/ASCII85Decode":
        s2 = n2(s2), c2.push("/ASCII85Encode");
        break;
      case "ASCII85Encode":
      case "/ASCII85Encode":
        s2 = r(s2), c2.push("/ASCII85Decode");
        break;
      case "ASCIIHexDecode":
      case "/ASCIIHexDecode":
        s2 = i(s2), c2.push("/ASCIIHexEncode");
        break;
      case "ASCIIHexEncode":
      case "/ASCIIHexEncode":
        s2 = s2.split("").map(function(t4) {
          return ("0" + t4.charCodeAt().toString(16)).slice(-2);
        }).join("") + ">", c2.push("/ASCIIHexDecode");
        break;
      case "FlateEncode":
      case "/FlateEncode":
        s2 = a2(s2), c2.push("/FlateDecode");
        break;
      default:
        throw new Error('The filter: "' + e2[o2] + '" is not implemented');
    }
    return { data: s2, reverseChain: c2.reverse().join(" ") };
  };
}(E$1.API), /**
 * @license
 * jsPDF fileloading PlugIn
 * Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  t2.loadFile = function(t3, e2, r) {
    return function(t4, e3, r2) {
      e3 = false !== e3, r2 = "function" == typeof r2 ? r2 : function() {
      };
      var n2 = void 0;
      try {
        n2 = function(t5, e4, r3) {
          var n3 = new XMLHttpRequest(), i = 0, a2 = function(t6) {
            var e5 = t6.length, r4 = [], n4 = String.fromCharCode;
            for (i = 0; i < e5; i += 1) r4.push(n4(255 & t6.charCodeAt(i)));
            return r4.join("");
          };
          if (n3.open("GET", t5, !e4), n3.overrideMimeType("text/plain; charset=x-user-defined"), false === e4 && (n3.onload = function() {
            200 === n3.status ? r3(a2(this.responseText)) : r3(void 0);
          }), n3.send(null), e4 && 200 === n3.status) return a2(n3.responseText);
        }(t4, e3, r2);
      } catch (t5) {
      }
      return n2;
    }(t3, e2, r);
  }, t2.loadImageFile = t2.loadFile;
}(E$1.API), function(e2) {
  function r() {
    return (n.html2canvas ? Promise.resolve(n.html2canvas) : __vitePreload(() => Promise.resolve().then(() => html2canvas_esm), true ? void 0 : void 0)).catch(function(t2) {
      return Promise.reject(new Error("Could not load html2canvas: " + t2));
    }).then(function(t2) {
      return t2.default ? t2.default : t2;
    });
  }
  function i() {
    return (n.DOMPurify ? Promise.resolve(n.DOMPurify) : __vitePreload(() => import("./purify.es-DgyTBGsH.js"), true ? [] : void 0)).catch(function(t2) {
      return Promise.reject(new Error("Could not load dompurify: " + t2));
    }).then(function(t2) {
      return t2.default ? t2.default : t2;
    });
  }
  var a2 = function(e3) {
    var r2 = _typeof(e3);
    return "undefined" === r2 ? "undefined" : "string" === r2 || e3 instanceof String ? "string" : "number" === r2 || e3 instanceof Number ? "number" : "function" === r2 || e3 instanceof Function ? "function" : e3 && e3.constructor === Array ? "array" : e3 && 1 === e3.nodeType ? "element" : "object" === r2 ? "object" : "unknown";
  }, o2 = function(t2, e3) {
    var r2 = document.createElement(t2);
    for (var n2 in e3.className && (r2.className = e3.className), e3.innerHTML && e3.dompurify && (r2.innerHTML = e3.dompurify.sanitize(e3.innerHTML)), e3.style) r2.style[n2] = e3.style[n2];
    return r2;
  }, s2 = function t2(e3) {
    var r2 = Object.assign(t2.convert(Promise.resolve()), JSON.parse(JSON.stringify(t2.template))), n2 = t2.convert(Promise.resolve(), r2);
    return n2 = (n2 = n2.setProgress(1, t2, 1, [t2])).set(e3);
  };
  (s2.prototype = Object.create(Promise.prototype)).constructor = s2, s2.convert = function(t2, e3) {
    return t2.__proto__ = e3 || s2.prototype, t2;
  }, s2.template = { prop: { src: null, container: null, overlay: null, canvas: null, img: null, pdf: null, pageSize: null, callback: function() {
  } }, progress: { val: 0, state: null, n: 0, stack: [] }, opt: { filename: "file.pdf", margin: [0, 0, 0, 0], enableLinks: true, x: 0, y: 0, html2canvas: {}, jsPDF: {}, backgroundColor: "transparent" } }, s2.prototype.from = function(t2, e3) {
    return this.then(function() {
      switch (e3 = e3 || function(t3) {
        switch (a2(t3)) {
          case "string":
            return "string";
          case "element":
            return "canvas" === t3.nodeName.toLowerCase() ? "canvas" : "element";
          default:
            return "unknown";
        }
      }(t2)) {
        case "string":
          return this.then(i).then(function(e4) {
            return this.set({ src: o2("div", { innerHTML: t2, dompurify: e4 }) });
          });
        case "element":
          return this.set({ src: t2 });
        case "canvas":
          return this.set({ canvas: t2 });
        case "img":
          return this.set({ img: t2 });
        default:
          return this.error("Unknown source type.");
      }
    });
  }, s2.prototype.to = function(t2) {
    switch (t2) {
      case "container":
        return this.toContainer();
      case "canvas":
        return this.toCanvas();
      case "img":
        return this.toImg();
      case "pdf":
        return this.toPdf();
      default:
        return this.error("Invalid target.");
    }
  }, s2.prototype.toContainer = function() {
    return this.thenList([function() {
      return this.prop.src || this.error("Cannot duplicate - no source HTML.");
    }, function() {
      return this.prop.pageSize || this.setPageSize();
    }]).then(function() {
      var t2 = { position: "relative", display: "inline-block", width: ("number" != typeof this.opt.width || isNaN(this.opt.width) || "number" != typeof this.opt.windowWidth || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px", left: 0, right: 0, top: 0, margin: "auto", backgroundColor: this.opt.backgroundColor }, e3 = function t3(e4, r2) {
        for (var n2 = 3 === e4.nodeType ? document.createTextNode(e4.nodeValue) : e4.cloneNode(false), i2 = e4.firstChild; i2; i2 = i2.nextSibling) true !== r2 && 1 === i2.nodeType && "SCRIPT" === i2.nodeName || n2.appendChild(t3(i2, r2));
        return 1 === e4.nodeType && ("CANVAS" === e4.nodeName ? (n2.width = e4.width, n2.height = e4.height, n2.getContext("2d").drawImage(e4, 0, 0)) : "TEXTAREA" !== e4.nodeName && "SELECT" !== e4.nodeName || (n2.value = e4.value), n2.addEventListener("load", function() {
          n2.scrollTop = e4.scrollTop, n2.scrollLeft = e4.scrollLeft;
        }, true)), n2;
      }(this.prop.src, this.opt.html2canvas.javascriptEnabled);
      "BODY" === e3.tagName && (t2.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = o2("div", { className: "html2pdf__overlay", style: { position: "fixed", overflow: "hidden", zIndex: 1e3, left: "-100000px", right: 0, bottom: 0, top: 0 } }), this.prop.container = o2("div", { className: "html2pdf__container", style: t2 }), this.prop.container.appendChild(e3), this.prop.container.firstChild.appendChild(o2("div", { style: { clear: "both", border: "0 none transparent", margin: 0, padding: 0, height: 0 } })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
    });
  }, s2.prototype.toCanvas = function() {
    var t2 = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(t2).then(r).then(function(t3) {
      var e3 = Object.assign({}, this.opt.html2canvas);
      return delete e3.onrendered, t3(this.prop.container, e3);
    }).then(function(t3) {
      (this.opt.html2canvas.onrendered || function() {
      })(t3), this.prop.canvas = t3, document.body.removeChild(this.prop.overlay);
    });
  }, s2.prototype.toContext2d = function() {
    var t2 = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(t2).then(r).then(function(t3) {
      var e3 = this.opt.jsPDF, r2 = this.opt.fontFaces, n2 = "number" != typeof this.opt.width || isNaN(this.opt.width) || "number" != typeof this.opt.windowWidth || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, i2 = Object.assign({ async: true, allowTaint: true, scale: n2, scrollX: this.opt.scrollX || 0, scrollY: this.opt.scrollY || 0, backgroundColor: "#ffffff", imageTimeout: 15e3, logging: true, proxy: null, removeContainer: true, foreignObjectRendering: false, useCORS: false }, this.opt.html2canvas);
      if (delete i2.onrendered, e3.context2d.autoPaging = void 0 === this.opt.autoPaging || this.opt.autoPaging, e3.context2d.posX = this.opt.x, e3.context2d.posY = this.opt.y, e3.context2d.margin = this.opt.margin, e3.context2d.fontFaces = r2, r2) for (var a3 = 0; a3 < r2.length; ++a3) {
        var o3 = r2[a3], s3 = o3.src.find(function(t4) {
          return "truetype" === t4.format;
        });
        s3 && e3.addFont(s3.url, o3.ref.name, o3.ref.style);
      }
      return i2.windowHeight = i2.windowHeight || 0, i2.windowHeight = 0 == i2.windowHeight ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : i2.windowHeight, e3.context2d.save(true), t3(this.prop.container, i2);
    }).then(function(t3) {
      this.opt.jsPDF.context2d.restore(true), (this.opt.html2canvas.onrendered || function() {
      })(t3), this.prop.canvas = t3, document.body.removeChild(this.prop.overlay);
    });
  }, s2.prototype.toImg = function() {
    return this.thenList([function() {
      return this.prop.canvas || this.toCanvas();
    }]).then(function() {
      var t2 = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
      this.prop.img = document.createElement("img"), this.prop.img.src = t2;
    });
  }, s2.prototype.toPdf = function() {
    return this.thenList([function() {
      return this.toContext2d();
    }]).then(function() {
      this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
    });
  }, s2.prototype.output = function(t2, e3, r2) {
    return "img" === (r2 = r2 || "pdf").toLowerCase() || "image" === r2.toLowerCase() ? this.outputImg(t2, e3) : this.outputPdf(t2, e3);
  }, s2.prototype.outputPdf = function(t2, e3) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      return this.prop.pdf.output(t2, e3);
    });
  }, s2.prototype.outputImg = function(t2) {
    return this.thenList([function() {
      return this.prop.img || this.toImg();
    }]).then(function() {
      switch (t2) {
        case void 0:
        case "img":
          return this.prop.img;
        case "datauristring":
        case "dataurlstring":
          return this.prop.img.src;
        case "datauri":
        case "dataurl":
          return document.location.href = this.prop.img.src;
        default:
          throw 'Image output type "' + t2 + '" is not supported.';
      }
    });
  }, s2.prototype.save = function(t2) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).set(t2 ? { filename: t2 } : null).then(function() {
      this.prop.pdf.save(this.opt.filename);
    });
  }, s2.prototype.doCallback = function() {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      this.prop.callback(this.prop.pdf);
    });
  }, s2.prototype.set = function(t2) {
    if ("object" !== a2(t2)) return this;
    var e3 = Object.keys(t2 || {}).map(function(e4) {
      if (e4 in s2.template.prop) return function() {
        this.prop[e4] = t2[e4];
      };
      switch (e4) {
        case "margin":
          return this.setMargin.bind(this, t2.margin);
        case "jsPDF":
          return function() {
            return this.opt.jsPDF = t2.jsPDF, this.setPageSize();
          };
        case "pageSize":
          return this.setPageSize.bind(this, t2.pageSize);
        default:
          return function() {
            this.opt[e4] = t2[e4];
          };
      }
    }, this);
    return this.then(function() {
      return this.thenList(e3);
    });
  }, s2.prototype.get = function(t2, e3) {
    return this.then(function() {
      var r2 = t2 in s2.template.prop ? this.prop[t2] : this.opt[t2];
      return e3 ? e3(r2) : r2;
    });
  }, s2.prototype.setMargin = function(t2) {
    return this.then(function() {
      switch (a2(t2)) {
        case "number":
          t2 = [t2, t2, t2, t2];
        case "array":
          if (2 === t2.length && (t2 = [t2[0], t2[1], t2[0], t2[1]]), 4 === t2.length) break;
        default:
          return this.error("Invalid margin array.");
      }
      this.opt.margin = t2;
    }).then(this.setPageSize);
  }, s2.prototype.setPageSize = function(t2) {
    function e3(t3, e4) {
      return Math.floor(t3 * e4 / 72 * 96);
    }
    return this.then(function() {
      (t2 = t2 || E$1.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (t2.inner = { width: t2.width - this.opt.margin[1] - this.opt.margin[3], height: t2.height - this.opt.margin[0] - this.opt.margin[2] }, t2.inner.px = { width: e3(t2.inner.width, t2.k), height: e3(t2.inner.height, t2.k) }, t2.inner.ratio = t2.inner.height / t2.inner.width), this.prop.pageSize = t2;
    });
  }, s2.prototype.setProgress = function(t2, e3, r2, n2) {
    return null != t2 && (this.progress.val = t2), null != e3 && (this.progress.state = e3), null != r2 && (this.progress.n = r2), null != n2 && (this.progress.stack = n2), this.progress.ratio = this.progress.val / this.progress.state, this;
  }, s2.prototype.updateProgress = function(t2, e3, r2, n2) {
    return this.setProgress(t2 ? this.progress.val + t2 : null, e3 || null, r2 ? this.progress.n + r2 : null, n2 ? this.progress.stack.concat(n2) : null);
  }, s2.prototype.then = function(t2, e3) {
    var r2 = this;
    return this.thenCore(t2, e3, function(t3, e4) {
      return r2.updateProgress(null, null, 1, [t3]), Promise.prototype.then.call(this, function(e5) {
        return r2.updateProgress(null, t3), e5;
      }).then(t3, e4).then(function(t4) {
        return r2.updateProgress(1), t4;
      });
    });
  }, s2.prototype.thenCore = function(t2, e3, r2) {
    r2 = r2 || Promise.prototype.then;
    t2 && (t2 = t2.bind(this)), e3 && (e3 = e3.bind(this));
    var n2 = -1 !== Promise.toString().indexOf("[native code]") && "Promise" === Promise.name ? this : s2.convert(Object.assign({}, this), Promise.prototype), i2 = r2.call(n2, t2, e3);
    return s2.convert(i2, this.__proto__);
  }, s2.prototype.thenExternal = function(t2, e3) {
    return Promise.prototype.then.call(this, t2, e3);
  }, s2.prototype.thenList = function(t2) {
    var e3 = this;
    return t2.forEach(function(t3) {
      e3 = e3.thenCore(t3);
    }), e3;
  }, s2.prototype.catch = function(t2) {
    t2 && (t2 = t2.bind(this));
    var e3 = Promise.prototype.catch.call(this, t2);
    return s2.convert(e3, this);
  }, s2.prototype.catchExternal = function(t2) {
    return Promise.prototype.catch.call(this, t2);
  }, s2.prototype.error = function(t2) {
    return this.then(function() {
      throw new Error(t2);
    });
  }, s2.prototype.using = s2.prototype.set, s2.prototype.saveAs = s2.prototype.save, s2.prototype.export = s2.prototype.output, s2.prototype.run = s2.prototype.then, E$1.getPageSize = function(e3, r2, n2) {
    if ("object" === _typeof(e3)) {
      var i2 = e3;
      e3 = i2.orientation, r2 = i2.unit || r2, n2 = i2.format || n2;
    }
    r2 = r2 || "mm", n2 = n2 || "a4", e3 = ("" + (e3 || "P")).toLowerCase();
    var a3, o3 = ("" + n2).toLowerCase(), s3 = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
    switch (r2) {
      case "pt":
        a3 = 1;
        break;
      case "mm":
        a3 = 72 / 25.4;
        break;
      case "cm":
        a3 = 72 / 2.54;
        break;
      case "in":
        a3 = 72;
        break;
      case "px":
        a3 = 0.75;
        break;
      case "pc":
      case "em":
        a3 = 12;
        break;
      case "ex":
        a3 = 6;
        break;
      default:
        throw "Invalid unit: " + r2;
    }
    var c2, u2 = 0, h2 = 0;
    if (s3.hasOwnProperty(o3)) u2 = s3[o3][1] / a3, h2 = s3[o3][0] / a3;
    else try {
      u2 = n2[1], h2 = n2[0];
    } catch (t2) {
      throw new Error("Invalid format: " + n2);
    }
    if ("p" === e3 || "portrait" === e3) e3 = "p", h2 > u2 && (c2 = h2, h2 = u2, u2 = c2);
    else {
      if ("l" !== e3 && "landscape" !== e3) throw "Invalid orientation: " + e3;
      e3 = "l", u2 > h2 && (c2 = h2, h2 = u2, u2 = c2);
    }
    return { width: h2, height: u2, unit: r2, k: a3, orientation: e3 };
  }, e2.html = function(t2, e3) {
    (e3 = e3 || {}).callback = e3.callback || function() {
    }, e3.html2canvas = e3.html2canvas || {}, e3.html2canvas.canvas = e3.html2canvas.canvas || this.canvas, e3.jsPDF = e3.jsPDF || this, e3.fontFaces = e3.fontFaces ? e3.fontFaces.map(jt) : null;
    var r2 = new s2(e3);
    return e3.worker ? r2 : r2.from(t2).doCallback();
  };
}(E$1.API), E$1.API.addJS = function(t2) {
  return Ht = t2, this.internal.events.subscribe("postPutResources", function() {
    Ut = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (Ut + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), zt = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + Ht + ")"), this.internal.out(">>"), this.internal.out("endobj");
  }), this.internal.events.subscribe("putCatalog", function() {
    void 0 !== Ut && void 0 !== zt && this.internal.out("/Names <</JavaScript " + Ut + " 0 R>>");
  }), this;
}, /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  var e2;
  t2.events.push(["postPutResources", function() {
    var t3 = this, r = /^(\d+) 0 obj$/;
    if (this.outline.root.children.length > 0) for (var n2 = t3.outline.render().split(/\r\n/), i = 0; i < n2.length; i++) {
      var a2 = n2[i], o2 = r.exec(a2);
      if (null != o2) {
        var s2 = o2[1];
        t3.internal.newObjectDeferredBegin(s2, false);
      }
      t3.internal.write(a2);
    }
    if (this.outline.createNamedDestinations) {
      var c2 = this.internal.pages.length, u2 = [];
      for (i = 0; i < c2; i++) {
        var h2 = t3.internal.newObject();
        u2.push(h2);
        var l2 = t3.internal.getPageInfo(i + 1);
        t3.internal.write("<< /D[" + l2.objId + " 0 R /XYZ null null null]>> endobj");
      }
      var f2 = t3.internal.newObject();
      t3.internal.write("<< /Names [ ");
      for (i = 0; i < u2.length; i++) t3.internal.write("(page_" + (i + 1) + ")" + u2[i] + " 0 R");
      t3.internal.write(" ] >>", "endobj"), e2 = t3.internal.newObject(), t3.internal.write("<< /Dests " + f2 + " 0 R"), t3.internal.write(">>", "endobj");
    }
  }]), t2.events.push(["putCatalog", function() {
    this.outline.root.children.length > 0 && (this.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && this.internal.write("/Names " + e2 + " 0 R"));
  }]), t2.events.push(["initialized", function() {
    var t3 = this;
    t3.outline = { createNamedDestinations: false, root: { children: [] } }, t3.outline.add = function(t4, e3, r) {
      var n2 = { title: e3, options: r, children: [] };
      return null == t4 && (t4 = this.root), t4.children.push(n2), n2;
    }, t3.outline.render = function() {
      return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = t3, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
    }, t3.outline.genIds_r = function(e3) {
      e3.id = t3.internal.newObjectDeferred();
      for (var r = 0; r < e3.children.length; r++) this.genIds_r(e3.children[r]);
    }, t3.outline.renderRoot = function(t4) {
      this.objStart(t4), this.line("/Type /Outlines"), t4.children.length > 0 && (this.line("/First " + this.makeRef(t4.children[0])), this.line("/Last " + this.makeRef(t4.children[t4.children.length - 1]))), this.line("/Count " + this.count_r({ count: 0 }, t4)), this.objEnd();
    }, t3.outline.renderItems = function(e3) {
      for (var r = this.ctx.pdf.internal.getVerticalCoordinateString, n2 = 0; n2 < e3.children.length; n2++) {
        var i = e3.children[n2];
        this.objStart(i), this.line("/Title " + this.makeString(i.title)), this.line("/Parent " + this.makeRef(e3)), n2 > 0 && this.line("/Prev " + this.makeRef(e3.children[n2 - 1])), n2 < e3.children.length - 1 && this.line("/Next " + this.makeRef(e3.children[n2 + 1])), i.children.length > 0 && (this.line("/First " + this.makeRef(i.children[0])), this.line("/Last " + this.makeRef(i.children[i.children.length - 1])));
        var a2 = this.count = this.count_r({ count: 0 }, i);
        if (a2 > 0 && this.line("/Count " + a2), i.options && i.options.pageNumber) {
          var o2 = t3.internal.getPageInfo(i.options.pageNumber);
          this.line("/Dest [" + o2.objId + " 0 R /XYZ 0 " + r(0) + " 0]");
        }
        this.objEnd();
      }
      for (var s2 = 0; s2 < e3.children.length; s2++) this.renderItems(e3.children[s2]);
    }, t3.outline.line = function(t4) {
      this.ctx.val += t4 + "\r\n";
    }, t3.outline.makeRef = function(t4) {
      return t4.id + " 0 R";
    }, t3.outline.makeString = function(e3) {
      return "(" + t3.internal.pdfEscape(e3) + ")";
    }, t3.outline.objStart = function(t4) {
      this.ctx.val += "\r\n" + t4.id + " 0 obj\r\n<<\r\n";
    }, t3.outline.objEnd = function() {
      this.ctx.val += ">> \r\nendobj\r\n";
    }, t3.outline.count_r = function(t4, e3) {
      for (var r = 0; r < e3.children.length; r++) t4.count++, this.count_r(t4, e3.children[r]);
      return t4.count;
    };
  }]);
}(E$1.API), /**
 * @license
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  var e2 = [192, 193, 194, 195, 196, 197, 198, 199];
  t2.processJPEG = function(t3, r, n2, i, a2, o2) {
    var s2, c2 = this.decode.DCT_DECODE, u2 = null;
    if ("string" == typeof t3 || this.__addimage__.isArrayBuffer(t3) || this.__addimage__.isArrayBufferView(t3)) {
      switch (t3 = a2 || t3, t3 = this.__addimage__.isArrayBuffer(t3) ? new Uint8Array(t3) : t3, (s2 = function(t4) {
        for (var r2, n3 = 256 * t4.charCodeAt(4) + t4.charCodeAt(5), i2 = t4.length, a3 = { width: 0, height: 0, numcomponents: 1 }, o3 = 4; o3 < i2; o3 += 2) {
          if (o3 += n3, -1 !== e2.indexOf(t4.charCodeAt(o3 + 1))) {
            r2 = 256 * t4.charCodeAt(o3 + 5) + t4.charCodeAt(o3 + 6), a3 = { width: 256 * t4.charCodeAt(o3 + 7) + t4.charCodeAt(o3 + 8), height: r2, numcomponents: t4.charCodeAt(o3 + 9) };
            break;
          }
          n3 = 256 * t4.charCodeAt(o3 + 2) + t4.charCodeAt(o3 + 3);
        }
        return a3;
      }(t3 = this.__addimage__.isArrayBufferView(t3) ? this.__addimage__.arrayBufferToBinaryString(t3) : t3)).numcomponents) {
        case 1:
          o2 = this.color_spaces.DEVICE_GRAY;
          break;
        case 4:
          o2 = this.color_spaces.DEVICE_CMYK;
          break;
        case 3:
          o2 = this.color_spaces.DEVICE_RGB;
      }
      u2 = { data: t3, width: s2.width, height: s2.height, colorSpace: o2, bitsPerComponent: 8, filter: c2, index: r, alias: n2 };
    }
    return u2;
  };
}(E$1.API);
var Vt, Gt, Yt, Jt, Xt, Kt = function() {
  var t2, e2, i;
  function a2(t3) {
    var e3, r, n2, i2, a3, o3, s2, c2, u2, h2, l2, f2, d2, p2;
    for (this.data = t3, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, o3 = null; ; ) {
      switch (e3 = this.readUInt32(), u2 = (function() {
        var t4, e4;
        for (e4 = [], t4 = 0; t4 < 4; ++t4) e4.push(String.fromCharCode(this.data[this.pos++]));
        return e4;
      }).call(this).join("")) {
        case "IHDR":
          this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
          break;
        case "acTL":
          this.animation = { numFrames: this.readUInt32(), numPlays: this.readUInt32() || 1 / 0, frames: [] };
          break;
        case "PLTE":
          this.palette = this.read(e3);
          break;
        case "fcTL":
          o3 && this.animation.frames.push(o3), this.pos += 4, o3 = { width: this.readUInt32(), height: this.readUInt32(), xOffset: this.readUInt32(), yOffset: this.readUInt32() }, a3 = this.readUInt16(), i2 = this.readUInt16() || 100, o3.delay = 1e3 * a3 / i2, o3.disposeOp = this.data[this.pos++], o3.blendOp = this.data[this.pos++], o3.data = [];
          break;
        case "IDAT":
        case "fdAT":
          for ("fdAT" === u2 && (this.pos += 4, e3 -= 4), t3 = (null != o3 ? o3.data : void 0) || this.imgData, f2 = 0; 0 <= e3 ? f2 < e3 : f2 > e3; 0 <= e3 ? ++f2 : --f2) t3.push(this.data[this.pos++]);
          break;
        case "tRNS":
          switch (this.transparency = {}, this.colorType) {
            case 3:
              if (n2 = this.palette.length / 3, this.transparency.indexed = this.read(e3), this.transparency.indexed.length > n2) throw new Error("More transparent colors than palette size");
              if ((h2 = n2 - this.transparency.indexed.length) > 0) for (d2 = 0; 0 <= h2 ? d2 < h2 : d2 > h2; 0 <= h2 ? ++d2 : --d2) this.transparency.indexed.push(255);
              break;
            case 0:
              this.transparency.grayscale = this.read(e3)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(e3);
          }
          break;
        case "tEXt":
          s2 = (l2 = this.read(e3)).indexOf(0), c2 = String.fromCharCode.apply(String, l2.slice(0, s2)), this.text[c2] = String.fromCharCode.apply(String, l2.slice(s2 + 1));
          break;
        case "IEND":
          return o3 && this.animation.frames.push(o3), this.colors = (function() {
            switch (this.colorType) {
              case 0:
              case 3:
              case 4:
                return 1;
              case 2:
              case 6:
                return 3;
            }
          }).call(this), this.hasAlphaChannel = 4 === (p2 = this.colorType) || 6 === p2, r = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * r, this.colorSpace = (function() {
            switch (this.colors) {
              case 1:
                return "DeviceGray";
              case 3:
                return "DeviceRGB";
            }
          }).call(this), void (this.imgData = new Uint8Array(this.imgData));
        default:
          this.pos += e3;
      }
      if (this.pos += 4, this.pos > this.data.length) throw new Error("Incomplete or corrupt PNG file");
    }
  }
  a2.prototype.read = function(t3) {
    var e3, r;
    for (r = [], e3 = 0; 0 <= t3 ? e3 < t3 : e3 > t3; 0 <= t3 ? ++e3 : --e3) r.push(this.data[this.pos++]);
    return r;
  }, a2.prototype.readUInt32 = function() {
    return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
  }, a2.prototype.readUInt16 = function() {
    return this.data[this.pos++] << 8 | this.data[this.pos++];
  }, a2.prototype.decodePixels = function(t3) {
    var e3 = this.pixelBitlength / 8, n2 = new Uint8Array(this.width * this.height * e3), i2 = 0, a3 = this;
    if (null == t3 && (t3 = this.imgData), 0 === t3.length) return new Uint8Array(0);
    function o3(r, o4, s2, c2) {
      var u2, h2, l2, f2, d2, p2, g2, m2, v2, b2, y2, w2, N2, L2, A2, x2, S2, _2, P2, k2, I2, F2 = Math.ceil((a3.width - r) / s2), C2 = Math.ceil((a3.height - o4) / c2), j2 = a3.width == F2 && a3.height == C2;
      for (L2 = e3 * F2, w2 = j2 ? n2 : new Uint8Array(L2 * C2), p2 = t3.length, N2 = 0, h2 = 0; N2 < C2 && i2 < p2; ) {
        switch (t3[i2++]) {
          case 0:
            for (f2 = S2 = 0; S2 < L2; f2 = S2 += 1) w2[h2++] = t3[i2++];
            break;
          case 1:
            for (f2 = _2 = 0; _2 < L2; f2 = _2 += 1) u2 = t3[i2++], d2 = f2 < e3 ? 0 : w2[h2 - e3], w2[h2++] = (u2 + d2) % 256;
            break;
          case 2:
            for (f2 = P2 = 0; P2 < L2; f2 = P2 += 1) u2 = t3[i2++], l2 = (f2 - f2 % e3) / e3, A2 = N2 && w2[(N2 - 1) * L2 + l2 * e3 + f2 % e3], w2[h2++] = (A2 + u2) % 256;
            break;
          case 3:
            for (f2 = k2 = 0; k2 < L2; f2 = k2 += 1) u2 = t3[i2++], l2 = (f2 - f2 % e3) / e3, d2 = f2 < e3 ? 0 : w2[h2 - e3], A2 = N2 && w2[(N2 - 1) * L2 + l2 * e3 + f2 % e3], w2[h2++] = (u2 + Math.floor((d2 + A2) / 2)) % 256;
            break;
          case 4:
            for (f2 = I2 = 0; I2 < L2; f2 = I2 += 1) u2 = t3[i2++], l2 = (f2 - f2 % e3) / e3, d2 = f2 < e3 ? 0 : w2[h2 - e3], 0 === N2 ? A2 = x2 = 0 : (A2 = w2[(N2 - 1) * L2 + l2 * e3 + f2 % e3], x2 = l2 && w2[(N2 - 1) * L2 + (l2 - 1) * e3 + f2 % e3]), g2 = d2 + A2 - x2, m2 = Math.abs(g2 - d2), b2 = Math.abs(g2 - A2), y2 = Math.abs(g2 - x2), v2 = m2 <= b2 && m2 <= y2 ? d2 : b2 <= y2 ? A2 : x2, w2[h2++] = (u2 + v2) % 256;
            break;
          default:
            throw new Error("Invalid filter algorithm: " + t3[i2 - 1]);
        }
        if (!j2) {
          var O2 = ((o4 + N2 * c2) * a3.width + r) * e3, B3 = N2 * L2;
          for (f2 = 0; f2 < F2; f2 += 1) {
            for (var M2 = 0; M2 < e3; M2 += 1) n2[O2++] = w2[B3++];
            O2 += (s2 - 1) * e3;
          }
        }
        N2++;
      }
    }
    return t3 = unzlibSync(t3), 1 == a3.interlaceMethod ? (o3(0, 0, 8, 8), o3(4, 0, 8, 8), o3(0, 4, 4, 8), o3(2, 0, 4, 4), o3(0, 2, 2, 4), o3(1, 0, 2, 2), o3(0, 1, 1, 2)) : o3(0, 0, 1, 1), n2;
  }, a2.prototype.decodePalette = function() {
    var t3, e3, r, n2, i2, a3, o3, s2, c2;
    for (r = this.palette, a3 = this.transparency.indexed || [], i2 = new Uint8Array((a3.length || 0) + r.length), n2 = 0, t3 = 0, e3 = o3 = 0, s2 = r.length; o3 < s2; e3 = o3 += 3) i2[n2++] = r[e3], i2[n2++] = r[e3 + 1], i2[n2++] = r[e3 + 2], i2[n2++] = null != (c2 = a3[t3++]) ? c2 : 255;
    return i2;
  }, a2.prototype.copyToImageData = function(t3, e3) {
    var r, n2, i2, a3, o3, s2, c2, u2, h2, l2, f2;
    if (n2 = this.colors, h2 = null, r = this.hasAlphaChannel, this.palette.length && (h2 = null != (f2 = this._decodedPalette) ? f2 : this._decodedPalette = this.decodePalette(), n2 = 4, r = true), u2 = (i2 = t3.data || t3).length, o3 = h2 || e3, a3 = s2 = 0, 1 === n2) for (; a3 < u2; ) c2 = h2 ? 4 * e3[a3 / 4] : s2, l2 = o3[c2++], i2[a3++] = l2, i2[a3++] = l2, i2[a3++] = l2, i2[a3++] = r ? o3[c2++] : 255, s2 = c2;
    else for (; a3 < u2; ) c2 = h2 ? 4 * e3[a3 / 4] : s2, i2[a3++] = o3[c2++], i2[a3++] = o3[c2++], i2[a3++] = o3[c2++], i2[a3++] = r ? o3[c2++] : 255, s2 = c2;
  }, a2.prototype.decode = function() {
    var t3;
    return t3 = new Uint8Array(this.width * this.height * 4), this.copyToImageData(t3, this.decodePixels()), t3;
  };
  var o2 = function() {
    if ("[object Window]" === Object.prototype.toString.call(n)) {
      try {
        e2 = n.document.createElement("canvas"), i = e2.getContext("2d");
      } catch (t3) {
        return false;
      }
      return true;
    }
    return false;
  };
  return o2(), t2 = function(t3) {
    var r;
    if (true === o2()) return i.width = t3.width, i.height = t3.height, i.clearRect(0, 0, t3.width, t3.height), i.putImageData(t3, 0, 0), (r = new Image()).src = e2.toDataURL(), r;
    throw new Error("This method requires a Browser with Canvas-capability.");
  }, a2.prototype.decodeFrames = function(e3) {
    var r, n2, i2, a3, o3, s2, c2, u2;
    if (this.animation) {
      for (u2 = [], n2 = o3 = 0, s2 = (c2 = this.animation.frames).length; o3 < s2; n2 = ++o3) r = c2[n2], i2 = e3.createImageData(r.width, r.height), a3 = this.decodePixels(new Uint8Array(r.data)), this.copyToImageData(i2, a3), r.imageData = i2, u2.push(r.image = t2(i2));
      return u2;
    }
  }, a2.prototype.renderFrame = function(t3, e3) {
    var r, n2, i2;
    return r = (n2 = this.animation.frames)[e3], i2 = n2[e3 - 1], 0 === e3 && t3.clearRect(0, 0, this.width, this.height), 1 === (null != i2 ? i2.disposeOp : void 0) ? t3.clearRect(i2.xOffset, i2.yOffset, i2.width, i2.height) : 2 === (null != i2 ? i2.disposeOp : void 0) && t3.putImageData(i2.imageData, i2.xOffset, i2.yOffset), 0 === r.blendOp && t3.clearRect(r.xOffset, r.yOffset, r.width, r.height), t3.drawImage(r.image, r.xOffset, r.yOffset);
  }, a2.prototype.animate = function(t3) {
    var e3, r, n2, i2, a3, o3, s2 = this;
    return r = 0, o3 = this.animation, i2 = o3.numFrames, n2 = o3.frames, a3 = o3.numPlays, (e3 = function() {
      var o4, c2;
      if (o4 = r++ % i2, c2 = n2[o4], s2.renderFrame(t3, o4), i2 > 1 && r / i2 < a3) return s2.animation._timeout = setTimeout(e3, c2.delay);
    })();
  }, a2.prototype.stopAnimation = function() {
    var t3;
    return clearTimeout(null != (t3 = this.animation) ? t3._timeout : void 0);
  }, a2.prototype.render = function(t3) {
    var e3, r;
    return t3._png && t3._png.stopAnimation(), t3._png = this, t3.width = this.width, t3.height = this.height, e3 = t3.getContext("2d"), this.animation ? (this.decodeFrames(e3), this.animate(e3)) : (r = e3.createImageData(this.width, this.height), this.copyToImageData(r, this.decodePixels()), e3.putImageData(r, 0, 0));
  }, a2;
}();
/**
 * @license
 *
 * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
/**
 * @license
 * (c) Dean McNamee <dean@gmail.com>, 2013.
 *
 * https://github.com/deanm/omggif
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
 * including animation and compression.  It does not rely on any specific
 * underlying system, so should run in the browser, Node, or Plask.
 */
function Zt(t2) {
  var e2 = 0;
  if (71 !== t2[e2++] || 73 !== t2[e2++] || 70 !== t2[e2++] || 56 !== t2[e2++] || 56 != (t2[e2++] + 1 & 253) || 97 !== t2[e2++]) throw new Error("Invalid GIF 87a/89a header.");
  var r = t2[e2++] | t2[e2++] << 8, n2 = t2[e2++] | t2[e2++] << 8, i = t2[e2++], a2 = i >> 7, o2 = 1 << (7 & i) + 1;
  t2[e2++];
  t2[e2++];
  var s2 = null, c2 = null;
  a2 && (s2 = e2, c2 = o2, e2 += 3 * o2);
  var u2 = true, h2 = [], l2 = 0, f2 = null, d2 = 0, p2 = null;
  for (this.width = r, this.height = n2; u2 && e2 < t2.length; ) switch (t2[e2++]) {
    case 33:
      switch (t2[e2++]) {
        case 255:
          if (11 !== t2[e2] || 78 == t2[e2 + 1] && 69 == t2[e2 + 2] && 84 == t2[e2 + 3] && 83 == t2[e2 + 4] && 67 == t2[e2 + 5] && 65 == t2[e2 + 6] && 80 == t2[e2 + 7] && 69 == t2[e2 + 8] && 50 == t2[e2 + 9] && 46 == t2[e2 + 10] && 48 == t2[e2 + 11] && 3 == t2[e2 + 12] && 1 == t2[e2 + 13] && 0 == t2[e2 + 16]) e2 += 14, p2 = t2[e2++] | t2[e2++] << 8, e2++;
          else for (e2 += 12; ; ) {
            if (!((P2 = t2[e2++]) >= 0)) throw Error("Invalid block size");
            if (0 === P2) break;
            e2 += P2;
          }
          break;
        case 249:
          if (4 !== t2[e2++] || 0 !== t2[e2 + 4]) throw new Error("Invalid graphics extension block.");
          var g2 = t2[e2++];
          l2 = t2[e2++] | t2[e2++] << 8, f2 = t2[e2++], 0 == (1 & g2) && (f2 = null), d2 = g2 >> 2 & 7, e2++;
          break;
        case 254:
          for (; ; ) {
            if (!((P2 = t2[e2++]) >= 0)) throw Error("Invalid block size");
            if (0 === P2) break;
            e2 += P2;
          }
          break;
        default:
          throw new Error("Unknown graphic control label: 0x" + t2[e2 - 1].toString(16));
      }
      break;
    case 44:
      var m2 = t2[e2++] | t2[e2++] << 8, v2 = t2[e2++] | t2[e2++] << 8, b2 = t2[e2++] | t2[e2++] << 8, y2 = t2[e2++] | t2[e2++] << 8, w2 = t2[e2++], N2 = w2 >> 6 & 1, L2 = 1 << (7 & w2) + 1, A2 = s2, x2 = c2, S2 = false;
      if (w2 >> 7) {
        S2 = true;
        A2 = e2, x2 = L2, e2 += 3 * L2;
      }
      var _2 = e2;
      for (e2++; ; ) {
        var P2;
        if (!((P2 = t2[e2++]) >= 0)) throw Error("Invalid block size");
        if (0 === P2) break;
        e2 += P2;
      }
      h2.push({ x: m2, y: v2, width: b2, height: y2, has_local_palette: S2, palette_offset: A2, palette_size: x2, data_offset: _2, data_length: e2 - _2, transparent_index: f2, interlaced: !!N2, delay: l2, disposal: d2 });
      break;
    case 59:
      u2 = false;
      break;
    default:
      throw new Error("Unknown gif block: 0x" + t2[e2 - 1].toString(16));
  }
  this.numFrames = function() {
    return h2.length;
  }, this.loopCount = function() {
    return p2;
  }, this.frameInfo = function(t3) {
    if (t3 < 0 || t3 >= h2.length) throw new Error("Frame index out of range.");
    return h2[t3];
  }, this.decodeAndBlitFrameBGRA = function(e3, n3) {
    var i2 = this.frameInfo(e3), a3 = i2.width * i2.height, o3 = new Uint8Array(a3);
    $t(t2, i2.data_offset, o3, a3);
    var s3 = i2.palette_offset, c3 = i2.transparent_index;
    null === c3 && (c3 = 256);
    var u3 = i2.width, h3 = r - u3, l3 = u3, f3 = 4 * (i2.y * r + i2.x), d3 = 4 * ((i2.y + i2.height) * r + i2.x), p3 = f3, g3 = 4 * h3;
    true === i2.interlaced && (g3 += 4 * r * 7);
    for (var m3 = 8, v3 = 0, b3 = o3.length; v3 < b3; ++v3) {
      var y3 = o3[v3];
      if (0 === l3 && (l3 = u3, (p3 += g3) >= d3 && (g3 = 4 * h3 + 4 * r * (m3 - 1), p3 = f3 + (u3 + h3) * (m3 << 1), m3 >>= 1)), y3 === c3) p3 += 4;
      else {
        var w3 = t2[s3 + 3 * y3], N3 = t2[s3 + 3 * y3 + 1], L3 = t2[s3 + 3 * y3 + 2];
        n3[p3++] = L3, n3[p3++] = N3, n3[p3++] = w3, n3[p3++] = 255;
      }
      --l3;
    }
  }, this.decodeAndBlitFrameRGBA = function(e3, n3) {
    var i2 = this.frameInfo(e3), a3 = i2.width * i2.height, o3 = new Uint8Array(a3);
    $t(t2, i2.data_offset, o3, a3);
    var s3 = i2.palette_offset, c3 = i2.transparent_index;
    null === c3 && (c3 = 256);
    var u3 = i2.width, h3 = r - u3, l3 = u3, f3 = 4 * (i2.y * r + i2.x), d3 = 4 * ((i2.y + i2.height) * r + i2.x), p3 = f3, g3 = 4 * h3;
    true === i2.interlaced && (g3 += 4 * r * 7);
    for (var m3 = 8, v3 = 0, b3 = o3.length; v3 < b3; ++v3) {
      var y3 = o3[v3];
      if (0 === l3 && (l3 = u3, (p3 += g3) >= d3 && (g3 = 4 * h3 + 4 * r * (m3 - 1), p3 = f3 + (u3 + h3) * (m3 << 1), m3 >>= 1)), y3 === c3) p3 += 4;
      else {
        var w3 = t2[s3 + 3 * y3], N3 = t2[s3 + 3 * y3 + 1], L3 = t2[s3 + 3 * y3 + 2];
        n3[p3++] = w3, n3[p3++] = N3, n3[p3++] = L3, n3[p3++] = 255;
      }
      --l3;
    }
  };
}
function $t(t2, e2, r, n2) {
  for (var i = t2[e2++], o2 = 1 << i, s2 = o2 + 1, c2 = s2 + 1, u2 = i + 1, h2 = (1 << u2) - 1, l2 = 0, f2 = 0, d2 = 0, p2 = t2[e2++], g2 = new Int32Array(4096), m2 = null; ; ) {
    for (; l2 < 16 && 0 !== p2; ) f2 |= t2[e2++] << l2, l2 += 8, 1 === p2 ? p2 = t2[e2++] : --p2;
    if (l2 < u2) break;
    var v2 = f2 & h2;
    if (f2 >>= u2, l2 -= u2, v2 !== o2) {
      if (v2 === s2) break;
      for (var b2 = v2 < c2 ? v2 : m2, y2 = 0, w2 = b2; w2 > o2; ) w2 = g2[w2] >> 8, ++y2;
      var N2 = w2;
      if (d2 + y2 + (b2 !== v2 ? 1 : 0) > n2) return void a$1.log("Warning, gif stream longer than expected.");
      r[d2++] = N2;
      var L2 = d2 += y2;
      for (b2 !== v2 && (r[d2++] = N2), w2 = b2; y2--; ) w2 = g2[w2], r[--L2] = 255 & w2, w2 >>= 8;
      null !== m2 && c2 < 4096 && (g2[c2++] = m2 << 8 | N2, c2 >= h2 + 1 && u2 < 12 && (++u2, h2 = h2 << 1 | 1)), m2 = v2;
    } else c2 = s2 + 1, h2 = (1 << (u2 = i + 1)) - 1, m2 = null;
  }
  return d2 !== n2 && a$1.log("Warning, gif stream shorter than expected."), r;
}
/**
 * @license
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
function Qt(t2) {
  var e2, r, n2, i, a2, o2 = Math.floor, s2 = new Array(64), c2 = new Array(64), u2 = new Array(64), h2 = new Array(64), l2 = new Array(65535), f2 = new Array(65535), d2 = new Array(64), p2 = new Array(64), g2 = [], m2 = 0, v2 = 7, b2 = new Array(64), y2 = new Array(64), w2 = new Array(64), N2 = new Array(256), L2 = new Array(2048), A2 = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], x2 = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], S2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], _2 = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], P2 = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], k2 = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], I2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], F2 = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], C2 = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
  function j2(t3, e3) {
    for (var r2 = 0, n3 = 0, i2 = new Array(), a3 = 1; a3 <= 16; a3++) {
      for (var o3 = 1; o3 <= t3[a3]; o3++) i2[e3[n3]] = [], i2[e3[n3]][0] = r2, i2[e3[n3]][1] = a3, n3++, r2++;
      r2 *= 2;
    }
    return i2;
  }
  function O2(t3) {
    for (var e3 = t3[0], r2 = t3[1] - 1; r2 >= 0; ) e3 & 1 << r2 && (m2 |= 1 << v2), r2--, --v2 < 0 && (255 == m2 ? (B3(255), B3(0)) : B3(m2), v2 = 7, m2 = 0);
  }
  function B3(t3) {
    g2.push(t3);
  }
  function M2(t3) {
    B3(t3 >> 8 & 255), B3(255 & t3);
  }
  function E2(t3, e3, r2, n3, i2) {
    for (var a3, o3 = i2[0], s3 = i2[240], c3 = function(t4, e4) {
      var r3, n4, i3, a4, o4, s4, c4, u4, h4, l3, f3 = 0;
      for (h4 = 0; h4 < 8; ++h4) {
        r3 = t4[f3], n4 = t4[f3 + 1], i3 = t4[f3 + 2], a4 = t4[f3 + 3], o4 = t4[f3 + 4], s4 = t4[f3 + 5], c4 = t4[f3 + 6];
        var p3 = r3 + (u4 = t4[f3 + 7]), g4 = r3 - u4, m4 = n4 + c4, v4 = n4 - c4, b4 = i3 + s4, y4 = i3 - s4, w4 = a4 + o4, N3 = a4 - o4, L3 = p3 + w4, A3 = p3 - w4, x3 = m4 + b4, S3 = m4 - b4;
        t4[f3] = L3 + x3, t4[f3 + 4] = L3 - x3;
        var _3 = 0.707106781 * (S3 + A3);
        t4[f3 + 2] = A3 + _3, t4[f3 + 6] = A3 - _3;
        var P3 = 0.382683433 * ((L3 = N3 + y4) - (S3 = v4 + g4)), k3 = 0.5411961 * L3 + P3, I3 = 1.306562965 * S3 + P3, F3 = 0.707106781 * (x3 = y4 + v4), C3 = g4 + F3, j3 = g4 - F3;
        t4[f3 + 5] = j3 + k3, t4[f3 + 3] = j3 - k3, t4[f3 + 1] = C3 + I3, t4[f3 + 7] = C3 - I3, f3 += 8;
      }
      for (f3 = 0, h4 = 0; h4 < 8; ++h4) {
        r3 = t4[f3], n4 = t4[f3 + 8], i3 = t4[f3 + 16], a4 = t4[f3 + 24], o4 = t4[f3 + 32], s4 = t4[f3 + 40], c4 = t4[f3 + 48];
        var O3 = r3 + (u4 = t4[f3 + 56]), B4 = r3 - u4, M3 = n4 + c4, E3 = n4 - c4, q3 = i3 + s4, D2 = i3 - s4, R2 = a4 + o4, T2 = a4 - o4, U2 = O3 + R2, z2 = O3 - R2, H4 = M3 + q3, W2 = M3 - q3;
        t4[f3] = U2 + H4, t4[f3 + 32] = U2 - H4;
        var V2 = 0.707106781 * (W2 + z2);
        t4[f3 + 16] = z2 + V2, t4[f3 + 48] = z2 - V2;
        var G2 = 0.382683433 * ((U2 = T2 + D2) - (W2 = E3 + B4)), Y2 = 0.5411961 * U2 + G2, J2 = 1.306562965 * W2 + G2, X2 = 0.707106781 * (H4 = D2 + E3), K2 = B4 + X2, Z2 = B4 - X2;
        t4[f3 + 40] = Z2 + Y2, t4[f3 + 24] = Z2 - Y2, t4[f3 + 8] = K2 + J2, t4[f3 + 56] = K2 - J2, f3++;
      }
      for (h4 = 0; h4 < 64; ++h4) l3 = t4[h4] * e4[h4], d2[h4] = l3 > 0 ? l3 + 0.5 | 0 : l3 - 0.5 | 0;
      return d2;
    }(t3, e3), u3 = 0; u3 < 64; ++u3) p2[A2[u3]] = c3[u3];
    var h3 = p2[0] - r2;
    r2 = p2[0], 0 == h3 ? O2(n3[0]) : (O2(n3[f2[a3 = 32767 + h3]]), O2(l2[a3]));
    for (var g3 = 63; g3 > 0 && 0 == p2[g3]; ) g3--;
    if (0 == g3) return O2(o3), r2;
    for (var m3, v3 = 1; v3 <= g3; ) {
      for (var b3 = v3; 0 == p2[v3] && v3 <= g3; ) ++v3;
      var y3 = v3 - b3;
      if (y3 >= 16) {
        m3 = y3 >> 4;
        for (var w3 = 1; w3 <= m3; ++w3) O2(s3);
        y3 &= 15;
      }
      a3 = 32767 + p2[v3], O2(i2[(y3 << 4) + f2[a3]]), O2(l2[a3]), v3++;
    }
    return 63 != g3 && O2(o3), r2;
  }
  function q2(t3) {
    (t3 = Math.min(Math.max(t3, 1), 100), a2 != t3) && (!function(t4) {
      for (var e3 = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], r2 = 0; r2 < 64; r2++) {
        var n3 = o2((e3[r2] * t4 + 50) / 100);
        n3 = Math.min(Math.max(n3, 1), 255), s2[A2[r2]] = n3;
      }
      for (var i2 = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], a3 = 0; a3 < 64; a3++) {
        var l3 = o2((i2[a3] * t4 + 50) / 100);
        l3 = Math.min(Math.max(l3, 1), 255), c2[A2[a3]] = l3;
      }
      for (var f3 = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], d3 = 0, p3 = 0; p3 < 8; p3++) for (var g3 = 0; g3 < 8; g3++) u2[d3] = 1 / (s2[A2[d3]] * f3[p3] * f3[g3] * 8), h2[d3] = 1 / (c2[A2[d3]] * f3[p3] * f3[g3] * 8), d3++;
    }(t3 < 50 ? Math.floor(5e3 / t3) : Math.floor(200 - 2 * t3)), a2 = t3);
  }
  this.encode = function(t3, a3) {
    a3 && q2(a3), g2 = new Array(), m2 = 0, v2 = 7, M2(65496), M2(65504), M2(16), B3(74), B3(70), B3(73), B3(70), B3(0), B3(1), B3(1), B3(0), M2(1), M2(1), B3(0), B3(0), function() {
      M2(65499), M2(132), B3(0);
      for (var t4 = 0; t4 < 64; t4++) B3(s2[t4]);
      B3(1);
      for (var e3 = 0; e3 < 64; e3++) B3(c2[e3]);
    }(), function(t4, e3) {
      M2(65472), M2(17), B3(8), M2(e3), M2(t4), B3(3), B3(1), B3(17), B3(0), B3(2), B3(17), B3(1), B3(3), B3(17), B3(1);
    }(t3.width, t3.height), function() {
      M2(65476), M2(418), B3(0);
      for (var t4 = 0; t4 < 16; t4++) B3(x2[t4 + 1]);
      for (var e3 = 0; e3 <= 11; e3++) B3(S2[e3]);
      B3(16);
      for (var r2 = 0; r2 < 16; r2++) B3(_2[r2 + 1]);
      for (var n3 = 0; n3 <= 161; n3++) B3(P2[n3]);
      B3(1);
      for (var i2 = 0; i2 < 16; i2++) B3(k2[i2 + 1]);
      for (var a4 = 0; a4 <= 11; a4++) B3(I2[a4]);
      B3(17);
      for (var o4 = 0; o4 < 16; o4++) B3(F2[o4 + 1]);
      for (var s3 = 0; s3 <= 161; s3++) B3(C2[s3]);
    }(), M2(65498), M2(12), B3(3), B3(1), B3(0), B3(2), B3(17), B3(3), B3(17), B3(0), B3(63), B3(0);
    var o3 = 0, l3 = 0, f3 = 0;
    m2 = 0, v2 = 7, this.encode.displayName = "_encode_";
    for (var d3, p3, N3, A3, j3, D2, R2, T2, U2, z2 = t3.data, H4 = t3.width, W2 = t3.height, V2 = 4 * H4, G2 = 0; G2 < W2; ) {
      for (d3 = 0; d3 < V2; ) {
        for (j3 = V2 * G2 + d3, R2 = -1, T2 = 0, U2 = 0; U2 < 64; U2++) D2 = j3 + (T2 = U2 >> 3) * V2 + (R2 = 4 * (7 & U2)), G2 + T2 >= W2 && (D2 -= V2 * (G2 + 1 + T2 - W2)), d3 + R2 >= V2 && (D2 -= d3 + R2 - V2 + 4), p3 = z2[D2++], N3 = z2[D2++], A3 = z2[D2++], b2[U2] = (L2[p3] + L2[N3 + 256 >> 0] + L2[A3 + 512 >> 0] >> 16) - 128, y2[U2] = (L2[p3 + 768 >> 0] + L2[N3 + 1024 >> 0] + L2[A3 + 1280 >> 0] >> 16) - 128, w2[U2] = (L2[p3 + 1280 >> 0] + L2[N3 + 1536 >> 0] + L2[A3 + 1792 >> 0] >> 16) - 128;
        o3 = E2(b2, u2, o3, e2, n2), l3 = E2(y2, h2, l3, r, i), f3 = E2(w2, h2, f3, r, i), d3 += 32;
      }
      G2 += 8;
    }
    if (v2 >= 0) {
      var Y2 = [];
      Y2[1] = v2 + 1, Y2[0] = (1 << v2 + 1) - 1, O2(Y2);
    }
    return M2(65497), new Uint8Array(g2);
  }, t2 = t2 || 50, function() {
    for (var t3 = String.fromCharCode, e3 = 0; e3 < 256; e3++) N2[e3] = t3(e3);
  }(), e2 = j2(x2, S2), r = j2(k2, I2), n2 = j2(_2, P2), i = j2(F2, C2), function() {
    for (var t3 = 1, e3 = 2, r2 = 1; r2 <= 15; r2++) {
      for (var n3 = t3; n3 < e3; n3++) f2[32767 + n3] = r2, l2[32767 + n3] = [], l2[32767 + n3][1] = r2, l2[32767 + n3][0] = n3;
      for (var i2 = -(e3 - 1); i2 <= -t3; i2++) f2[32767 + i2] = r2, l2[32767 + i2] = [], l2[32767 + i2][1] = r2, l2[32767 + i2][0] = e3 - 1 + i2;
      t3 <<= 1, e3 <<= 1;
    }
  }(), function() {
    for (var t3 = 0; t3 < 256; t3++) L2[t3] = 19595 * t3, L2[t3 + 256 >> 0] = 38470 * t3, L2[t3 + 512 >> 0] = 7471 * t3 + 32768, L2[t3 + 768 >> 0] = -11059 * t3, L2[t3 + 1024 >> 0] = -21709 * t3, L2[t3 + 1280 >> 0] = 32768 * t3 + 8421375, L2[t3 + 1536 >> 0] = -27439 * t3, L2[t3 + 1792 >> 0] = -5329 * t3;
  }(), q2(t2);
}
/**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function te(t2, e2) {
  if (this.pos = 0, this.buffer = t2, this.datav = new DataView(t2.buffer), this.is_with_alpha = !!e2, this.bottom_up = true, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, -1 === ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag)) throw new Error("Invalid BMP File");
  this.parseHeader(), this.parseBGR();
}
function ee(t2) {
  function e2(t3) {
    if (!t3) throw Error("assert :P");
  }
  function r(t3, e3, r2) {
    for (var n3 = 0; 4 > n3; n3++) if (t3[e3 + n3] != r2.charCodeAt(n3)) return true;
    return false;
  }
  function n2(t3, e3, r2, n3, i2) {
    for (var a3 = 0; a3 < i2; a3++) t3[e3 + a3] = r2[n3 + a3];
  }
  function i(t3, e3, r2, n3) {
    for (var i2 = 0; i2 < n3; i2++) t3[e3 + i2] = r2;
  }
  function a2(t3) {
    return new Int32Array(t3);
  }
  function o2(t3, e3) {
    for (var r2 = [], n3 = 0; n3 < t3; n3++) r2.push(new e3());
    return r2;
  }
  function s2(t3, e3) {
    var r2 = [];
    return function t4(r3, n3, i2) {
      for (var a3 = i2[n3], o3 = 0; o3 < a3 && (r3.push(i2.length > n3 + 1 ? [] : new e3()), !(i2.length < n3 + 1)); o3++) t4(r3[o3], n3 + 1, i2);
    }(r2, 0, t3), r2;
  }
  var c2 = function() {
    var t3 = this;
    function c3(t4, e3) {
      for (var r2 = 1 << e3 - 1 >>> 0; t4 & r2; ) r2 >>>= 1;
      return r2 ? (t4 & r2 - 1) + r2 : t4;
    }
    function u3(t4, r2, n3, i2, a3) {
      e2(!(i2 % n3));
      do {
        t4[r2 + (i2 -= n3)] = a3;
      } while (0 < i2);
    }
    function h3(t4, r2, n3, i2, o3) {
      if (e2(2328 >= o3), 512 >= o3) var s3 = a2(512);
      else if (null == (s3 = a2(o3))) return 0;
      return function(t5, r3, n4, i3, o4, s4) {
        var h4, f4, d4 = r3, p4 = 1 << n4, g4 = a2(16), m4 = a2(16);
        for (e2(0 != o4), e2(null != i3), e2(null != t5), e2(0 < n4), f4 = 0; f4 < o4; ++f4) {
          if (15 < i3[f4]) return 0;
          ++g4[i3[f4]];
        }
        if (g4[0] == o4) return 0;
        for (m4[1] = 0, h4 = 1; 15 > h4; ++h4) {
          if (g4[h4] > 1 << h4) return 0;
          m4[h4 + 1] = m4[h4] + g4[h4];
        }
        for (f4 = 0; f4 < o4; ++f4) h4 = i3[f4], 0 < i3[f4] && (s4[m4[h4]++] = f4);
        if (1 == m4[15]) return (i3 = new l3()).g = 0, i3.value = s4[0], u3(t5, d4, 1, p4, i3), p4;
        var v4, b4 = -1, y4 = p4 - 1, w4 = 0, N4 = 1, L4 = 1, A4 = 1 << n4;
        for (f4 = 0, h4 = 1, o4 = 2; h4 <= n4; ++h4, o4 <<= 1) {
          if (N4 += L4 <<= 1, 0 > (L4 -= g4[h4])) return 0;
          for (; 0 < g4[h4]; --g4[h4]) (i3 = new l3()).g = h4, i3.value = s4[f4++], u3(t5, d4 + w4, o4, A4, i3), w4 = c3(w4, h4);
        }
        for (h4 = n4 + 1, o4 = 2; 15 >= h4; ++h4, o4 <<= 1) {
          if (N4 += L4 <<= 1, 0 > (L4 -= g4[h4])) return 0;
          for (; 0 < g4[h4]; --g4[h4]) {
            if (i3 = new l3(), (w4 & y4) != b4) {
              for (d4 += A4, v4 = 1 << (b4 = h4) - n4; 15 > b4 && !(0 >= (v4 -= g4[b4])); ) ++b4, v4 <<= 1;
              p4 += A4 = 1 << (v4 = b4 - n4), t5[r3 + (b4 = w4 & y4)].g = v4 + n4, t5[r3 + b4].value = d4 - r3 - b4;
            }
            i3.g = h4 - n4, i3.value = s4[f4++], u3(t5, d4 + (w4 >> n4), o4, A4, i3), w4 = c3(w4, h4);
          }
        }
        return N4 != 2 * m4[15] - 1 ? 0 : p4;
      }(t4, r2, n3, i2, o3, s3);
    }
    function l3() {
      this.value = this.g = 0;
    }
    function f3() {
      this.value = this.g = 0;
    }
    function d3() {
      this.G = o2(5, l3), this.H = a2(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = o2(Dr, f3);
    }
    function p3(t4, r2, n3, i2) {
      e2(null != t4), e2(null != r2), e2(2147483648 > i2), t4.Ca = 254, t4.I = 0, t4.b = -8, t4.Ka = 0, t4.oa = r2, t4.pa = n3, t4.Jd = r2, t4.Yc = n3 + i2, t4.Zc = 4 <= i2 ? n3 + i2 - 4 + 1 : n3, _2(t4);
    }
    function g3(t4, e3) {
      for (var r2 = 0; 0 < e3--; ) r2 |= k2(t4, 128) << e3;
      return r2;
    }
    function m3(t4, e3) {
      var r2 = g3(t4, e3);
      return P2(t4) ? -r2 : r2;
    }
    function v3(t4, r2, n3, i2) {
      var a3, o3 = 0;
      for (e2(null != t4), e2(null != r2), e2(4294967288 > i2), t4.Sb = i2, t4.Ra = 0, t4.u = 0, t4.h = 0, 4 < i2 && (i2 = 4), a3 = 0; a3 < i2; ++a3) o3 += r2[n3 + a3] << 8 * a3;
      t4.Ra = o3, t4.bb = i2, t4.oa = r2, t4.pa = n3;
    }
    function b3(t4) {
      for (; 8 <= t4.u && t4.bb < t4.Sb; ) t4.Ra >>>= 8, t4.Ra += t4.oa[t4.pa + t4.bb] << Ur - 8 >>> 0, ++t4.bb, t4.u -= 8;
      A3(t4) && (t4.h = 1, t4.u = 0);
    }
    function y3(t4, r2) {
      if (e2(0 <= r2), !t4.h && r2 <= Tr) {
        var n3 = L3(t4) & Rr[r2];
        return t4.u += r2, b3(t4), n3;
      }
      return t4.h = 1, t4.u = 0;
    }
    function w3() {
      this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;
    }
    function N3() {
      this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;
    }
    function L3(t4) {
      return t4.Ra >>> (t4.u & Ur - 1) >>> 0;
    }
    function A3(t4) {
      return e2(t4.bb <= t4.Sb), t4.h || t4.bb == t4.Sb && t4.u > Ur;
    }
    function x2(t4, e3) {
      t4.u = e3, t4.h = A3(t4);
    }
    function S2(t4) {
      t4.u >= zr && (e2(t4.u >= zr), b3(t4));
    }
    function _2(t4) {
      e2(null != t4 && null != t4.oa), t4.pa < t4.Zc ? (t4.I = (t4.oa[t4.pa++] | t4.I << 8) >>> 0, t4.b += 8) : (e2(null != t4 && null != t4.oa), t4.pa < t4.Yc ? (t4.b += 8, t4.I = t4.oa[t4.pa++] | t4.I << 8) : t4.Ka ? t4.b = 0 : (t4.I <<= 8, t4.b += 8, t4.Ka = 1));
    }
    function P2(t4) {
      return g3(t4, 1);
    }
    function k2(t4, e3) {
      var r2 = t4.Ca;
      0 > t4.b && _2(t4);
      var n3 = t4.b, i2 = r2 * e3 >>> 8, a3 = (t4.I >>> n3 > i2) + 0;
      for (a3 ? (r2 -= i2, t4.I -= i2 + 1 << n3 >>> 0) : r2 = i2 + 1, n3 = r2, i2 = 0; 256 <= n3; ) i2 += 8, n3 >>= 8;
      return n3 = 7 ^ i2 + Hr[n3], t4.b -= n3, t4.Ca = (r2 << n3) - 1, a3;
    }
    function I2(t4, e3, r2) {
      t4[e3 + 0] = r2 >> 24 & 255, t4[e3 + 1] = r2 >> 16 & 255, t4[e3 + 2] = r2 >> 8 & 255, t4[e3 + 3] = r2 >> 0 & 255;
    }
    function F2(t4, e3) {
      return t4[e3 + 0] << 0 | t4[e3 + 1] << 8;
    }
    function C2(t4, e3) {
      return F2(t4, e3) | t4[e3 + 2] << 16;
    }
    function j2(t4, e3) {
      return F2(t4, e3) | F2(t4, e3 + 2) << 16;
    }
    function O2(t4, r2) {
      var n3 = 1 << r2;
      return e2(null != t4), e2(0 < r2), t4.X = a2(n3), null == t4.X ? 0 : (t4.Mb = 32 - r2, t4.Xa = r2, 1);
    }
    function B3(t4, r2) {
      e2(null != t4), e2(null != r2), e2(t4.Xa == r2.Xa), n2(r2.X, 0, t4.X, 0, 1 << r2.Xa);
    }
    function M2() {
      this.X = [], this.Xa = this.Mb = 0;
    }
    function E2(t4, r2, n3, i2) {
      e2(null != n3), e2(null != i2);
      var a3 = n3[0], o3 = i2[0];
      return 0 == a3 && (a3 = (t4 * o3 + r2 / 2) / r2), 0 == o3 && (o3 = (r2 * a3 + t4 / 2) / t4), 0 >= a3 || 0 >= o3 ? 0 : (n3[0] = a3, i2[0] = o3, 1);
    }
    function q2(t4, e3) {
      return t4 + (1 << e3) - 1 >>> e3;
    }
    function D2(t4, e3) {
      return ((4278255360 & t4) + (4278255360 & e3) >>> 0 & 4278255360) + ((16711935 & t4) + (16711935 & e3) >>> 0 & 16711935) >>> 0;
    }
    function R2(e3, r2) {
      t3[r2] = function(r3, n3, i2, a3, o3, s3, c4) {
        var u4;
        for (u4 = 0; u4 < o3; ++u4) {
          var h4 = t3[e3](s3[c4 + u4 - 1], i2, a3 + u4);
          s3[c4 + u4] = D2(r3[n3 + u4], h4);
        }
      };
    }
    function T2() {
      this.ud = this.hd = this.jd = 0;
    }
    function U2(t4, e3) {
      return ((4278124286 & (t4 ^ e3)) >>> 1) + (t4 & e3) >>> 0;
    }
    function z2(t4) {
      return 0 <= t4 && 256 > t4 ? t4 : 0 > t4 ? 0 : 255 < t4 ? 255 : void 0;
    }
    function H4(t4, e3) {
      return z2(t4 + (t4 - e3 + 0.5 >> 1));
    }
    function W2(t4, e3, r2) {
      return Math.abs(e3 - r2) - Math.abs(t4 - r2);
    }
    function V2(t4, e3, r2, n3, i2, a3, o3) {
      for (n3 = a3[o3 - 1], r2 = 0; r2 < i2; ++r2) a3[o3 + r2] = n3 = D2(t4[e3 + r2], n3);
    }
    function G2(t4, e3, r2, n3, i2) {
      var a3;
      for (a3 = 0; a3 < r2; ++a3) {
        var o3 = t4[e3 + a3], s3 = o3 >> 8 & 255, c4 = 16711935 & (c4 = (c4 = 16711935 & o3) + ((s3 << 16) + s3));
        n3[i2 + a3] = (4278255360 & o3) + c4 >>> 0;
      }
    }
    function Y2(t4, e3) {
      e3.jd = t4 >> 0 & 255, e3.hd = t4 >> 8 & 255, e3.ud = t4 >> 16 & 255;
    }
    function J2(t4, e3, r2, n3, i2, a3) {
      var o3;
      for (o3 = 0; o3 < n3; ++o3) {
        var s3 = e3[r2 + o3], c4 = s3 >>> 8, u4 = s3, h4 = 255 & (h4 = (h4 = s3 >>> 16) + ((t4.jd << 24 >> 24) * (c4 << 24 >> 24) >>> 5));
        u4 = 255 & (u4 = (u4 = u4 + ((t4.hd << 24 >> 24) * (c4 << 24 >> 24) >>> 5)) + ((t4.ud << 24 >> 24) * (h4 << 24 >> 24) >>> 5));
        i2[a3 + o3] = (4278255360 & s3) + (h4 << 16) + u4;
      }
    }
    function X2(e3, r2, n3, i2, a3) {
      t3[r2] = function(t4, e4, r3, n4, o3, s3, c4, u4, h4) {
        for (n4 = c4; n4 < u4; ++n4) for (c4 = 0; c4 < h4; ++c4) o3[s3++] = a3(r3[i2(t4[e4++])]);
      }, t3[e3] = function(e4, r3, o3, s3, c4, u4, h4) {
        var l4 = 8 >> e4.b, f4 = e4.Ea, d4 = e4.K[0], p4 = e4.w;
        if (8 > l4) for (e4 = (1 << e4.b) - 1, p4 = (1 << l4) - 1; r3 < o3; ++r3) {
          var g4, m4 = 0;
          for (g4 = 0; g4 < f4; ++g4) g4 & e4 || (m4 = i2(s3[c4++])), u4[h4++] = a3(d4[m4 & p4]), m4 >>= l4;
        }
        else t3["VP8LMapColor" + n3](s3, c4, d4, p4, u4, h4, r3, o3, f4);
      };
    }
    function K2(t4, e3, r2, n3, i2) {
      for (r2 = e3 + r2; e3 < r2; ) {
        var a3 = t4[e3++];
        n3[i2++] = a3 >> 16 & 255, n3[i2++] = a3 >> 8 & 255, n3[i2++] = a3 >> 0 & 255;
      }
    }
    function Z2(t4, e3, r2, n3, i2) {
      for (r2 = e3 + r2; e3 < r2; ) {
        var a3 = t4[e3++];
        n3[i2++] = a3 >> 16 & 255, n3[i2++] = a3 >> 8 & 255, n3[i2++] = a3 >> 0 & 255, n3[i2++] = a3 >> 24 & 255;
      }
    }
    function $2(t4, e3, r2, n3, i2) {
      for (r2 = e3 + r2; e3 < r2; ) {
        var a3 = (o3 = t4[e3++]) >> 16 & 240 | o3 >> 12 & 15, o3 = o3 >> 0 & 240 | o3 >> 28 & 15;
        n3[i2++] = a3, n3[i2++] = o3;
      }
    }
    function Q2(t4, e3, r2, n3, i2) {
      for (r2 = e3 + r2; e3 < r2; ) {
        var a3 = (o3 = t4[e3++]) >> 16 & 248 | o3 >> 13 & 7, o3 = o3 >> 5 & 224 | o3 >> 3 & 31;
        n3[i2++] = a3, n3[i2++] = o3;
      }
    }
    function tt2(t4, e3, r2, n3, i2) {
      for (r2 = e3 + r2; e3 < r2; ) {
        var a3 = t4[e3++];
        n3[i2++] = a3 >> 0 & 255, n3[i2++] = a3 >> 8 & 255, n3[i2++] = a3 >> 16 & 255;
      }
    }
    function et2(t4, e3, r2, i2, a3, o3) {
      if (0 == o3) for (r2 = e3 + r2; e3 < r2; ) I2(i2, ((o3 = t4[e3++])[0] >> 24 | o3[1] >> 8 & 65280 | o3[2] << 8 & 16711680 | o3[3] << 24) >>> 0), a3 += 32;
      else n2(i2, a3, t4, e3, r2);
    }
    function rt2(e3, r2) {
      t3[r2][0] = t3[e3 + "0"], t3[r2][1] = t3[e3 + "1"], t3[r2][2] = t3[e3 + "2"], t3[r2][3] = t3[e3 + "3"], t3[r2][4] = t3[e3 + "4"], t3[r2][5] = t3[e3 + "5"], t3[r2][6] = t3[e3 + "6"], t3[r2][7] = t3[e3 + "7"], t3[r2][8] = t3[e3 + "8"], t3[r2][9] = t3[e3 + "9"], t3[r2][10] = t3[e3 + "10"], t3[r2][11] = t3[e3 + "11"], t3[r2][12] = t3[e3 + "12"], t3[r2][13] = t3[e3 + "13"], t3[r2][14] = t3[e3 + "0"], t3[r2][15] = t3[e3 + "0"];
    }
    function nt2(t4) {
      return t4 == Hn || t4 == Wn || t4 == Vn || t4 == Gn;
    }
    function it2() {
      this.eb = [], this.size = this.A = this.fb = 0;
    }
    function at2() {
      this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
    }
    function ot2() {
      this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new it2(), this.f.kb = new at2(), this.sd = null;
    }
    function st2() {
      this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0];
    }
    function ct2() {
      this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
    }
    function ut2(t4) {
      return alert("todo:WebPSamplerProcessPlane"), t4.T;
    }
    function ht2(t4, e3) {
      var r2 = t4.T, i2 = e3.ba.f.RGBA, a3 = i2.eb, o3 = i2.fb + t4.ka * i2.A, s3 = vi[e3.ba.S], c4 = t4.y, u4 = t4.O, h4 = t4.f, l4 = t4.N, f4 = t4.ea, d4 = t4.W, p4 = e3.cc, g4 = e3.dc, m4 = e3.Mc, v4 = e3.Nc, b4 = t4.ka, y4 = t4.ka + t4.T, w4 = t4.U, N4 = w4 + 1 >> 1;
      for (0 == b4 ? s3(c4, u4, null, null, h4, l4, f4, d4, h4, l4, f4, d4, a3, o3, null, null, w4) : (s3(e3.ec, e3.fc, c4, u4, p4, g4, m4, v4, h4, l4, f4, d4, a3, o3 - i2.A, a3, o3, w4), ++r2); b4 + 2 < y4; b4 += 2) p4 = h4, g4 = l4, m4 = f4, v4 = d4, l4 += t4.Rc, d4 += t4.Rc, o3 += 2 * i2.A, s3(c4, (u4 += 2 * t4.fa) - t4.fa, c4, u4, p4, g4, m4, v4, h4, l4, f4, d4, a3, o3 - i2.A, a3, o3, w4);
      return u4 += t4.fa, t4.j + y4 < t4.o ? (n2(e3.ec, e3.fc, c4, u4, w4), n2(e3.cc, e3.dc, h4, l4, N4), n2(e3.Mc, e3.Nc, f4, d4, N4), r2--) : 1 & y4 || s3(c4, u4, null, null, h4, l4, f4, d4, h4, l4, f4, d4, a3, o3 + i2.A, null, null, w4), r2;
    }
    function lt2(t4, r2, n3) {
      var i2 = t4.F, a3 = [t4.J];
      if (null != i2) {
        var o3 = t4.U, s3 = r2.ba.S, c4 = s3 == Tn || s3 == Vn;
        r2 = r2.ba.f.RGBA;
        var u4 = [0], h4 = t4.ka;
        u4[0] = t4.T, t4.Kb && (0 == h4 ? --u4[0] : (--h4, a3[0] -= t4.width), t4.j + t4.ka + t4.T == t4.o && (u4[0] = t4.o - t4.j - h4));
        var l4 = r2.eb;
        h4 = r2.fb + h4 * r2.A;
        t4 = Sn(i2, a3[0], t4.width, o3, u4, l4, h4 + (c4 ? 0 : 3), r2.A), e2(n3 == u4), t4 && nt2(s3) && An(l4, h4, c4, o3, u4, r2.A);
      }
      return 0;
    }
    function ft2(t4) {
      var e3 = t4.ma, r2 = e3.ba.S, n3 = 11 > r2, i2 = r2 == qn || r2 == Rn || r2 == Tn || r2 == Un || 12 == r2 || nt2(r2);
      if (e3.memory = null, e3.Ib = null, e3.Jb = null, e3.Nd = null, !Mr(e3.Oa, t4, i2 ? 11 : 12)) return 0;
      if (i2 && nt2(r2) && br(), t4.da) alert("todo:use_scaling");
      else {
        if (n3) {
          if (e3.Ib = ut2, t4.Kb) {
            if (r2 = t4.U + 1 >> 1, e3.memory = a2(t4.U + 2 * r2), null == e3.memory) return 0;
            e3.ec = e3.memory, e3.fc = 0, e3.cc = e3.ec, e3.dc = e3.fc + t4.U, e3.Mc = e3.cc, e3.Nc = e3.dc + r2, e3.Ib = ht2, br();
          }
        } else alert("todo:EmitYUV");
        i2 && (e3.Jb = lt2, n3 && mr());
      }
      if (n3 && !Ci) {
        for (t4 = 0; 256 > t4; ++t4) ji[t4] = 89858 * (t4 - 128) + _i >> Si, Mi[t4] = -22014 * (t4 - 128) + _i, Bi[t4] = -45773 * (t4 - 128), Oi[t4] = 113618 * (t4 - 128) + _i >> Si;
        for (t4 = Pi; t4 < ki; ++t4) e3 = 76283 * (t4 - 16) + _i >> Si, Ei[t4 - Pi] = Vt2(e3, 255), qi[t4 - Pi] = Vt2(e3 + 8 >> 4, 15);
        Ci = 1;
      }
      return 1;
    }
    function dt2(t4) {
      var r2 = t4.ma, n3 = t4.U, i2 = t4.T;
      return e2(!(1 & t4.ka)), 0 >= n3 || 0 >= i2 ? 0 : (n3 = r2.Ib(t4, r2), null != r2.Jb && r2.Jb(t4, r2, n3), r2.Dc += n3, 1);
    }
    function pt2(t4) {
      t4.ma.memory = null;
    }
    function gt2(t4, e3, r2, n3) {
      return 47 != y3(t4, 8) ? 0 : (e3[0] = y3(t4, 14) + 1, r2[0] = y3(t4, 14) + 1, n3[0] = y3(t4, 1), 0 != y3(t4, 3) ? 0 : !t4.h);
    }
    function mt2(t4, e3) {
      if (4 > t4) return t4 + 1;
      var r2 = t4 - 2 >> 1;
      return (2 + (1 & t4) << r2) + y3(e3, r2) + 1;
    }
    function vt2(t4, e3) {
      return 120 < e3 ? e3 - 120 : 1 <= (r2 = ((r2 = $n[e3 - 1]) >> 4) * t4 + (8 - (15 & r2))) ? r2 : 1;
      var r2;
    }
    function bt2(t4, e3, r2) {
      var n3 = L3(r2), i2 = t4[e3 += 255 & n3].g - 8;
      return 0 < i2 && (x2(r2, r2.u + 8), n3 = L3(r2), e3 += t4[e3].value, e3 += n3 & (1 << i2) - 1), x2(r2, r2.u + t4[e3].g), t4[e3].value;
    }
    function yt2(t4, r2, n3) {
      return n3.g += t4.g, n3.value += t4.value << r2 >>> 0, e2(8 >= n3.g), t4.g;
    }
    function wt2(t4, r2, n3) {
      var i2 = t4.xc;
      return e2((r2 = 0 == i2 ? 0 : t4.vc[t4.md * (n3 >> i2) + (r2 >> i2)]) < t4.Wb), t4.Ya[r2];
    }
    function Nt2(t4, r2, i2, a3) {
      var o3 = t4.ab, s3 = t4.c * r2, c4 = t4.C;
      r2 = c4 + r2;
      var u4 = i2, h4 = a3;
      for (a3 = t4.Ta, i2 = t4.Ua; 0 < o3--; ) {
        var l4 = t4.gc[o3], f4 = c4, d4 = r2, p4 = u4, g4 = h4, m4 = (h4 = a3, u4 = i2, l4.Ea);
        switch (e2(f4 < d4), e2(d4 <= l4.nc), l4.hc) {
          case 2:
            Gr(p4, g4, (d4 - f4) * m4, h4, u4);
            break;
          case 0:
            var v4 = f4, b4 = d4, y4 = h4, w4 = u4, N4 = (_3 = l4).Ea;
            0 == v4 && (Wr(p4, g4, null, null, 1, y4, w4), V2(p4, g4 + 1, 0, 0, N4 - 1, y4, w4 + 1), g4 += N4, w4 += N4, ++v4);
            for (var L4 = 1 << _3.b, A4 = L4 - 1, x3 = q2(N4, _3.b), S3 = _3.K, _3 = _3.w + (v4 >> _3.b) * x3; v4 < b4; ) {
              var P3 = S3, k3 = _3, I3 = 1;
              for (Vr(p4, g4, y4, w4 - N4, 1, y4, w4); I3 < N4; ) {
                var F3 = (I3 & ~A4) + L4;
                F3 > N4 && (F3 = N4), (0, Zr[P3[k3++] >> 8 & 15])(p4, g4 + +I3, y4, w4 + I3 - N4, F3 - I3, y4, w4 + I3), I3 = F3;
              }
              g4 += N4, w4 += N4, ++v4 & A4 || (_3 += x3);
            }
            d4 != l4.nc && n2(h4, u4 - m4, h4, u4 + (d4 - f4 - 1) * m4, m4);
            break;
          case 1:
            for (m4 = p4, b4 = g4, N4 = (p4 = l4.Ea) - (w4 = p4 & ~(y4 = (g4 = 1 << l4.b) - 1)), v4 = q2(p4, l4.b), L4 = l4.K, l4 = l4.w + (f4 >> l4.b) * v4; f4 < d4; ) {
              for (A4 = L4, x3 = l4, S3 = new T2(), _3 = b4 + w4, P3 = b4 + p4; b4 < _3; ) Y2(A4[x3++], S3), $r(S3, m4, b4, g4, h4, u4), b4 += g4, u4 += g4;
              b4 < P3 && (Y2(A4[x3++], S3), $r(S3, m4, b4, N4, h4, u4), b4 += N4, u4 += N4), ++f4 & y4 || (l4 += v4);
            }
            break;
          case 3:
            if (p4 == h4 && g4 == u4 && 0 < l4.b) {
              for (b4 = h4, p4 = m4 = u4 + (d4 - f4) * m4 - (w4 = (d4 - f4) * q2(l4.Ea, l4.b)), g4 = h4, y4 = u4, v4 = [], w4 = (N4 = w4) - 1; 0 <= w4; --w4) v4[w4] = g4[y4 + w4];
              for (w4 = N4 - 1; 0 <= w4; --w4) b4[p4 + w4] = v4[w4];
              Yr(l4, f4, d4, h4, m4, h4, u4);
            } else Yr(l4, f4, d4, p4, g4, h4, u4);
        }
        u4 = a3, h4 = i2;
      }
      h4 != i2 && n2(a3, i2, u4, h4, s3);
    }
    function Lt2(t4, r2) {
      var n3 = t4.V, i2 = t4.Ba + t4.c * t4.C, a3 = r2 - t4.C;
      if (e2(r2 <= t4.l.o), e2(16 >= a3), 0 < a3) {
        var o3 = t4.l, s3 = t4.Ta, c4 = t4.Ua, u4 = o3.width;
        if (Nt2(t4, a3, n3, i2), a3 = c4 = [c4], e2((n3 = t4.C) < (i2 = r2)), e2(o3.v < o3.va), i2 > o3.o && (i2 = o3.o), n3 < o3.j) {
          var h4 = o3.j - n3;
          n3 = o3.j;
          a3[0] += h4 * u4;
        }
        if (n3 >= i2 ? n3 = 0 : (a3[0] += 4 * o3.v, o3.ka = n3 - o3.j, o3.U = o3.va - o3.v, o3.T = i2 - n3, n3 = 1), n3) {
          if (c4 = c4[0], 11 > (n3 = t4.ca).S) {
            var l4 = n3.f.RGBA, f4 = (i2 = n3.S, a3 = o3.U, o3 = o3.T, h4 = l4.eb, l4.A), d4 = o3;
            for (l4 = l4.fb + t4.Ma * l4.A; 0 < d4--; ) {
              var p4 = s3, g4 = c4, m4 = a3, v4 = h4, b4 = l4;
              switch (i2) {
                case En:
                  Qr(p4, g4, m4, v4, b4);
                  break;
                case qn:
                  tn(p4, g4, m4, v4, b4);
                  break;
                case Hn:
                  tn(p4, g4, m4, v4, b4), An(v4, b4, 0, m4, 1, 0);
                  break;
                case Dn:
                  nn(p4, g4, m4, v4, b4);
                  break;
                case Rn:
                  et2(p4, g4, m4, v4, b4, 1);
                  break;
                case Wn:
                  et2(p4, g4, m4, v4, b4, 1), An(v4, b4, 0, m4, 1, 0);
                  break;
                case Tn:
                  et2(p4, g4, m4, v4, b4, 0);
                  break;
                case Vn:
                  et2(p4, g4, m4, v4, b4, 0), An(v4, b4, 1, m4, 1, 0);
                  break;
                case Un:
                  en(p4, g4, m4, v4, b4);
                  break;
                case Gn:
                  en(p4, g4, m4, v4, b4), xn(v4, b4, m4, 1, 0);
                  break;
                case zn:
                  rn(p4, g4, m4, v4, b4);
                  break;
                default:
                  e2(0);
              }
              c4 += u4, l4 += f4;
            }
            t4.Ma += o3;
          } else alert("todo:EmitRescaledRowsYUVA");
          e2(t4.Ma <= n3.height);
        }
      }
      t4.C = r2, e2(t4.C <= t4.i);
    }
    function At2(t4) {
      var e3;
      if (0 < t4.ua) return 0;
      for (e3 = 0; e3 < t4.Wb; ++e3) {
        var r2 = t4.Ya[e3].G, n3 = t4.Ya[e3].H;
        if (0 < r2[1][n3[1] + 0].g || 0 < r2[2][n3[2] + 0].g || 0 < r2[3][n3[3] + 0].g) return 0;
      }
      return 1;
    }
    function xt2(t4, r2, n3, i2, a3, o3) {
      if (0 != t4.Z) {
        var s3 = t4.qd, c4 = t4.rd;
        for (e2(null != mi[t4.Z]); r2 < n3; ++r2) mi[t4.Z](s3, c4, i2, a3, i2, a3, o3), s3 = i2, c4 = a3, a3 += o3;
        t4.qd = s3, t4.rd = c4;
      }
    }
    function St(t4, r2) {
      var n3 = t4.l.ma, i2 = 0 == n3.Z || 1 == n3.Z ? t4.l.j : t4.C;
      i2 = t4.C < i2 ? i2 : t4.C;
      if (e2(r2 <= t4.l.o), r2 > i2) {
        var a3 = t4.l.width, o3 = n3.ca, s3 = n3.tb + a3 * i2, c4 = t4.V, u4 = t4.Ba + t4.c * i2, h4 = t4.gc;
        e2(1 == t4.ab), e2(3 == h4[0].hc), Xr(h4[0], i2, r2, c4, u4, o3, s3), xt2(n3, i2, r2, o3, s3, a3);
      }
      t4.C = t4.Ma = r2;
    }
    function _t2(t4, r2, n3, i2, a3, o3, s3) {
      var c4 = t4.$ / i2, u4 = t4.$ % i2, h4 = t4.m, l4 = t4.s, f4 = n3 + t4.$, d4 = f4;
      a3 = n3 + i2 * a3;
      var p4 = n3 + i2 * o3, g4 = 280 + l4.ua, m4 = t4.Pb ? c4 : 16777216, v4 = 0 < l4.ua ? l4.Wa : null, b4 = l4.wc, y4 = f4 < p4 ? wt2(l4, u4, c4) : null;
      e2(t4.C < o3), e2(p4 <= a3);
      var w4 = false;
      t: for (; ; ) {
        for (; w4 || f4 < p4; ) {
          var N4 = 0;
          if (c4 >= m4) {
            var _3 = f4 - n3;
            e2((m4 = t4).Pb), m4.wd = m4.m, m4.xd = _3, 0 < m4.s.ua && B3(m4.s.Wa, m4.s.vb), m4 = c4 + ti2;
          }
          if (u4 & b4 || (y4 = wt2(l4, u4, c4)), e2(null != y4), y4.Qb && (r2[f4] = y4.qb, w4 = true), !w4) if (S2(h4), y4.jc) {
            N4 = h4, _3 = r2;
            var P3 = f4, k3 = y4.pd[L3(N4) & Dr - 1];
            e2(y4.jc), 256 > k3.g ? (x2(N4, N4.u + k3.g), _3[P3] = k3.value, N4 = 0) : (x2(N4, N4.u + k3.g - 256), e2(256 <= k3.value), N4 = k3.value), 0 == N4 && (w4 = true);
          } else N4 = bt2(y4.G[0], y4.H[0], h4);
          if (h4.h) break;
          if (w4 || 256 > N4) {
            if (!w4) if (y4.nd) r2[f4] = (y4.qb | N4 << 8) >>> 0;
            else {
              if (S2(h4), w4 = bt2(y4.G[1], y4.H[1], h4), S2(h4), _3 = bt2(y4.G[2], y4.H[2], h4), P3 = bt2(y4.G[3], y4.H[3], h4), h4.h) break;
              r2[f4] = (P3 << 24 | w4 << 16 | N4 << 8 | _3) >>> 0;
            }
            if (w4 = false, ++f4, ++u4 >= i2 && (u4 = 0, ++c4, null != s3 && c4 <= o3 && !(c4 % 16) && s3(t4, c4), null != v4)) for (; d4 < f4; ) N4 = r2[d4++], v4.X[(506832829 * N4 & 4294967295) >>> v4.Mb] = N4;
          } else if (280 > N4) {
            if (N4 = mt2(N4 - 256, h4), _3 = bt2(y4.G[4], y4.H[4], h4), S2(h4), _3 = vt2(i2, _3 = mt2(_3, h4)), h4.h) break;
            if (f4 - n3 < _3 || a3 - f4 < N4) break t;
            for (P3 = 0; P3 < N4; ++P3) r2[f4 + P3] = r2[f4 + P3 - _3];
            for (f4 += N4, u4 += N4; u4 >= i2; ) u4 -= i2, ++c4, null != s3 && c4 <= o3 && !(c4 % 16) && s3(t4, c4);
            if (e2(f4 <= a3), u4 & b4 && (y4 = wt2(l4, u4, c4)), null != v4) for (; d4 < f4; ) N4 = r2[d4++], v4.X[(506832829 * N4 & 4294967295) >>> v4.Mb] = N4;
          } else {
            if (!(N4 < g4)) break t;
            for (w4 = N4 - 280, e2(null != v4); d4 < f4; ) N4 = r2[d4++], v4.X[(506832829 * N4 & 4294967295) >>> v4.Mb] = N4;
            N4 = f4, e2(!(w4 >>> (_3 = v4).Xa)), r2[N4] = _3.X[w4], w4 = true;
          }
          w4 || e2(h4.h == A3(h4));
        }
        if (t4.Pb && h4.h && f4 < a3) e2(t4.m.h), t4.a = 5, t4.m = t4.wd, t4.$ = t4.xd, 0 < t4.s.ua && B3(t4.s.vb, t4.s.Wa);
        else {
          if (h4.h) break t;
          null != s3 && s3(t4, c4 > o3 ? o3 : c4), t4.a = 0, t4.$ = f4 - n3;
        }
        return 1;
      }
      return t4.a = 3, 0;
    }
    function Pt2(t4) {
      e2(null != t4), t4.vc = null, t4.yc = null, t4.Ya = null;
      var r2 = t4.Wa;
      null != r2 && (r2.X = null), t4.vb = null, e2(null != t4);
    }
    function kt2() {
      var e3 = new or();
      return null == e3 ? null : (e3.a = 0, e3.xb = gi, rt2("Predictor", "VP8LPredictors"), rt2("Predictor", "VP8LPredictors_C"), rt2("PredictorAdd", "VP8LPredictorsAdd"), rt2("PredictorAdd", "VP8LPredictorsAdd_C"), Gr = G2, $r = J2, Qr = K2, tn = Z2, en = $2, rn = Q2, nn = tt2, t3.VP8LMapColor32b = Jr, t3.VP8LMapColor8b = Kr, e3);
    }
    function It2(t4, r2, n3, s3, c4) {
      var u4 = 1, f4 = [t4], p4 = [r2], g4 = s3.m, m4 = s3.s, v4 = null, b4 = 0;
      t: for (; ; ) {
        if (n3) for (; u4 && y3(g4, 1); ) {
          var w4 = f4, N4 = p4, A4 = s3, _3 = 1, P3 = A4.m, k3 = A4.gc[A4.ab], I3 = y3(P3, 2);
          if (A4.Oc & 1 << I3) u4 = 0;
          else {
            switch (A4.Oc |= 1 << I3, k3.hc = I3, k3.Ea = w4[0], k3.nc = N4[0], k3.K = [null], ++A4.ab, e2(4 >= A4.ab), I3) {
              case 0:
              case 1:
                k3.b = y3(P3, 3) + 2, _3 = It2(q2(k3.Ea, k3.b), q2(k3.nc, k3.b), 0, A4, k3.K), k3.K = k3.K[0];
                break;
              case 3:
                var F3, C3 = y3(P3, 8) + 1, j3 = 16 < C3 ? 0 : 4 < C3 ? 1 : 2 < C3 ? 2 : 3;
                if (w4[0] = q2(k3.Ea, j3), k3.b = j3, F3 = _3 = It2(C3, 1, 0, A4, k3.K)) {
                  var B4, M3 = C3, E3 = k3, R3 = 1 << (8 >> E3.b), T3 = a2(R3);
                  if (null == T3) F3 = 0;
                  else {
                    var U3 = E3.K[0], z3 = E3.w;
                    for (T3[0] = E3.K[0][0], B4 = 1; B4 < 1 * M3; ++B4) T3[B4] = D2(U3[z3 + B4], T3[B4 - 1]);
                    for (; B4 < 4 * R3; ++B4) T3[B4] = 0;
                    E3.K[0] = null, E3.K[0] = T3, F3 = 1;
                  }
                }
                _3 = F3;
                break;
              case 2:
                break;
              default:
                e2(0);
            }
            u4 = _3;
          }
        }
        if (f4 = f4[0], p4 = p4[0], u4 && y3(g4, 1) && !(u4 = 1 <= (b4 = y3(g4, 4)) && 11 >= b4)) {
          s3.a = 3;
          break t;
        }
        var H5;
        if (H5 = u4) e: {
          var W3, V3, G3, Y3 = s3, J3 = f4, X3 = p4, K3 = b4, Z3 = n3, $3 = Y3.m, Q3 = Y3.s, tt3 = [null], et3 = 1, rt3 = 0, nt3 = Qn[K3];
          r: for (; ; ) {
            if (Z3 && y3($3, 1)) {
              var it3 = y3($3, 3) + 2, at3 = q2(J3, it3), ot3 = q2(X3, it3), st3 = at3 * ot3;
              if (!It2(at3, ot3, 0, Y3, tt3)) break r;
              for (tt3 = tt3[0], Q3.xc = it3, W3 = 0; W3 < st3; ++W3) {
                var ct3 = tt3[W3] >> 8 & 65535;
                tt3[W3] = ct3, ct3 >= et3 && (et3 = ct3 + 1);
              }
            }
            if ($3.h) break r;
            for (V3 = 0; 5 > V3; ++V3) {
              var ut3 = Xn[V3];
              !V3 && 0 < K3 && (ut3 += 1 << K3), rt3 < ut3 && (rt3 = ut3);
            }
            var ht3 = o2(et3 * nt3, l3), lt3 = et3, ft3 = o2(lt3, d3);
            if (null == ft3) var dt3 = null;
            else e2(65536 >= lt3), dt3 = ft3;
            var pt3 = a2(rt3);
            if (null == dt3 || null == pt3 || null == ht3) {
              Y3.a = 1;
              break r;
            }
            var gt3 = ht3;
            for (W3 = G3 = 0; W3 < et3; ++W3) {
              var mt3 = dt3[W3], vt3 = mt3.G, bt3 = mt3.H, wt3 = 0, Nt3 = 1, Lt3 = 0;
              for (V3 = 0; 5 > V3; ++V3) {
                ut3 = Xn[V3], vt3[V3] = gt3, bt3[V3] = G3, !V3 && 0 < K3 && (ut3 += 1 << K3);
                n: {
                  var At3, xt3 = ut3, St2 = Y3, kt3 = pt3, Ft3 = gt3, Ct3 = G3, jt3 = 0, Ot3 = St2.m, Bt3 = y3(Ot3, 1);
                  if (i(kt3, 0, 0, xt3), Bt3) {
                    var Mt3 = y3(Ot3, 1) + 1, Et3 = y3(Ot3, 1), qt3 = y3(Ot3, 0 == Et3 ? 1 : 8);
                    kt3[qt3] = 1, 2 == Mt3 && (kt3[qt3 = y3(Ot3, 8)] = 1);
                    var Dt3 = 1;
                  } else {
                    var Rt3 = a2(19), Tt3 = y3(Ot3, 4) + 4;
                    if (19 < Tt3) {
                      St2.a = 3;
                      var Ut3 = 0;
                      break n;
                    }
                    for (At3 = 0; At3 < Tt3; ++At3) Rt3[Zn[At3]] = y3(Ot3, 3);
                    var zt3 = void 0, Ht3 = void 0, Wt3 = St2, Vt3 = Rt3, Gt3 = xt3, Yt3 = kt3, Jt3 = 0, Xt3 = Wt3.m, Kt3 = 8, Zt3 = o2(128, l3);
                    i: for (; h3(Zt3, 0, 7, Vt3, 19); ) {
                      if (y3(Xt3, 1)) {
                        var $t3 = 2 + 2 * y3(Xt3, 3);
                        if ((zt3 = 2 + y3(Xt3, $t3)) > Gt3) break i;
                      } else zt3 = Gt3;
                      for (Ht3 = 0; Ht3 < Gt3 && zt3--; ) {
                        S2(Xt3);
                        var Qt3 = Zt3[0 + (127 & L3(Xt3))];
                        x2(Xt3, Xt3.u + Qt3.g);
                        var te3 = Qt3.value;
                        if (16 > te3) Yt3[Ht3++] = te3, 0 != te3 && (Kt3 = te3);
                        else {
                          var ee3 = 16 == te3, re3 = te3 - 16, ne3 = Jn[re3], ie3 = y3(Xt3, Yn[re3]) + ne3;
                          if (Ht3 + ie3 > Gt3) break i;
                          for (var ae3 = ee3 ? Kt3 : 0; 0 < ie3--; ) Yt3[Ht3++] = ae3;
                        }
                      }
                      Jt3 = 1;
                      break i;
                    }
                    Jt3 || (Wt3.a = 3), Dt3 = Jt3;
                  }
                  (Dt3 = Dt3 && !Ot3.h) && (jt3 = h3(Ft3, Ct3, 8, kt3, xt3)), Dt3 && 0 != jt3 ? Ut3 = jt3 : (St2.a = 3, Ut3 = 0);
                }
                if (0 == Ut3) break r;
                if (Nt3 && 1 == Kn[V3] && (Nt3 = 0 == gt3[G3].g), wt3 += gt3[G3].g, G3 += Ut3, 3 >= V3) {
                  var oe3, se3 = pt3[0];
                  for (oe3 = 1; oe3 < ut3; ++oe3) pt3[oe3] > se3 && (se3 = pt3[oe3]);
                  Lt3 += se3;
                }
              }
              if (mt3.nd = Nt3, mt3.Qb = 0, Nt3 && (mt3.qb = (vt3[3][bt3[3] + 0].value << 24 | vt3[1][bt3[1] + 0].value << 16 | vt3[2][bt3[2] + 0].value) >>> 0, 0 == wt3 && 256 > vt3[0][bt3[0] + 0].value && (mt3.Qb = 1, mt3.qb += vt3[0][bt3[0] + 0].value << 8)), mt3.jc = !mt3.Qb && 6 > Lt3, mt3.jc) {
                var ce3, ue3 = mt3;
                for (ce3 = 0; ce3 < Dr; ++ce3) {
                  var he3 = ce3, le3 = ue3.pd[he3], fe3 = ue3.G[0][ue3.H[0] + he3];
                  256 <= fe3.value ? (le3.g = fe3.g + 256, le3.value = fe3.value) : (le3.g = 0, le3.value = 0, he3 >>= yt2(fe3, 8, le3), he3 >>= yt2(ue3.G[1][ue3.H[1] + he3], 16, le3), he3 >>= yt2(ue3.G[2][ue3.H[2] + he3], 0, le3), yt2(ue3.G[3][ue3.H[3] + he3], 24, le3));
                }
              }
            }
            Q3.vc = tt3, Q3.Wb = et3, Q3.Ya = dt3, Q3.yc = ht3, H5 = 1;
            break e;
          }
          H5 = 0;
        }
        if (!(u4 = H5)) {
          s3.a = 3;
          break t;
        }
        if (0 < b4) {
          if (m4.ua = 1 << b4, !O2(m4.Wa, b4)) {
            s3.a = 1, u4 = 0;
            break t;
          }
        } else m4.ua = 0;
        var de3 = s3, pe3 = f4, ge3 = p4, me3 = de3.s, ve3 = me3.xc;
        if (de3.c = pe3, de3.i = ge3, me3.md = q2(pe3, ve3), me3.wc = 0 == ve3 ? -1 : (1 << ve3) - 1, n3) {
          s3.xb = pi;
          break t;
        }
        if (null == (v4 = a2(f4 * p4))) {
          s3.a = 1, u4 = 0;
          break t;
        }
        u4 = (u4 = _t2(s3, v4, 0, f4, p4, p4, null)) && !g4.h;
        break t;
      }
      return u4 ? (null != c4 ? c4[0] = v4 : (e2(null == v4), e2(n3)), s3.$ = 0, n3 || Pt2(m4)) : Pt2(m4), u4;
    }
    function Ft2(t4, r2) {
      var n3 = t4.c * t4.i, i2 = n3 + r2 + 16 * r2;
      return e2(t4.c <= r2), t4.V = a2(i2), null == t4.V ? (t4.Ta = null, t4.Ua = 0, t4.a = 1, 0) : (t4.Ta = t4.V, t4.Ua = t4.Ba + n3 + r2, 1);
    }
    function Ct2(t4, r2) {
      var n3 = t4.C, i2 = r2 - n3, a3 = t4.V, o3 = t4.Ba + t4.c * n3;
      for (e2(r2 <= t4.l.o); 0 < i2; ) {
        var s3 = 16 < i2 ? 16 : i2, c4 = t4.l.ma, u4 = t4.l.width, h4 = u4 * s3, l4 = c4.ca, f4 = c4.tb + u4 * n3, d4 = t4.Ta, p4 = t4.Ua;
        Nt2(t4, s3, a3, o3), _n(d4, p4, l4, f4, h4), xt2(c4, n3, n3 + s3, l4, f4, u4), i2 -= s3, a3 += s3 * t4.c, n3 += s3;
      }
      e2(n3 == r2), t4.C = t4.Ma = r2;
    }
    function jt2() {
      this.ub = this.yd = this.td = this.Rb = 0;
    }
    function Ot2() {
      this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
    }
    function Bt2() {
      this.Fb = this.Bb = this.Cb = 0, this.Zb = a2(4), this.Lb = a2(4);
    }
    function Mt2() {
      this.Yb = function() {
        var t4 = [];
        return function t5(e3, r2, n3) {
          for (var i2 = n3[r2], a3 = 0; a3 < i2 && (e3.push(n3.length > r2 + 1 ? [] : 0), !(n3.length < r2 + 1)); a3++) t5(e3[a3], r2 + 1, n3);
        }(t4, 0, [3, 11]), t4;
      }();
    }
    function Et2() {
      this.jb = a2(3), this.Wc = s2([4, 8], Mt2), this.Xc = s2([4, 17], Mt2);
    }
    function qt2() {
      this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new a2(4), this.od = new a2(4);
    }
    function Dt2() {
      this.ld = this.La = this.dd = this.tc = 0;
    }
    function Rt2() {
      this.Na = this.la = 0;
    }
    function Tt2() {
      this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0;
    }
    function Ut2() {
      this.ad = a2(384), this.Za = 0, this.Ob = a2(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
    }
    function zt2() {
      this.uc = this.M = this.Nb = 0, this.wa = Array(new Dt2()), this.Y = 0, this.ya = Array(new Ut2()), this.aa = 0, this.l = new Gt2();
    }
    function Ht2() {
      this.y = a2(16), this.f = a2(8), this.ea = a2(8);
    }
    function Wt2() {
      this.cb = this.a = 0, this.sc = "", this.m = new w3(), this.Od = new jt2(), this.Kc = new Ot2(), this.ed = new qt2(), this.Qa = new Bt2(), this.Ic = this.$c = this.Aa = 0, this.D = new zt2(), this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = o2(8, w3), this.ia = 0, this.pb = o2(4, Tt2), this.Pa = new Et2(), this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new Ht2()), this.Hd = 0, this.rb = Array(new Rt2()), this.sb = 0, this.wa = Array(new Dt2()), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new Ut2()), this.L = this.aa = 0, this.gd = s2([4, 2], Dt2), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;
    }
    function Vt2(t4, e3) {
      return 0 > t4 ? 0 : t4 > e3 ? e3 : t4;
    }
    function Gt2() {
      this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;
    }
    function Yt2() {
      var t4 = new Wt2();
      return null != t4 && (t4.a = 0, t4.sc = "OK", t4.cb = 0, t4.Xb = 0, ni || (ni = Zt2)), t4;
    }
    function Jt2(t4, e3, r2) {
      return 0 == t4.a && (t4.a = e3, t4.sc = r2, t4.cb = 0), 0;
    }
    function Xt2(t4, e3, r2) {
      return 3 <= r2 && 157 == t4[e3 + 0] && 1 == t4[e3 + 1] && 42 == t4[e3 + 2];
    }
    function Kt2(t4, r2) {
      if (null == t4) return 0;
      if (t4.a = 0, t4.sc = "OK", null == r2) return Jt2(t4, 2, "null VP8Io passed to VP8GetHeaders()");
      var n3 = r2.data, a3 = r2.w, o3 = r2.ha;
      if (4 > o3) return Jt2(t4, 7, "Truncated header.");
      var s3 = n3[a3 + 0] | n3[a3 + 1] << 8 | n3[a3 + 2] << 16, c4 = t4.Od;
      if (c4.Rb = !(1 & s3), c4.td = s3 >> 1 & 7, c4.yd = s3 >> 4 & 1, c4.ub = s3 >> 5, 3 < c4.td) return Jt2(t4, 3, "Incorrect keyframe parameters.");
      if (!c4.yd) return Jt2(t4, 4, "Frame not displayable.");
      a3 += 3, o3 -= 3;
      var u4 = t4.Kc;
      if (c4.Rb) {
        if (7 > o3) return Jt2(t4, 7, "cannot parse picture header");
        if (!Xt2(n3, a3, o3)) return Jt2(t4, 3, "Bad code word");
        u4.c = 16383 & (n3[a3 + 4] << 8 | n3[a3 + 3]), u4.Td = n3[a3 + 4] >> 6, u4.i = 16383 & (n3[a3 + 6] << 8 | n3[a3 + 5]), u4.Ud = n3[a3 + 6] >> 6, a3 += 7, o3 -= 7, t4.za = u4.c + 15 >> 4, t4.Ub = u4.i + 15 >> 4, r2.width = u4.c, r2.height = u4.i, r2.Da = 0, r2.j = 0, r2.v = 0, r2.va = r2.width, r2.o = r2.height, r2.da = 0, r2.ib = r2.width, r2.hb = r2.height, r2.U = r2.width, r2.T = r2.height, i((s3 = t4.Pa).jb, 0, 255, s3.jb.length), e2(null != (s3 = t4.Qa)), s3.Cb = 0, s3.Bb = 0, s3.Fb = 1, i(s3.Zb, 0, 0, s3.Zb.length), i(s3.Lb, 0, 0, s3.Lb);
      }
      if (c4.ub > o3) return Jt2(t4, 7, "bad partition length");
      p3(s3 = t4.m, n3, a3, c4.ub), a3 += c4.ub, o3 -= c4.ub, c4.Rb && (u4.Ld = P2(s3), u4.Kd = P2(s3)), u4 = t4.Qa;
      var h4, l4 = t4.Pa;
      if (e2(null != s3), e2(null != u4), u4.Cb = P2(s3), u4.Cb) {
        if (u4.Bb = P2(s3), P2(s3)) {
          for (u4.Fb = P2(s3), h4 = 0; 4 > h4; ++h4) u4.Zb[h4] = P2(s3) ? m3(s3, 7) : 0;
          for (h4 = 0; 4 > h4; ++h4) u4.Lb[h4] = P2(s3) ? m3(s3, 6) : 0;
        }
        if (u4.Bb) for (h4 = 0; 3 > h4; ++h4) l4.jb[h4] = P2(s3) ? g3(s3, 8) : 255;
      } else u4.Bb = 0;
      if (s3.Ka) return Jt2(t4, 3, "cannot parse segment header");
      if ((u4 = t4.ed).zd = P2(s3), u4.Tb = g3(s3, 6), u4.wb = g3(s3, 3), u4.Pc = P2(s3), u4.Pc && P2(s3)) {
        for (l4 = 0; 4 > l4; ++l4) P2(s3) && (u4.vd[l4] = m3(s3, 6));
        for (l4 = 0; 4 > l4; ++l4) P2(s3) && (u4.od[l4] = m3(s3, 6));
      }
      if (t4.L = 0 == u4.Tb ? 0 : u4.zd ? 1 : 2, s3.Ka) return Jt2(t4, 3, "cannot parse filter header");
      var f4 = o3;
      if (o3 = h4 = a3, a3 = h4 + f4, u4 = f4, t4.Xb = (1 << g3(t4.m, 2)) - 1, f4 < 3 * (l4 = t4.Xb)) n3 = 7;
      else {
        for (h4 += 3 * l4, u4 -= 3 * l4, f4 = 0; f4 < l4; ++f4) {
          var d4 = n3[o3 + 0] | n3[o3 + 1] << 8 | n3[o3 + 2] << 16;
          d4 > u4 && (d4 = u4), p3(t4.Jc[+f4], n3, h4, d4), h4 += d4, u4 -= d4, o3 += 3;
        }
        p3(t4.Jc[+l4], n3, h4, u4), n3 = h4 < a3 ? 0 : 5;
      }
      if (0 != n3) return Jt2(t4, n3, "cannot parse partitions");
      for (n3 = g3(h4 = t4.m, 7), o3 = P2(h4) ? m3(h4, 4) : 0, a3 = P2(h4) ? m3(h4, 4) : 0, u4 = P2(h4) ? m3(h4, 4) : 0, l4 = P2(h4) ? m3(h4, 4) : 0, h4 = P2(h4) ? m3(h4, 4) : 0, f4 = t4.Qa, d4 = 0; 4 > d4; ++d4) {
        if (f4.Cb) {
          var v4 = f4.Zb[d4];
          f4.Fb || (v4 += n3);
        } else {
          if (0 < d4) {
            t4.pb[d4] = t4.pb[0];
            continue;
          }
          v4 = n3;
        }
        var b4 = t4.pb[d4];
        b4.Sc[0] = ei2[Vt2(v4 + o3, 127)], b4.Sc[1] = ri[Vt2(v4 + 0, 127)], b4.Eb[0] = 2 * ei2[Vt2(v4 + a3, 127)], b4.Eb[1] = 101581 * ri[Vt2(v4 + u4, 127)] >> 16, 8 > b4.Eb[1] && (b4.Eb[1] = 8), b4.Qc[0] = ei2[Vt2(v4 + l4, 117)], b4.Qc[1] = ri[Vt2(v4 + h4, 127)], b4.lc = v4 + h4;
      }
      if (!c4.Rb) return Jt2(t4, 4, "Not a key frame.");
      for (P2(s3), c4 = t4.Pa, n3 = 0; 4 > n3; ++n3) {
        for (o3 = 0; 8 > o3; ++o3) for (a3 = 0; 3 > a3; ++a3) for (u4 = 0; 11 > u4; ++u4) l4 = k2(s3, ui[n3][o3][a3][u4]) ? g3(s3, 8) : si[n3][o3][a3][u4], c4.Wc[n3][o3].Yb[a3][u4] = l4;
        for (o3 = 0; 17 > o3; ++o3) c4.Xc[n3][o3] = c4.Wc[n3][hi[o3]];
      }
      return t4.kc = P2(s3), t4.kc && (t4.Bd = g3(s3, 8)), t4.cb = 1;
    }
    function Zt2(t4, e3, r2, n3, i2, a3, o3) {
      var s3 = e3[i2].Yb[r2];
      for (r2 = 0; 16 > i2; ++i2) {
        if (!k2(t4, s3[r2 + 0])) return i2;
        for (; !k2(t4, s3[r2 + 1]); ) if (s3 = e3[++i2].Yb[0], r2 = 0, 16 == i2) return 16;
        var c4 = e3[i2 + 1].Yb;
        if (k2(t4, s3[r2 + 2])) {
          var u4 = t4, h4 = 0;
          if (k2(u4, (f4 = s3)[(l4 = r2) + 3])) if (k2(u4, f4[l4 + 6])) {
            for (s3 = 0, l4 = 2 * (h4 = k2(u4, f4[l4 + 8])) + (f4 = k2(u4, f4[l4 + 9 + h4])), h4 = 0, f4 = ii2[l4]; f4[s3]; ++s3) h4 += h4 + k2(u4, f4[s3]);
            h4 += 3 + (8 << l4);
          } else k2(u4, f4[l4 + 7]) ? (h4 = 7 + 2 * k2(u4, 165), h4 += k2(u4, 145)) : h4 = 5 + k2(u4, 159);
          else h4 = k2(u4, f4[l4 + 4]) ? 3 + k2(u4, f4[l4 + 5]) : 2;
          s3 = c4[2];
        } else h4 = 1, s3 = c4[1];
        c4 = o3 + ai[i2], 0 > (u4 = t4).b && _2(u4);
        var l4, f4 = u4.b, d4 = (l4 = u4.Ca >> 1) - (u4.I >> f4) >> 31;
        --u4.b, u4.Ca += d4, u4.Ca |= 1, u4.I -= (l4 + 1 & d4) << f4, a3[c4] = ((h4 ^ d4) - d4) * n3[(0 < i2) + 0];
      }
      return 16;
    }
    function $t2(t4) {
      var e3 = t4.rb[t4.sb - 1];
      e3.la = 0, e3.Na = 0, i(t4.zc, 0, 0, t4.zc.length), t4.ja = 0;
    }
    function Qt2(t4, r2) {
      if (null == t4) return 0;
      if (null == r2) return Jt2(t4, 2, "NULL VP8Io parameter in VP8Decode().");
      if (!t4.cb && !Kt2(t4, r2)) return 0;
      if (e2(t4.cb), null == r2.ac || r2.ac(r2)) {
        r2.ob && (t4.L = 0);
        var s3 = Ri[t4.L];
        if (2 == t4.L ? (t4.yb = 0, t4.zb = 0) : (t4.yb = r2.v - s3 >> 4, t4.zb = r2.j - s3 >> 4, 0 > t4.yb && (t4.yb = 0), 0 > t4.zb && (t4.zb = 0)), t4.Va = r2.o + 15 + s3 >> 4, t4.Hb = r2.va + 15 + s3 >> 4, t4.Hb > t4.za && (t4.Hb = t4.za), t4.Va > t4.Ub && (t4.Va = t4.Ub), 0 < t4.L) {
          var c4 = t4.ed;
          for (s3 = 0; 4 > s3; ++s3) {
            var u4;
            if (t4.Qa.Cb) {
              var h4 = t4.Qa.Lb[s3];
              t4.Qa.Fb || (h4 += c4.Tb);
            } else h4 = c4.Tb;
            for (u4 = 0; 1 >= u4; ++u4) {
              var l4 = t4.gd[s3][u4], f4 = h4;
              if (c4.Pc && (f4 += c4.vd[0], u4 && (f4 += c4.od[0])), 0 < (f4 = 0 > f4 ? 0 : 63 < f4 ? 63 : f4)) {
                var d4 = f4;
                0 < c4.wb && ((d4 = 4 < c4.wb ? d4 >> 2 : d4 >> 1) > 9 - c4.wb && (d4 = 9 - c4.wb)), 1 > d4 && (d4 = 1), l4.dd = d4, l4.tc = 2 * f4 + d4, l4.ld = 40 <= f4 ? 2 : 15 <= f4 ? 1 : 0;
              } else l4.tc = 0;
              l4.La = u4;
            }
          }
        }
        s3 = 0;
      } else Jt2(t4, 6, "Frame setup failed"), s3 = t4.a;
      if (s3 = 0 == s3) {
        if (s3) {
          t4.$c = 0, 0 < t4.Aa || (t4.Ic = Ui);
          t: {
            s3 = t4.Ic;
            c4 = 4 * (d4 = t4.za);
            var p4 = 32 * d4, g4 = d4 + 1, m4 = 0 < t4.L ? d4 * (0 < t4.Aa ? 2 : 1) : 0, v4 = (2 == t4.Aa ? 2 : 1) * d4;
            if ((l4 = c4 + 832 + (u4 = 3 * (16 * s3 + Ri[t4.L]) / 2 * p4) + (h4 = null != t4.Fa && 0 < t4.Fa.length ? t4.Kc.c * t4.Kc.i : 0)) != l4) s3 = 0;
            else {
              if (l4 > t4.Vb) {
                if (t4.Vb = 0, t4.Ec = a2(l4), t4.Fc = 0, null == t4.Ec) {
                  s3 = Jt2(t4, 1, "no memory during frame initialization.");
                  break t;
                }
                t4.Vb = l4;
              }
              l4 = t4.Ec, f4 = t4.Fc, t4.Ac = l4, t4.Bc = f4, f4 += c4, t4.Gd = o2(p4, Ht2), t4.Hd = 0, t4.rb = o2(g4 + 1, Rt2), t4.sb = 1, t4.wa = m4 ? o2(m4, Dt2) : null, t4.Y = 0, t4.D.Nb = 0, t4.D.wa = t4.wa, t4.D.Y = t4.Y, 0 < t4.Aa && (t4.D.Y += d4), e2(true), t4.oc = l4, t4.pc = f4, f4 += 832, t4.ya = o2(v4, Ut2), t4.aa = 0, t4.D.ya = t4.ya, t4.D.aa = t4.aa, 2 == t4.Aa && (t4.D.aa += d4), t4.R = 16 * d4, t4.B = 8 * d4, d4 = (p4 = Ri[t4.L]) * t4.R, p4 = p4 / 2 * t4.B, t4.sa = l4, t4.ta = f4 + d4, t4.qa = t4.sa, t4.ra = t4.ta + 16 * s3 * t4.R + p4, t4.Ha = t4.qa, t4.Ia = t4.ra + 8 * s3 * t4.B + p4, t4.$c = 0, f4 += u4, t4.mb = h4 ? l4 : null, t4.nb = h4 ? f4 : null, e2(f4 + h4 <= t4.Fc + t4.Vb), $t2(t4), i(t4.Ac, t4.Bc, 0, c4), s3 = 1;
            }
          }
          if (s3) {
            if (r2.ka = 0, r2.y = t4.sa, r2.O = t4.ta, r2.f = t4.qa, r2.N = t4.ra, r2.ea = t4.Ha, r2.Vd = t4.Ia, r2.fa = t4.R, r2.Rc = t4.B, r2.F = null, r2.J = 0, !Cn) {
              for (s3 = -255; 255 >= s3; ++s3) Pn[255 + s3] = 0 > s3 ? -s3 : s3;
              for (s3 = -1020; 1020 >= s3; ++s3) kn[1020 + s3] = -128 > s3 ? -128 : 127 < s3 ? 127 : s3;
              for (s3 = -112; 112 >= s3; ++s3) In[112 + s3] = -16 > s3 ? -16 : 15 < s3 ? 15 : s3;
              for (s3 = -255; 510 >= s3; ++s3) Fn[255 + s3] = 0 > s3 ? 0 : 255 < s3 ? 255 : s3;
              Cn = 1;
            }
            an = ue2, on2 = ae2, cn = oe2, un = se2, hn = ce2, sn = ie2, ln2 = Je, fn = Xe, dn = $e, pn = Qe, gn = Ke, mn = Ze, vn = tr, bn = er, yn = ze, wn = He, Nn = We, Ln = Ve, fi[0] = xe, fi[1] = le2, fi[2] = Le2, fi[3] = Ae, fi[4] = Se, fi[5] = Pe, fi[6] = _e, fi[7] = ke, fi[8] = Fe, fi[9] = Ie, li[0] = ve2, li[1] = de2, li[2] = pe2, li[3] = ge2, li[4] = be2, li[5] = ye2, li[6] = we2, di[0] = Be, di[1] = fe2, di[2] = Ce, di[3] = je, di[4] = Ee, di[5] = Me, di[6] = qe2, s3 = 1;
          } else s3 = 0;
        }
        s3 && (s3 = function(t5, r3) {
          for (t5.M = 0; t5.M < t5.Va; ++t5.M) {
            var o3, s4 = t5.Jc[t5.M & t5.Xb], c5 = t5.m, u5 = t5;
            for (o3 = 0; o3 < u5.za; ++o3) {
              var h5 = c5, l5 = u5, f5 = l5.Ac, d5 = l5.Bc + 4 * o3, p5 = l5.zc, g5 = l5.ya[l5.aa + o3];
              if (l5.Qa.Bb ? g5.$b = k2(h5, l5.Pa.jb[0]) ? 2 + k2(h5, l5.Pa.jb[2]) : k2(h5, l5.Pa.jb[1]) : g5.$b = 0, l5.kc && (g5.Ad = k2(h5, l5.Bd)), g5.Za = !k2(h5, 145) + 0, g5.Za) {
                var m5 = g5.Ob, v5 = 0;
                for (l5 = 0; 4 > l5; ++l5) {
                  var b4, y4 = p5[0 + l5];
                  for (b4 = 0; 4 > b4; ++b4) {
                    y4 = ci[f5[d5 + b4]][y4];
                    for (var w4 = oi[k2(h5, y4[0])]; 0 < w4; ) w4 = oi[2 * w4 + k2(h5, y4[w4])];
                    y4 = -w4, f5[d5 + b4] = y4;
                  }
                  n2(m5, v5, f5, d5, 4), v5 += 4, p5[0 + l5] = y4;
                }
              } else y4 = k2(h5, 156) ? k2(h5, 128) ? 1 : 3 : k2(h5, 163) ? 2 : 0, g5.Ob[0] = y4, i(f5, d5, y4, 4), i(p5, 0, y4, 4);
              g5.Dd = k2(h5, 142) ? k2(h5, 114) ? k2(h5, 183) ? 1 : 3 : 2 : 0;
            }
            if (u5.m.Ka) return Jt2(t5, 7, "Premature end-of-partition0 encountered.");
            for (; t5.ja < t5.za; ++t5.ja) {
              if (u5 = s4, h5 = (c5 = t5).rb[c5.sb - 1], f5 = c5.rb[c5.sb + c5.ja], o3 = c5.ya[c5.aa + c5.ja], d5 = c5.kc ? o3.Ad : 0) h5.la = f5.la = 0, o3.Za || (h5.Na = f5.Na = 0), o3.Hc = 0, o3.Gc = 0, o3.ia = 0;
              else {
                var N4, L4;
                h5 = f5, f5 = u5, d5 = c5.Pa.Xc, p5 = c5.ya[c5.aa + c5.ja], g5 = c5.pb[p5.$b];
                if (l5 = p5.ad, m5 = 0, v5 = c5.rb[c5.sb - 1], y4 = b4 = 0, i(l5, m5, 0, 384), p5.Za) var A4 = 0, x3 = d5[3];
                else {
                  w4 = a2(16);
                  var S3 = h5.Na + v5.Na;
                  if (S3 = ni(f5, d5[1], S3, g5.Eb, 0, w4, 0), h5.Na = v5.Na = (0 < S3) + 0, 1 < S3) an(w4, 0, l5, m5);
                  else {
                    var _3 = w4[0] + 3 >> 3;
                    for (w4 = 0; 256 > w4; w4 += 16) l5[m5 + w4] = _3;
                  }
                  A4 = 1, x3 = d5[0];
                }
                var P3 = 15 & h5.la, I3 = 15 & v5.la;
                for (w4 = 0; 4 > w4; ++w4) {
                  var F3 = 1 & I3;
                  for (_3 = L4 = 0; 4 > _3; ++_3) P3 = P3 >> 1 | (F3 = (S3 = ni(f5, x3, S3 = F3 + (1 & P3), g5.Sc, A4, l5, m5)) > A4) << 7, L4 = L4 << 2 | (3 < S3 ? 3 : 1 < S3 ? 2 : 0 != l5[m5 + 0]), m5 += 16;
                  P3 >>= 4, I3 = I3 >> 1 | F3 << 7, b4 = (b4 << 8 | L4) >>> 0;
                }
                for (x3 = P3, A4 = I3 >> 4, N4 = 0; 4 > N4; N4 += 2) {
                  for (L4 = 0, P3 = h5.la >> 4 + N4, I3 = v5.la >> 4 + N4, w4 = 0; 2 > w4; ++w4) {
                    for (F3 = 1 & I3, _3 = 0; 2 > _3; ++_3) S3 = F3 + (1 & P3), P3 = P3 >> 1 | (F3 = 0 < (S3 = ni(f5, d5[2], S3, g5.Qc, 0, l5, m5))) << 3, L4 = L4 << 2 | (3 < S3 ? 3 : 1 < S3 ? 2 : 0 != l5[m5 + 0]), m5 += 16;
                    P3 >>= 2, I3 = I3 >> 1 | F3 << 5;
                  }
                  y4 |= L4 << 4 * N4, x3 |= P3 << 4 << N4, A4 |= (240 & I3) << N4;
                }
                h5.la = x3, v5.la = A4, p5.Hc = b4, p5.Gc = y4, p5.ia = 43690 & y4 ? 0 : g5.ia, d5 = !(b4 | y4);
              }
              if (0 < c5.L && (c5.wa[c5.Y + c5.ja] = c5.gd[o3.$b][o3.Za], c5.wa[c5.Y + c5.ja].La |= !d5), u5.Ka) return Jt2(t5, 7, "Premature end-of-file encountered.");
            }
            if ($t2(t5), c5 = r3, u5 = 1, o3 = (s4 = t5).D, h5 = 0 < s4.L && s4.M >= s4.zb && s4.M <= s4.Va, 0 == s4.Aa) t: {
              if (o3.M = s4.M, o3.uc = h5, Or(s4, o3), u5 = 1, o3 = (L4 = s4.D).Nb, h5 = (y4 = Ri[s4.L]) * s4.R, f5 = y4 / 2 * s4.B, w4 = 16 * o3 * s4.R, _3 = 8 * o3 * s4.B, d5 = s4.sa, p5 = s4.ta - h5 + w4, g5 = s4.qa, l5 = s4.ra - f5 + _3, m5 = s4.Ha, v5 = s4.Ia - f5 + _3, I3 = 0 == (P3 = L4.M), b4 = P3 >= s4.Va - 1, 2 == s4.Aa && Or(s4, L4), L4.uc) for (F3 = (S3 = s4).D.M, e2(S3.D.uc), L4 = S3.yb; L4 < S3.Hb; ++L4) {
                A4 = L4, x3 = F3;
                var C3 = (j3 = (U3 = S3).D).Nb;
                N4 = U3.R;
                var j3 = j3.wa[j3.Y + A4], O3 = U3.sa, B4 = U3.ta + 16 * C3 * N4 + 16 * A4, M3 = j3.dd, E3 = j3.tc;
                if (0 != E3) if (e2(3 <= E3), 1 == U3.L) 0 < A4 && wn(O3, B4, N4, E3 + 4), j3.La && Ln(O3, B4, N4, E3), 0 < x3 && yn(O3, B4, N4, E3 + 4), j3.La && Nn(O3, B4, N4, E3);
                else {
                  var q3 = U3.B, D3 = U3.qa, R3 = U3.ra + 8 * C3 * q3 + 8 * A4, T3 = U3.Ha, U3 = U3.Ia + 8 * C3 * q3 + 8 * A4;
                  C3 = j3.ld;
                  0 < A4 && (fn(O3, B4, N4, E3 + 4, M3, C3), pn(D3, R3, T3, U3, q3, E3 + 4, M3, C3)), j3.La && (mn(O3, B4, N4, E3, M3, C3), bn(D3, R3, T3, U3, q3, E3, M3, C3)), 0 < x3 && (ln2(O3, B4, N4, E3 + 4, M3, C3), dn(D3, R3, T3, U3, q3, E3 + 4, M3, C3)), j3.La && (gn(O3, B4, N4, E3, M3, C3), vn(D3, R3, T3, U3, q3, E3, M3, C3));
                }
              }
              if (s4.ia && alert("todo:DitherRow"), null != c5.put) {
                if (L4 = 16 * P3, P3 = 16 * (P3 + 1), I3 ? (c5.y = s4.sa, c5.O = s4.ta + w4, c5.f = s4.qa, c5.N = s4.ra + _3, c5.ea = s4.Ha, c5.W = s4.Ia + _3) : (L4 -= y4, c5.y = d5, c5.O = p5, c5.f = g5, c5.N = l5, c5.ea = m5, c5.W = v5), b4 || (P3 -= y4), P3 > c5.o && (P3 = c5.o), c5.F = null, c5.J = null, null != s4.Fa && 0 < s4.Fa.length && L4 < P3 && (c5.J = lr(s4, c5, L4, P3 - L4), c5.F = s4.mb, null == c5.F && 0 == c5.F.length)) {
                  u5 = Jt2(s4, 3, "Could not decode alpha data.");
                  break t;
                }
                L4 < c5.j && (y4 = c5.j - L4, L4 = c5.j, e2(!(1 & y4)), c5.O += s4.R * y4, c5.N += s4.B * (y4 >> 1), c5.W += s4.B * (y4 >> 1), null != c5.F && (c5.J += c5.width * y4)), L4 < P3 && (c5.O += c5.v, c5.N += c5.v >> 1, c5.W += c5.v >> 1, null != c5.F && (c5.J += c5.v), c5.ka = L4 - c5.j, c5.U = c5.va - c5.v, c5.T = P3 - L4, u5 = c5.put(c5));
              }
              o3 + 1 != s4.Ic || b4 || (n2(s4.sa, s4.ta - h5, d5, p5 + 16 * s4.R, h5), n2(s4.qa, s4.ra - f5, g5, l5 + 8 * s4.B, f5), n2(s4.Ha, s4.Ia - f5, m5, v5 + 8 * s4.B, f5));
            }
            if (!u5) return Jt2(t5, 6, "Output aborted.");
          }
          return 1;
        }(t4, r2)), null != r2.bc && r2.bc(r2), s3 &= 1;
      }
      return s3 ? (t4.cb = 0, s3) : 0;
    }
    function te2(t4, e3, r2, n3, i2) {
      i2 = t4[e3 + r2 + 32 * n3] + (i2 >> 3), t4[e3 + r2 + 32 * n3] = -256 & i2 ? 0 > i2 ? 0 : 255 : i2;
    }
    function ee2(t4, e3, r2, n3, i2, a3) {
      te2(t4, e3, 0, r2, n3 + i2), te2(t4, e3, 1, r2, n3 + a3), te2(t4, e3, 2, r2, n3 - a3), te2(t4, e3, 3, r2, n3 - i2);
    }
    function re2(t4) {
      return (20091 * t4 >> 16) + t4;
    }
    function ne2(t4, e3, r2, n3) {
      var i2, o3 = 0, s3 = a2(16);
      for (i2 = 0; 4 > i2; ++i2) {
        var c4 = t4[e3 + 0] + t4[e3 + 8], u4 = t4[e3 + 0] - t4[e3 + 8], h4 = (35468 * t4[e3 + 4] >> 16) - re2(t4[e3 + 12]), l4 = re2(t4[e3 + 4]) + (35468 * t4[e3 + 12] >> 16);
        s3[o3 + 0] = c4 + l4, s3[o3 + 1] = u4 + h4, s3[o3 + 2] = u4 - h4, s3[o3 + 3] = c4 - l4, o3 += 4, e3++;
      }
      for (i2 = o3 = 0; 4 > i2; ++i2) c4 = (t4 = s3[o3 + 0] + 4) + s3[o3 + 8], u4 = t4 - s3[o3 + 8], h4 = (35468 * s3[o3 + 4] >> 16) - re2(s3[o3 + 12]), te2(r2, n3, 0, 0, c4 + (l4 = re2(s3[o3 + 4]) + (35468 * s3[o3 + 12] >> 16))), te2(r2, n3, 1, 0, u4 + h4), te2(r2, n3, 2, 0, u4 - h4), te2(r2, n3, 3, 0, c4 - l4), o3++, n3 += 32;
    }
    function ie2(t4, e3, r2, n3) {
      var i2 = t4[e3 + 0] + 4, a3 = 35468 * t4[e3 + 4] >> 16, o3 = re2(t4[e3 + 4]), s3 = 35468 * t4[e3 + 1] >> 16;
      ee2(r2, n3, 0, i2 + o3, t4 = re2(t4[e3 + 1]), s3), ee2(r2, n3, 1, i2 + a3, t4, s3), ee2(r2, n3, 2, i2 - a3, t4, s3), ee2(r2, n3, 3, i2 - o3, t4, s3);
    }
    function ae2(t4, e3, r2, n3, i2) {
      ne2(t4, e3, r2, n3), i2 && ne2(t4, e3 + 16, r2, n3 + 4);
    }
    function oe2(t4, e3, r2, n3) {
      on2(t4, e3 + 0, r2, n3, 1), on2(t4, e3 + 32, r2, n3 + 128, 1);
    }
    function se2(t4, e3, r2, n3) {
      var i2;
      for (t4 = t4[e3 + 0] + 4, i2 = 0; 4 > i2; ++i2) for (e3 = 0; 4 > e3; ++e3) te2(r2, n3, e3, i2, t4);
    }
    function ce2(t4, e3, r2, n3) {
      t4[e3 + 0] && un(t4, e3 + 0, r2, n3), t4[e3 + 16] && un(t4, e3 + 16, r2, n3 + 4), t4[e3 + 32] && un(t4, e3 + 32, r2, n3 + 128), t4[e3 + 48] && un(t4, e3 + 48, r2, n3 + 128 + 4);
    }
    function ue2(t4, e3, r2, n3) {
      var i2, o3 = a2(16);
      for (i2 = 0; 4 > i2; ++i2) {
        var s3 = t4[e3 + 0 + i2] + t4[e3 + 12 + i2], c4 = t4[e3 + 4 + i2] + t4[e3 + 8 + i2], u4 = t4[e3 + 4 + i2] - t4[e3 + 8 + i2], h4 = t4[e3 + 0 + i2] - t4[e3 + 12 + i2];
        o3[0 + i2] = s3 + c4, o3[8 + i2] = s3 - c4, o3[4 + i2] = h4 + u4, o3[12 + i2] = h4 - u4;
      }
      for (i2 = 0; 4 > i2; ++i2) s3 = (t4 = o3[0 + 4 * i2] + 3) + o3[3 + 4 * i2], c4 = o3[1 + 4 * i2] + o3[2 + 4 * i2], u4 = o3[1 + 4 * i2] - o3[2 + 4 * i2], h4 = t4 - o3[3 + 4 * i2], r2[n3 + 0] = s3 + c4 >> 3, r2[n3 + 16] = h4 + u4 >> 3, r2[n3 + 32] = s3 - c4 >> 3, r2[n3 + 48] = h4 - u4 >> 3, n3 += 64;
    }
    function he2(t4, e3, r2) {
      var n3, i2 = e3 - 32, a3 = Bn, o3 = 255 - t4[i2 - 1];
      for (n3 = 0; n3 < r2; ++n3) {
        var s3, c4 = a3, u4 = o3 + t4[e3 - 1];
        for (s3 = 0; s3 < r2; ++s3) t4[e3 + s3] = c4[u4 + t4[i2 + s3]];
        e3 += 32;
      }
    }
    function le2(t4, e3) {
      he2(t4, e3, 4);
    }
    function fe2(t4, e3) {
      he2(t4, e3, 8);
    }
    function de2(t4, e3) {
      he2(t4, e3, 16);
    }
    function pe2(t4, e3) {
      var r2;
      for (r2 = 0; 16 > r2; ++r2) n2(t4, e3 + 32 * r2, t4, e3 - 32, 16);
    }
    function ge2(t4, e3) {
      var r2;
      for (r2 = 16; 0 < r2; --r2) i(t4, e3, t4[e3 - 1], 16), e3 += 32;
    }
    function me2(t4, e3, r2) {
      var n3;
      for (n3 = 0; 16 > n3; ++n3) i(e3, r2 + 32 * n3, t4, 16);
    }
    function ve2(t4, e3) {
      var r2, n3 = 16;
      for (r2 = 0; 16 > r2; ++r2) n3 += t4[e3 - 1 + 32 * r2] + t4[e3 + r2 - 32];
      me2(n3 >> 5, t4, e3);
    }
    function be2(t4, e3) {
      var r2, n3 = 8;
      for (r2 = 0; 16 > r2; ++r2) n3 += t4[e3 - 1 + 32 * r2];
      me2(n3 >> 4, t4, e3);
    }
    function ye2(t4, e3) {
      var r2, n3 = 8;
      for (r2 = 0; 16 > r2; ++r2) n3 += t4[e3 + r2 - 32];
      me2(n3 >> 4, t4, e3);
    }
    function we2(t4, e3) {
      me2(128, t4, e3);
    }
    function Ne2(t4, e3, r2) {
      return t4 + 2 * e3 + r2 + 2 >> 2;
    }
    function Le2(t4, e3) {
      var r2, i2 = e3 - 32;
      i2 = new Uint8Array([Ne2(t4[i2 - 1], t4[i2 + 0], t4[i2 + 1]), Ne2(t4[i2 + 0], t4[i2 + 1], t4[i2 + 2]), Ne2(t4[i2 + 1], t4[i2 + 2], t4[i2 + 3]), Ne2(t4[i2 + 2], t4[i2 + 3], t4[i2 + 4])]);
      for (r2 = 0; 4 > r2; ++r2) n2(t4, e3 + 32 * r2, i2, 0, i2.length);
    }
    function Ae(t4, e3) {
      var r2 = t4[e3 - 1], n3 = t4[e3 - 1 + 32], i2 = t4[e3 - 1 + 64], a3 = t4[e3 - 1 + 96];
      I2(t4, e3 + 0, 16843009 * Ne2(t4[e3 - 1 - 32], r2, n3)), I2(t4, e3 + 32, 16843009 * Ne2(r2, n3, i2)), I2(t4, e3 + 64, 16843009 * Ne2(n3, i2, a3)), I2(t4, e3 + 96, 16843009 * Ne2(i2, a3, a3));
    }
    function xe(t4, e3) {
      var r2, n3 = 4;
      for (r2 = 0; 4 > r2; ++r2) n3 += t4[e3 + r2 - 32] + t4[e3 - 1 + 32 * r2];
      for (n3 >>= 3, r2 = 0; 4 > r2; ++r2) i(t4, e3 + 32 * r2, n3, 4);
    }
    function Se(t4, e3) {
      var r2 = t4[e3 - 1 + 0], n3 = t4[e3 - 1 + 32], i2 = t4[e3 - 1 + 64], a3 = t4[e3 - 1 - 32], o3 = t4[e3 + 0 - 32], s3 = t4[e3 + 1 - 32], c4 = t4[e3 + 2 - 32], u4 = t4[e3 + 3 - 32];
      t4[e3 + 0 + 96] = Ne2(n3, i2, t4[e3 - 1 + 96]), t4[e3 + 1 + 96] = t4[e3 + 0 + 64] = Ne2(r2, n3, i2), t4[e3 + 2 + 96] = t4[e3 + 1 + 64] = t4[e3 + 0 + 32] = Ne2(a3, r2, n3), t4[e3 + 3 + 96] = t4[e3 + 2 + 64] = t4[e3 + 1 + 32] = t4[e3 + 0 + 0] = Ne2(o3, a3, r2), t4[e3 + 3 + 64] = t4[e3 + 2 + 32] = t4[e3 + 1 + 0] = Ne2(s3, o3, a3), t4[e3 + 3 + 32] = t4[e3 + 2 + 0] = Ne2(c4, s3, o3), t4[e3 + 3 + 0] = Ne2(u4, c4, s3);
    }
    function _e(t4, e3) {
      var r2 = t4[e3 + 1 - 32], n3 = t4[e3 + 2 - 32], i2 = t4[e3 + 3 - 32], a3 = t4[e3 + 4 - 32], o3 = t4[e3 + 5 - 32], s3 = t4[e3 + 6 - 32], c4 = t4[e3 + 7 - 32];
      t4[e3 + 0 + 0] = Ne2(t4[e3 + 0 - 32], r2, n3), t4[e3 + 1 + 0] = t4[e3 + 0 + 32] = Ne2(r2, n3, i2), t4[e3 + 2 + 0] = t4[e3 + 1 + 32] = t4[e3 + 0 + 64] = Ne2(n3, i2, a3), t4[e3 + 3 + 0] = t4[e3 + 2 + 32] = t4[e3 + 1 + 64] = t4[e3 + 0 + 96] = Ne2(i2, a3, o3), t4[e3 + 3 + 32] = t4[e3 + 2 + 64] = t4[e3 + 1 + 96] = Ne2(a3, o3, s3), t4[e3 + 3 + 64] = t4[e3 + 2 + 96] = Ne2(o3, s3, c4), t4[e3 + 3 + 96] = Ne2(s3, c4, c4);
    }
    function Pe(t4, e3) {
      var r2 = t4[e3 - 1 + 0], n3 = t4[e3 - 1 + 32], i2 = t4[e3 - 1 + 64], a3 = t4[e3 - 1 - 32], o3 = t4[e3 + 0 - 32], s3 = t4[e3 + 1 - 32], c4 = t4[e3 + 2 - 32], u4 = t4[e3 + 3 - 32];
      t4[e3 + 0 + 0] = t4[e3 + 1 + 64] = a3 + o3 + 1 >> 1, t4[e3 + 1 + 0] = t4[e3 + 2 + 64] = o3 + s3 + 1 >> 1, t4[e3 + 2 + 0] = t4[e3 + 3 + 64] = s3 + c4 + 1 >> 1, t4[e3 + 3 + 0] = c4 + u4 + 1 >> 1, t4[e3 + 0 + 96] = Ne2(i2, n3, r2), t4[e3 + 0 + 64] = Ne2(n3, r2, a3), t4[e3 + 0 + 32] = t4[e3 + 1 + 96] = Ne2(r2, a3, o3), t4[e3 + 1 + 32] = t4[e3 + 2 + 96] = Ne2(a3, o3, s3), t4[e3 + 2 + 32] = t4[e3 + 3 + 96] = Ne2(o3, s3, c4), t4[e3 + 3 + 32] = Ne2(s3, c4, u4);
    }
    function ke(t4, e3) {
      var r2 = t4[e3 + 0 - 32], n3 = t4[e3 + 1 - 32], i2 = t4[e3 + 2 - 32], a3 = t4[e3 + 3 - 32], o3 = t4[e3 + 4 - 32], s3 = t4[e3 + 5 - 32], c4 = t4[e3 + 6 - 32], u4 = t4[e3 + 7 - 32];
      t4[e3 + 0 + 0] = r2 + n3 + 1 >> 1, t4[e3 + 1 + 0] = t4[e3 + 0 + 64] = n3 + i2 + 1 >> 1, t4[e3 + 2 + 0] = t4[e3 + 1 + 64] = i2 + a3 + 1 >> 1, t4[e3 + 3 + 0] = t4[e3 + 2 + 64] = a3 + o3 + 1 >> 1, t4[e3 + 0 + 32] = Ne2(r2, n3, i2), t4[e3 + 1 + 32] = t4[e3 + 0 + 96] = Ne2(n3, i2, a3), t4[e3 + 2 + 32] = t4[e3 + 1 + 96] = Ne2(i2, a3, o3), t4[e3 + 3 + 32] = t4[e3 + 2 + 96] = Ne2(a3, o3, s3), t4[e3 + 3 + 64] = Ne2(o3, s3, c4), t4[e3 + 3 + 96] = Ne2(s3, c4, u4);
    }
    function Ie(t4, e3) {
      var r2 = t4[e3 - 1 + 0], n3 = t4[e3 - 1 + 32], i2 = t4[e3 - 1 + 64], a3 = t4[e3 - 1 + 96];
      t4[e3 + 0 + 0] = r2 + n3 + 1 >> 1, t4[e3 + 2 + 0] = t4[e3 + 0 + 32] = n3 + i2 + 1 >> 1, t4[e3 + 2 + 32] = t4[e3 + 0 + 64] = i2 + a3 + 1 >> 1, t4[e3 + 1 + 0] = Ne2(r2, n3, i2), t4[e3 + 3 + 0] = t4[e3 + 1 + 32] = Ne2(n3, i2, a3), t4[e3 + 3 + 32] = t4[e3 + 1 + 64] = Ne2(i2, a3, a3), t4[e3 + 3 + 64] = t4[e3 + 2 + 64] = t4[e3 + 0 + 96] = t4[e3 + 1 + 96] = t4[e3 + 2 + 96] = t4[e3 + 3 + 96] = a3;
    }
    function Fe(t4, e3) {
      var r2 = t4[e3 - 1 + 0], n3 = t4[e3 - 1 + 32], i2 = t4[e3 - 1 + 64], a3 = t4[e3 - 1 + 96], o3 = t4[e3 - 1 - 32], s3 = t4[e3 + 0 - 32], c4 = t4[e3 + 1 - 32], u4 = t4[e3 + 2 - 32];
      t4[e3 + 0 + 0] = t4[e3 + 2 + 32] = r2 + o3 + 1 >> 1, t4[e3 + 0 + 32] = t4[e3 + 2 + 64] = n3 + r2 + 1 >> 1, t4[e3 + 0 + 64] = t4[e3 + 2 + 96] = i2 + n3 + 1 >> 1, t4[e3 + 0 + 96] = a3 + i2 + 1 >> 1, t4[e3 + 3 + 0] = Ne2(s3, c4, u4), t4[e3 + 2 + 0] = Ne2(o3, s3, c4), t4[e3 + 1 + 0] = t4[e3 + 3 + 32] = Ne2(r2, o3, s3), t4[e3 + 1 + 32] = t4[e3 + 3 + 64] = Ne2(n3, r2, o3), t4[e3 + 1 + 64] = t4[e3 + 3 + 96] = Ne2(i2, n3, r2), t4[e3 + 1 + 96] = Ne2(a3, i2, n3);
    }
    function Ce(t4, e3) {
      var r2;
      for (r2 = 0; 8 > r2; ++r2) n2(t4, e3 + 32 * r2, t4, e3 - 32, 8);
    }
    function je(t4, e3) {
      var r2;
      for (r2 = 0; 8 > r2; ++r2) i(t4, e3, t4[e3 - 1], 8), e3 += 32;
    }
    function Oe(t4, e3, r2) {
      var n3;
      for (n3 = 0; 8 > n3; ++n3) i(e3, r2 + 32 * n3, t4, 8);
    }
    function Be(t4, e3) {
      var r2, n3 = 8;
      for (r2 = 0; 8 > r2; ++r2) n3 += t4[e3 + r2 - 32] + t4[e3 - 1 + 32 * r2];
      Oe(n3 >> 4, t4, e3);
    }
    function Me(t4, e3) {
      var r2, n3 = 4;
      for (r2 = 0; 8 > r2; ++r2) n3 += t4[e3 + r2 - 32];
      Oe(n3 >> 3, t4, e3);
    }
    function Ee(t4, e3) {
      var r2, n3 = 4;
      for (r2 = 0; 8 > r2; ++r2) n3 += t4[e3 - 1 + 32 * r2];
      Oe(n3 >> 3, t4, e3);
    }
    function qe2(t4, e3) {
      Oe(128, t4, e3);
    }
    function De(t4, e3, r2) {
      var n3 = t4[e3 - r2], i2 = t4[e3 + 0], a3 = 3 * (i2 - n3) + jn[1020 + t4[e3 - 2 * r2] - t4[e3 + r2]], o3 = On[112 + (a3 + 4 >> 3)];
      t4[e3 - r2] = Bn[255 + n3 + On[112 + (a3 + 3 >> 3)]], t4[e3 + 0] = Bn[255 + i2 - o3];
    }
    function Re(t4, e3, r2, n3) {
      var i2 = t4[e3 + 0], a3 = t4[e3 + r2];
      return Mn[255 + t4[e3 - 2 * r2] - t4[e3 - r2]] > n3 || Mn[255 + a3 - i2] > n3;
    }
    function Te(t4, e3, r2, n3) {
      return 4 * Mn[255 + t4[e3 - r2] - t4[e3 + 0]] + Mn[255 + t4[e3 - 2 * r2] - t4[e3 + r2]] <= n3;
    }
    function Ue2(t4, e3, r2, n3, i2) {
      var a3 = t4[e3 - 3 * r2], o3 = t4[e3 - 2 * r2], s3 = t4[e3 - r2], c4 = t4[e3 + 0], u4 = t4[e3 + r2], h4 = t4[e3 + 2 * r2], l4 = t4[e3 + 3 * r2];
      return 4 * Mn[255 + s3 - c4] + Mn[255 + o3 - u4] > n3 ? 0 : Mn[255 + t4[e3 - 4 * r2] - a3] <= i2 && Mn[255 + a3 - o3] <= i2 && Mn[255 + o3 - s3] <= i2 && Mn[255 + l4 - h4] <= i2 && Mn[255 + h4 - u4] <= i2 && Mn[255 + u4 - c4] <= i2;
    }
    function ze(t4, e3, r2, n3) {
      var i2 = 2 * n3 + 1;
      for (n3 = 0; 16 > n3; ++n3) Te(t4, e3 + n3, r2, i2) && De(t4, e3 + n3, r2);
    }
    function He(t4, e3, r2, n3) {
      var i2 = 2 * n3 + 1;
      for (n3 = 0; 16 > n3; ++n3) Te(t4, e3 + n3 * r2, 1, i2) && De(t4, e3 + n3 * r2, 1);
    }
    function We(t4, e3, r2, n3) {
      var i2;
      for (i2 = 3; 0 < i2; --i2) ze(t4, e3 += 4 * r2, r2, n3);
    }
    function Ve(t4, e3, r2, n3) {
      var i2;
      for (i2 = 3; 0 < i2; --i2) He(t4, e3 += 4, r2, n3);
    }
    function Ge(t4, e3, r2, n3, i2, a3, o3, s3) {
      for (a3 = 2 * a3 + 1; 0 < i2--; ) {
        if (Ue2(t4, e3, r2, a3, o3)) if (Re(t4, e3, r2, s3)) De(t4, e3, r2);
        else {
          var c4 = t4, u4 = e3, h4 = r2, l4 = c4[u4 - 2 * h4], f4 = c4[u4 - h4], d4 = c4[u4 + 0], p4 = c4[u4 + h4], g4 = c4[u4 + 2 * h4], m4 = 27 * (b4 = jn[1020 + 3 * (d4 - f4) + jn[1020 + l4 - p4]]) + 63 >> 7, v4 = 18 * b4 + 63 >> 7, b4 = 9 * b4 + 63 >> 7;
          c4[u4 - 3 * h4] = Bn[255 + c4[u4 - 3 * h4] + b4], c4[u4 - 2 * h4] = Bn[255 + l4 + v4], c4[u4 - h4] = Bn[255 + f4 + m4], c4[u4 + 0] = Bn[255 + d4 - m4], c4[u4 + h4] = Bn[255 + p4 - v4], c4[u4 + 2 * h4] = Bn[255 + g4 - b4];
        }
        e3 += n3;
      }
    }
    function Ye(t4, e3, r2, n3, i2, a3, o3, s3) {
      for (a3 = 2 * a3 + 1; 0 < i2--; ) {
        if (Ue2(t4, e3, r2, a3, o3)) if (Re(t4, e3, r2, s3)) De(t4, e3, r2);
        else {
          var c4 = t4, u4 = e3, h4 = r2, l4 = c4[u4 - h4], f4 = c4[u4 + 0], d4 = c4[u4 + h4], p4 = On[112 + ((g4 = 3 * (f4 - l4)) + 4 >> 3)], g4 = On[112 + (g4 + 3 >> 3)], m4 = p4 + 1 >> 1;
          c4[u4 - 2 * h4] = Bn[255 + c4[u4 - 2 * h4] + m4], c4[u4 - h4] = Bn[255 + l4 + g4], c4[u4 + 0] = Bn[255 + f4 - p4], c4[u4 + h4] = Bn[255 + d4 - m4];
        }
        e3 += n3;
      }
    }
    function Je(t4, e3, r2, n3, i2, a3) {
      Ge(t4, e3, r2, 1, 16, n3, i2, a3);
    }
    function Xe(t4, e3, r2, n3, i2, a3) {
      Ge(t4, e3, 1, r2, 16, n3, i2, a3);
    }
    function Ke(t4, e3, r2, n3, i2, a3) {
      var o3;
      for (o3 = 3; 0 < o3; --o3) Ye(t4, e3 += 4 * r2, r2, 1, 16, n3, i2, a3);
    }
    function Ze(t4, e3, r2, n3, i2, a3) {
      var o3;
      for (o3 = 3; 0 < o3; --o3) Ye(t4, e3 += 4, 1, r2, 16, n3, i2, a3);
    }
    function $e(t4, e3, r2, n3, i2, a3, o3, s3) {
      Ge(t4, e3, i2, 1, 8, a3, o3, s3), Ge(r2, n3, i2, 1, 8, a3, o3, s3);
    }
    function Qe(t4, e3, r2, n3, i2, a3, o3, s3) {
      Ge(t4, e3, 1, i2, 8, a3, o3, s3), Ge(r2, n3, 1, i2, 8, a3, o3, s3);
    }
    function tr(t4, e3, r2, n3, i2, a3, o3, s3) {
      Ye(t4, e3 + 4 * i2, i2, 1, 8, a3, o3, s3), Ye(r2, n3 + 4 * i2, i2, 1, 8, a3, o3, s3);
    }
    function er(t4, e3, r2, n3, i2, a3, o3, s3) {
      Ye(t4, e3 + 4, 1, i2, 8, a3, o3, s3), Ye(r2, n3 + 4, 1, i2, 8, a3, o3, s3);
    }
    function rr() {
      this.ba = new ot2(), this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new ct2(), this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc";
    }
    function nr() {
      this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
    }
    function ir() {
      this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;
    }
    function ar() {
      this.ua = 0, this.Wa = new M2(), this.vb = new M2(), this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new d3(), this.yc = new l3();
    }
    function or() {
      this.xb = this.a = 0, this.l = new Gt2(), this.ca = new ot2(), this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new N3(), this.Pb = 0, this.wd = new N3(), this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new ar(), this.ab = 0, this.gc = o2(4, ir), this.Oc = 0;
    }
    function sr() {
      this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new Gt2(), this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;
    }
    function cr(t4, e3, r2, n3, i2, a3, o3) {
      for (t4 = null == t4 ? 0 : t4[e3 + 0], e3 = 0; e3 < o3; ++e3) i2[a3 + e3] = t4 + r2[n3 + e3] & 255, t4 = i2[a3 + e3];
    }
    function ur(t4, e3, r2, n3, i2, a3, o3) {
      var s3;
      if (null == t4) cr(null, null, r2, n3, i2, a3, o3);
      else for (s3 = 0; s3 < o3; ++s3) i2[a3 + s3] = t4[e3 + s3] + r2[n3 + s3] & 255;
    }
    function hr(t4, e3, r2, n3, i2, a3, o3) {
      if (null == t4) cr(null, null, r2, n3, i2, a3, o3);
      else {
        var s3, c4 = t4[e3 + 0], u4 = c4, h4 = c4;
        for (s3 = 0; s3 < o3; ++s3) u4 = h4 + (c4 = t4[e3 + s3]) - u4, h4 = r2[n3 + s3] + (-256 & u4 ? 0 > u4 ? 0 : 255 : u4) & 255, u4 = c4, i2[a3 + s3] = h4;
      }
    }
    function lr(t4, r2, i2, o3) {
      var s3 = r2.width, c4 = r2.o;
      if (e2(null != t4 && null != r2), 0 > i2 || 0 >= o3 || i2 + o3 > c4) return null;
      if (!t4.Cc) {
        if (null == t4.ga) {
          var u4;
          if (t4.ga = new sr(), (u4 = null == t4.ga) || (u4 = r2.width * r2.o, e2(0 == t4.Gb.length), t4.Gb = a2(u4), t4.Uc = 0, null == t4.Gb ? u4 = 0 : (t4.mb = t4.Gb, t4.nb = t4.Uc, t4.rc = null, u4 = 1), u4 = !u4), !u4) {
            u4 = t4.ga;
            var h4 = t4.Fa, l4 = t4.P, f4 = t4.qc, d4 = t4.mb, p4 = t4.nb, g4 = l4 + 1, m4 = f4 - 1, b4 = u4.l;
            if (e2(null != h4 && null != d4 && null != r2), mi[0] = null, mi[1] = cr, mi[2] = ur, mi[3] = hr, u4.ca = d4, u4.tb = p4, u4.c = r2.width, u4.i = r2.height, e2(0 < u4.c && 0 < u4.i), 1 >= f4) r2 = 0;
            else if (u4.$a = h4[l4 + 0] >> 0 & 3, u4.Z = h4[l4 + 0] >> 2 & 3, u4.Lc = h4[l4 + 0] >> 4 & 3, l4 = h4[l4 + 0] >> 6 & 3, 0 > u4.$a || 1 < u4.$a || 4 <= u4.Z || 1 < u4.Lc || l4) r2 = 0;
            else if (b4.put = dt2, b4.ac = ft2, b4.bc = pt2, b4.ma = u4, b4.width = r2.width, b4.height = r2.height, b4.Da = r2.Da, b4.v = r2.v, b4.va = r2.va, b4.j = r2.j, b4.o = r2.o, u4.$a) t: {
              e2(1 == u4.$a), r2 = kt2();
              e: for (; ; ) {
                if (null == r2) {
                  r2 = 0;
                  break t;
                }
                if (e2(null != u4), u4.mc = r2, r2.c = u4.c, r2.i = u4.i, r2.l = u4.l, r2.l.ma = u4, r2.l.width = u4.c, r2.l.height = u4.i, r2.a = 0, v3(r2.m, h4, g4, m4), !It2(u4.c, u4.i, 1, r2, null)) break e;
                if (1 == r2.ab && 3 == r2.gc[0].hc && At2(r2.s) ? (u4.ic = 1, h4 = r2.c * r2.i, r2.Ta = null, r2.Ua = 0, r2.V = a2(h4), r2.Ba = 0, null == r2.V ? (r2.a = 1, r2 = 0) : r2 = 1) : (u4.ic = 0, r2 = Ft2(r2, u4.c)), !r2) break e;
                r2 = 1;
                break t;
              }
              u4.mc = null, r2 = 0;
            }
            else r2 = m4 >= u4.c * u4.i;
            u4 = !r2;
          }
          if (u4) return null;
          1 != t4.ga.Lc ? t4.Ga = 0 : o3 = c4 - i2;
        }
        e2(null != t4.ga), e2(i2 + o3 <= c4);
        t: {
          if (r2 = (h4 = t4.ga).c, c4 = h4.l.o, 0 == h4.$a) {
            if (g4 = t4.rc, m4 = t4.Vc, b4 = t4.Fa, l4 = t4.P + 1 + i2 * r2, f4 = t4.mb, d4 = t4.nb + i2 * r2, e2(l4 <= t4.P + t4.qc), 0 != h4.Z) for (e2(null != mi[h4.Z]), u4 = 0; u4 < o3; ++u4) mi[h4.Z](g4, m4, b4, l4, f4, d4, r2), g4 = f4, m4 = d4, d4 += r2, l4 += r2;
            else for (u4 = 0; u4 < o3; ++u4) n2(f4, d4, b4, l4, r2), g4 = f4, m4 = d4, d4 += r2, l4 += r2;
            t4.rc = g4, t4.Vc = m4;
          } else {
            if (e2(null != h4.mc), r2 = i2 + o3, e2(null != (u4 = h4.mc)), e2(r2 <= u4.i), u4.C >= r2) r2 = 1;
            else if (h4.ic || mr(), h4.ic) {
              h4 = u4.V, g4 = u4.Ba, m4 = u4.c;
              var y4 = u4.i, w4 = (b4 = 1, l4 = u4.$ / m4, f4 = u4.$ % m4, d4 = u4.m, p4 = u4.s, u4.$), N4 = m4 * y4, L4 = m4 * r2, x3 = p4.wc, _3 = w4 < L4 ? wt2(p4, f4, l4) : null;
              e2(w4 <= N4), e2(r2 <= y4), e2(At2(p4));
              e: for (; ; ) {
                for (; !d4.h && w4 < L4; ) {
                  if (f4 & x3 || (_3 = wt2(p4, f4, l4)), e2(null != _3), S2(d4), 256 > (y4 = bt2(_3.G[0], _3.H[0], d4))) h4[g4 + w4] = y4, ++w4, ++f4 >= m4 && (f4 = 0, ++l4 <= r2 && !(l4 % 16) && St(u4, l4));
                  else {
                    if (!(280 > y4)) {
                      b4 = 0;
                      break e;
                    }
                    y4 = mt2(y4 - 256, d4);
                    var P3, k3 = bt2(_3.G[4], _3.H[4], d4);
                    if (S2(d4), !(w4 >= (k3 = vt2(m4, k3 = mt2(k3, d4))) && N4 - w4 >= y4)) {
                      b4 = 0;
                      break e;
                    }
                    for (P3 = 0; P3 < y4; ++P3) h4[g4 + w4 + P3] = h4[g4 + w4 + P3 - k3];
                    for (w4 += y4, f4 += y4; f4 >= m4; ) f4 -= m4, ++l4 <= r2 && !(l4 % 16) && St(u4, l4);
                    w4 < L4 && f4 & x3 && (_3 = wt2(p4, f4, l4));
                  }
                  e2(d4.h == A3(d4));
                }
                St(u4, l4 > r2 ? r2 : l4);
                break e;
              }
              !b4 || d4.h && w4 < N4 ? (b4 = 0, u4.a = d4.h ? 5 : 3) : u4.$ = w4, r2 = b4;
            } else r2 = _t2(u4, u4.V, u4.Ba, u4.c, u4.i, r2, Ct2);
            if (!r2) {
              o3 = 0;
              break t;
            }
          }
          i2 + o3 >= c4 && (t4.Cc = 1), o3 = 1;
        }
        if (!o3) return null;
        if (t4.Cc && (null != (o3 = t4.ga) && (o3.mc = null), t4.ga = null, 0 < t4.Ga)) return alert("todo:WebPDequantizeLevels"), null;
      }
      return t4.nb + i2 * s3;
    }
    function fr(t4, e3, r2, n3, i2, a3) {
      for (; 0 < i2--; ) {
        var o3, s3 = t4, c4 = e3 + (r2 ? 1 : 0), u4 = t4, h4 = e3 + (r2 ? 0 : 3);
        for (o3 = 0; o3 < n3; ++o3) {
          var l4 = u4[h4 + 4 * o3];
          255 != l4 && (l4 *= 32897, s3[c4 + 4 * o3 + 0] = s3[c4 + 4 * o3 + 0] * l4 >> 23, s3[c4 + 4 * o3 + 1] = s3[c4 + 4 * o3 + 1] * l4 >> 23, s3[c4 + 4 * o3 + 2] = s3[c4 + 4 * o3 + 2] * l4 >> 23);
        }
        e3 += a3;
      }
    }
    function dr(t4, e3, r2, n3, i2) {
      for (; 0 < n3--; ) {
        var a3;
        for (a3 = 0; a3 < r2; ++a3) {
          var o3 = t4[e3 + 2 * a3 + 0], s3 = 15 & (u4 = t4[e3 + 2 * a3 + 1]), c4 = 4369 * s3, u4 = (240 & u4 | u4 >> 4) * c4 >> 16;
          t4[e3 + 2 * a3 + 0] = (240 & o3 | o3 >> 4) * c4 >> 16 & 240 | (15 & o3 | o3 << 4) * c4 >> 16 >> 4 & 15, t4[e3 + 2 * a3 + 1] = 240 & u4 | s3;
        }
        e3 += i2;
      }
    }
    function pr(t4, e3, r2, n3, i2, a3, o3, s3) {
      var c4, u4, h4 = 255;
      for (u4 = 0; u4 < i2; ++u4) {
        for (c4 = 0; c4 < n3; ++c4) {
          var l4 = t4[e3 + c4];
          a3[o3 + 4 * c4] = l4, h4 &= l4;
        }
        e3 += r2, o3 += s3;
      }
      return 255 != h4;
    }
    function gr(t4, e3, r2, n3, i2) {
      var a3;
      for (a3 = 0; a3 < i2; ++a3) r2[n3 + a3] = t4[e3 + a3] >> 8;
    }
    function mr() {
      An = fr, xn = dr, Sn = pr, _n = gr;
    }
    function vr(r2, n3, i2) {
      t3[r2] = function(t4, r3, a3, o3, s3, c4, u4, h4, l4, f4, d4, p4, g4, m4, v4, b4, y4) {
        var w4, N4 = y4 - 1 >> 1, L4 = s3[c4 + 0] | u4[h4 + 0] << 16, A4 = l4[f4 + 0] | d4[p4 + 0] << 16;
        e2(null != t4);
        var x3 = 3 * L4 + A4 + 131074 >> 2;
        for (n3(t4[r3 + 0], 255 & x3, x3 >> 16, g4, m4), null != a3 && (x3 = 3 * A4 + L4 + 131074 >> 2, n3(a3[o3 + 0], 255 & x3, x3 >> 16, v4, b4)), w4 = 1; w4 <= N4; ++w4) {
          var S3 = s3[c4 + w4] | u4[h4 + w4] << 16, _3 = l4[f4 + w4] | d4[p4 + w4] << 16, P3 = L4 + S3 + A4 + _3 + 524296, k3 = P3 + 2 * (S3 + A4) >> 3;
          x3 = k3 + L4 >> 1, L4 = (P3 = P3 + 2 * (L4 + _3) >> 3) + S3 >> 1, n3(t4[r3 + 2 * w4 - 1], 255 & x3, x3 >> 16, g4, m4 + (2 * w4 - 1) * i2), n3(t4[r3 + 2 * w4 - 0], 255 & L4, L4 >> 16, g4, m4 + (2 * w4 - 0) * i2), null != a3 && (x3 = P3 + A4 >> 1, L4 = k3 + _3 >> 1, n3(a3[o3 + 2 * w4 - 1], 255 & x3, x3 >> 16, v4, b4 + (2 * w4 - 1) * i2), n3(a3[o3 + 2 * w4 + 0], 255 & L4, L4 >> 16, v4, b4 + (2 * w4 + 0) * i2)), L4 = S3, A4 = _3;
        }
        1 & y4 || (x3 = 3 * L4 + A4 + 131074 >> 2, n3(t4[r3 + y4 - 1], 255 & x3, x3 >> 16, g4, m4 + (y4 - 1) * i2), null != a3 && (x3 = 3 * A4 + L4 + 131074 >> 2, n3(a3[o3 + y4 - 1], 255 & x3, x3 >> 16, v4, b4 + (y4 - 1) * i2)));
      };
    }
    function br() {
      vi[En] = bi, vi[qn] = wi, vi[Dn] = yi, vi[Rn] = Ni, vi[Tn] = Li, vi[Un] = Ai, vi[zn] = xi, vi[Hn] = wi, vi[Wn] = Ni, vi[Vn] = Li, vi[Gn] = Ai;
    }
    function yr(t4) {
      return t4 & ~Fi ? 0 > t4 ? 0 : 255 : t4 >> Ii;
    }
    function wr(t4, e3) {
      return yr((19077 * t4 >> 8) + (26149 * e3 >> 8) - 14234);
    }
    function Nr(t4, e3, r2) {
      return yr((19077 * t4 >> 8) - (6419 * e3 >> 8) - (13320 * r2 >> 8) + 8708);
    }
    function Lr(t4, e3) {
      return yr((19077 * t4 >> 8) + (33050 * e3 >> 8) - 17685);
    }
    function Ar(t4, e3, r2, n3, i2) {
      n3[i2 + 0] = wr(t4, r2), n3[i2 + 1] = Nr(t4, e3, r2), n3[i2 + 2] = Lr(t4, e3);
    }
    function xr(t4, e3, r2, n3, i2) {
      n3[i2 + 0] = Lr(t4, e3), n3[i2 + 1] = Nr(t4, e3, r2), n3[i2 + 2] = wr(t4, r2);
    }
    function Sr(t4, e3, r2, n3, i2) {
      var a3 = Nr(t4, e3, r2);
      e3 = a3 << 3 & 224 | Lr(t4, e3) >> 3, n3[i2 + 0] = 248 & wr(t4, r2) | a3 >> 5, n3[i2 + 1] = e3;
    }
    function _r(t4, e3, r2, n3, i2) {
      var a3 = 240 & Lr(t4, e3) | 15;
      n3[i2 + 0] = 240 & wr(t4, r2) | Nr(t4, e3, r2) >> 4, n3[i2 + 1] = a3;
    }
    function Pr(t4, e3, r2, n3, i2) {
      n3[i2 + 0] = 255, Ar(t4, e3, r2, n3, i2 + 1);
    }
    function kr(t4, e3, r2, n3, i2) {
      xr(t4, e3, r2, n3, i2), n3[i2 + 3] = 255;
    }
    function Ir(t4, e3, r2, n3, i2) {
      Ar(t4, e3, r2, n3, i2), n3[i2 + 3] = 255;
    }
    function Vt2(t4, e3) {
      return 0 > t4 ? 0 : t4 > e3 ? e3 : t4;
    }
    function Fr(e3, r2, n3) {
      t3[e3] = function(t4, e4, i2, a3, o3, s3, c4, u4, h4) {
        for (var l4 = u4 + (-2 & h4) * n3; u4 != l4; ) r2(t4[e4 + 0], i2[a3 + 0], o3[s3 + 0], c4, u4), r2(t4[e4 + 1], i2[a3 + 0], o3[s3 + 0], c4, u4 + n3), e4 += 2, ++a3, ++s3, u4 += 2 * n3;
        1 & h4 && r2(t4[e4 + 0], i2[a3 + 0], o3[s3 + 0], c4, u4);
      };
    }
    function Cr(t4, e3, r2) {
      return 0 == r2 ? 0 == t4 ? 0 == e3 ? 6 : 5 : 0 == e3 ? 4 : 0 : r2;
    }
    function jr(t4, e3, r2, n3, i2) {
      switch (t4 >>> 30) {
        case 3:
          on2(e3, r2, n3, i2, 0);
          break;
        case 2:
          sn(e3, r2, n3, i2);
          break;
        case 1:
          un(e3, r2, n3, i2);
      }
    }
    function Or(t4, e3) {
      var r2, a3, o3 = e3.M, s3 = e3.Nb, c4 = t4.oc, u4 = t4.pc + 40, h4 = t4.oc, l4 = t4.pc + 584, f4 = t4.oc, d4 = t4.pc + 600;
      for (r2 = 0; 16 > r2; ++r2) c4[u4 + 32 * r2 - 1] = 129;
      for (r2 = 0; 8 > r2; ++r2) h4[l4 + 32 * r2 - 1] = 129, f4[d4 + 32 * r2 - 1] = 129;
      for (0 < o3 ? c4[u4 - 1 - 32] = h4[l4 - 1 - 32] = f4[d4 - 1 - 32] = 129 : (i(c4, u4 - 32 - 1, 127, 21), i(h4, l4 - 32 - 1, 127, 9), i(f4, d4 - 32 - 1, 127, 9)), a3 = 0; a3 < t4.za; ++a3) {
        var p4 = e3.ya[e3.aa + a3];
        if (0 < a3) {
          for (r2 = -1; 16 > r2; ++r2) n2(c4, u4 + 32 * r2 - 4, c4, u4 + 32 * r2 + 12, 4);
          for (r2 = -1; 8 > r2; ++r2) n2(h4, l4 + 32 * r2 - 4, h4, l4 + 32 * r2 + 4, 4), n2(f4, d4 + 32 * r2 - 4, f4, d4 + 32 * r2 + 4, 4);
        }
        var g4 = t4.Gd, m4 = t4.Hd + a3, v4 = p4.ad, b4 = p4.Hc;
        if (0 < o3 && (n2(c4, u4 - 32, g4[m4].y, 0, 16), n2(h4, l4 - 32, g4[m4].f, 0, 8), n2(f4, d4 - 32, g4[m4].ea, 0, 8)), p4.Za) {
          var y4 = c4, w4 = u4 - 32 + 16;
          for (0 < o3 && (a3 >= t4.za - 1 ? i(y4, w4, g4[m4].y[15], 4) : n2(y4, w4, g4[m4 + 1].y, 0, 4)), r2 = 0; 4 > r2; r2++) y4[w4 + 128 + r2] = y4[w4 + 256 + r2] = y4[w4 + 384 + r2] = y4[w4 + 0 + r2];
          for (r2 = 0; 16 > r2; ++r2, b4 <<= 2) y4 = c4, w4 = u4 + Di[r2], fi[p4.Ob[r2]](y4, w4), jr(b4, v4, 16 * +r2, y4, w4);
        } else if (y4 = Cr(a3, o3, p4.Ob[0]), li[y4](c4, u4), 0 != b4) for (r2 = 0; 16 > r2; ++r2, b4 <<= 2) jr(b4, v4, 16 * +r2, c4, u4 + Di[r2]);
        for (r2 = p4.Gc, y4 = Cr(a3, o3, p4.Dd), di[y4](h4, l4), di[y4](f4, d4), b4 = v4, y4 = h4, w4 = l4, 255 & (p4 = r2 >> 0) && (170 & p4 ? cn(b4, 256, y4, w4) : hn(b4, 256, y4, w4)), p4 = f4, b4 = d4, 255 & (r2 >>= 8) && (170 & r2 ? cn(v4, 320, p4, b4) : hn(v4, 320, p4, b4)), o3 < t4.Ub - 1 && (n2(g4[m4].y, 0, c4, u4 + 480, 16), n2(g4[m4].f, 0, h4, l4 + 224, 8), n2(g4[m4].ea, 0, f4, d4 + 224, 8)), r2 = 8 * s3 * t4.B, g4 = t4.sa, m4 = t4.ta + 16 * a3 + 16 * s3 * t4.R, v4 = t4.qa, p4 = t4.ra + 8 * a3 + r2, b4 = t4.Ha, y4 = t4.Ia + 8 * a3 + r2, r2 = 0; 16 > r2; ++r2) n2(g4, m4 + r2 * t4.R, c4, u4 + 32 * r2, 16);
        for (r2 = 0; 8 > r2; ++r2) n2(v4, p4 + r2 * t4.B, h4, l4 + 32 * r2, 8), n2(b4, y4 + r2 * t4.B, f4, d4 + 32 * r2, 8);
      }
    }
    function Br(t4, n3, i2, a3, o3, s3, c4, u4, h4) {
      var l4 = [0], f4 = [0], d4 = 0, p4 = null != h4 ? h4.kd : 0, g4 = null != h4 ? h4 : new nr();
      if (null == t4 || 12 > i2) return 7;
      g4.data = t4, g4.w = n3, g4.ha = i2, n3 = [n3], i2 = [i2], g4.gb = [g4.gb];
      t: {
        var m4 = n3, b4 = i2, y4 = g4.gb;
        if (e2(null != t4), e2(null != b4), e2(null != y4), y4[0] = 0, 12 <= b4[0] && !r(t4, m4[0], "RIFF")) {
          if (r(t4, m4[0] + 8, "WEBP")) {
            y4 = 3;
            break t;
          }
          var w4 = j2(t4, m4[0] + 4);
          if (12 > w4 || 4294967286 < w4) {
            y4 = 3;
            break t;
          }
          if (p4 && w4 > b4[0] - 8) {
            y4 = 7;
            break t;
          }
          y4[0] = w4, m4[0] += 12, b4[0] -= 12;
        }
        y4 = 0;
      }
      if (0 != y4) return y4;
      for (w4 = 0 < g4.gb[0], i2 = i2[0]; ; ) {
        t: {
          var L4 = t4;
          b4 = n3, y4 = i2;
          var A4 = l4, x3 = f4, S3 = m4 = [0];
          if ((k3 = d4 = [d4])[0] = 0, 8 > y4[0]) y4 = 7;
          else {
            if (!r(L4, b4[0], "VP8X")) {
              if (10 != j2(L4, b4[0] + 4)) {
                y4 = 3;
                break t;
              }
              if (18 > y4[0]) {
                y4 = 7;
                break t;
              }
              var _3 = j2(L4, b4[0] + 8), P3 = 1 + C2(L4, b4[0] + 12);
              if (2147483648 <= P3 * (L4 = 1 + C2(L4, b4[0] + 15))) {
                y4 = 3;
                break t;
              }
              null != S3 && (S3[0] = _3), null != A4 && (A4[0] = P3), null != x3 && (x3[0] = L4), b4[0] += 18, y4[0] -= 18, k3[0] = 1;
            }
            y4 = 0;
          }
        }
        if (d4 = d4[0], m4 = m4[0], 0 != y4) return y4;
        if (b4 = !!(2 & m4), !w4 && d4) return 3;
        if (null != s3 && (s3[0] = !!(16 & m4)), null != c4 && (c4[0] = b4), null != u4 && (u4[0] = 0), c4 = l4[0], m4 = f4[0], d4 && b4 && null == h4) {
          y4 = 0;
          break;
        }
        if (4 > i2) {
          y4 = 7;
          break;
        }
        if (w4 && d4 || !w4 && !d4 && !r(t4, n3[0], "ALPH")) {
          i2 = [i2], g4.na = [g4.na], g4.P = [g4.P], g4.Sa = [g4.Sa];
          t: {
            _3 = t4, y4 = n3, w4 = i2;
            var k3 = g4.gb;
            A4 = g4.na, x3 = g4.P, S3 = g4.Sa;
            P3 = 22, e2(null != _3), e2(null != w4), L4 = y4[0];
            var I3 = w4[0];
            for (e2(null != A4), e2(null != S3), A4[0] = null, x3[0] = null, S3[0] = 0; ; ) {
              if (y4[0] = L4, w4[0] = I3, 8 > I3) {
                y4 = 7;
                break t;
              }
              var F3 = j2(_3, L4 + 4);
              if (4294967286 < F3) {
                y4 = 3;
                break t;
              }
              var O3 = 8 + F3 + 1 & -2;
              if (P3 += O3, 0 < k3 && P3 > k3) {
                y4 = 3;
                break t;
              }
              if (!r(_3, L4, "VP8 ") || !r(_3, L4, "VP8L")) {
                y4 = 0;
                break t;
              }
              if (I3[0] < O3) {
                y4 = 7;
                break t;
              }
              r(_3, L4, "ALPH") || (A4[0] = _3, x3[0] = L4 + 8, S3[0] = F3), L4 += O3, I3 -= O3;
            }
          }
          if (i2 = i2[0], g4.na = g4.na[0], g4.P = g4.P[0], g4.Sa = g4.Sa[0], 0 != y4) break;
        }
        i2 = [i2], g4.Ja = [g4.Ja], g4.xa = [g4.xa];
        t: if (k3 = t4, y4 = n3, w4 = i2, A4 = g4.gb[0], x3 = g4.Ja, S3 = g4.xa, _3 = y4[0], L4 = !r(k3, _3, "VP8 "), P3 = !r(k3, _3, "VP8L"), e2(null != k3), e2(null != w4), e2(null != x3), e2(null != S3), 8 > w4[0]) y4 = 7;
        else {
          if (L4 || P3) {
            if (k3 = j2(k3, _3 + 4), 12 <= A4 && k3 > A4 - 12) {
              y4 = 3;
              break t;
            }
            if (p4 && k3 > w4[0] - 8) {
              y4 = 7;
              break t;
            }
            x3[0] = k3, y4[0] += 8, w4[0] -= 8, S3[0] = P3;
          } else S3[0] = 5 <= w4[0] && 47 == k3[_3 + 0] && !(k3[_3 + 4] >> 5), x3[0] = w4[0];
          y4 = 0;
        }
        if (i2 = i2[0], g4.Ja = g4.Ja[0], g4.xa = g4.xa[0], n3 = n3[0], 0 != y4) break;
        if (4294967286 < g4.Ja) return 3;
        if (null == u4 || b4 || (u4[0] = g4.xa ? 2 : 1), c4 = [c4], m4 = [m4], g4.xa) {
          if (5 > i2) {
            y4 = 7;
            break;
          }
          u4 = c4, p4 = m4, b4 = s3, null == t4 || 5 > i2 ? t4 = 0 : 5 <= i2 && 47 == t4[n3 + 0] && !(t4[n3 + 4] >> 5) ? (w4 = [0], k3 = [0], A4 = [0], v3(x3 = new N3(), t4, n3, i2), gt2(x3, w4, k3, A4) ? (null != u4 && (u4[0] = w4[0]), null != p4 && (p4[0] = k3[0]), null != b4 && (b4[0] = A4[0]), t4 = 1) : t4 = 0) : t4 = 0;
        } else {
          if (10 > i2) {
            y4 = 7;
            break;
          }
          u4 = m4, null == t4 || 10 > i2 || !Xt2(t4, n3 + 3, i2 - 3) ? t4 = 0 : (p4 = t4[n3 + 0] | t4[n3 + 1] << 8 | t4[n3 + 2] << 16, b4 = 16383 & (t4[n3 + 7] << 8 | t4[n3 + 6]), t4 = 16383 & (t4[n3 + 9] << 8 | t4[n3 + 8]), 1 & p4 || 3 < (p4 >> 1 & 7) || !(p4 >> 4 & 1) || p4 >> 5 >= g4.Ja || !b4 || !t4 ? t4 = 0 : (c4 && (c4[0] = b4), u4 && (u4[0] = t4), t4 = 1));
        }
        if (!t4) return 3;
        if (c4 = c4[0], m4 = m4[0], d4 && (l4[0] != c4 || f4[0] != m4)) return 3;
        null != h4 && (h4[0] = g4, h4.offset = n3 - h4.w, e2(4294967286 > n3 - h4.w), e2(h4.offset == h4.ha - i2));
        break;
      }
      return 0 == y4 || 7 == y4 && d4 && null == h4 ? (null != s3 && (s3[0] |= null != g4.na && 0 < g4.na.length), null != a3 && (a3[0] = c4), null != o3 && (o3[0] = m4), 0) : y4;
    }
    function Mr(t4, e3, r2) {
      var n3 = e3.width, i2 = e3.height, a3 = 0, o3 = 0, s3 = n3, c4 = i2;
      if (e3.Da = null != t4 && 0 < t4.Da, e3.Da && (s3 = t4.cd, c4 = t4.bd, a3 = t4.v, o3 = t4.j, 11 > r2 || (a3 &= -2, o3 &= -2), 0 > a3 || 0 > o3 || 0 >= s3 || 0 >= c4 || a3 + s3 > n3 || o3 + c4 > i2)) return 0;
      if (e3.v = a3, e3.j = o3, e3.va = a3 + s3, e3.o = o3 + c4, e3.U = s3, e3.T = c4, e3.da = null != t4 && 0 < t4.da, e3.da) {
        if (!E2(s3, c4, r2 = [t4.ib], a3 = [t4.hb])) return 0;
        e3.ib = r2[0], e3.hb = a3[0];
      }
      return e3.ob = null != t4 && t4.ob, e3.Kb = null == t4 || !t4.Sd, e3.da && (e3.ob = e3.ib < 3 * n3 / 4 && e3.hb < 3 * i2 / 4, e3.Kb = 0), 1;
    }
    function Er(t4) {
      if (null == t4) return 2;
      if (11 > t4.S) {
        var e3 = t4.f.RGBA;
        e3.fb += (t4.height - 1) * e3.A, e3.A = -e3.A;
      } else e3 = t4.f.kb, t4 = t4.height, e3.O += (t4 - 1) * e3.fa, e3.fa = -e3.fa, e3.N += (t4 - 1 >> 1) * e3.Ab, e3.Ab = -e3.Ab, e3.W += (t4 - 1 >> 1) * e3.Db, e3.Db = -e3.Db, null != e3.F && (e3.J += (t4 - 1) * e3.lb, e3.lb = -e3.lb);
      return 0;
    }
    function qr(t4, e3, r2, n3) {
      if (null == n3 || 0 >= t4 || 0 >= e3) return 2;
      if (null != r2) {
        if (r2.Da) {
          var i2 = r2.cd, o3 = r2.bd, s3 = -2 & r2.v, c4 = -2 & r2.j;
          if (0 > s3 || 0 > c4 || 0 >= i2 || 0 >= o3 || s3 + i2 > t4 || c4 + o3 > e3) return 2;
          t4 = i2, e3 = o3;
        }
        if (r2.da) {
          if (!E2(t4, e3, i2 = [r2.ib], o3 = [r2.hb])) return 2;
          t4 = i2[0], e3 = o3[0];
        }
      }
      n3.width = t4, n3.height = e3;
      t: {
        var u4 = n3.width, h4 = n3.height;
        if (t4 = n3.S, 0 >= u4 || 0 >= h4 || !(t4 >= En && 13 > t4)) t4 = 2;
        else {
          if (0 >= n3.Rd && null == n3.sd) {
            s3 = o3 = i2 = e3 = 0;
            var l4 = (c4 = u4 * zi[t4]) * h4;
            if (11 > t4 || (o3 = (h4 + 1) / 2 * (e3 = (u4 + 1) / 2), 12 == t4 && (s3 = (i2 = u4) * h4)), null == (h4 = a2(l4 + 2 * o3 + s3))) {
              t4 = 1;
              break t;
            }
            n3.sd = h4, 11 > t4 ? ((u4 = n3.f.RGBA).eb = h4, u4.fb = 0, u4.A = c4, u4.size = l4) : ((u4 = n3.f.kb).y = h4, u4.O = 0, u4.fa = c4, u4.Fd = l4, u4.f = h4, u4.N = 0 + l4, u4.Ab = e3, u4.Cd = o3, u4.ea = h4, u4.W = 0 + l4 + o3, u4.Db = e3, u4.Ed = o3, 12 == t4 && (u4.F = h4, u4.J = 0 + l4 + 2 * o3), u4.Tc = s3, u4.lb = i2);
          }
          if (e3 = 1, i2 = n3.S, o3 = n3.width, s3 = n3.height, i2 >= En && 13 > i2) if (11 > i2) t4 = n3.f.RGBA, e3 &= (c4 = Math.abs(t4.A)) * (s3 - 1) + o3 <= t4.size, e3 &= c4 >= o3 * zi[i2], e3 &= null != t4.eb;
          else {
            t4 = n3.f.kb, c4 = (o3 + 1) / 2, l4 = (s3 + 1) / 2, u4 = Math.abs(t4.fa);
            h4 = Math.abs(t4.Ab);
            var f4 = Math.abs(t4.Db), d4 = Math.abs(t4.lb), p4 = d4 * (s3 - 1) + o3;
            e3 &= u4 * (s3 - 1) + o3 <= t4.Fd, e3 &= h4 * (l4 - 1) + c4 <= t4.Cd, e3 = (e3 &= f4 * (l4 - 1) + c4 <= t4.Ed) & u4 >= o3 & h4 >= c4 & f4 >= c4, e3 &= null != t4.y, e3 &= null != t4.f, e3 &= null != t4.ea, 12 == i2 && (e3 &= d4 >= o3, e3 &= p4 <= t4.Tc, e3 &= null != t4.F);
          }
          else e3 = 0;
          t4 = e3 ? 0 : 2;
        }
      }
      return 0 != t4 || null != r2 && r2.fd && (t4 = Er(n3)), t4;
    }
    var Dr = 64, Rr = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], Tr = 24, Ur = 32, zr = 8, Hr = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
    R2("Predictor0", "PredictorAdd0"), t3.Predictor0 = function() {
      return 4278190080;
    }, t3.Predictor1 = function(t4) {
      return t4;
    }, t3.Predictor2 = function(t4, e3, r2) {
      return e3[r2 + 0];
    }, t3.Predictor3 = function(t4, e3, r2) {
      return e3[r2 + 1];
    }, t3.Predictor4 = function(t4, e3, r2) {
      return e3[r2 - 1];
    }, t3.Predictor5 = function(t4, e3, r2) {
      return U2(U2(t4, e3[r2 + 1]), e3[r2 + 0]);
    }, t3.Predictor6 = function(t4, e3, r2) {
      return U2(t4, e3[r2 - 1]);
    }, t3.Predictor7 = function(t4, e3, r2) {
      return U2(t4, e3[r2 + 0]);
    }, t3.Predictor8 = function(t4, e3, r2) {
      return U2(e3[r2 - 1], e3[r2 + 0]);
    }, t3.Predictor9 = function(t4, e3, r2) {
      return U2(e3[r2 + 0], e3[r2 + 1]);
    }, t3.Predictor10 = function(t4, e3, r2) {
      return U2(U2(t4, e3[r2 - 1]), U2(e3[r2 + 0], e3[r2 + 1]));
    }, t3.Predictor11 = function(t4, e3, r2) {
      var n3 = e3[r2 + 0];
      return 0 >= W2(n3 >> 24 & 255, t4 >> 24 & 255, (e3 = e3[r2 - 1]) >> 24 & 255) + W2(n3 >> 16 & 255, t4 >> 16 & 255, e3 >> 16 & 255) + W2(n3 >> 8 & 255, t4 >> 8 & 255, e3 >> 8 & 255) + W2(255 & n3, 255 & t4, 255 & e3) ? n3 : t4;
    }, t3.Predictor12 = function(t4, e3, r2) {
      var n3 = e3[r2 + 0];
      return (z2((t4 >> 24 & 255) + (n3 >> 24 & 255) - ((e3 = e3[r2 - 1]) >> 24 & 255)) << 24 | z2((t4 >> 16 & 255) + (n3 >> 16 & 255) - (e3 >> 16 & 255)) << 16 | z2((t4 >> 8 & 255) + (n3 >> 8 & 255) - (e3 >> 8 & 255)) << 8 | z2((255 & t4) + (255 & n3) - (255 & e3))) >>> 0;
    }, t3.Predictor13 = function(t4, e3, r2) {
      var n3 = e3[r2 - 1];
      return (H4((t4 = U2(t4, e3[r2 + 0])) >> 24 & 255, n3 >> 24 & 255) << 24 | H4(t4 >> 16 & 255, n3 >> 16 & 255) << 16 | H4(t4 >> 8 & 255, n3 >> 8 & 255) << 8 | H4(t4 >> 0 & 255, n3 >> 0 & 255)) >>> 0;
    };
    var Wr = t3.PredictorAdd0;
    t3.PredictorAdd1 = V2, R2("Predictor2", "PredictorAdd2"), R2("Predictor3", "PredictorAdd3"), R2("Predictor4", "PredictorAdd4"), R2("Predictor5", "PredictorAdd5"), R2("Predictor6", "PredictorAdd6"), R2("Predictor7", "PredictorAdd7"), R2("Predictor8", "PredictorAdd8"), R2("Predictor9", "PredictorAdd9"), R2("Predictor10", "PredictorAdd10"), R2("Predictor11", "PredictorAdd11"), R2("Predictor12", "PredictorAdd12"), R2("Predictor13", "PredictorAdd13");
    var Vr = t3.PredictorAdd2;
    X2("ColorIndexInverseTransform", "MapARGB", "32b", function(t4) {
      return t4 >> 8 & 255;
    }, function(t4) {
      return t4;
    }), X2("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(t4) {
      return t4;
    }, function(t4) {
      return t4 >> 8 & 255;
    });
    var Gr, Yr = t3.ColorIndexInverseTransform, Jr = t3.MapARGB, Xr = t3.VP8LColorIndexInverseTransformAlpha, Kr = t3.MapAlpha, Zr = t3.VP8LPredictorsAdd = [];
    Zr.length = 16, (t3.VP8LPredictors = []).length = 16, (t3.VP8LPredictorsAdd_C = []).length = 16, (t3.VP8LPredictors_C = []).length = 16;
    var $r, Qr, tn, en, rn, nn, an, on2, sn, cn, un, hn, ln2, fn, dn, pn, gn, mn, vn, bn, yn, wn, Nn, Ln, An, xn, Sn, _n, Pn = a2(511), kn = a2(2041), In = a2(225), Fn = a2(767), Cn = 0, jn = kn, On = In, Bn = Fn, Mn = Pn, En = 0, qn = 1, Dn = 2, Rn = 3, Tn = 4, Un = 5, zn = 6, Hn = 7, Wn = 8, Vn = 9, Gn = 10, Yn = [2, 3, 7], Jn = [3, 3, 11], Xn = [280, 256, 256, 256, 40], Kn = [0, 1, 1, 1, 0], Zn = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], $n = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], Qn = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], ti2 = 8, ei2 = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], ri = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], ni = null, ii2 = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], ai = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], oi = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], si = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], ci = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], ui = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], hi = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], li = [], fi = [], di = [], pi = 1, gi = 2, mi = [], vi = [];
    vr("UpsampleRgbLinePair", Ar, 3), vr("UpsampleBgrLinePair", xr, 3), vr("UpsampleRgbaLinePair", Ir, 4), vr("UpsampleBgraLinePair", kr, 4), vr("UpsampleArgbLinePair", Pr, 4), vr("UpsampleRgba4444LinePair", _r, 2), vr("UpsampleRgb565LinePair", Sr, 2);
    var bi = t3.UpsampleRgbLinePair, yi = t3.UpsampleBgrLinePair, wi = t3.UpsampleRgbaLinePair, Ni = t3.UpsampleBgraLinePair, Li = t3.UpsampleArgbLinePair, Ai = t3.UpsampleRgba4444LinePair, xi = t3.UpsampleRgb565LinePair, Si = 16, _i = 1 << Si - 1, Pi = -227, ki = 482, Ii = 6, Fi = (256 << Ii) - 1, Ci = 0, ji = a2(256), Oi = a2(256), Bi = a2(256), Mi = a2(256), Ei = a2(ki - Pi), qi = a2(ki - Pi);
    Fr("YuvToRgbRow", Ar, 3), Fr("YuvToBgrRow", xr, 3), Fr("YuvToRgbaRow", Ir, 4), Fr("YuvToBgraRow", kr, 4), Fr("YuvToArgbRow", Pr, 4), Fr("YuvToRgba4444Row", _r, 2), Fr("YuvToRgb565Row", Sr, 2);
    var Di = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], Ri = [0, 2, 8], Ti = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], Ui = 1;
    this.WebPDecodeRGBA = function(t4, r2, n3, i2, a3) {
      var o3 = qn, s3 = new rr(), c4 = new ot2();
      s3.ba = c4, c4.S = o3, c4.width = [c4.width], c4.height = [c4.height];
      var u4 = c4.width, h4 = c4.height, l4 = new st2();
      if (null == l4 || null == t4) var f4 = 2;
      else e2(null != l4), f4 = Br(t4, r2, n3, l4.width, l4.height, l4.Pd, l4.Qd, l4.format, null);
      if (0 != f4 ? u4 = 0 : (null != u4 && (u4[0] = l4.width[0]), null != h4 && (h4[0] = l4.height[0]), u4 = 1), u4) {
        c4.width = c4.width[0], c4.height = c4.height[0], null != i2 && (i2[0] = c4.width), null != a3 && (a3[0] = c4.height);
        t: {
          if (i2 = new Gt2(), (a3 = new nr()).data = t4, a3.w = r2, a3.ha = n3, a3.kd = 1, r2 = [0], e2(null != a3), (0 == (t4 = Br(a3.data, a3.w, a3.ha, null, null, null, r2, null, a3)) || 7 == t4) && r2[0] && (t4 = 4), 0 == (r2 = t4)) {
            if (e2(null != s3), i2.data = a3.data, i2.w = a3.w + a3.offset, i2.ha = a3.ha - a3.offset, i2.put = dt2, i2.ac = ft2, i2.bc = pt2, i2.ma = s3, a3.xa) {
              if (null == (t4 = kt2())) {
                s3 = 1;
                break t;
              }
              if (function(t5, r3) {
                var n4 = [0], i3 = [0], a4 = [0];
                e: for (; ; ) {
                  if (null == t5) return 0;
                  if (null == r3) return t5.a = 2, 0;
                  if (t5.l = r3, t5.a = 0, v3(t5.m, r3.data, r3.w, r3.ha), !gt2(t5.m, n4, i3, a4)) {
                    t5.a = 3;
                    break e;
                  }
                  if (t5.xb = gi, r3.width = n4[0], r3.height = i3[0], !It2(n4[0], i3[0], 1, t5, null)) break e;
                  return 1;
                }
                return e2(0 != t5.a), 0;
              }(t4, i2)) {
                if (i2 = 0 == (r2 = qr(i2.width, i2.height, s3.Oa, s3.ba))) {
                  e: {
                    i2 = t4;
                    r: for (; ; ) {
                      if (null == i2) {
                        i2 = 0;
                        break e;
                      }
                      if (e2(null != i2.s.yc), e2(null != i2.s.Ya), e2(0 < i2.s.Wb), e2(null != (n3 = i2.l)), e2(null != (a3 = n3.ma)), 0 != i2.xb) {
                        if (i2.ca = a3.ba, i2.tb = a3.tb, e2(null != i2.ca), !Mr(a3.Oa, n3, Rn)) {
                          i2.a = 2;
                          break r;
                        }
                        if (!Ft2(i2, n3.width)) break r;
                        if (n3.da) break r;
                        if ((n3.da || nt2(i2.ca.S)) && mr(), 11 > i2.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), null != i2.ca.f.kb.F && mr()), i2.Pb && 0 < i2.s.ua && null == i2.s.vb.X && !O2(i2.s.vb, i2.s.Wa.Xa)) {
                          i2.a = 1;
                          break r;
                        }
                        i2.xb = 0;
                      }
                      if (!_t2(i2, i2.V, i2.Ba, i2.c, i2.i, n3.o, Lt2)) break r;
                      a3.Dc = i2.Ma, i2 = 1;
                      break e;
                    }
                    e2(0 != i2.a), i2 = 0;
                  }
                  i2 = !i2;
                }
                i2 && (r2 = t4.a);
              } else r2 = t4.a;
            } else {
              if (null == (t4 = new Yt2())) {
                s3 = 1;
                break t;
              }
              if (t4.Fa = a3.na, t4.P = a3.P, t4.qc = a3.Sa, Kt2(t4, i2)) {
                if (0 == (r2 = qr(i2.width, i2.height, s3.Oa, s3.ba))) {
                  if (t4.Aa = 0, n3 = s3.Oa, e2(null != (a3 = t4)), null != n3) {
                    if (0 < (u4 = 0 > (u4 = n3.Md) ? 0 : 100 < u4 ? 255 : 255 * u4 / 100)) {
                      for (h4 = l4 = 0; 4 > h4; ++h4) 12 > (f4 = a3.pb[h4]).lc && (f4.ia = u4 * Ti[0 > f4.lc ? 0 : f4.lc] >> 3), l4 |= f4.ia;
                      l4 && (alert("todo:VP8InitRandom"), a3.ia = 1);
                    }
                    a3.Ga = n3.Id, 100 < a3.Ga ? a3.Ga = 100 : 0 > a3.Ga && (a3.Ga = 0);
                  }
                  Qt2(t4, i2) || (r2 = t4.a);
                }
              } else r2 = t4.a;
            }
            0 == r2 && null != s3.Oa && s3.Oa.fd && (r2 = Er(s3.ba));
          }
          s3 = r2;
        }
        o3 = 0 != s3 ? null : 11 > o3 ? c4.f.RGBA.eb : c4.f.kb.y;
      } else o3 = null;
      return o3;
    };
    var zi = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];
  };
  function u2(t3, e3) {
    for (var r2 = "", n3 = 0; n3 < 4; n3++) r2 += String.fromCharCode(t3[e3++]);
    return r2;
  }
  function h2(t3, e3) {
    return (t3[e3 + 0] << 0 | t3[e3 + 1] << 8 | t3[e3 + 2] << 16) >>> 0;
  }
  function l2(t3, e3) {
    return (t3[e3 + 0] << 0 | t3[e3 + 1] << 8 | t3[e3 + 2] << 16 | t3[e3 + 3] << 24) >>> 0;
  }
  new c2();
  var f2 = [0], d2 = [0], p2 = [], g2 = new c2(), m2 = t2, v2 = function(t3, e3) {
    var r2 = {}, n3 = 0, i2 = false, a3 = 0, o3 = 0;
    if (r2.frames = [], !/** @license
       * Copyright (c) 2017 Dominik Homberger
      Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
      The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
      https://webpjs.appspot.com
      WebPRiffParser dominikhlbg@gmail.com
      */
    function(t4, e4, r3, n4) {
      for (var i3 = 0; i3 < n4; i3++) if (t4[e4 + i3] != r3.charCodeAt(i3)) return true;
      return false;
    }(t3, e3, "RIFF", 4)) {
      var s3, c3;
      l2(t3, e3 += 4);
      for (e3 += 8; e3 < t3.length; ) {
        var f3 = u2(t3, e3), d3 = l2(t3, e3 += 4);
        e3 += 4;
        var p3 = d3 + (1 & d3);
        switch (f3) {
          case "VP8 ":
          case "VP8L":
            void 0 === r2.frames[n3] && (r2.frames[n3] = {});
            (v3 = r2.frames[n3]).src_off = i2 ? o3 : e3 - 8, v3.src_size = a3 + d3 + 8, n3++, i2 && (i2 = false, a3 = 0, o3 = 0);
            break;
          case "VP8X":
            (v3 = r2.header = {}).feature_flags = t3[e3];
            var g3 = e3 + 4;
            v3.canvas_width = 1 + h2(t3, g3);
            g3 += 3;
            v3.canvas_height = 1 + h2(t3, g3);
            g3 += 3;
            break;
          case "ALPH":
            i2 = true, a3 = p3 + 8, o3 = e3 - 8;
            break;
          case "ANIM":
            (v3 = r2.header).bgcolor = l2(t3, e3);
            g3 = e3 + 4;
            v3.loop_count = (s3 = t3)[(c3 = g3) + 0] << 0 | s3[c3 + 1] << 8;
            g3 += 2;
            break;
          case "ANMF":
            var m3, v3;
            (v3 = r2.frames[n3] = {}).offset_x = 2 * h2(t3, e3), e3 += 3, v3.offset_y = 2 * h2(t3, e3), e3 += 3, v3.width = 1 + h2(t3, e3), e3 += 3, v3.height = 1 + h2(t3, e3), e3 += 3, v3.duration = h2(t3, e3), e3 += 3, m3 = t3[e3++], v3.dispose = 1 & m3, v3.blend = m3 >> 1 & 1;
        }
        "ANMF" != f3 && (e3 += p3);
      }
      return r2;
    }
  }(m2, 0);
  v2.response = m2, v2.rgbaoutput = true, v2.dataurl = false;
  var b2 = v2.header ? v2.header : null, y2 = v2.frames ? v2.frames : null;
  if (b2) {
    b2.loop_counter = b2.loop_count, f2 = [b2.canvas_height], d2 = [b2.canvas_width];
    for (var w2 = 0; w2 < y2.length && 0 != y2[w2].blend; w2++) ;
  }
  var N2 = y2[0], L2 = g2.WebPDecodeRGBA(m2, N2.src_off, N2.src_size, d2, f2);
  N2.rgba = L2, N2.imgwidth = d2[0], N2.imgheight = f2[0];
  for (var A2 = 0; A2 < d2[0] * f2[0] * 4; A2++) p2[A2] = L2[A2];
  return this.width = d2, this.height = f2, this.data = p2, this;
}
!function(t2) {
  var r = function() {
    return "function" == typeof zlibSync;
  }, n2 = function(r2, n3, a3, h3) {
    var l3 = 4, f3 = s2;
    switch (h3) {
      case t2.image_compression.FAST:
        l3 = 1, f3 = o2;
        break;
      case t2.image_compression.MEDIUM:
        l3 = 6, f3 = c2;
        break;
      case t2.image_compression.SLOW:
        l3 = 9, f3 = u2;
    }
    r2 = i(r2, n3, a3, f3);
    var d2 = zlibSync(r2, { level: l3 });
    return t2.__addimage__.arrayBufferToBinaryString(d2);
  }, i = function(t3, e2, r2, n3) {
    for (var i2, a3, o3, s3 = t3.length / e2, c3 = new Uint8Array(t3.length + s3), u3 = l2(), h3 = 0; h3 < s3; h3 += 1) {
      if (o3 = h3 * e2, i2 = t3.subarray(o3, o3 + e2), n3) c3.set(n3(i2, r2, a3), o3 + h3);
      else {
        for (var d2, p2 = u3.length, g2 = []; d2 < p2; d2 += 1) g2[d2] = u3[d2](i2, r2, a3);
        var m2 = f2(g2.concat());
        c3.set(g2[m2], o3 + h3);
      }
      a3 = i2;
    }
    return c3;
  }, a2 = function(t3) {
    var e2 = Array.apply([], t3);
    return e2.unshift(0), e2;
  }, o2 = function(t3, e2) {
    var r2, n3 = [], i2 = t3.length;
    n3[0] = 1;
    for (var a3 = 0; a3 < i2; a3 += 1) r2 = t3[a3 - e2] || 0, n3[a3 + 1] = t3[a3] - r2 + 256 & 255;
    return n3;
  }, s2 = function(t3, e2, r2) {
    var n3, i2 = [], a3 = t3.length;
    i2[0] = 2;
    for (var o3 = 0; o3 < a3; o3 += 1) n3 = r2 && r2[o3] || 0, i2[o3 + 1] = t3[o3] - n3 + 256 & 255;
    return i2;
  }, c2 = function(t3, e2, r2) {
    var n3, i2, a3 = [], o3 = t3.length;
    a3[0] = 3;
    for (var s3 = 0; s3 < o3; s3 += 1) n3 = t3[s3 - e2] || 0, i2 = r2 && r2[s3] || 0, a3[s3 + 1] = t3[s3] + 256 - (n3 + i2 >>> 1) & 255;
    return a3;
  }, u2 = function(t3, e2, r2) {
    var n3, i2, a3, o3, s3 = [], c3 = t3.length;
    s3[0] = 4;
    for (var u3 = 0; u3 < c3; u3 += 1) n3 = t3[u3 - e2] || 0, i2 = r2 && r2[u3] || 0, a3 = r2 && r2[u3 - e2] || 0, o3 = h2(n3, i2, a3), s3[u3 + 1] = t3[u3] - o3 + 256 & 255;
    return s3;
  }, h2 = function(t3, e2, r2) {
    if (t3 === e2 && e2 === r2) return t3;
    var n3 = Math.abs(e2 - r2), i2 = Math.abs(t3 - r2), a3 = Math.abs(t3 + e2 - r2 - r2);
    return n3 <= i2 && n3 <= a3 ? t3 : i2 <= a3 ? e2 : r2;
  }, l2 = function() {
    return [a2, o2, s2, c2, u2];
  }, f2 = function(t3) {
    var e2 = t3.map(function(t4) {
      return t4.reduce(function(t5, e3) {
        return t5 + Math.abs(e3);
      }, 0);
    });
    return e2.indexOf(Math.min.apply(null, e2));
  };
  t2.processPNG = function(e2, i2, a3, o3) {
    var s3, c3, u3, h3, l3, f3, d2, p2, g2, m2, v2, b2, y2, w2, N2, L2 = this.decode.FLATE_DECODE, A2 = "";
    if (this.__addimage__.isArrayBuffer(e2) && (e2 = new Uint8Array(e2)), this.__addimage__.isArrayBufferView(e2)) {
      if (e2 = (u3 = new Kt(e2)).imgData, c3 = u3.bits, s3 = u3.colorSpace, l3 = u3.colors, -1 !== [4, 6].indexOf(u3.colorType)) {
        if (8 === u3.bits) {
          g2 = (p2 = 32 == u3.pixelBitlength ? new Uint32Array(u3.decodePixels().buffer) : 16 == u3.pixelBitlength ? new Uint16Array(u3.decodePixels().buffer) : new Uint8Array(u3.decodePixels().buffer)).length, v2 = new Uint8Array(g2 * u3.colors), m2 = new Uint8Array(g2);
          var x2, S2 = u3.pixelBitlength - u3.bits;
          for (w2 = 0, N2 = 0; w2 < g2; w2++) {
            for (y2 = p2[w2], x2 = 0; x2 < S2; ) v2[N2++] = y2 >>> x2 & 255, x2 += u3.bits;
            m2[w2] = y2 >>> x2 & 255;
          }
        }
        if (16 === u3.bits) {
          g2 = (p2 = new Uint32Array(u3.decodePixels().buffer)).length, v2 = new Uint8Array(g2 * (32 / u3.pixelBitlength) * u3.colors), m2 = new Uint8Array(g2 * (32 / u3.pixelBitlength)), b2 = u3.colors > 1, w2 = 0, N2 = 0;
          for (var _2 = 0; w2 < g2; ) y2 = p2[w2++], v2[N2++] = y2 >>> 0 & 255, b2 && (v2[N2++] = y2 >>> 16 & 255, y2 = p2[w2++], v2[N2++] = y2 >>> 0 & 255), m2[_2++] = y2 >>> 16 & 255;
          c3 = 8;
        }
        o3 !== t2.image_compression.NONE && r() ? (e2 = n2(v2, u3.width * u3.colors, u3.colors, o3), d2 = n2(m2, u3.width, 1, o3)) : (e2 = v2, d2 = m2, L2 = void 0);
      }
      if (3 === u3.colorType && (s3 = this.color_spaces.INDEXED, f3 = u3.palette, u3.transparency.indexed)) {
        var P2 = u3.transparency.indexed, k2 = 0;
        for (w2 = 0, g2 = P2.length; w2 < g2; ++w2) k2 += P2[w2];
        if ((k2 /= 255) === g2 - 1 && -1 !== P2.indexOf(0)) h3 = [P2.indexOf(0)];
        else if (k2 !== g2) {
          for (p2 = u3.decodePixels(), m2 = new Uint8Array(p2.length), w2 = 0, g2 = p2.length; w2 < g2; w2++) m2[w2] = P2[p2[w2]];
          d2 = n2(m2, u3.width, 1);
        }
      }
      var I2 = function(e3) {
        var r2;
        switch (e3) {
          case t2.image_compression.FAST:
            r2 = 11;
            break;
          case t2.image_compression.MEDIUM:
            r2 = 13;
            break;
          case t2.image_compression.SLOW:
            r2 = 14;
            break;
          default:
            r2 = 12;
        }
        return r2;
      }(o3);
      return L2 === this.decode.FLATE_DECODE && (A2 = "/Predictor " + I2 + " "), A2 += "/Colors " + l3 + " /BitsPerComponent " + c3 + " /Columns " + u3.width, (this.__addimage__.isArrayBuffer(e2) || this.__addimage__.isArrayBufferView(e2)) && (e2 = this.__addimage__.arrayBufferToBinaryString(e2)), (d2 && this.__addimage__.isArrayBuffer(d2) || this.__addimage__.isArrayBufferView(d2)) && (d2 = this.__addimage__.arrayBufferToBinaryString(d2)), { alias: a3, data: e2, index: i2, filter: L2, decodeParameters: A2, transparency: h3, palette: f3, sMask: d2, predictor: I2, width: u3.width, height: u3.height, bitsPerComponent: c3, colorSpace: s3 };
    }
  };
}(E$1.API), function(t2) {
  t2.processGIF89A = function(e2, r, n2, i) {
    var a2 = new Zt(e2), o2 = a2.width, s2 = a2.height, c2 = [];
    a2.decodeAndBlitFrameRGBA(0, c2);
    var u2 = { data: c2, width: o2, height: s2 }, h2 = new Qt(100).encode(u2, 100);
    return t2.processJPEG.call(this, h2, r, n2, i);
  }, t2.processGIF87A = t2.processGIF89A;
}(E$1.API), te.prototype.parseHeader = function() {
  if (this.fileSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, true), this.pos += 4, this.offset = this.datav.getUint32(this.pos, true), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.width = this.datav.getUint32(this.pos, true), this.pos += 4, this.height = this.datav.getInt32(this.pos, true), this.pos += 4, this.planes = this.datav.getUint16(this.pos, true), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, true), this.pos += 2, this.compress = this.datav.getUint32(this.pos, true), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.hr = this.datav.getUint32(this.pos, true), this.pos += 4, this.vr = this.datav.getUint32(this.pos, true), this.pos += 4, this.colors = this.datav.getUint32(this.pos, true), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, true), this.pos += 4, 16 === this.bitPP && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
    var t2 = 0 === this.colors ? 1 << this.bitPP : this.colors;
    this.palette = new Array(t2);
    for (var e2 = 0; e2 < t2; e2++) {
      var r = this.datav.getUint8(this.pos++, true), n2 = this.datav.getUint8(this.pos++, true), i = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true);
      this.palette[e2] = { red: i, green: n2, blue: r, quad: a2 };
    }
  }
  this.height < 0 && (this.height *= -1, this.bottom_up = false);
}, te.prototype.parseBGR = function() {
  this.pos = this.offset;
  try {
    var t2 = "bit" + this.bitPP, e2 = this.width * this.height * 4;
    this.data = new Uint8Array(e2), this[t2]();
  } catch (t3) {
    a$1.log("bit decode error:" + t3);
  }
}, te.prototype.bit1 = function() {
  var t2, e2 = Math.ceil(this.width / 8), r = e2 % 4;
  for (t2 = this.height - 1; t2 >= 0; t2--) {
    for (var n2 = this.bottom_up ? t2 : this.height - 1 - t2, i = 0; i < e2; i++) for (var a2 = this.datav.getUint8(this.pos++, true), o2 = n2 * this.width * 4 + 8 * i * 4, s2 = 0; s2 < 8 && 8 * i + s2 < this.width; s2++) {
      var c2 = this.palette[a2 >> 7 - s2 & 1];
      this.data[o2 + 4 * s2] = c2.blue, this.data[o2 + 4 * s2 + 1] = c2.green, this.data[o2 + 4 * s2 + 2] = c2.red, this.data[o2 + 4 * s2 + 3] = 255;
    }
    0 !== r && (this.pos += 4 - r);
  }
}, te.prototype.bit4 = function() {
  for (var t2 = Math.ceil(this.width / 2), e2 = t2 % 4, r = this.height - 1; r >= 0; r--) {
    for (var n2 = this.bottom_up ? r : this.height - 1 - r, i = 0; i < t2; i++) {
      var a2 = this.datav.getUint8(this.pos++, true), o2 = n2 * this.width * 4 + 2 * i * 4, s2 = a2 >> 4, c2 = 15 & a2, u2 = this.palette[s2];
      if (this.data[o2] = u2.blue, this.data[o2 + 1] = u2.green, this.data[o2 + 2] = u2.red, this.data[o2 + 3] = 255, 2 * i + 1 >= this.width) break;
      u2 = this.palette[c2], this.data[o2 + 4] = u2.blue, this.data[o2 + 4 + 1] = u2.green, this.data[o2 + 4 + 2] = u2.red, this.data[o2 + 4 + 3] = 255;
    }
    0 !== e2 && (this.pos += 4 - e2);
  }
}, te.prototype.bit8 = function() {
  for (var t2 = this.width % 4, e2 = this.height - 1; e2 >= 0; e2--) {
    for (var r = this.bottom_up ? e2 : this.height - 1 - e2, n2 = 0; n2 < this.width; n2++) {
      var i = this.datav.getUint8(this.pos++, true), a2 = r * this.width * 4 + 4 * n2;
      if (i < this.palette.length) {
        var o2 = this.palette[i];
        this.data[a2] = o2.red, this.data[a2 + 1] = o2.green, this.data[a2 + 2] = o2.blue, this.data[a2 + 3] = 255;
      } else this.data[a2] = 255, this.data[a2 + 1] = 255, this.data[a2 + 2] = 255, this.data[a2 + 3] = 255;
    }
    0 !== t2 && (this.pos += 4 - t2);
  }
}, te.prototype.bit15 = function() {
  for (var t2 = this.width % 3, e2 = parseInt("11111", 2), r = this.height - 1; r >= 0; r--) {
    for (var n2 = this.bottom_up ? r : this.height - 1 - r, i = 0; i < this.width; i++) {
      var a2 = this.datav.getUint16(this.pos, true);
      this.pos += 2;
      var o2 = (a2 & e2) / e2 * 255 | 0, s2 = (a2 >> 5 & e2) / e2 * 255 | 0, c2 = (a2 >> 10 & e2) / e2 * 255 | 0, u2 = a2 >> 15 ? 255 : 0, h2 = n2 * this.width * 4 + 4 * i;
      this.data[h2] = c2, this.data[h2 + 1] = s2, this.data[h2 + 2] = o2, this.data[h2 + 3] = u2;
    }
    this.pos += t2;
  }
}, te.prototype.bit16 = function() {
  for (var t2 = this.width % 3, e2 = parseInt("11111", 2), r = parseInt("111111", 2), n2 = this.height - 1; n2 >= 0; n2--) {
    for (var i = this.bottom_up ? n2 : this.height - 1 - n2, a2 = 0; a2 < this.width; a2++) {
      var o2 = this.datav.getUint16(this.pos, true);
      this.pos += 2;
      var s2 = (o2 & e2) / e2 * 255 | 0, c2 = (o2 >> 5 & r) / r * 255 | 0, u2 = (o2 >> 11) / e2 * 255 | 0, h2 = i * this.width * 4 + 4 * a2;
      this.data[h2] = u2, this.data[h2 + 1] = c2, this.data[h2 + 2] = s2, this.data[h2 + 3] = 255;
    }
    this.pos += t2;
  }
}, te.prototype.bit24 = function() {
  for (var t2 = this.height - 1; t2 >= 0; t2--) {
    for (var e2 = this.bottom_up ? t2 : this.height - 1 - t2, r = 0; r < this.width; r++) {
      var n2 = this.datav.getUint8(this.pos++, true), i = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true), o2 = e2 * this.width * 4 + 4 * r;
      this.data[o2] = a2, this.data[o2 + 1] = i, this.data[o2 + 2] = n2, this.data[o2 + 3] = 255;
    }
    this.pos += this.width % 4;
  }
}, te.prototype.bit32 = function() {
  for (var t2 = this.height - 1; t2 >= 0; t2--) for (var e2 = this.bottom_up ? t2 : this.height - 1 - t2, r = 0; r < this.width; r++) {
    var n2 = this.datav.getUint8(this.pos++, true), i = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true), o2 = this.datav.getUint8(this.pos++, true), s2 = e2 * this.width * 4 + 4 * r;
    this.data[s2] = a2, this.data[s2 + 1] = i, this.data[s2 + 2] = n2, this.data[s2 + 3] = o2;
  }
}, te.prototype.getData = function() {
  return this.data;
}, /**
 * @license
 * Copyright (c) 2018 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  t2.processBMP = function(e2, r, n2, i) {
    var a2 = new te(e2, false), o2 = a2.width, s2 = a2.height, c2 = { data: a2.getData(), width: o2, height: s2 }, u2 = new Qt(100).encode(c2, 100);
    return t2.processJPEG.call(this, u2, r, n2, i);
  };
}(E$1.API), ee.prototype.getData = function() {
  return this.data;
}, /**
 * @license
 * Copyright (c) 2019 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  t2.processWEBP = function(e2, r, n2, i) {
    var a2 = new ee(e2), o2 = a2.width, s2 = a2.height, c2 = { data: a2.getData(), width: o2, height: s2 }, u2 = new Qt(100).encode(c2, 100);
    return t2.processJPEG.call(this, u2, r, n2, i);
  };
}(E$1.API), E$1.API.processRGBA = function(t2, e2, r) {
  for (var n2 = t2.data, i = n2.length, a2 = new Uint8Array(i / 4 * 3), o2 = new Uint8Array(i / 4), s2 = 0, c2 = 0, u2 = 0; u2 < i; u2 += 4) {
    var h2 = n2[u2], l2 = n2[u2 + 1], f2 = n2[u2 + 2], d2 = n2[u2 + 3];
    a2[s2++] = h2, a2[s2++] = l2, a2[s2++] = f2, o2[c2++] = d2;
  }
  var p2 = this.__addimage__.arrayBufferToBinaryString(a2);
  return { alpha: this.__addimage__.arrayBufferToBinaryString(o2), data: p2, index: e2, alias: r, colorSpace: "DeviceRGB", bitsPerComponent: 8, width: t2.width, height: t2.height };
}, E$1.API.setLanguage = function(t2) {
  return void 0 === this.internal.languageSettings && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = false), void 0 !== { af: "Afrikaans", sq: "Albanian", ar: "Arabic (Standard)", "ar-DZ": "Arabic (Algeria)", "ar-BH": "Arabic (Bahrain)", "ar-EG": "Arabic (Egypt)", "ar-IQ": "Arabic (Iraq)", "ar-JO": "Arabic (Jordan)", "ar-KW": "Arabic (Kuwait)", "ar-LB": "Arabic (Lebanon)", "ar-LY": "Arabic (Libya)", "ar-MA": "Arabic (Morocco)", "ar-OM": "Arabic (Oman)", "ar-QA": "Arabic (Qatar)", "ar-SA": "Arabic (Saudi Arabia)", "ar-SY": "Arabic (Syria)", "ar-TN": "Arabic (Tunisia)", "ar-AE": "Arabic (U.A.E.)", "ar-YE": "Arabic (Yemen)", an: "Aragonese", hy: "Armenian", as: "Assamese", ast: "Asturian", az: "Azerbaijani", eu: "Basque", be: "Belarusian", bn: "Bengali", bs: "Bosnian", br: "Breton", bg: "Bulgarian", my: "Burmese", ca: "Catalan", ch: "Chamorro", ce: "Chechen", zh: "Chinese", "zh-HK": "Chinese (Hong Kong)", "zh-CN": "Chinese (PRC)", "zh-SG": "Chinese (Singapore)", "zh-TW": "Chinese (Taiwan)", cv: "Chuvash", co: "Corsican", cr: "Cree", hr: "Croatian", cs: "Czech", da: "Danish", nl: "Dutch (Standard)", "nl-BE": "Dutch (Belgian)", en: "English", "en-AU": "English (Australia)", "en-BZ": "English (Belize)", "en-CA": "English (Canada)", "en-IE": "English (Ireland)", "en-JM": "English (Jamaica)", "en-NZ": "English (New Zealand)", "en-PH": "English (Philippines)", "en-ZA": "English (South Africa)", "en-TT": "English (Trinidad & Tobago)", "en-GB": "English (United Kingdom)", "en-US": "English (United States)", "en-ZW": "English (Zimbabwe)", eo: "Esperanto", et: "Estonian", fo: "Faeroese", fj: "Fijian", fi: "Finnish", fr: "French (Standard)", "fr-BE": "French (Belgium)", "fr-CA": "French (Canada)", "fr-FR": "French (France)", "fr-LU": "French (Luxembourg)", "fr-MC": "French (Monaco)", "fr-CH": "French (Switzerland)", fy: "Frisian", fur: "Friulian", gd: "Gaelic (Scots)", "gd-IE": "Gaelic (Irish)", gl: "Galacian", ka: "Georgian", de: "German (Standard)", "de-AT": "German (Austria)", "de-DE": "German (Germany)", "de-LI": "German (Liechtenstein)", "de-LU": "German (Luxembourg)", "de-CH": "German (Switzerland)", el: "Greek", gu: "Gujurati", ht: "Haitian", he: "Hebrew", hi: "Hindi", hu: "Hungarian", is: "Icelandic", id: "Indonesian", iu: "Inuktitut", ga: "Irish", it: "Italian (Standard)", "it-CH": "Italian (Switzerland)", ja: "Japanese", kn: "Kannada", ks: "Kashmiri", kk: "Kazakh", km: "Khmer", ky: "Kirghiz", tlh: "Klingon", ko: "Korean", "ko-KP": "Korean (North Korea)", "ko-KR": "Korean (South Korea)", la: "Latin", lv: "Latvian", lt: "Lithuanian", lb: "Luxembourgish", mk: "North Macedonia", ms: "Malay", ml: "Malayalam", mt: "Maltese", mi: "Maori", mr: "Marathi", mo: "Moldavian", nv: "Navajo", ng: "Ndonga", ne: "Nepali", no: "Norwegian", nb: "Norwegian (Bokmal)", nn: "Norwegian (Nynorsk)", oc: "Occitan", or: "Oriya", om: "Oromo", fa: "Persian", "fa-IR": "Persian/Iran", pl: "Polish", pt: "Portuguese", "pt-BR": "Portuguese (Brazil)", pa: "Punjabi", "pa-IN": "Punjabi (India)", "pa-PK": "Punjabi (Pakistan)", qu: "Quechua", rm: "Rhaeto-Romanic", ro: "Romanian", "ro-MO": "Romanian (Moldavia)", ru: "Russian", "ru-MO": "Russian (Moldavia)", sz: "Sami (Lappish)", sg: "Sango", sa: "Sanskrit", sc: "Sardinian", sd: "Sindhi", si: "Singhalese", sr: "Serbian", sk: "Slovak", sl: "Slovenian", so: "Somani", sb: "Sorbian", es: "Spanish", "es-AR": "Spanish (Argentina)", "es-BO": "Spanish (Bolivia)", "es-CL": "Spanish (Chile)", "es-CO": "Spanish (Colombia)", "es-CR": "Spanish (Costa Rica)", "es-DO": "Spanish (Dominican Republic)", "es-EC": "Spanish (Ecuador)", "es-SV": "Spanish (El Salvador)", "es-GT": "Spanish (Guatemala)", "es-HN": "Spanish (Honduras)", "es-MX": "Spanish (Mexico)", "es-NI": "Spanish (Nicaragua)", "es-PA": "Spanish (Panama)", "es-PY": "Spanish (Paraguay)", "es-PE": "Spanish (Peru)", "es-PR": "Spanish (Puerto Rico)", "es-ES": "Spanish (Spain)", "es-UY": "Spanish (Uruguay)", "es-VE": "Spanish (Venezuela)", sx: "Sutu", sw: "Swahili", sv: "Swedish", "sv-FI": "Swedish (Finland)", "sv-SV": "Swedish (Sweden)", ta: "Tamil", tt: "Tatar", te: "Teluga", th: "Thai", tig: "Tigre", ts: "Tsonga", tn: "Tswana", tr: "Turkish", tk: "Turkmen", uk: "Ukrainian", hsb: "Upper Sorbian", ur: "Urdu", ve: "Venda", vi: "Vietnamese", vo: "Volapuk", wa: "Walloon", cy: "Welsh", xh: "Xhosa", ji: "Yiddish", zu: "Zulu" }[t2] && (this.internal.languageSettings.languageCode = t2, false === this.internal.languageSettings.isSubscribed && (this.internal.events.subscribe("putCatalog", function() {
    this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
  }), this.internal.languageSettings.isSubscribed = true)), this;
}, Vt = E$1.API, Gt = Vt.getCharWidthsArray = function(e2, r) {
  var n2, i, a2 = (r = r || {}).font || this.internal.getFont(), o2 = r.fontSize || this.internal.getFontSize(), s2 = r.charSpace || this.internal.getCharSpace(), c2 = r.widths ? r.widths : a2.metadata.Unicode.widths, u2 = c2.fof ? c2.fof : 1, h2 = r.kerning ? r.kerning : a2.metadata.Unicode.kerning, l2 = h2.fof ? h2.fof : 1, f2 = false !== r.doKerning, d2 = 0, p2 = e2.length, g2 = 0, m2 = c2[0] || u2, v2 = [];
  for (n2 = 0; n2 < p2; n2++) i = e2.charCodeAt(n2), "function" == typeof a2.metadata.widthOfString ? v2.push((a2.metadata.widthOfGlyph(a2.metadata.characterToGlyph(i)) + s2 * (1e3 / o2) || 0) / 1e3) : (d2 = f2 && "object" === _typeof(h2[i]) && !isNaN(parseInt(h2[i][g2], 10)) ? h2[i][g2] / l2 : 0, v2.push((c2[i] || m2) / u2 + d2)), g2 = i;
  return v2;
}, Yt = Vt.getStringUnitWidth = function(t2, e2) {
  var r = (e2 = e2 || {}).fontSize || this.internal.getFontSize(), n2 = e2.font || this.internal.getFont(), i = e2.charSpace || this.internal.getCharSpace();
  return Vt.processArabic && (t2 = Vt.processArabic(t2)), "function" == typeof n2.metadata.widthOfString ? n2.metadata.widthOfString(t2, r, i) / r : Gt.apply(this, arguments).reduce(function(t3, e3) {
    return t3 + e3;
  }, 0);
}, Jt = function(t2, e2, r, n2) {
  for (var i = [], a2 = 0, o2 = t2.length, s2 = 0; a2 !== o2 && s2 + e2[a2] < r; ) s2 += e2[a2], a2++;
  i.push(t2.slice(0, a2));
  var c2 = a2;
  for (s2 = 0; a2 !== o2; ) s2 + e2[a2] > n2 && (i.push(t2.slice(c2, a2)), s2 = 0, c2 = a2), s2 += e2[a2], a2++;
  return c2 !== a2 && i.push(t2.slice(c2, a2)), i;
}, Xt = function(t2, e2, r) {
  r || (r = {});
  var n2, i, a2, o2, s2, c2, u2, h2 = [], l2 = [h2], f2 = r.textIndent || 0, d2 = 0, p2 = 0, g2 = t2.split(" "), m2 = Gt.apply(this, [" ", r])[0];
  if (c2 = -1 === r.lineIndent ? g2[0].length + 2 : r.lineIndent || 0) {
    var v2 = Array(c2).join(" "), b2 = [];
    g2.map(function(t3) {
      (t3 = t3.split(/\s*\n/)).length > 1 ? b2 = b2.concat(t3.map(function(t4, e3) {
        return (e3 && t4.length ? "\n" : "") + t4;
      })) : b2.push(t3[0]);
    }), g2 = b2, c2 = Yt.apply(this, [v2, r]);
  }
  for (a2 = 0, o2 = g2.length; a2 < o2; a2++) {
    var y2 = 0;
    if (n2 = g2[a2], c2 && "\n" == n2[0] && (n2 = n2.substr(1), y2 = 1), f2 + d2 + (p2 = (i = Gt.apply(this, [n2, r])).reduce(function(t3, e3) {
      return t3 + e3;
    }, 0)) > e2 || y2) {
      if (p2 > e2) {
        for (s2 = Jt.apply(this, [n2, i, e2 - (f2 + d2), e2]), h2.push(s2.shift()), h2 = [s2.pop()]; s2.length; ) l2.push([s2.shift()]);
        p2 = i.slice(n2.length - (h2[0] ? h2[0].length : 0)).reduce(function(t3, e3) {
          return t3 + e3;
        }, 0);
      } else h2 = [n2];
      l2.push(h2), f2 = p2 + c2, d2 = m2;
    } else h2.push(n2), f2 += d2 + p2, d2 = m2;
  }
  return u2 = c2 ? function(t3, e3) {
    return (e3 ? v2 : "") + t3.join(" ");
  } : function(t3) {
    return t3.join(" ");
  }, l2.map(u2);
}, Vt.splitTextToSize = function(t2, e2, r) {
  var n2, i = (r = r || {}).fontSize || this.internal.getFontSize(), a2 = (function(t3) {
    if (t3.widths && t3.kerning) return { widths: t3.widths, kerning: t3.kerning };
    var e3 = this.internal.getFont(t3.fontName, t3.fontStyle);
    return e3.metadata.Unicode ? { widths: e3.metadata.Unicode.widths || { 0: 1 }, kerning: e3.metadata.Unicode.kerning || {} } : { font: e3.metadata, fontSize: this.internal.getFontSize(), charSpace: this.internal.getCharSpace() };
  }).call(this, r);
  n2 = Array.isArray(t2) ? t2 : String(t2).split(/\r?\n/);
  var o2 = 1 * this.internal.scaleFactor * e2 / i;
  a2.textIndent = r.textIndent ? 1 * r.textIndent * this.internal.scaleFactor / i : 0, a2.lineIndent = r.lineIndent;
  var s2, c2, u2 = [];
  for (s2 = 0, c2 = n2.length; s2 < c2; s2++) u2 = u2.concat(Xt.apply(this, [n2[s2], o2, a2]));
  return u2;
}, function(e2) {
  e2.__fontmetrics__ = e2.__fontmetrics__ || {};
  for (var r = "klmnopqrstuvwxyz", n2 = {}, i = {}, a2 = 0; a2 < r.length; a2++) n2[r[a2]] = "0123456789abcdef"[a2], i["0123456789abcdef"[a2]] = r[a2];
  var o2 = function(t2) {
    return "0x" + parseInt(t2, 10).toString(16);
  }, s2 = e2.__fontmetrics__.compress = function(e3) {
    var r2, n3, a3, c3, u3 = ["{"];
    for (var h3 in e3) {
      if (r2 = e3[h3], isNaN(parseInt(h3, 10)) ? n3 = "'" + h3 + "'" : (h3 = parseInt(h3, 10), n3 = (n3 = o2(h3).slice(2)).slice(0, -1) + i[n3.slice(-1)]), "number" == typeof r2) r2 < 0 ? (a3 = o2(r2).slice(3), c3 = "-") : (a3 = o2(r2).slice(2), c3 = ""), a3 = c3 + a3.slice(0, -1) + i[a3.slice(-1)];
      else {
        if ("object" !== _typeof(r2)) throw new Error("Don't know what to do with value type " + _typeof(r2) + ".");
        a3 = s2(r2);
      }
      u3.push(n3 + a3);
    }
    return u3.push("}"), u3.join("");
  }, c2 = e2.__fontmetrics__.uncompress = function(t2) {
    if ("string" != typeof t2) throw new Error("Invalid argument passed to uncompress.");
    for (var e3, r2, i2, a3, o3 = {}, s3 = 1, c3 = o3, u3 = [], h3 = "", l3 = "", f2 = t2.length - 1, d2 = 1; d2 < f2; d2 += 1) "'" == (a3 = t2[d2]) ? e3 ? (i2 = e3.join(""), e3 = void 0) : e3 = [] : e3 ? e3.push(a3) : "{" == a3 ? (u3.push([c3, i2]), c3 = {}, i2 = void 0) : "}" == a3 ? ((r2 = u3.pop())[0][r2[1]] = c3, i2 = void 0, c3 = r2[0]) : "-" == a3 ? s3 = -1 : void 0 === i2 ? n2.hasOwnProperty(a3) ? (h3 += n2[a3], i2 = parseInt(h3, 16) * s3, s3 = 1, h3 = "") : h3 += a3 : n2.hasOwnProperty(a3) ? (l3 += n2[a3], c3[i2] = parseInt(l3, 16) * s3, s3 = 1, i2 = void 0, l3 = "") : l3 += a3;
    return o3;
  }, u2 = { codePages: ["WinAnsiEncoding"], WinAnsiEncoding: c2("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}") }, h2 = { Unicode: { Courier: u2, "Courier-Bold": u2, "Courier-BoldOblique": u2, "Courier-Oblique": u2, Helvetica: u2, "Helvetica-Bold": u2, "Helvetica-BoldOblique": u2, "Helvetica-Oblique": u2, "Times-Roman": u2, "Times-Bold": u2, "Times-BoldItalic": u2, "Times-Italic": u2 } }, l2 = { Unicode: { "Courier-Oblique": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-BoldItalic": c2("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"), "Helvetica-Bold": c2("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), Courier: c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-BoldOblique": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Bold": c2("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"), Symbol: c2("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"), Helvetica: c2("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"), "Helvetica-BoldOblique": c2("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), ZapfDingbats: c2("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-Bold": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Italic": c2("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"), "Times-Roman": c2("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"), "Helvetica-Oblique": c2("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}") } };
  e2.events.push(["addFont", function(t2) {
    var e3 = t2.font, r2 = l2.Unicode[e3.postScriptName];
    r2 && (e3.metadata.Unicode = {}, e3.metadata.Unicode.widths = r2.widths, e3.metadata.Unicode.kerning = r2.kerning);
    var n3 = h2.Unicode[e3.postScriptName];
    n3 && (e3.metadata.Unicode.encoding = n3, e3.encoding = n3.codePages[0]);
  }]);
}(E$1.API), /**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  var e2 = function(t3) {
    for (var e3 = t3.length, r = new Uint8Array(e3), n2 = 0; n2 < e3; n2++) r[n2] = t3.charCodeAt(n2);
    return r;
  };
  t2.API.events.push(["addFont", function(r) {
    var n2 = void 0, i = r.font, a2 = r.instance;
    if (!i.isStandardFont) {
      if (void 0 === a2) throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + i.postScriptName + "').");
      if ("string" != typeof (n2 = false === a2.existsFileInVFS(i.postScriptName) ? a2.loadFile(i.postScriptName) : a2.getFileFromVFS(i.postScriptName))) throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + i.postScriptName + "').");
      !function(r2, n3) {
        n3 = /^\x00\x01\x00\x00/.test(n3) ? e2(n3) : e2(u$1(n3)), r2.metadata = t2.API.TTFFont.open(n3), r2.metadata.Unicode = r2.metadata.Unicode || { encoding: {}, kerning: {}, widths: [] }, r2.metadata.glyIdsUsed = [0];
      }(i, n2);
    }
  }]);
}(E$1), /** @license
 * Copyright (c) 2012 Willow Systems Corporation, https://github.com/willowsystems
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
function(t2) {
  function e2() {
    return (n.canvg ? Promise.resolve(n.canvg) : __vitePreload(() => import("./index.es-V0VUhD8B.js"), true ? [] : void 0)).catch(function(t3) {
      return Promise.reject(new Error("Could not load canvg: " + t3));
    }).then(function(t3) {
      return t3.default ? t3.default : t3;
    });
  }
  E$1.API.addSvgAsImage = function(t3, r, n2, i, o2, s2, c2, u2) {
    if (isNaN(r) || isNaN(n2)) throw a$1.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
    if (isNaN(i) || isNaN(o2)) throw a$1.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
    var h2 = document.createElement("canvas");
    h2.width = i, h2.height = o2;
    var l2 = h2.getContext("2d");
    l2.fillStyle = "#fff", l2.fillRect(0, 0, h2.width, h2.height);
    var f2 = { ignoreMouse: true, ignoreAnimation: true, ignoreDimensions: true }, d2 = this;
    return e2().then(function(e3) {
      return e3.fromString(l2, t3, f2);
    }, function() {
      return Promise.reject(new Error("Could not load canvg."));
    }).then(function(t4) {
      return t4.render(f2);
    }).then(function() {
      d2.addImage(h2.toDataURL("image/jpeg", 1), r, n2, i, o2, c2, u2);
    });
  };
}(), E$1.API.putTotalPages = function(t2) {
  var e2, r = 0;
  parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (e2 = new RegExp(t2, "g"), r = this.internal.getNumberOfPages()) : (e2 = new RegExp(this.pdfEscape16(t2, this.internal.getFont()), "g"), r = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));
  for (var n2 = 1; n2 <= this.internal.getNumberOfPages(); n2++) for (var i = 0; i < this.internal.pages[n2].length; i++) this.internal.pages[n2][i] = this.internal.pages[n2][i].replace(e2, r);
  return this;
}, E$1.API.viewerPreferences = function(e2, r) {
  var n2;
  e2 = e2 || {}, r = r || false;
  var i, a2, o2, s2 = { HideToolbar: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, HideMenubar: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, HideWindowUI: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, FitWindow: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, CenterWindow: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, DisplayDocTitle: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.4 }, NonFullScreenPageMode: { defaultValue: "UseNone", value: "UseNone", type: "name", explicitSet: false, valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"], pdfVersion: 1.3 }, Direction: { defaultValue: "L2R", value: "L2R", type: "name", explicitSet: false, valueSet: ["L2R", "R2L"], pdfVersion: 1.3 }, ViewArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, ViewClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintScaling: { defaultValue: "AppDefault", value: "AppDefault", type: "name", explicitSet: false, valueSet: ["AppDefault", "None"], pdfVersion: 1.6 }, Duplex: { defaultValue: "", value: "none", type: "name", explicitSet: false, valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"], pdfVersion: 1.7 }, PickTrayByPDFSize: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.7 }, PrintPageRange: { defaultValue: "", value: "", type: "array", explicitSet: false, valueSet: null, pdfVersion: 1.7 }, NumCopies: { defaultValue: 1, value: 1, type: "integer", explicitSet: false, valueSet: null, pdfVersion: 1.7 } }, c2 = Object.keys(s2), u2 = [], h2 = 0, l2 = 0, f2 = 0;
  function d2(t2, e3) {
    var r2, n3 = false;
    for (r2 = 0; r2 < t2.length; r2 += 1) t2[r2] === e3 && (n3 = true);
    return n3;
  }
  if (void 0 === this.internal.viewerpreferences && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(s2)), this.internal.viewerpreferences.isSubscribed = false), n2 = this.internal.viewerpreferences.configuration, "reset" === e2 || true === r) {
    var p2 = c2.length;
    for (f2 = 0; f2 < p2; f2 += 1) n2[c2[f2]].value = n2[c2[f2]].defaultValue, n2[c2[f2]].explicitSet = false;
  }
  if ("object" === _typeof(e2)) {
    for (a2 in e2) if (o2 = e2[a2], d2(c2, a2) && void 0 !== o2) {
      if ("boolean" === n2[a2].type && "boolean" == typeof o2) n2[a2].value = o2;
      else if ("name" === n2[a2].type && d2(n2[a2].valueSet, o2)) n2[a2].value = o2;
      else if ("integer" === n2[a2].type && Number.isInteger(o2)) n2[a2].value = o2;
      else if ("array" === n2[a2].type) {
        for (h2 = 0; h2 < o2.length; h2 += 1) if (i = true, 1 === o2[h2].length && "number" == typeof o2[h2][0]) u2.push(String(o2[h2] - 1));
        else if (o2[h2].length > 1) {
          for (l2 = 0; l2 < o2[h2].length; l2 += 1) "number" != typeof o2[h2][l2] && (i = false);
          true === i && u2.push([o2[h2][0] - 1, o2[h2][1] - 1].join(" "));
        }
        n2[a2].value = "[" + u2.join(" ") + "]";
      } else n2[a2].value = n2[a2].defaultValue;
      n2[a2].explicitSet = true;
    }
  }
  return false === this.internal.viewerpreferences.isSubscribed && (this.internal.events.subscribe("putCatalog", function() {
    var t2, e3 = [];
    for (t2 in n2) true === n2[t2].explicitSet && ("name" === n2[t2].type ? e3.push("/" + t2 + " /" + n2[t2].value) : e3.push("/" + t2 + " " + n2[t2].value));
    0 !== e3.length && this.internal.write("/ViewerPreferences\n<<\n" + e3.join("\n") + "\n>>");
  }), this.internal.viewerpreferences.isSubscribed = true), this.internal.viewerpreferences.configuration = n2, this;
}, /** ====================================================================
 * @license
 * jsPDF XMP metadata plugin
 * Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
function(t2) {
  var e2 = function() {
    var t3 = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>', e3 = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')), r2 = unescape(encodeURIComponent(t3)), n2 = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), i = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")), a2 = unescape(encodeURIComponent("</x:xmpmeta>")), o2 = r2.length + n2.length + i.length + e3.length + a2.length;
    this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + o2 + " >>"), this.internal.write("stream"), this.internal.write(e3 + r2 + n2 + i + a2), this.internal.write("endstream"), this.internal.write("endobj");
  }, r = function() {
    this.internal.__metadata__.metadata_object_number && this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R");
  };
  t2.addMetadata = function(t3, n2) {
    return void 0 === this.internal.__metadata__ && (this.internal.__metadata__ = { metadata: t3, namespaceuri: n2 || "http://jspdf.default.namespaceuri/" }, this.internal.events.subscribe("putCatalog", r), this.internal.events.subscribe("postPutResources", e2)), this;
  };
}(E$1.API), function(t2) {
  var e2 = t2.API, r = e2.pdfEscape16 = function(t3, e3) {
    for (var r2, n3 = e3.metadata.Unicode.widths, i2 = ["", "0", "00", "000", "0000"], a2 = [""], o2 = 0, s2 = t3.length; o2 < s2; ++o2) {
      if (r2 = e3.metadata.characterToGlyph(t3.charCodeAt(o2)), e3.metadata.glyIdsUsed.push(r2), e3.metadata.toUnicode[r2] = t3.charCodeAt(o2), -1 == n3.indexOf(r2) && (n3.push(r2), n3.push([parseInt(e3.metadata.widthOfGlyph(r2), 10)])), "0" == r2) return a2.join("");
      r2 = r2.toString(16), a2.push(i2[4 - r2.length], r2);
    }
    return a2.join("");
  }, n2 = function(t3) {
    var e3, r2, n3, i2, a2, o2, s2;
    for (a2 = "/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange", n3 = [], o2 = 0, s2 = (r2 = Object.keys(t3).sort(function(t4, e4) {
      return t4 - e4;
    })).length; o2 < s2; o2++) e3 = r2[o2], n3.length >= 100 && (a2 += "\n" + n3.length + " beginbfchar\n" + n3.join("\n") + "\nendbfchar", n3 = []), void 0 !== t3[e3] && null !== t3[e3] && "function" == typeof t3[e3].toString && (i2 = ("0000" + t3[e3].toString(16)).slice(-4), e3 = ("0000" + (+e3).toString(16)).slice(-4), n3.push("<" + e3 + "><" + i2 + ">"));
    return n3.length && (a2 += "\n" + n3.length + " beginbfchar\n" + n3.join("\n") + "\nendbfchar\n"), a2 += "endcmap\nCMapName currentdict /CMap defineresource pop\nend\nend";
  };
  e2.events.push(["putFont", function(e3) {
    !function(e4) {
      var r2 = e4.font, i2 = e4.out, a2 = e4.newObject, o2 = e4.putStream;
      if (r2.metadata instanceof t2.API.TTFFont && "Identity-H" === r2.encoding) {
        for (var s2 = r2.metadata.Unicode.widths, c2 = r2.metadata.subset.encode(r2.metadata.glyIdsUsed, 1), u2 = "", h2 = 0; h2 < c2.length; h2++) u2 += String.fromCharCode(c2[h2]);
        var l2 = a2();
        o2({ data: u2, addLength1: true, objectId: l2 }), i2("endobj");
        var f2 = a2();
        o2({ data: n2(r2.metadata.toUnicode), addLength1: true, objectId: f2 }), i2("endobj");
        var d2 = a2();
        i2("<<"), i2("/Type /FontDescriptor"), i2("/FontName /" + F$1(r2.fontName)), i2("/FontFile2 " + l2 + " 0 R"), i2("/FontBBox " + t2.API.PDFObject.convert(r2.metadata.bbox)), i2("/Flags " + r2.metadata.flags), i2("/StemV " + r2.metadata.stemV), i2("/ItalicAngle " + r2.metadata.italicAngle), i2("/Ascent " + r2.metadata.ascender), i2("/Descent " + r2.metadata.decender), i2("/CapHeight " + r2.metadata.capHeight), i2(">>"), i2("endobj");
        var p2 = a2();
        i2("<<"), i2("/Type /Font"), i2("/BaseFont /" + F$1(r2.fontName)), i2("/FontDescriptor " + d2 + " 0 R"), i2("/W " + t2.API.PDFObject.convert(s2)), i2("/CIDToGIDMap /Identity"), i2("/DW 1000"), i2("/Subtype /CIDFontType2"), i2("/CIDSystemInfo"), i2("<<"), i2("/Supplement 0"), i2("/Registry (Adobe)"), i2("/Ordering (" + r2.encoding + ")"), i2(">>"), i2(">>"), i2("endobj"), r2.objectNumber = a2(), i2("<<"), i2("/Type /Font"), i2("/Subtype /Type0"), i2("/ToUnicode " + f2 + " 0 R"), i2("/BaseFont /" + F$1(r2.fontName)), i2("/Encoding /" + r2.encoding), i2("/DescendantFonts [" + p2 + " 0 R]"), i2(">>"), i2("endobj"), r2.isAlreadyPutted = true;
      }
    }(e3);
  }]);
  e2.events.push(["putFont", function(e3) {
    !function(e4) {
      var r2 = e4.font, i2 = e4.out, a2 = e4.newObject, o2 = e4.putStream;
      if (r2.metadata instanceof t2.API.TTFFont && "WinAnsiEncoding" === r2.encoding) {
        for (var s2 = r2.metadata.rawData, c2 = "", u2 = 0; u2 < s2.length; u2++) c2 += String.fromCharCode(s2[u2]);
        var h2 = a2();
        o2({ data: c2, addLength1: true, objectId: h2 }), i2("endobj");
        var l2 = a2();
        o2({ data: n2(r2.metadata.toUnicode), addLength1: true, objectId: l2 }), i2("endobj");
        var f2 = a2();
        i2("<<"), i2("/Descent " + r2.metadata.decender), i2("/CapHeight " + r2.metadata.capHeight), i2("/StemV " + r2.metadata.stemV), i2("/Type /FontDescriptor"), i2("/FontFile2 " + h2 + " 0 R"), i2("/Flags 96"), i2("/FontBBox " + t2.API.PDFObject.convert(r2.metadata.bbox)), i2("/FontName /" + F$1(r2.fontName)), i2("/ItalicAngle " + r2.metadata.italicAngle), i2("/Ascent " + r2.metadata.ascender), i2(">>"), i2("endobj"), r2.objectNumber = a2();
        for (var d2 = 0; d2 < r2.metadata.hmtx.widths.length; d2++) r2.metadata.hmtx.widths[d2] = parseInt(r2.metadata.hmtx.widths[d2] * (1e3 / r2.metadata.head.unitsPerEm));
        i2("<</Subtype/TrueType/Type/Font/ToUnicode " + l2 + " 0 R/BaseFont/" + F$1(r2.fontName) + "/FontDescriptor " + f2 + " 0 R/Encoding/" + r2.encoding + " /FirstChar 29 /LastChar 255 /Widths " + t2.API.PDFObject.convert(r2.metadata.hmtx.widths) + ">>"), i2("endobj"), r2.isAlreadyPutted = true;
      }
    }(e3);
  }]);
  var i = function(t3) {
    var e3, n3 = t3.text || "", i2 = t3.x, a2 = t3.y, o2 = t3.options || {}, s2 = t3.mutex || {}, c2 = s2.pdfEscape, u2 = s2.activeFontKey, h2 = s2.fonts, l2 = u2, f2 = "", d2 = 0, p2 = "", g2 = h2[l2].encoding;
    if ("Identity-H" !== h2[l2].encoding) return { text: n3, x: i2, y: a2, options: o2, mutex: s2 };
    for (p2 = n3, l2 = u2, Array.isArray(n3) && (p2 = n3[0]), d2 = 0; d2 < p2.length; d2 += 1) h2[l2].metadata.hasOwnProperty("cmap") && (e3 = h2[l2].metadata.cmap.unicode.codeMap[p2[d2].charCodeAt(0)]), e3 || p2[d2].charCodeAt(0) < 256 && h2[l2].metadata.hasOwnProperty("Unicode") ? f2 += p2[d2] : f2 += "";
    var m2 = "";
    return parseInt(l2.slice(1)) < 14 || "WinAnsiEncoding" === g2 ? m2 = c2(f2, l2).split("").map(function(t4) {
      return t4.charCodeAt(0).toString(16);
    }).join("") : "Identity-H" === g2 && (m2 = r(f2, h2[l2])), s2.isHex = true, { text: m2, x: i2, y: a2, options: o2, mutex: s2 };
  };
  e2.events.push(["postProcessText", function(t3) {
    var e3 = t3.text || "", r2 = [], n3 = { text: e3, x: t3.x, y: t3.y, options: t3.options, mutex: t3.mutex };
    if (Array.isArray(e3)) {
      var a2 = 0;
      for (a2 = 0; a2 < e3.length; a2 += 1) Array.isArray(e3[a2]) && 3 === e3[a2].length ? r2.push([i(Object.assign({}, n3, { text: e3[a2][0] })).text, e3[a2][1], e3[a2][2]]) : r2.push(i(Object.assign({}, n3, { text: e3[a2] })).text);
      t3.text = r2;
    } else t3.text = i(Object.assign({}, n3, { text: e3 })).text;
  }]);
}(E$1), /**
 * @license
 * jsPDF virtual FileSystem functionality
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  var e2 = function() {
    return void 0 === this.internal.vFS && (this.internal.vFS = {}), true;
  };
  t2.existsFileInVFS = function(t3) {
    return e2.call(this), void 0 !== this.internal.vFS[t3];
  }, t2.addFileToVFS = function(t3, r) {
    return e2.call(this), this.internal.vFS[t3] = r, this;
  }, t2.getFileFromVFS = function(t3) {
    return e2.call(this), void 0 !== this.internal.vFS[t3] ? this.internal.vFS[t3] : null;
  };
}(E$1.API), /**
 * @license
 * Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)
 * MIT License
 */
function(t2) {
  t2.__bidiEngine__ = t2.prototype.__bidiEngine__ = function(t3) {
    var r2, n2, i, a2, o2, s2, c2, u2 = e2, h2 = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], l2 = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], f2 = { L: 0, R: 1, EN: 2, AN: 3, N: 4, B: 5, S: 6 }, d2 = { 0: 0, 5: 1, 6: 2, 7: 3, 32: 4, 251: 5, 254: 6, 255: 7 }, p2 = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "«", "»", "«", "‹", "›", "‹", "⁅", "⁆", "⁅", "⁽", "⁾", "⁽", "₍", "₎", "₍", "≤", "≥", "≤", "〈", "〉", "〈", "﹙", "﹚", "﹙", "﹛", "﹜", "﹛", "﹝", "﹞", "﹝", "﹤", "﹥", "﹤"], g2 = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), m2 = false, v2 = 0;
    this.__bidiEngine__ = {};
    var b2 = function(t4) {
      var e3 = t4.charCodeAt(), r3 = e3 >> 8, n3 = d2[r3];
      return void 0 !== n3 ? u2[256 * n3 + (255 & e3)] : 252 === r3 || 253 === r3 ? "AL" : g2.test(r3) ? "L" : 8 === r3 ? "R" : "N";
    }, y2 = function(t4) {
      for (var e3, r3 = 0; r3 < t4.length; r3++) {
        if ("L" === (e3 = b2(t4.charAt(r3)))) return false;
        if ("R" === e3) return true;
      }
      return false;
    }, w2 = function(t4, e3, o3, s3) {
      var c3, u3, h3, l3, f3 = e3[s3];
      switch (f3) {
        case "L":
        case "R":
          m2 = false;
          break;
        case "N":
        case "AN":
          break;
        case "EN":
          m2 && (f3 = "AN");
          break;
        case "AL":
          m2 = true, f3 = "R";
          break;
        case "WS":
          f3 = "N";
          break;
        case "CS":
          s3 < 1 || s3 + 1 >= e3.length || "EN" !== (c3 = o3[s3 - 1]) && "AN" !== c3 || "EN" !== (u3 = e3[s3 + 1]) && "AN" !== u3 ? f3 = "N" : m2 && (u3 = "AN"), f3 = u3 === c3 ? u3 : "N";
          break;
        case "ES":
          f3 = "EN" === (c3 = s3 > 0 ? o3[s3 - 1] : "B") && s3 + 1 < e3.length && "EN" === e3[s3 + 1] ? "EN" : "N";
          break;
        case "ET":
          if (s3 > 0 && "EN" === o3[s3 - 1]) {
            f3 = "EN";
            break;
          }
          if (m2) {
            f3 = "N";
            break;
          }
          for (h3 = s3 + 1, l3 = e3.length; h3 < l3 && "ET" === e3[h3]; ) h3++;
          f3 = h3 < l3 && "EN" === e3[h3] ? "EN" : "N";
          break;
        case "NSM":
          if (i && !a2) {
            for (l3 = e3.length, h3 = s3 + 1; h3 < l3 && "NSM" === e3[h3]; ) h3++;
            if (h3 < l3) {
              var d3 = t4[s3], p3 = d3 >= 1425 && d3 <= 2303 || 64286 === d3;
              if (c3 = e3[h3], p3 && ("R" === c3 || "AL" === c3)) {
                f3 = "R";
                break;
              }
            }
          }
          f3 = s3 < 1 || "B" === (c3 = e3[s3 - 1]) ? "N" : o3[s3 - 1];
          break;
        case "B":
          m2 = false, r2 = true, f3 = v2;
          break;
        case "S":
          n2 = true, f3 = "N";
          break;
        case "LRE":
        case "RLE":
        case "LRO":
        case "RLO":
        case "PDF":
          m2 = false;
          break;
        case "BN":
          f3 = "N";
      }
      return f3;
    }, N2 = function(t4, e3, r3) {
      var n3 = t4.split("");
      return r3 && L2(n3, r3, { hiLevel: v2 }), n3.reverse(), e3 && e3.reverse(), n3.join("");
    }, L2 = function(t4, e3, i2) {
      var a3, o3, s3, c3, u3, d3 = -1, p3 = t4.length, g3 = 0, y3 = [], N3 = v2 ? l2 : h2, L3 = [];
      for (m2 = false, r2 = false, n2 = false, o3 = 0; o3 < p3; o3++) L3[o3] = b2(t4[o3]);
      for (s3 = 0; s3 < p3; s3++) {
        if (u3 = g3, y3[s3] = w2(t4, L3, y3, s3), a3 = 240 & (g3 = N3[u3][f2[y3[s3]]]), g3 &= 15, e3[s3] = c3 = N3[g3][5], a3 > 0) if (16 === a3) {
          for (o3 = d3; o3 < s3; o3++) e3[o3] = 1;
          d3 = -1;
        } else d3 = -1;
        if (N3[g3][6]) -1 === d3 && (d3 = s3);
        else if (d3 > -1) {
          for (o3 = d3; o3 < s3; o3++) e3[o3] = c3;
          d3 = -1;
        }
        "B" === L3[s3] && (e3[s3] = 0), i2.hiLevel |= c3;
      }
      n2 && function(t5, e4, r3) {
        for (var n3 = 0; n3 < r3; n3++) if ("S" === t5[n3]) {
          e4[n3] = v2;
          for (var i3 = n3 - 1; i3 >= 0 && "WS" === t5[i3]; i3--) e4[i3] = v2;
        }
      }(L3, e3, p3);
    }, A2 = function(t4, e3, n3, i2, a3) {
      if (!(a3.hiLevel < t4)) {
        if (1 === t4 && 1 === v2 && !r2) return e3.reverse(), void (n3 && n3.reverse());
        for (var o3, s3, c3, u3, h3 = e3.length, l3 = 0; l3 < h3; ) {
          if (i2[l3] >= t4) {
            for (c3 = l3 + 1; c3 < h3 && i2[c3] >= t4; ) c3++;
            for (u3 = l3, s3 = c3 - 1; u3 < s3; u3++, s3--) o3 = e3[u3], e3[u3] = e3[s3], e3[s3] = o3, n3 && (o3 = n3[u3], n3[u3] = n3[s3], n3[s3] = o3);
            l3 = c3;
          }
          l3++;
        }
      }
    }, x2 = function(t4, e3, r3) {
      var n3 = t4.split(""), i2 = { hiLevel: v2 };
      return r3 || (r3 = []), L2(n3, r3, i2), function(t5, e4, r4) {
        if (0 !== r4.hiLevel && c2) for (var n4, i3 = 0; i3 < t5.length; i3++) 1 === e4[i3] && (n4 = p2.indexOf(t5[i3])) >= 0 && (t5[i3] = p2[n4 + 1]);
      }(n3, r3, i2), A2(2, n3, e3, r3, i2), A2(1, n3, e3, r3, i2), n3.join("");
    };
    return this.__bidiEngine__.doBidiReorder = function(t4, e3, r3) {
      if (function(t5, e4) {
        if (e4) for (var r4 = 0; r4 < t5.length; r4++) e4[r4] = r4;
        void 0 === a2 && (a2 = y2(t5)), void 0 === s2 && (s2 = y2(t5));
      }(t4, e3), i || !o2 || s2) if (i && o2 && a2 ^ s2) v2 = a2 ? 1 : 0, t4 = N2(t4, e3, r3);
      else if (!i && o2 && s2) v2 = a2 ? 1 : 0, t4 = x2(t4, e3, r3), t4 = N2(t4, e3);
      else if (!i || a2 || o2 || s2) {
        if (i && !o2 && a2 ^ s2) t4 = N2(t4, e3), a2 ? (v2 = 0, t4 = x2(t4, e3, r3)) : (v2 = 1, t4 = x2(t4, e3, r3), t4 = N2(t4, e3));
        else if (i && a2 && !o2 && s2) v2 = 1, t4 = x2(t4, e3, r3), t4 = N2(t4, e3);
        else if (!i && !o2 && a2 ^ s2) {
          var n3 = c2;
          a2 ? (v2 = 1, t4 = x2(t4, e3, r3), v2 = 0, c2 = false, t4 = x2(t4, e3, r3), c2 = n3) : (v2 = 0, t4 = x2(t4, e3, r3), t4 = N2(t4, e3), v2 = 1, c2 = false, t4 = x2(t4, e3, r3), c2 = n3, t4 = N2(t4, e3));
        }
      } else v2 = 0, t4 = x2(t4, e3, r3);
      else v2 = a2 ? 1 : 0, t4 = x2(t4, e3, r3);
      return t4;
    }, this.__bidiEngine__.setOptions = function(t4) {
      t4 && (i = t4.isInputVisual, o2 = t4.isOutputVisual, a2 = t4.isInputRtl, s2 = t4.isOutputRtl, c2 = t4.isSymmetricSwapping);
    }, this.__bidiEngine__.setOptions(t3), this.__bidiEngine__;
  };
  var e2 = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"], r = new t2.__bidiEngine__({ isInputVisual: true });
  t2.API.events.push(["postProcessText", function(t3) {
    var e3 = t3.text, n2 = (t3.x, t3.y, t3.options || {}), i = (t3.mutex, n2.lang, []);
    if (n2.isInputVisual = "boolean" != typeof n2.isInputVisual || n2.isInputVisual, r.setOptions(n2), "[object Array]" === Object.prototype.toString.call(e3)) {
      var a2 = 0;
      for (i = [], a2 = 0; a2 < e3.length; a2 += 1) "[object Array]" === Object.prototype.toString.call(e3[a2]) ? i.push([r.doBidiReorder(e3[a2][0]), e3[a2][1], e3[a2][2]]) : i.push([r.doBidiReorder(e3[a2])]);
      t3.text = i;
    } else t3.text = r.doBidiReorder(e3);
    r.setOptions({ isInputVisual: true });
  }]);
}(E$1), E$1.API.TTFFont = function() {
  function t2(t3) {
    var e2;
    if (this.rawData = t3, e2 = this.contents = new ne(t3), this.contents.pos = 4, "ttcf" === e2.readString(4)) throw new Error("TTCF not supported.");
    e2.pos = 0, this.parse(), this.subset = new Le(this), this.registerTTF();
  }
  return t2.open = function(e2) {
    return new t2(e2);
  }, t2.prototype.parse = function() {
    return this.directory = new ie(this.contents), this.head = new se(this), this.name = new pe(this), this.cmap = new ue(this), this.toUnicode = {}, this.hhea = new he(this), this.maxp = new ge(this), this.hmtx = new me(this), this.post = new fe(this), this.os2 = new le(this), this.loca = new Ne(this), this.glyf = new be(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
  }, t2.prototype.registerTTF = function() {
    var t3, e2, r, n2, i;
    if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = (function() {
      var e3, r2, n3, i2;
      for (i2 = [], e3 = 0, r2 = (n3 = this.bbox).length; e3 < r2; e3++) t3 = n3[e3], i2.push(Math.round(t3 * this.scaleFactor));
      return i2;
    }).call(this), this.stemV = 0, this.post.exists ? (r = 255 & (n2 = this.post.italic_angle), 0 != (32768 & (e2 = n2 >> 16)) && (e2 = -(1 + (65535 ^ e2))), this.italicAngle = +(e2 + "." + r)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = 1 === (i = this.familyClass) || 2 === i || 3 === i || 4 === i || 5 === i || 7 === i, this.isScript = 10 === this.familyClass, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), 0 !== this.italicAngle && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode) throw new Error("No unicode cmap for font");
  }, t2.prototype.characterToGlyph = function(t3) {
    var e2;
    return (null != (e2 = this.cmap.unicode) ? e2.codeMap[t3] : void 0) || 0;
  }, t2.prototype.widthOfGlyph = function(t3) {
    var e2;
    return e2 = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(t3).advance * e2;
  }, t2.prototype.widthOfString = function(t3, e2, r) {
    var n2, i, a2, o2;
    for (a2 = 0, i = 0, o2 = (t3 = "" + t3).length; 0 <= o2 ? i < o2 : i > o2; i = 0 <= o2 ? ++i : --i) n2 = t3.charCodeAt(i), a2 += this.widthOfGlyph(this.characterToGlyph(n2)) + r * (1e3 / e2) || 0;
    return a2 * (e2 / 1e3);
  }, t2.prototype.lineHeight = function(t3, e2) {
    var r;
    return null == e2 && (e2 = false), r = e2 ? this.lineGap : 0, (this.ascender + r - this.decender) / 1e3 * t3;
  }, t2;
}();
var re, ne = function() {
  function t2(t3) {
    this.data = null != t3 ? t3 : [], this.pos = 0, this.length = this.data.length;
  }
  return t2.prototype.readByte = function() {
    return this.data[this.pos++];
  }, t2.prototype.writeByte = function(t3) {
    return this.data[this.pos++] = t3;
  }, t2.prototype.readUInt32 = function() {
    return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
  }, t2.prototype.writeUInt32 = function(t3) {
    return this.writeByte(t3 >>> 24 & 255), this.writeByte(t3 >> 16 & 255), this.writeByte(t3 >> 8 & 255), this.writeByte(255 & t3);
  }, t2.prototype.readInt32 = function() {
    var t3;
    return (t3 = this.readUInt32()) >= 2147483648 ? t3 - 4294967296 : t3;
  }, t2.prototype.writeInt32 = function(t3) {
    return t3 < 0 && (t3 += 4294967296), this.writeUInt32(t3);
  }, t2.prototype.readUInt16 = function() {
    return this.readByte() << 8 | this.readByte();
  }, t2.prototype.writeUInt16 = function(t3) {
    return this.writeByte(t3 >> 8 & 255), this.writeByte(255 & t3);
  }, t2.prototype.readInt16 = function() {
    var t3;
    return (t3 = this.readUInt16()) >= 32768 ? t3 - 65536 : t3;
  }, t2.prototype.writeInt16 = function(t3) {
    return t3 < 0 && (t3 += 65536), this.writeUInt16(t3);
  }, t2.prototype.readString = function(t3) {
    var e2, r;
    for (r = [], e2 = 0; 0 <= t3 ? e2 < t3 : e2 > t3; e2 = 0 <= t3 ? ++e2 : --e2) r[e2] = String.fromCharCode(this.readByte());
    return r.join("");
  }, t2.prototype.writeString = function(t3) {
    var e2, r, n2;
    for (n2 = [], e2 = 0, r = t3.length; 0 <= r ? e2 < r : e2 > r; e2 = 0 <= r ? ++e2 : --e2) n2.push(this.writeByte(t3.charCodeAt(e2)));
    return n2;
  }, t2.prototype.readShort = function() {
    return this.readInt16();
  }, t2.prototype.writeShort = function(t3) {
    return this.writeInt16(t3);
  }, t2.prototype.readLongLong = function() {
    var t3, e2, r, n2, i, a2, o2, s2;
    return t3 = this.readByte(), e2 = this.readByte(), r = this.readByte(), n2 = this.readByte(), i = this.readByte(), a2 = this.readByte(), o2 = this.readByte(), s2 = this.readByte(), 128 & t3 ? -1 * (72057594037927940 * (255 ^ t3) + 281474976710656 * (255 ^ e2) + 1099511627776 * (255 ^ r) + 4294967296 * (255 ^ n2) + 16777216 * (255 ^ i) + 65536 * (255 ^ a2) + 256 * (255 ^ o2) + (255 ^ s2) + 1) : 72057594037927940 * t3 + 281474976710656 * e2 + 1099511627776 * r + 4294967296 * n2 + 16777216 * i + 65536 * a2 + 256 * o2 + s2;
  }, t2.prototype.writeLongLong = function(t3) {
    var e2, r;
    return e2 = Math.floor(t3 / 4294967296), r = 4294967295 & t3, this.writeByte(e2 >> 24 & 255), this.writeByte(e2 >> 16 & 255), this.writeByte(e2 >> 8 & 255), this.writeByte(255 & e2), this.writeByte(r >> 24 & 255), this.writeByte(r >> 16 & 255), this.writeByte(r >> 8 & 255), this.writeByte(255 & r);
  }, t2.prototype.readInt = function() {
    return this.readInt32();
  }, t2.prototype.writeInt = function(t3) {
    return this.writeInt32(t3);
  }, t2.prototype.read = function(t3) {
    var e2, r;
    for (e2 = [], r = 0; 0 <= t3 ? r < t3 : r > t3; r = 0 <= t3 ? ++r : --r) e2.push(this.readByte());
    return e2;
  }, t2.prototype.write = function(t3) {
    var e2, r, n2, i;
    for (i = [], r = 0, n2 = t3.length; r < n2; r++) e2 = t3[r], i.push(this.writeByte(e2));
    return i;
  }, t2;
}(), ie = function() {
  var t2;
  function e2(t3) {
    var e3, r, n2;
    for (this.scalarType = t3.readInt(), this.tableCount = t3.readShort(), this.searchRange = t3.readShort(), this.entrySelector = t3.readShort(), this.rangeShift = t3.readShort(), this.tables = {}, r = 0, n2 = this.tableCount; 0 <= n2 ? r < n2 : r > n2; r = 0 <= n2 ? ++r : --r) e3 = { tag: t3.readString(4), checksum: t3.readInt(), offset: t3.readInt(), length: t3.readInt() }, this.tables[e3.tag] = e3;
  }
  return e2.prototype.encode = function(e3) {
    var r, n2, i, a2, o2, s2, c2, u2, h2, l2, f2, d2, p2;
    for (p2 in f2 = Object.keys(e3).length, s2 = Math.log(2), h2 = 16 * Math.floor(Math.log(f2) / s2), a2 = Math.floor(h2 / s2), u2 = 16 * f2 - h2, (n2 = new ne()).writeInt(this.scalarType), n2.writeShort(f2), n2.writeShort(h2), n2.writeShort(a2), n2.writeShort(u2), i = 16 * f2, c2 = n2.pos + i, o2 = null, d2 = [], e3) for (l2 = e3[p2], n2.writeString(p2), n2.writeInt(t2(l2)), n2.writeInt(c2), n2.writeInt(l2.length), d2 = d2.concat(l2), "head" === p2 && (o2 = c2), c2 += l2.length; c2 % 4; ) d2.push(0), c2++;
    return n2.write(d2), r = 2981146554 - t2(n2.data), n2.pos = o2 + 8, n2.writeUInt32(r), n2.data;
  }, t2 = function(t3) {
    var e3, r, n2, i;
    for (t3 = ve.call(t3); t3.length % 4; ) t3.push(0);
    for (n2 = new ne(t3), r = 0, e3 = 0, i = t3.length; e3 < i; e3 = e3 += 4) r += n2.readUInt32();
    return 4294967295 & r;
  }, e2;
}(), ae = {}.hasOwnProperty, oe = function(t2, e2) {
  for (var r in e2) ae.call(e2, r) && (t2[r] = e2[r]);
  function n2() {
    this.constructor = t2;
  }
  return n2.prototype = e2.prototype, t2.prototype = new n2(), t2.__super__ = e2.prototype, t2;
};
re = function() {
  function t2(t3) {
    var e2;
    this.file = t3, e2 = this.file.directory.tables[this.tag], this.exists = !!e2, e2 && (this.offset = e2.offset, this.length = e2.length, this.parse(this.file.contents));
  }
  return t2.prototype.parse = function() {
  }, t2.prototype.encode = function() {
  }, t2.prototype.raw = function() {
    return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
  }, t2;
}();
var se = function(t2) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "head", e2.prototype.parse = function(t3) {
    return t3.pos = this.offset, this.version = t3.readInt(), this.revision = t3.readInt(), this.checkSumAdjustment = t3.readInt(), this.magicNumber = t3.readInt(), this.flags = t3.readShort(), this.unitsPerEm = t3.readShort(), this.created = t3.readLongLong(), this.modified = t3.readLongLong(), this.xMin = t3.readShort(), this.yMin = t3.readShort(), this.xMax = t3.readShort(), this.yMax = t3.readShort(), this.macStyle = t3.readShort(), this.lowestRecPPEM = t3.readShort(), this.fontDirectionHint = t3.readShort(), this.indexToLocFormat = t3.readShort(), this.glyphDataFormat = t3.readShort();
  }, e2.prototype.encode = function(t3) {
    var e3;
    return (e3 = new ne()).writeInt(this.version), e3.writeInt(this.revision), e3.writeInt(this.checkSumAdjustment), e3.writeInt(this.magicNumber), e3.writeShort(this.flags), e3.writeShort(this.unitsPerEm), e3.writeLongLong(this.created), e3.writeLongLong(this.modified), e3.writeShort(this.xMin), e3.writeShort(this.yMin), e3.writeShort(this.xMax), e3.writeShort(this.yMax), e3.writeShort(this.macStyle), e3.writeShort(this.lowestRecPPEM), e3.writeShort(this.fontDirectionHint), e3.writeShort(t3), e3.writeShort(this.glyphDataFormat), e3.data;
  }, e2;
}(), ce = function() {
  function t2(t3, e2) {
    var r, n2, i, a2, o2, s2, c2, u2, h2, l2, f2, d2, p2, g2, m2, v2, b2;
    switch (this.platformID = t3.readUInt16(), this.encodingID = t3.readShort(), this.offset = e2 + t3.readInt(), h2 = t3.pos, t3.pos = this.offset, this.format = t3.readUInt16(), this.length = t3.readUInt16(), this.language = t3.readUInt16(), this.isUnicode = 3 === this.platformID && 1 === this.encodingID && 4 === this.format || 0 === this.platformID && 4 === this.format, this.codeMap = {}, this.format) {
      case 0:
        for (s2 = 0; s2 < 256; ++s2) this.codeMap[s2] = t3.readByte();
        break;
      case 4:
        for (f2 = t3.readUInt16(), l2 = f2 / 2, t3.pos += 6, i = function() {
          var e3, r2;
          for (r2 = [], s2 = e3 = 0; 0 <= l2 ? e3 < l2 : e3 > l2; s2 = 0 <= l2 ? ++e3 : --e3) r2.push(t3.readUInt16());
          return r2;
        }(), t3.pos += 2, p2 = function() {
          var e3, r2;
          for (r2 = [], s2 = e3 = 0; 0 <= l2 ? e3 < l2 : e3 > l2; s2 = 0 <= l2 ? ++e3 : --e3) r2.push(t3.readUInt16());
          return r2;
        }(), c2 = function() {
          var e3, r2;
          for (r2 = [], s2 = e3 = 0; 0 <= l2 ? e3 < l2 : e3 > l2; s2 = 0 <= l2 ? ++e3 : --e3) r2.push(t3.readUInt16());
          return r2;
        }(), u2 = function() {
          var e3, r2;
          for (r2 = [], s2 = e3 = 0; 0 <= l2 ? e3 < l2 : e3 > l2; s2 = 0 <= l2 ? ++e3 : --e3) r2.push(t3.readUInt16());
          return r2;
        }(), n2 = (this.length - t3.pos + this.offset) / 2, o2 = function() {
          var e3, r2;
          for (r2 = [], s2 = e3 = 0; 0 <= n2 ? e3 < n2 : e3 > n2; s2 = 0 <= n2 ? ++e3 : --e3) r2.push(t3.readUInt16());
          return r2;
        }(), s2 = m2 = 0, b2 = i.length; m2 < b2; s2 = ++m2) for (g2 = i[s2], r = v2 = d2 = p2[s2]; d2 <= g2 ? v2 <= g2 : v2 >= g2; r = d2 <= g2 ? ++v2 : --v2) 0 === u2[s2] ? a2 = r + c2[s2] : 0 !== (a2 = o2[u2[s2] / 2 + (r - d2) - (l2 - s2)] || 0) && (a2 += c2[s2]), this.codeMap[r] = 65535 & a2;
    }
    t3.pos = h2;
  }
  return t2.encode = function(t3, e2) {
    var r, n2, i, a2, o2, s2, c2, u2, h2, l2, f2, d2, p2, g2, m2, v2, b2, y2, w2, N2, L2, A2, x2, S2, _2, P2, k2, I2, F2, C2, j2, O2, B3, M2, E2, q2, D2, R2, T2, U2, z2, H4, W2, V2, G2, Y2;
    switch (I2 = new ne(), a2 = Object.keys(t3).sort(function(t4, e3) {
      return t4 - e3;
    }), e2) {
      case "macroman":
        for (p2 = 0, g2 = function() {
          var t4 = [];
          for (d2 = 0; d2 < 256; ++d2) t4.push(0);
          return t4;
        }(), v2 = { 0: 0 }, i = {}, F2 = 0, B3 = a2.length; F2 < B3; F2++) null == v2[W2 = t3[n2 = a2[F2]]] && (v2[W2] = ++p2), i[n2] = { old: t3[n2], new: v2[t3[n2]] }, g2[n2] = v2[t3[n2]];
        return I2.writeUInt16(1), I2.writeUInt16(0), I2.writeUInt32(12), I2.writeUInt16(0), I2.writeUInt16(262), I2.writeUInt16(0), I2.write(g2), { charMap: i, subtable: I2.data, maxGlyphID: p2 + 1 };
      case "unicode":
        for (P2 = [], h2 = [], b2 = 0, v2 = {}, r = {}, m2 = c2 = null, C2 = 0, M2 = a2.length; C2 < M2; C2++) null == v2[w2 = t3[n2 = a2[C2]]] && (v2[w2] = ++b2), r[n2] = { old: w2, new: v2[w2] }, o2 = v2[w2] - n2, null != m2 && o2 === c2 || (m2 && h2.push(m2), P2.push(n2), c2 = o2), m2 = n2;
        for (m2 && h2.push(m2), h2.push(65535), P2.push(65535), S2 = 2 * (x2 = P2.length), A2 = 2 * Math.pow(Math.log(x2) / Math.LN2, 2), l2 = Math.log(A2 / 2) / Math.LN2, L2 = 2 * x2 - A2, s2 = [], N2 = [], f2 = [], d2 = j2 = 0, E2 = P2.length; j2 < E2; d2 = ++j2) {
          if (_2 = P2[d2], u2 = h2[d2], 65535 === _2) {
            s2.push(0), N2.push(0);
            break;
          }
          if (_2 - (k2 = r[_2].new) >= 32768) for (s2.push(0), N2.push(2 * (f2.length + x2 - d2)), n2 = O2 = _2; _2 <= u2 ? O2 <= u2 : O2 >= u2; n2 = _2 <= u2 ? ++O2 : --O2) f2.push(r[n2].new);
          else s2.push(k2 - _2), N2.push(0);
        }
        for (I2.writeUInt16(3), I2.writeUInt16(1), I2.writeUInt32(12), I2.writeUInt16(4), I2.writeUInt16(16 + 8 * x2 + 2 * f2.length), I2.writeUInt16(0), I2.writeUInt16(S2), I2.writeUInt16(A2), I2.writeUInt16(l2), I2.writeUInt16(L2), z2 = 0, q2 = h2.length; z2 < q2; z2++) n2 = h2[z2], I2.writeUInt16(n2);
        for (I2.writeUInt16(0), H4 = 0, D2 = P2.length; H4 < D2; H4++) n2 = P2[H4], I2.writeUInt16(n2);
        for (V2 = 0, R2 = s2.length; V2 < R2; V2++) o2 = s2[V2], I2.writeUInt16(o2);
        for (G2 = 0, T2 = N2.length; G2 < T2; G2++) y2 = N2[G2], I2.writeUInt16(y2);
        for (Y2 = 0, U2 = f2.length; Y2 < U2; Y2++) p2 = f2[Y2], I2.writeUInt16(p2);
        return { charMap: r, subtable: I2.data, maxGlyphID: b2 + 1 };
    }
  }, t2;
}(), ue = function(t2) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "cmap", e2.prototype.parse = function(t3) {
    var e3, r, n2;
    for (t3.pos = this.offset, this.version = t3.readUInt16(), n2 = t3.readUInt16(), this.tables = [], this.unicode = null, r = 0; 0 <= n2 ? r < n2 : r > n2; r = 0 <= n2 ? ++r : --r) e3 = new ce(t3, this.offset), this.tables.push(e3), e3.isUnicode && null == this.unicode && (this.unicode = e3);
    return true;
  }, e2.encode = function(t3, e3) {
    var r, n2;
    return null == e3 && (e3 = "macroman"), r = ce.encode(t3, e3), (n2 = new ne()).writeUInt16(0), n2.writeUInt16(1), r.table = n2.data.concat(r.subtable), r;
  }, e2;
}(), he = function(t2) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "hhea", e2.prototype.parse = function(t3) {
    return t3.pos = this.offset, this.version = t3.readInt(), this.ascender = t3.readShort(), this.decender = t3.readShort(), this.lineGap = t3.readShort(), this.advanceWidthMax = t3.readShort(), this.minLeftSideBearing = t3.readShort(), this.minRightSideBearing = t3.readShort(), this.xMaxExtent = t3.readShort(), this.caretSlopeRise = t3.readShort(), this.caretSlopeRun = t3.readShort(), this.caretOffset = t3.readShort(), t3.pos += 8, this.metricDataFormat = t3.readShort(), this.numberOfMetrics = t3.readUInt16();
  }, e2;
}(), le = function(t2) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "OS/2", e2.prototype.parse = function(t3) {
    if (t3.pos = this.offset, this.version = t3.readUInt16(), this.averageCharWidth = t3.readShort(), this.weightClass = t3.readUInt16(), this.widthClass = t3.readUInt16(), this.type = t3.readShort(), this.ySubscriptXSize = t3.readShort(), this.ySubscriptYSize = t3.readShort(), this.ySubscriptXOffset = t3.readShort(), this.ySubscriptYOffset = t3.readShort(), this.ySuperscriptXSize = t3.readShort(), this.ySuperscriptYSize = t3.readShort(), this.ySuperscriptXOffset = t3.readShort(), this.ySuperscriptYOffset = t3.readShort(), this.yStrikeoutSize = t3.readShort(), this.yStrikeoutPosition = t3.readShort(), this.familyClass = t3.readShort(), this.panose = function() {
      var e3, r;
      for (r = [], e3 = 0; e3 < 10; ++e3) r.push(t3.readByte());
      return r;
    }(), this.charRange = function() {
      var e3, r;
      for (r = [], e3 = 0; e3 < 4; ++e3) r.push(t3.readInt());
      return r;
    }(), this.vendorID = t3.readString(4), this.selection = t3.readShort(), this.firstCharIndex = t3.readShort(), this.lastCharIndex = t3.readShort(), this.version > 0 && (this.ascent = t3.readShort(), this.descent = t3.readShort(), this.lineGap = t3.readShort(), this.winAscent = t3.readShort(), this.winDescent = t3.readShort(), this.codePageRange = function() {
      var e3, r;
      for (r = [], e3 = 0; e3 < 2; e3 = ++e3) r.push(t3.readInt());
      return r;
    }(), this.version > 1)) return this.xHeight = t3.readShort(), this.capHeight = t3.readShort(), this.defaultChar = t3.readShort(), this.breakChar = t3.readShort(), this.maxContext = t3.readShort();
  }, e2;
}(), fe = function(t2) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "post", e2.prototype.parse = function(t3) {
    var e3, r, n2;
    switch (t3.pos = this.offset, this.format = t3.readInt(), this.italicAngle = t3.readInt(), this.underlinePosition = t3.readShort(), this.underlineThickness = t3.readShort(), this.isFixedPitch = t3.readInt(), this.minMemType42 = t3.readInt(), this.maxMemType42 = t3.readInt(), this.minMemType1 = t3.readInt(), this.maxMemType1 = t3.readInt(), this.format) {
      case 65536:
        break;
      case 131072:
        var i;
        for (r = t3.readUInt16(), this.glyphNameIndex = [], i = 0; 0 <= r ? i < r : i > r; i = 0 <= r ? ++i : --i) this.glyphNameIndex.push(t3.readUInt16());
        for (this.names = [], n2 = []; t3.pos < this.offset + this.length; ) e3 = t3.readByte(), n2.push(this.names.push(t3.readString(e3)));
        return n2;
      case 151552:
        return r = t3.readUInt16(), this.offsets = t3.read(r);
      case 196608:
        break;
      case 262144:
        return this.map = (function() {
          var e4, r2, n3;
          for (n3 = [], i = e4 = 0, r2 = this.file.maxp.numGlyphs; 0 <= r2 ? e4 < r2 : e4 > r2; i = 0 <= r2 ? ++e4 : --e4) n3.push(t3.readUInt32());
          return n3;
        }).call(this);
    }
  }, e2;
}(), de = function(t2, e2) {
  this.raw = t2, this.length = t2.length, this.platformID = e2.platformID, this.encodingID = e2.encodingID, this.languageID = e2.languageID;
}, pe = function(t2) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "name", e2.prototype.parse = function(t3) {
    var e3, r, n2, i, a2, o2, s2, c2, u2, h2, l2;
    for (t3.pos = this.offset, t3.readShort(), e3 = t3.readShort(), o2 = t3.readShort(), r = [], i = 0; 0 <= e3 ? i < e3 : i > e3; i = 0 <= e3 ? ++i : --i) r.push({ platformID: t3.readShort(), encodingID: t3.readShort(), languageID: t3.readShort(), nameID: t3.readShort(), length: t3.readShort(), offset: this.offset + o2 + t3.readShort() });
    for (s2 = {}, i = u2 = 0, h2 = r.length; u2 < h2; i = ++u2) n2 = r[i], t3.pos = n2.offset, c2 = t3.readString(n2.length), a2 = new de(c2, n2), null == s2[l2 = n2.nameID] && (s2[l2] = []), s2[n2.nameID].push(a2);
    this.strings = s2, this.copyright = s2[0], this.fontFamily = s2[1], this.fontSubfamily = s2[2], this.uniqueSubfamily = s2[3], this.fontName = s2[4], this.version = s2[5];
    try {
      this.postscriptName = s2[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    } catch (t4) {
      this.postscriptName = s2[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    }
    return this.trademark = s2[7], this.manufacturer = s2[8], this.designer = s2[9], this.description = s2[10], this.vendorUrl = s2[11], this.designerUrl = s2[12], this.license = s2[13], this.licenseUrl = s2[14], this.preferredFamily = s2[15], this.preferredSubfamily = s2[17], this.compatibleFull = s2[18], this.sampleText = s2[19];
  }, e2;
}(), ge = function(t2) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "maxp", e2.prototype.parse = function(t3) {
    return t3.pos = this.offset, this.version = t3.readInt(), this.numGlyphs = t3.readUInt16(), this.maxPoints = t3.readUInt16(), this.maxContours = t3.readUInt16(), this.maxCompositePoints = t3.readUInt16(), this.maxComponentContours = t3.readUInt16(), this.maxZones = t3.readUInt16(), this.maxTwilightPoints = t3.readUInt16(), this.maxStorage = t3.readUInt16(), this.maxFunctionDefs = t3.readUInt16(), this.maxInstructionDefs = t3.readUInt16(), this.maxStackElements = t3.readUInt16(), this.maxSizeOfInstructions = t3.readUInt16(), this.maxComponentElements = t3.readUInt16(), this.maxComponentDepth = t3.readUInt16();
  }, e2;
}(), me = function(t2) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "hmtx", e2.prototype.parse = function(t3) {
    var e3, r, n2, i, a2, o2, s2;
    for (t3.pos = this.offset, this.metrics = [], e3 = 0, o2 = this.file.hhea.numberOfMetrics; 0 <= o2 ? e3 < o2 : e3 > o2; e3 = 0 <= o2 ? ++e3 : --e3) this.metrics.push({ advance: t3.readUInt16(), lsb: t3.readInt16() });
    for (n2 = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = function() {
      var r2, i2;
      for (i2 = [], e3 = r2 = 0; 0 <= n2 ? r2 < n2 : r2 > n2; e3 = 0 <= n2 ? ++r2 : --r2) i2.push(t3.readInt16());
      return i2;
    }(), this.widths = (function() {
      var t4, e4, r2, n3;
      for (n3 = [], t4 = 0, e4 = (r2 = this.metrics).length; t4 < e4; t4++) i = r2[t4], n3.push(i.advance);
      return n3;
    }).call(this), r = this.widths[this.widths.length - 1], s2 = [], e3 = a2 = 0; 0 <= n2 ? a2 < n2 : a2 > n2; e3 = 0 <= n2 ? ++a2 : --a2) s2.push(this.widths.push(r));
    return s2;
  }, e2.prototype.forGlyph = function(t3) {
    return t3 in this.metrics ? this.metrics[t3] : { advance: this.metrics[this.metrics.length - 1].advance, lsb: this.leftSideBearings[t3 - this.metrics.length] };
  }, e2;
}(), ve = [].slice, be = function(t2) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "glyf", e2.prototype.parse = function() {
    return this.cache = {};
  }, e2.prototype.glyphFor = function(t3) {
    var e3, r, n2, i, a2, o2, s2, c2, u2, h2;
    return t3 in this.cache ? this.cache[t3] : (i = this.file.loca, e3 = this.file.contents, r = i.indexOf(t3), 0 === (n2 = i.lengthOf(t3)) ? this.cache[t3] = null : (e3.pos = this.offset + r, a2 = (o2 = new ne(e3.read(n2))).readShort(), c2 = o2.readShort(), h2 = o2.readShort(), s2 = o2.readShort(), u2 = o2.readShort(), this.cache[t3] = -1 === a2 ? new we(o2, c2, h2, s2, u2) : new ye(o2, a2, c2, h2, s2, u2), this.cache[t3]));
  }, e2.prototype.encode = function(t3, e3, r) {
    var n2, i, a2, o2, s2;
    for (a2 = [], i = [], o2 = 0, s2 = e3.length; o2 < s2; o2++) n2 = t3[e3[o2]], i.push(a2.length), n2 && (a2 = a2.concat(n2.encode(r)));
    return i.push(a2.length), { table: a2, offsets: i };
  }, e2;
}(), ye = function() {
  function t2(t3, e2, r, n2, i, a2) {
    this.raw = t3, this.numberOfContours = e2, this.xMin = r, this.yMin = n2, this.xMax = i, this.yMax = a2, this.compound = false;
  }
  return t2.prototype.encode = function() {
    return this.raw.data;
  }, t2;
}(), we = function() {
  function t2(t3, e2, r, n2, i) {
    var a2, o2;
    for (this.raw = t3, this.xMin = e2, this.yMin = r, this.xMax = n2, this.yMax = i, this.compound = true, this.glyphIDs = [], this.glyphOffsets = [], a2 = this.raw; o2 = a2.readShort(), this.glyphOffsets.push(a2.pos), this.glyphIDs.push(a2.readUInt16()), 32 & o2; ) a2.pos += 1 & o2 ? 4 : 2, 128 & o2 ? a2.pos += 8 : 64 & o2 ? a2.pos += 4 : 8 & o2 && (a2.pos += 2);
  }
  return t2.prototype.encode = function() {
    var t3, e2, r;
    for (e2 = new ne(ve.call(this.raw.data)), t3 = 0, r = this.glyphIDs.length; t3 < r; ++t3) e2.pos = this.glyphOffsets[t3];
    return e2.data;
  }, t2;
}(), Ne = function(t2) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "loca", e2.prototype.parse = function(t3) {
    var e3, r;
    return t3.pos = this.offset, e3 = this.file.head.indexToLocFormat, this.offsets = 0 === e3 ? (function() {
      var e4, n2;
      for (n2 = [], r = 0, e4 = this.length; r < e4; r += 2) n2.push(2 * t3.readUInt16());
      return n2;
    }).call(this) : (function() {
      var e4, n2;
      for (n2 = [], r = 0, e4 = this.length; r < e4; r += 4) n2.push(t3.readUInt32());
      return n2;
    }).call(this);
  }, e2.prototype.indexOf = function(t3) {
    return this.offsets[t3];
  }, e2.prototype.lengthOf = function(t3) {
    return this.offsets[t3 + 1] - this.offsets[t3];
  }, e2.prototype.encode = function(t3, e3) {
    for (var r = new Uint32Array(this.offsets.length), n2 = 0, i = 0, a2 = 0; a2 < r.length; ++a2) if (r[a2] = n2, i < e3.length && e3[i] == a2) {
      ++i, r[a2] = n2;
      var o2 = this.offsets[a2], s2 = this.offsets[a2 + 1] - o2;
      s2 > 0 && (n2 += s2);
    }
    for (var c2 = new Array(4 * r.length), u2 = 0; u2 < r.length; ++u2) c2[4 * u2 + 3] = 255 & r[u2], c2[4 * u2 + 2] = (65280 & r[u2]) >> 8, c2[4 * u2 + 1] = (16711680 & r[u2]) >> 16, c2[4 * u2] = (4278190080 & r[u2]) >> 24;
    return c2;
  }, e2;
}(), Le = function() {
  function t2(t3) {
    this.font = t3, this.subset = {}, this.unicodes = {}, this.next = 33;
  }
  return t2.prototype.generateCmap = function() {
    var t3, e2, r, n2, i;
    for (e2 in n2 = this.font.cmap.tables[0].codeMap, t3 = {}, i = this.subset) r = i[e2], t3[e2] = n2[r];
    return t3;
  }, t2.prototype.glyphsFor = function(t3) {
    var e2, r, n2, i, a2, o2, s2;
    for (n2 = {}, a2 = 0, o2 = t3.length; a2 < o2; a2++) n2[i = t3[a2]] = this.font.glyf.glyphFor(i);
    for (i in e2 = [], n2) (null != (r = n2[i]) ? r.compound : void 0) && e2.push.apply(e2, r.glyphIDs);
    if (e2.length > 0) for (i in s2 = this.glyphsFor(e2)) r = s2[i], n2[i] = r;
    return n2;
  }, t2.prototype.encode = function(t3, e2) {
    var r, n2, i, a2, o2, s2, c2, u2, h2, l2, f2, d2, p2, g2, m2;
    for (n2 in r = ue.encode(this.generateCmap(), "unicode"), a2 = this.glyphsFor(t3), f2 = { 0: 0 }, m2 = r.charMap) f2[(s2 = m2[n2]).old] = s2.new;
    for (d2 in l2 = r.maxGlyphID, a2) d2 in f2 || (f2[d2] = l2++);
    return u2 = function(t4) {
      var e3, r2;
      for (e3 in r2 = {}, t4) r2[t4[e3]] = e3;
      return r2;
    }(f2), h2 = Object.keys(u2).sort(function(t4, e3) {
      return t4 - e3;
    }), p2 = function() {
      var t4, e3, r2;
      for (r2 = [], t4 = 0, e3 = h2.length; t4 < e3; t4++) o2 = h2[t4], r2.push(u2[o2]);
      return r2;
    }(), i = this.font.glyf.encode(a2, p2, f2), c2 = this.font.loca.encode(i.offsets, p2), g2 = { cmap: this.font.cmap.raw(), glyf: i.table, loca: c2, hmtx: this.font.hmtx.raw(), hhea: this.font.hhea.raw(), maxp: this.font.maxp.raw(), post: this.font.post.raw(), name: this.font.name.raw(), head: this.font.head.encode(e2) }, this.font.os2.exists && (g2["OS/2"] = this.font.os2.raw()), this.font.directory.encode(g2);
  }, t2;
}();
E$1.API.PDFObject = function() {
  var t2;
  function e2() {
  }
  return t2 = function(t3, e3) {
    return (Array(e3 + 1).join("0") + t3).slice(-e3);
  }, e2.convert = function(r) {
    var n2, i, a2, o2;
    if (Array.isArray(r)) return "[" + function() {
      var t3, i2, a3;
      for (a3 = [], t3 = 0, i2 = r.length; t3 < i2; t3++) n2 = r[t3], a3.push(e2.convert(n2));
      return a3;
    }().join(" ") + "]";
    if ("string" == typeof r) return "/" + r;
    if (null != r ? r.isString : void 0) return "(" + r + ")";
    if (r instanceof Date) return "(D:" + t2(r.getUTCFullYear(), 4) + t2(r.getUTCMonth(), 2) + t2(r.getUTCDate(), 2) + t2(r.getUTCHours(), 2) + t2(r.getUTCMinutes(), 2) + t2(r.getUTCSeconds(), 2) + "Z)";
    if ("[object Object]" === {}.toString.call(r)) {
      for (i in a2 = ["<<"], r) o2 = r[i], a2.push("/" + i + " " + e2.convert(o2));
      return a2.push(">>"), a2.join("\n");
    }
    return "" + r;
  }, e2;
}();
/*!
 * html2canvas 1.4.1 <https://html2canvas.hertzen.com>
 * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
 * Released under MIT License
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d3[p2] = b3[p2];
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve2) {
      resolve2(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1) throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (_2) try {
      if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done) return t2;
      if (y2 = 0, t2) op = [op[0] & 2, t2.value];
      switch (op[0]) {
        case 0:
        case 1:
          t2 = op;
          break;
        case 4:
          _2.label++;
          return { value: op[1], done: false };
        case 5:
          _2.label++;
          y2 = op[1];
          op = [0];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t2[1]) {
            _2.label = t2[1];
            t2 = op;
            break;
          }
          if (t2 && _2.label < t2[2]) {
            _2.label = t2[2];
            _2.ops.push(op);
            break;
          }
          if (t2[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e2) {
      op = [6, e2];
      y2 = 0;
    } finally {
      f2 = t2 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __spreadArray(to, from, pack2) {
  if (arguments.length === 2) for (var i = 0, l2 = from.length, ar; i < l2; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || from);
}
var Bounds = (
  /** @class */
  function() {
    function Bounds2(left, top, width2, height) {
      this.left = left;
      this.top = top;
      this.width = width2;
      this.height = height;
    }
    Bounds2.prototype.add = function(x2, y2, w2, h2) {
      return new Bounds2(this.left + x2, this.top + y2, this.width + w2, this.height + h2);
    };
    Bounds2.fromClientRect = function(context, clientRect) {
      return new Bounds2(clientRect.left + context.windowBounds.left, clientRect.top + context.windowBounds.top, clientRect.width, clientRect.height);
    };
    Bounds2.fromDOMRectList = function(context, domRectList) {
      var domRect = Array.from(domRectList).find(function(rect) {
        return rect.width !== 0;
      });
      return domRect ? new Bounds2(domRect.left + context.windowBounds.left, domRect.top + context.windowBounds.top, domRect.width, domRect.height) : Bounds2.EMPTY;
    };
    Bounds2.EMPTY = new Bounds2(0, 0, 0, 0);
    return Bounds2;
  }()
);
var parseBounds = function(context, node) {
  return Bounds.fromClientRect(context, node.getBoundingClientRect());
};
var parseDocumentSize = function(document2) {
  var body = document2.body;
  var documentElement = document2.documentElement;
  if (!body || !documentElement) {
    throw new Error("Unable to get document size");
  }
  var width2 = Math.max(Math.max(body.scrollWidth, documentElement.scrollWidth), Math.max(body.offsetWidth, documentElement.offsetWidth), Math.max(body.clientWidth, documentElement.clientWidth));
  var height = Math.max(Math.max(body.scrollHeight, documentElement.scrollHeight), Math.max(body.offsetHeight, documentElement.offsetHeight), Math.max(body.clientHeight, documentElement.clientHeight));
  return new Bounds(0, 0, width2, height);
};
var toCodePoints$1 = function(str) {
  var codePoints = [];
  var i = 0;
  var length = str.length;
  while (i < length) {
    var value2 = str.charCodeAt(i++);
    if (value2 >= 55296 && value2 <= 56319 && i < length) {
      var extra = str.charCodeAt(i++);
      if ((extra & 64512) === 56320) {
        codePoints.push(((value2 & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        codePoints.push(value2);
        i--;
      }
    } else {
      codePoints.push(value2);
    }
  }
  return codePoints;
};
var fromCodePoint$1 = function() {
  var codePoints = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    codePoints[_i] = arguments[_i];
  }
  if (String.fromCodePoint) {
    return String.fromCodePoint.apply(String, codePoints);
  }
  var length = codePoints.length;
  if (!length) {
    return "";
  }
  var codeUnits = [];
  var index = -1;
  var result = "";
  while (++index < length) {
    var codePoint = codePoints[index];
    if (codePoint <= 65535) {
      codeUnits.push(codePoint);
    } else {
      codePoint -= 65536;
      codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
    }
    if (index + 1 === length || codeUnits.length > 16384) {
      result += String.fromCharCode.apply(String, codeUnits);
      codeUnits.length = 0;
    }
  }
  return result;
};
var chars$2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup$2 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$2 = 0; i$2 < chars$2.length; i$2++) {
  lookup$2[chars$2.charCodeAt(i$2)] = i$2;
}
var chars$1$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup$1$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$1$1 = 0; i$1$1 < chars$1$1.length; i$1$1++) {
  lookup$1$1[chars$1$1.charCodeAt(i$1$1)] = i$1$1;
}
var decode$1 = function(base642) {
  var bufferLength = base642.length * 0.75, len = base642.length, i, p2 = 0, encoded1, encoded2, encoded3, encoded4;
  if (base642[base642.length - 1] === "=") {
    bufferLength--;
    if (base642[base642.length - 2] === "=") {
      bufferLength--;
    }
  }
  var buffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
  var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
  for (i = 0; i < len; i += 4) {
    encoded1 = lookup$1$1[base642.charCodeAt(i)];
    encoded2 = lookup$1$1[base642.charCodeAt(i + 1)];
    encoded3 = lookup$1$1[base642.charCodeAt(i + 2)];
    encoded4 = lookup$1$1[base642.charCodeAt(i + 3)];
    bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return buffer;
};
var polyUint16Array$1 = function(buffer) {
  var length = buffer.length;
  var bytes = [];
  for (var i = 0; i < length; i += 2) {
    bytes.push(buffer[i + 1] << 8 | buffer[i]);
  }
  return bytes;
};
var polyUint32Array$1 = function(buffer) {
  var length = buffer.length;
  var bytes = [];
  for (var i = 0; i < length; i += 4) {
    bytes.push(buffer[i + 3] << 24 | buffer[i + 2] << 16 | buffer[i + 1] << 8 | buffer[i]);
  }
  return bytes;
};
var UTRIE2_SHIFT_2$1 = 5;
var UTRIE2_SHIFT_1$1 = 6 + 5;
var UTRIE2_INDEX_SHIFT$1 = 2;
var UTRIE2_SHIFT_1_2$1 = UTRIE2_SHIFT_1$1 - UTRIE2_SHIFT_2$1;
var UTRIE2_LSCP_INDEX_2_OFFSET$1 = 65536 >> UTRIE2_SHIFT_2$1;
var UTRIE2_DATA_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_2$1;
var UTRIE2_DATA_MASK$1 = UTRIE2_DATA_BLOCK_LENGTH$1 - 1;
var UTRIE2_LSCP_INDEX_2_LENGTH$1 = 1024 >> UTRIE2_SHIFT_2$1;
var UTRIE2_INDEX_2_BMP_LENGTH$1 = UTRIE2_LSCP_INDEX_2_OFFSET$1 + UTRIE2_LSCP_INDEX_2_LENGTH$1;
var UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 = UTRIE2_INDEX_2_BMP_LENGTH$1;
var UTRIE2_UTF8_2B_INDEX_2_LENGTH$1 = 2048 >> 6;
var UTRIE2_INDEX_1_OFFSET$1 = UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 + UTRIE2_UTF8_2B_INDEX_2_LENGTH$1;
var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 = 65536 >> UTRIE2_SHIFT_1$1;
var UTRIE2_INDEX_2_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_1_2$1;
var UTRIE2_INDEX_2_MASK$1 = UTRIE2_INDEX_2_BLOCK_LENGTH$1 - 1;
var slice16$1 = function(view, start, end) {
  if (view.slice) {
    return view.slice(start, end);
  }
  return new Uint16Array(Array.prototype.slice.call(view, start, end));
};
var slice32$1 = function(view, start, end) {
  if (view.slice) {
    return view.slice(start, end);
  }
  return new Uint32Array(Array.prototype.slice.call(view, start, end));
};
var createTrieFromBase64$1 = function(base642, _byteLength) {
  var buffer = decode$1(base642);
  var view32 = Array.isArray(buffer) ? polyUint32Array$1(buffer) : new Uint32Array(buffer);
  var view16 = Array.isArray(buffer) ? polyUint16Array$1(buffer) : new Uint16Array(buffer);
  var headerLength = 24;
  var index = slice16$1(view16, headerLength / 2, view32[4] / 2);
  var data = view32[5] === 2 ? slice16$1(view16, (headerLength + view32[4]) / 2) : slice32$1(view32, Math.ceil((headerLength + view32[4]) / 4));
  return new Trie$1(view32[0], view32[1], view32[2], view32[3], index, data);
};
var Trie$1 = (
  /** @class */
  function() {
    function Trie2(initialValue, errorValue, highStart, highValueIndex, index, data) {
      this.initialValue = initialValue;
      this.errorValue = errorValue;
      this.highStart = highStart;
      this.highValueIndex = highValueIndex;
      this.index = index;
      this.data = data;
    }
    Trie2.prototype.get = function(codePoint) {
      var ix;
      if (codePoint >= 0) {
        if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
          ix = this.index[codePoint >> UTRIE2_SHIFT_2$1];
          ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
          return this.data[ix];
        }
        if (codePoint <= 65535) {
          ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET$1 + (codePoint - 55296 >> UTRIE2_SHIFT_2$1)];
          ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
          return this.data[ix];
        }
        if (codePoint < this.highStart) {
          ix = UTRIE2_INDEX_1_OFFSET$1 - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 + (codePoint >> UTRIE2_SHIFT_1$1);
          ix = this.index[ix];
          ix += codePoint >> UTRIE2_SHIFT_2$1 & UTRIE2_INDEX_2_MASK$1;
          ix = this.index[ix];
          ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
          return this.data[ix];
        }
        if (codePoint <= 1114111) {
          return this.data[this.highValueIndex];
        }
      }
      return this.errorValue;
    };
    return Trie2;
  }()
);
var chars$3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup$3 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$3 = 0; i$3 < chars$3.length; i$3++) {
  lookup$3[chars$3.charCodeAt(i$3)] = i$3;
}
var base64$1 = "KwAAAAAAAAAACA4AUD0AADAgAAACAAAAAAAIABAAGABAAEgAUABYAGAAaABgAGgAYgBqAF8AZwBgAGgAcQB5AHUAfQCFAI0AlQCdAKIAqgCyALoAYABoAGAAaABgAGgAwgDKAGAAaADGAM4A0wDbAOEA6QDxAPkAAQEJAQ8BFwF1AH0AHAEkASwBNAE6AUIBQQFJAVEBWQFhAWgBcAF4ATAAgAGGAY4BlQGXAZ8BpwGvAbUBvQHFAc0B0wHbAeMB6wHxAfkBAQIJAvEBEQIZAiECKQIxAjgCQAJGAk4CVgJeAmQCbAJ0AnwCgQKJApECmQKgAqgCsAK4ArwCxAIwAMwC0wLbAjAA4wLrAvMC+AIAAwcDDwMwABcDHQMlAy0DNQN1AD0DQQNJA0kDSQNRA1EDVwNZA1kDdQB1AGEDdQBpA20DdQN1AHsDdQCBA4kDkQN1AHUAmQOhA3UAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AKYDrgN1AHUAtgO+A8YDzgPWAxcD3gPjA+sD8wN1AHUA+wMDBAkEdQANBBUEHQQlBCoEFwMyBDgEYABABBcDSARQBFgEYARoBDAAcAQzAXgEgASIBJAEdQCXBHUAnwSnBK4EtgS6BMIEyAR1AHUAdQB1AHUAdQCVANAEYABgAGAAYABgAGAAYABgANgEYADcBOQEYADsBPQE/AQEBQwFFAUcBSQFLAU0BWQEPAVEBUsFUwVbBWAAYgVgAGoFcgV6BYIFigWRBWAAmQWfBaYFYABgAGAAYABgAKoFYACxBbAFuQW6BcEFwQXHBcEFwQXPBdMF2wXjBeoF8gX6BQIGCgYSBhoGIgYqBjIGOgZgAD4GRgZMBmAAUwZaBmAAYABgAGAAYABgAGAAYABgAGAAYABgAGIGYABpBnAGYABgAGAAYABgAGAAYABgAGAAYAB4Bn8GhQZgAGAAYAB1AHcDFQSLBmAAYABgAJMGdQA9A3UAmwajBqsGqwaVALMGuwbDBjAAywbSBtIG1QbSBtIG0gbSBtIG0gbdBuMG6wbzBvsGAwcLBxMHAwcbByMHJwcsBywHMQcsB9IGOAdAB0gHTgfSBkgHVgfSBtIG0gbSBtIG0gbSBtIG0gbSBiwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdgAGAALAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdbB2MHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB2kH0gZwB64EdQB1AHUAdQB1AHUAdQB1AHUHfQdgAIUHjQd1AHUAlQedB2AAYAClB6sHYACzB7YHvgfGB3UAzgfWBzMB3gfmB1EB7gf1B/0HlQENAQUIDQh1ABUIHQglCBcDLQg1CD0IRQhNCEEDUwh1AHUAdQBbCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIcAh3CHoIMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIgggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAALAcsBywHLAcsBywHLAcsBywHLAcsB4oILAcsB44I0gaWCJ4Ipgh1AHUAqgiyCHUAdQB1AHUAdQB1AHUAdQB1AHUAtwh8AXUAvwh1AMUIyQjRCNkI4AjoCHUAdQB1AO4I9gj+CAYJDgkTCS0HGwkjCYIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiAAIAAAAFAAYABgAGIAXwBgAHEAdQBFAJUAogCyAKAAYABgAEIA4ABGANMA4QDxAMEBDwE1AFwBLAE6AQEBUQF4QkhCmEKoQrhCgAHIQsAB0MLAAcABwAHAAeDC6ABoAHDCwMMAAcABwAHAAdDDGMMAAcAB6MM4wwjDWMNow3jDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEjDqABWw6bDqABpg6gAaABoAHcDvwOPA+gAaABfA/8DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DpcPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB9cPKwkyCToJMAB1AHUAdQBCCUoJTQl1AFUJXAljCWcJawkwADAAMAAwAHMJdQB2CX4JdQCECYoJjgmWCXUAngkwAGAAYABxAHUApgn3A64JtAl1ALkJdQDACTAAMAAwADAAdQB1AHUAdQB1AHUAdQB1AHUAowYNBMUIMAAwADAAMADICcsJ0wnZCRUE4QkwAOkJ8An4CTAAMAB1AAAKvwh1AAgKDwoXCh8KdQAwACcKLgp1ADYKqAmICT4KRgowADAAdQB1AE4KMAB1AFYKdQBeCnUAZQowADAAMAAwADAAMAAwADAAMAAVBHUAbQowADAAdQC5CXUKMAAwAHwBxAijBogEMgF9CoQKiASMCpQKmgqIBKIKqgquCogEDQG2Cr4KxgrLCjAAMADTCtsKCgHjCusK8Qr5CgELMAAwADAAMAB1AIsECQsRC3UANAEZCzAAMAAwADAAMAB1ACELKQswAHUANAExCzkLdQBBC0kLMABRC1kLMAAwADAAMAAwADAAdQBhCzAAMAAwAGAAYABpC3ELdwt/CzAAMACHC4sLkwubC58Lpwt1AK4Ltgt1APsDMAAwADAAMAAwADAAMAAwAL4LwwvLC9IL1wvdCzAAMADlC+kL8Qv5C/8LSQswADAAMAAwADAAMAAwADAAMAAHDDAAMAAwADAAMAAODBYMHgx1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1ACYMMAAwADAAdQB1AHUALgx1AHUAdQB1AHUAdQA2DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AD4MdQBGDHUAdQB1AHUAdQB1AEkMdQB1AHUAdQB1AFAMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQBYDHUAdQB1AF8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUA+wMVBGcMMAAwAHwBbwx1AHcMfwyHDI8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAYABgAJcMMAAwADAAdQB1AJ8MlQClDDAAMACtDCwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB7UMLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AA0EMAC9DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAsBywHLAcsBywHLAcsBywHLQcwAMEMyAwsBywHLAcsBywHLAcsBywHLAcsBywHzAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1ANQM2QzhDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABgAGAAYABgAGAAYABgAOkMYADxDGAA+AwADQYNYABhCWAAYAAODTAAMAAwADAAFg1gAGAAHg37AzAAMAAwADAAYABgACYNYAAsDTQNPA1gAEMNPg1LDWAAYABgAGAAYABgAGAAYABgAGAAUg1aDYsGVglhDV0NcQBnDW0NdQ15DWAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAlQCBDZUAiA2PDZcNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAnw2nDTAAMAAwADAAMAAwAHUArw23DTAAMAAwADAAMAAwADAAMAAwADAAMAB1AL8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQDHDTAAYABgAM8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA1w11ANwNMAAwAD0B5A0wADAAMAAwADAAMADsDfQN/A0EDgwOFA4wABsOMAAwADAAMAAwADAAMAAwANIG0gbSBtIG0gbSBtIG0gYjDigOwQUuDsEFMw7SBjoO0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGQg5KDlIOVg7SBtIGXg5lDm0OdQ7SBtIGfQ6EDooOjQ6UDtIGmg6hDtIG0gaoDqwO0ga0DrwO0gZgAGAAYADEDmAAYAAkBtIGzA5gANIOYADaDokO0gbSBt8O5w7SBu8O0gb1DvwO0gZgAGAAxA7SBtIG0gbSBtIGYABgAGAAYAAED2AAsAUMD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHJA8sBywHLAcsBywHLAccDywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywPLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAc0D9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHPA/SBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gYUD0QPlQCVAJUAMAAwADAAMACVAJUAlQCVAJUAlQCVAEwPMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA//8EAAQABAAEAAQABAAEAAQABAANAAMAAQABAAIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQACgATABcAHgAbABoAHgAXABYAEgAeABsAGAAPABgAHABLAEsASwBLAEsASwBLAEsASwBLABgAGAAeAB4AHgATAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAGwASAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWAA0AEQAeAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAFAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJABYAGgAbABsAGwAeAB0AHQAeAE8AFwAeAA0AHgAeABoAGwBPAE8ADgBQAB0AHQAdAE8ATwAXAE8ATwBPABYAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwBWAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsABAAbABsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEAA0ADQBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABABQACsAKwArACsAKwArACsAKwAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUAAaABoAUABQAFAAUABQAEwAHgAbAFAAHgAEACsAKwAEAAQABAArAFAAUABQAFAAUABQACsAKwArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQACsAUABQACsAKwAEACsABAAEAAQABAAEACsAKwArACsABAAEACsAKwAEAAQABAArACsAKwAEACsAKwArACsAKwArACsAUABQAFAAUAArAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAAQABABQAFAAUAAEAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAArACsAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AGwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAKwArACsAKwArAAQABAAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAAQAUAArAFAAUABQAFAAUABQACsAKwArAFAAUABQACsAUABQAFAAUAArACsAKwBQAFAAKwBQACsAUABQACsAKwArAFAAUAArACsAKwBQAFAAUAArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAArACsAKwAEAAQABAArAAQABAAEAAQAKwArAFAAKwArACsAKwArACsABAArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAHgAeAB4AHgAeAB4AGwAeACsAKwArACsAKwAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAUABQAFAAKwArACsAKwArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwAOAFAAUABQAFAAUABQAFAAHgBQAAQABAAEAA4AUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAKwArAAQAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAKwArACsAKwArACsAUAArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAXABcAFwAXABcACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAXAArAFwAXABcAFwAXABcAFwAXABcAFwAKgBcAFwAKgAqACoAKgAqACoAKgAqACoAXAArACsAXABcAFwAXABcACsAXAArACoAKgAqACoAKgAqACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwBcAFwAXABcAFAADgAOAA4ADgAeAA4ADgAJAA4ADgANAAkAEwATABMAEwATAAkAHgATAB4AHgAeAAQABAAeAB4AHgAeAB4AHgBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAADQAEAB4ABAAeAAQAFgARABYAEQAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAAQABAAEAAQADQAEAAQAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAA0ADQAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeACsAHgAeAA4ADgANAA4AHgAeAB4AHgAeAAkACQArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgBcAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4AHgAeAB4AXABcAFwAXABcAFwAKgAqACoAKgBcAFwAXABcACoAKgAqAFwAKgAqACoAXABcACoAKgAqACoAKgAqACoAXABcAFwAKgAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwAKgBLAEsASwBLAEsASwBLAEsASwBLACoAKgAqACoAKgAqAFAAUABQAFAAUABQACsAUAArACsAKwArACsAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAKwBQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsABAAEAAQAHgANAB4AHgAeAB4AHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUAArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWABEAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAANAA0AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUAArAAQABAArACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAA0ADQAVAFwADQAeAA0AGwBcACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwAeAB4AEwATAA0ADQAOAB4AEwATAB4ABAAEAAQACQArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAHgArACsAKwATABMASwBLAEsASwBLAEsASwBLAEsASwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAXABcAFwAXABcACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXAArACsAKwAqACoAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsAHgAeAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKwArAAQASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACoAKgAqACoAKgAqACoAXAAqACoAKgAqACoAKgArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABABQAFAAUABQAFAAUABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgANAA0ADQANAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwAeAB4AHgAeAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArAA0ADQANAA0ADQBLAEsASwBLAEsASwBLAEsASwBLACsAKwArAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUAAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAAQAUABQAFAAUABQAFAABABQAFAABAAEAAQAUAArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQACsAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQACsAKwAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQACsAHgAeAB4AHgAeAB4AHgAOAB4AKwANAA0ADQANAA0ADQANAAkADQANAA0ACAAEAAsABAAEAA0ACQANAA0ADAAdAB0AHgAXABcAFgAXABcAFwAWABcAHQAdAB4AHgAUABQAFAANAAEAAQAEAAQABAAEAAQACQAaABoAGgAaABoAGgAaABoAHgAXABcAHQAVABUAHgAeAB4AHgAeAB4AGAAWABEAFQAVABUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ADQAeAA0ADQANAA0AHgANAA0ADQAHAB4AHgAeAB4AKwAEAAQABAAEAAQABAAEAAQABAAEAFAAUAArACsATwBQAFAAUABQAFAAHgAeAB4AFgARAE8AUABPAE8ATwBPAFAAUABQAFAAUAAeAB4AHgAWABEAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArABsAGwAbABsAGwAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGgAbABsAGwAbABoAGwAbABoAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAFAAGgAeAB0AHgBQAB4AGgAeAB4AHgAeAB4AHgAeAB4AHgBPAB4AUAAbAB4AHgBQAFAAUABQAFAAHgAeAB4AHQAdAB4AUAAeAFAAHgBQAB4AUABPAFAAUAAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgBQAFAAUABQAE8ATwBQAFAAUABQAFAATwBQAFAATwBQAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAUABQAFAATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABPAB4AHgArACsAKwArAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAdAB4AHgAeAB0AHQAeAB4AHQAeAB4AHgAdAB4AHQAbABsAHgAdAB4AHgAeAB4AHQAeAB4AHQAdAB0AHQAeAB4AHQAeAB0AHgAdAB0AHQAdAB0AHQAeAB0AHgAeAB4AHgAeAB0AHQAdAB0AHgAeAB4AHgAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB0AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAdAB0AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHQAdAB0AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHQAdAB4AHgAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AJQAlAB0AHQAlAB4AJQAlACUAIAAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAeAB0AJQAdAB0AHgAdAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAdAB0AHQAdACUAHgAlACUAJQAdACUAJQAdAB0AHQAlACUAHQAdACUAHQAdACUAJQAlAB4AHQAeAB4AHgAeAB0AHQAlAB0AHQAdAB0AHQAdACUAJQAlACUAJQAdACUAJQAgACUAHQAdACUAJQAlACUAJQAlACUAJQAeAB4AHgAlACUAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AFwAXABcAFwAXABcAHgATABMAJQAeAB4AHgAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARABYAEQAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANAA0AHgANAB4ADQANAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwAlACUAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACsAKwArACsAKwArACsAKwArACsAKwArAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBPAE8ATwBPAE8ATwBPAE8AJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeAAQAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUABQAAQAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAUABQAFAAUABQAAQABAAEACsABAAEACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAKwBQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAA0ADQANAA0ADQANAA0ADQAeACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAArACsAKwArAFAAUABQAFAAUAANAA0ADQANAA0ADQAUACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQANAA0ADQANAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAANACsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAB4AHgAeAB4AHgArACsAKwArACsAKwAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANAFAABAAEAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAEAAQABAAEAB4ABAAEAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsABAAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLAA0ADQArAB4ABABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUAAeAFAAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAAEAAQADgANAA0AEwATAB4AHgAeAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAFAAUABQAFAABAAEACsAKwAEAA0ADQAeAFAAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcAFwADQANAA0AKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQAKwAEAAQAKwArAAQABAAEAAQAUAAEAFAABAAEAA0ADQANACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABABQAA4AUAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANAFAADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAaABoAGgAaAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAJAAkACQAJAAkACQAJABYAEQArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AHgAeACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAARwBHABUARwAJACsAKwArACsAKwArACsAKwArACsAKwAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAKwArACsAKwArACsAKwArACsAKwArACsAKwBRAFEAUQBRACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAHgAEAAQADQAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAeAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQAHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAKwArAFAAKwArAFAAUAArACsAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAHgAeAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeACsAKwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4ABAAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAHgAeAA0ADQANAA0AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArAAQABAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwBQAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArABsAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAB4AHgAeAB4ABAAEAAQABAAEAAQABABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArABYAFgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAGgBQAFAAUAAaAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUAArACsAKwArACsAKwBQACsAKwArACsAUAArAFAAKwBQACsAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUAArAFAAKwBQACsAUAArAFAAUAArAFAAKwArAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAKwBQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeACUAJQAlAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAHgAlACUAJQAlACUAIAAgACAAJQAlACAAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACEAIQAhACEAIQAlACUAIAAgACUAJQAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAlACUAJQAlACAAIAAgACUAIAAgACAAJQAlACUAJQAlACUAJQAgACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAlAB4AJQAeACUAJQAlACUAJQAgACUAJQAlACUAHgAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACAAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABcAFwAXABUAFQAVAB4AHgAeAB4AJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAgACUAJQAgACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAIAAgACUAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACAAIAAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACAAIAAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAA==";
var LETTER_NUMBER_MODIFIER = 50;
var BK = 1;
var CR$1 = 2;
var LF$1 = 3;
var CM = 4;
var NL = 5;
var WJ = 7;
var ZW = 8;
var GL = 9;
var SP = 10;
var ZWJ$1 = 11;
var B2 = 12;
var BA = 13;
var BB = 14;
var HY = 15;
var CB = 16;
var CL = 17;
var CP = 18;
var EX = 19;
var IN = 20;
var NS = 21;
var OP = 22;
var QU = 23;
var IS = 24;
var NU = 25;
var PO = 26;
var PR = 27;
var SY = 28;
var AI = 29;
var AL = 30;
var CJ = 31;
var EB = 32;
var EM = 33;
var H2 = 34;
var H3 = 35;
var HL = 36;
var ID = 37;
var JL = 38;
var JV = 39;
var JT = 40;
var RI$1 = 41;
var SA = 42;
var XX = 43;
var ea_OP = [9001, 65288];
var BREAK_MANDATORY = "!";
var BREAK_NOT_ALLOWED$1 = "×";
var BREAK_ALLOWED$1 = "÷";
var UnicodeTrie$1 = createTrieFromBase64$1(base64$1);
var ALPHABETICS = [AL, HL];
var HARD_LINE_BREAKS = [BK, CR$1, LF$1, NL];
var SPACE$1 = [SP, ZW];
var PREFIX_POSTFIX = [PR, PO];
var LINE_BREAKS = HARD_LINE_BREAKS.concat(SPACE$1);
var KOREAN_SYLLABLE_BLOCK = [JL, JV, JT, H2, H3];
var HYPHEN = [HY, BA];
var codePointsToCharacterClasses = function(codePoints, lineBreak2) {
  if (lineBreak2 === void 0) {
    lineBreak2 = "strict";
  }
  var types = [];
  var indices = [];
  var categories = [];
  codePoints.forEach(function(codePoint, index) {
    var classType = UnicodeTrie$1.get(codePoint);
    if (classType > LETTER_NUMBER_MODIFIER) {
      categories.push(true);
      classType -= LETTER_NUMBER_MODIFIER;
    } else {
      categories.push(false);
    }
    if (["normal", "auto", "loose"].indexOf(lineBreak2) !== -1) {
      if ([8208, 8211, 12316, 12448].indexOf(codePoint) !== -1) {
        indices.push(index);
        return types.push(CB);
      }
    }
    if (classType === CM || classType === ZWJ$1) {
      if (index === 0) {
        indices.push(index);
        return types.push(AL);
      }
      var prev = types[index - 1];
      if (LINE_BREAKS.indexOf(prev) === -1) {
        indices.push(indices[index - 1]);
        return types.push(prev);
      }
      indices.push(index);
      return types.push(AL);
    }
    indices.push(index);
    if (classType === CJ) {
      return types.push(lineBreak2 === "strict" ? NS : ID);
    }
    if (classType === SA) {
      return types.push(AL);
    }
    if (classType === AI) {
      return types.push(AL);
    }
    if (classType === XX) {
      if (codePoint >= 131072 && codePoint <= 196605 || codePoint >= 196608 && codePoint <= 262141) {
        return types.push(ID);
      } else {
        return types.push(AL);
      }
    }
    types.push(classType);
  });
  return [indices, types, categories];
};
var isAdjacentWithSpaceIgnored = function(a2, b2, currentIndex, classTypes) {
  var current = classTypes[currentIndex];
  if (Array.isArray(a2) ? a2.indexOf(current) !== -1 : a2 === current) {
    var i = currentIndex;
    while (i <= classTypes.length) {
      i++;
      var next = classTypes[i];
      if (next === b2) {
        return true;
      }
      if (next !== SP) {
        break;
      }
    }
  }
  if (current === SP) {
    var i = currentIndex;
    while (i > 0) {
      i--;
      var prev = classTypes[i];
      if (Array.isArray(a2) ? a2.indexOf(prev) !== -1 : a2 === prev) {
        var n2 = currentIndex;
        while (n2 <= classTypes.length) {
          n2++;
          var next = classTypes[n2];
          if (next === b2) {
            return true;
          }
          if (next !== SP) {
            break;
          }
        }
      }
      if (prev !== SP) {
        break;
      }
    }
  }
  return false;
};
var previousNonSpaceClassType = function(currentIndex, classTypes) {
  var i = currentIndex;
  while (i >= 0) {
    var type = classTypes[i];
    if (type === SP) {
      i--;
    } else {
      return type;
    }
  }
  return 0;
};
var _lineBreakAtIndex = function(codePoints, classTypes, indicies, index, forbiddenBreaks) {
  if (indicies[index] === 0) {
    return BREAK_NOT_ALLOWED$1;
  }
  var currentIndex = index - 1;
  if (Array.isArray(forbiddenBreaks) && forbiddenBreaks[currentIndex] === true) {
    return BREAK_NOT_ALLOWED$1;
  }
  var beforeIndex = currentIndex - 1;
  var afterIndex = currentIndex + 1;
  var current = classTypes[currentIndex];
  var before = beforeIndex >= 0 ? classTypes[beforeIndex] : 0;
  var next = classTypes[afterIndex];
  if (current === CR$1 && next === LF$1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (HARD_LINE_BREAKS.indexOf(current) !== -1) {
    return BREAK_MANDATORY;
  }
  if (HARD_LINE_BREAKS.indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (SPACE$1.indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (previousNonSpaceClassType(currentIndex, classTypes) === ZW) {
    return BREAK_ALLOWED$1;
  }
  if (UnicodeTrie$1.get(codePoints[currentIndex]) === ZWJ$1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if ((current === EB || current === EM) && UnicodeTrie$1.get(codePoints[afterIndex]) === ZWJ$1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === WJ || next === WJ) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === GL) {
    return BREAK_NOT_ALLOWED$1;
  }
  if ([SP, BA, HY].indexOf(current) === -1 && next === GL) {
    return BREAK_NOT_ALLOWED$1;
  }
  if ([CL, CP, EX, IS, SY].indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (previousNonSpaceClassType(currentIndex, classTypes) === OP) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (isAdjacentWithSpaceIgnored(QU, OP, currentIndex, classTypes)) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (isAdjacentWithSpaceIgnored([CL, CP], NS, currentIndex, classTypes)) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (isAdjacentWithSpaceIgnored(B2, B2, currentIndex, classTypes)) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === SP) {
    return BREAK_ALLOWED$1;
  }
  if (current === QU || next === QU) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (next === CB || current === CB) {
    return BREAK_ALLOWED$1;
  }
  if ([BA, HY, NS].indexOf(next) !== -1 || current === BB) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (before === HL && HYPHEN.indexOf(current) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === SY && next === HL) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (next === IN) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (ALPHABETICS.indexOf(next) !== -1 && current === NU || ALPHABETICS.indexOf(current) !== -1 && next === NU) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === PR && [ID, EB, EM].indexOf(next) !== -1 || [ID, EB, EM].indexOf(current) !== -1 && next === PO) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (ALPHABETICS.indexOf(current) !== -1 && PREFIX_POSTFIX.indexOf(next) !== -1 || PREFIX_POSTFIX.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (
    // (PR | PO) × ( OP | HY )? NU
    [PR, PO].indexOf(current) !== -1 && (next === NU || [OP, HY].indexOf(next) !== -1 && classTypes[afterIndex + 1] === NU) || // ( OP | HY ) × NU
    [OP, HY].indexOf(current) !== -1 && next === NU || // NU ×	(NU | SY | IS)
    current === NU && [NU, SY, IS].indexOf(next) !== -1
  ) {
    return BREAK_NOT_ALLOWED$1;
  }
  if ([NU, SY, IS, CL, CP].indexOf(next) !== -1) {
    var prevIndex = currentIndex;
    while (prevIndex >= 0) {
      var type = classTypes[prevIndex];
      if (type === NU) {
        return BREAK_NOT_ALLOWED$1;
      } else if ([SY, IS].indexOf(type) !== -1) {
        prevIndex--;
      } else {
        break;
      }
    }
  }
  if ([PR, PO].indexOf(next) !== -1) {
    var prevIndex = [CL, CP].indexOf(current) !== -1 ? beforeIndex : currentIndex;
    while (prevIndex >= 0) {
      var type = classTypes[prevIndex];
      if (type === NU) {
        return BREAK_NOT_ALLOWED$1;
      } else if ([SY, IS].indexOf(type) !== -1) {
        prevIndex--;
      } else {
        break;
      }
    }
  }
  if (JL === current && [JL, JV, H2, H3].indexOf(next) !== -1 || [JV, H2].indexOf(current) !== -1 && [JV, JT].indexOf(next) !== -1 || [JT, H3].indexOf(current) !== -1 && next === JT) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (KOREAN_SYLLABLE_BLOCK.indexOf(current) !== -1 && [IN, PO].indexOf(next) !== -1 || KOREAN_SYLLABLE_BLOCK.indexOf(next) !== -1 && current === PR) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (ALPHABETICS.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === IS && ALPHABETICS.indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (ALPHABETICS.concat(NU).indexOf(current) !== -1 && next === OP && ea_OP.indexOf(codePoints[afterIndex]) === -1 || ALPHABETICS.concat(NU).indexOf(next) !== -1 && current === CP) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === RI$1 && next === RI$1) {
    var i = indicies[currentIndex];
    var count = 1;
    while (i > 0) {
      i--;
      if (classTypes[i] === RI$1) {
        count++;
      } else {
        break;
      }
    }
    if (count % 2 !== 0) {
      return BREAK_NOT_ALLOWED$1;
    }
  }
  if (current === EB && next === EM) {
    return BREAK_NOT_ALLOWED$1;
  }
  return BREAK_ALLOWED$1;
};
var cssFormattedClasses = function(codePoints, options) {
  if (!options) {
    options = { lineBreak: "normal", wordBreak: "normal" };
  }
  var _a2 = codePointsToCharacterClasses(codePoints, options.lineBreak), indicies = _a2[0], classTypes = _a2[1], isLetterNumber = _a2[2];
  if (options.wordBreak === "break-all" || options.wordBreak === "break-word") {
    classTypes = classTypes.map(function(type) {
      return [NU, AL, SA].indexOf(type) !== -1 ? ID : type;
    });
  }
  var forbiddenBreakpoints = options.wordBreak === "keep-all" ? isLetterNumber.map(function(letterNumber, i) {
    return letterNumber && codePoints[i] >= 19968 && codePoints[i] <= 40959;
  }) : void 0;
  return [indicies, classTypes, forbiddenBreakpoints];
};
var Break = (
  /** @class */
  function() {
    function Break2(codePoints, lineBreak2, start, end) {
      this.codePoints = codePoints;
      this.required = lineBreak2 === BREAK_MANDATORY;
      this.start = start;
      this.end = end;
    }
    Break2.prototype.slice = function() {
      return fromCodePoint$1.apply(void 0, this.codePoints.slice(this.start, this.end));
    };
    return Break2;
  }()
);
var LineBreaker = function(str, options) {
  var codePoints = toCodePoints$1(str);
  var _a2 = cssFormattedClasses(codePoints, options), indicies = _a2[0], classTypes = _a2[1], forbiddenBreakpoints = _a2[2];
  var length = codePoints.length;
  var lastEnd = 0;
  var nextIndex = 0;
  return {
    next: function() {
      if (nextIndex >= length) {
        return { done: true, value: null };
      }
      var lineBreak2 = BREAK_NOT_ALLOWED$1;
      while (nextIndex < length && (lineBreak2 = _lineBreakAtIndex(codePoints, classTypes, indicies, ++nextIndex, forbiddenBreakpoints)) === BREAK_NOT_ALLOWED$1) {
      }
      if (lineBreak2 !== BREAK_NOT_ALLOWED$1 || nextIndex === length) {
        var value2 = new Break(codePoints, lineBreak2, lastEnd, nextIndex);
        lastEnd = nextIndex;
        return { value: value2, done: false };
      }
      return { done: true, value: null };
    }
  };
};
var FLAG_UNRESTRICTED = 1 << 0;
var FLAG_ID = 1 << 1;
var FLAG_INTEGER = 1 << 2;
var FLAG_NUMBER = 1 << 3;
var LINE_FEED = 10;
var SOLIDUS = 47;
var REVERSE_SOLIDUS = 92;
var CHARACTER_TABULATION = 9;
var SPACE = 32;
var QUOTATION_MARK = 34;
var EQUALS_SIGN = 61;
var NUMBER_SIGN = 35;
var DOLLAR_SIGN = 36;
var PERCENTAGE_SIGN = 37;
var APOSTROPHE = 39;
var LEFT_PARENTHESIS = 40;
var RIGHT_PARENTHESIS = 41;
var LOW_LINE = 95;
var HYPHEN_MINUS = 45;
var EXCLAMATION_MARK = 33;
var LESS_THAN_SIGN = 60;
var GREATER_THAN_SIGN = 62;
var COMMERCIAL_AT = 64;
var LEFT_SQUARE_BRACKET = 91;
var RIGHT_SQUARE_BRACKET = 93;
var CIRCUMFLEX_ACCENT = 61;
var LEFT_CURLY_BRACKET = 123;
var QUESTION_MARK = 63;
var RIGHT_CURLY_BRACKET = 125;
var VERTICAL_LINE = 124;
var TILDE = 126;
var CONTROL = 128;
var REPLACEMENT_CHARACTER = 65533;
var ASTERISK = 42;
var PLUS_SIGN = 43;
var COMMA = 44;
var COLON = 58;
var SEMICOLON = 59;
var FULL_STOP = 46;
var NULL = 0;
var BACKSPACE = 8;
var LINE_TABULATION = 11;
var SHIFT_OUT = 14;
var INFORMATION_SEPARATOR_ONE = 31;
var DELETE = 127;
var EOF = -1;
var ZERO = 48;
var a = 97;
var e = 101;
var f = 102;
var u = 117;
var z = 122;
var A = 65;
var E = 69;
var F = 70;
var U = 85;
var Z = 90;
var isDigit = function(codePoint) {
  return codePoint >= ZERO && codePoint <= 57;
};
var isSurrogateCodePoint = function(codePoint) {
  return codePoint >= 55296 && codePoint <= 57343;
};
var isHex = function(codePoint) {
  return isDigit(codePoint) || codePoint >= A && codePoint <= F || codePoint >= a && codePoint <= f;
};
var isLowerCaseLetter = function(codePoint) {
  return codePoint >= a && codePoint <= z;
};
var isUpperCaseLetter = function(codePoint) {
  return codePoint >= A && codePoint <= Z;
};
var isLetter = function(codePoint) {
  return isLowerCaseLetter(codePoint) || isUpperCaseLetter(codePoint);
};
var isNonASCIICodePoint = function(codePoint) {
  return codePoint >= CONTROL;
};
var isWhiteSpace = function(codePoint) {
  return codePoint === LINE_FEED || codePoint === CHARACTER_TABULATION || codePoint === SPACE;
};
var isNameStartCodePoint = function(codePoint) {
  return isLetter(codePoint) || isNonASCIICodePoint(codePoint) || codePoint === LOW_LINE;
};
var isNameCodePoint = function(codePoint) {
  return isNameStartCodePoint(codePoint) || isDigit(codePoint) || codePoint === HYPHEN_MINUS;
};
var isNonPrintableCodePoint = function(codePoint) {
  return codePoint >= NULL && codePoint <= BACKSPACE || codePoint === LINE_TABULATION || codePoint >= SHIFT_OUT && codePoint <= INFORMATION_SEPARATOR_ONE || codePoint === DELETE;
};
var isValidEscape = function(c1, c2) {
  if (c1 !== REVERSE_SOLIDUS) {
    return false;
  }
  return c2 !== LINE_FEED;
};
var isIdentifierStart = function(c1, c2, c3) {
  if (c1 === HYPHEN_MINUS) {
    return isNameStartCodePoint(c2) || isValidEscape(c2, c3);
  } else if (isNameStartCodePoint(c1)) {
    return true;
  } else if (c1 === REVERSE_SOLIDUS && isValidEscape(c1, c2)) {
    return true;
  }
  return false;
};
var isNumberStart = function(c1, c2, c3) {
  if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
    if (isDigit(c2)) {
      return true;
    }
    return c2 === FULL_STOP && isDigit(c3);
  }
  if (c1 === FULL_STOP) {
    return isDigit(c2);
  }
  return isDigit(c1);
};
var stringToNumber = function(codePoints) {
  var c2 = 0;
  var sign = 1;
  if (codePoints[c2] === PLUS_SIGN || codePoints[c2] === HYPHEN_MINUS) {
    if (codePoints[c2] === HYPHEN_MINUS) {
      sign = -1;
    }
    c2++;
  }
  var integers = [];
  while (isDigit(codePoints[c2])) {
    integers.push(codePoints[c2++]);
  }
  var int = integers.length ? parseInt(fromCodePoint$1.apply(void 0, integers), 10) : 0;
  if (codePoints[c2] === FULL_STOP) {
    c2++;
  }
  var fraction = [];
  while (isDigit(codePoints[c2])) {
    fraction.push(codePoints[c2++]);
  }
  var fracd = fraction.length;
  var frac = fracd ? parseInt(fromCodePoint$1.apply(void 0, fraction), 10) : 0;
  if (codePoints[c2] === E || codePoints[c2] === e) {
    c2++;
  }
  var expsign = 1;
  if (codePoints[c2] === PLUS_SIGN || codePoints[c2] === HYPHEN_MINUS) {
    if (codePoints[c2] === HYPHEN_MINUS) {
      expsign = -1;
    }
    c2++;
  }
  var exponent = [];
  while (isDigit(codePoints[c2])) {
    exponent.push(codePoints[c2++]);
  }
  var exp = exponent.length ? parseInt(fromCodePoint$1.apply(void 0, exponent), 10) : 0;
  return sign * (int + frac * Math.pow(10, -fracd)) * Math.pow(10, expsign * exp);
};
var LEFT_PARENTHESIS_TOKEN = {
  type: 2
  /* LEFT_PARENTHESIS_TOKEN */
};
var RIGHT_PARENTHESIS_TOKEN = {
  type: 3
  /* RIGHT_PARENTHESIS_TOKEN */
};
var COMMA_TOKEN = {
  type: 4
  /* COMMA_TOKEN */
};
var SUFFIX_MATCH_TOKEN = {
  type: 13
  /* SUFFIX_MATCH_TOKEN */
};
var PREFIX_MATCH_TOKEN = {
  type: 8
  /* PREFIX_MATCH_TOKEN */
};
var COLUMN_TOKEN = {
  type: 21
  /* COLUMN_TOKEN */
};
var DASH_MATCH_TOKEN = {
  type: 9
  /* DASH_MATCH_TOKEN */
};
var INCLUDE_MATCH_TOKEN = {
  type: 10
  /* INCLUDE_MATCH_TOKEN */
};
var LEFT_CURLY_BRACKET_TOKEN = {
  type: 11
  /* LEFT_CURLY_BRACKET_TOKEN */
};
var RIGHT_CURLY_BRACKET_TOKEN = {
  type: 12
  /* RIGHT_CURLY_BRACKET_TOKEN */
};
var SUBSTRING_MATCH_TOKEN = {
  type: 14
  /* SUBSTRING_MATCH_TOKEN */
};
var BAD_URL_TOKEN = {
  type: 23
  /* BAD_URL_TOKEN */
};
var BAD_STRING_TOKEN = {
  type: 1
  /* BAD_STRING_TOKEN */
};
var CDO_TOKEN = {
  type: 25
  /* CDO_TOKEN */
};
var CDC_TOKEN = {
  type: 24
  /* CDC_TOKEN */
};
var COLON_TOKEN = {
  type: 26
  /* COLON_TOKEN */
};
var SEMICOLON_TOKEN = {
  type: 27
  /* SEMICOLON_TOKEN */
};
var LEFT_SQUARE_BRACKET_TOKEN = {
  type: 28
  /* LEFT_SQUARE_BRACKET_TOKEN */
};
var RIGHT_SQUARE_BRACKET_TOKEN = {
  type: 29
  /* RIGHT_SQUARE_BRACKET_TOKEN */
};
var WHITESPACE_TOKEN = {
  type: 31
  /* WHITESPACE_TOKEN */
};
var EOF_TOKEN = {
  type: 32
  /* EOF_TOKEN */
};
var Tokenizer = (
  /** @class */
  function() {
    function Tokenizer2() {
      this._value = [];
    }
    Tokenizer2.prototype.write = function(chunk) {
      this._value = this._value.concat(toCodePoints$1(chunk));
    };
    Tokenizer2.prototype.read = function() {
      var tokens = [];
      var token2 = this.consumeToken();
      while (token2 !== EOF_TOKEN) {
        tokens.push(token2);
        token2 = this.consumeToken();
      }
      return tokens;
    };
    Tokenizer2.prototype.consumeToken = function() {
      var codePoint = this.consumeCodePoint();
      switch (codePoint) {
        case QUOTATION_MARK:
          return this.consumeStringToken(QUOTATION_MARK);
        case NUMBER_SIGN:
          var c1 = this.peekCodePoint(0);
          var c2 = this.peekCodePoint(1);
          var c3 = this.peekCodePoint(2);
          if (isNameCodePoint(c1) || isValidEscape(c2, c3)) {
            var flags = isIdentifierStart(c1, c2, c3) ? FLAG_ID : FLAG_UNRESTRICTED;
            var value2 = this.consumeName();
            return { type: 5, value: value2, flags };
          }
          break;
        case DOLLAR_SIGN:
          if (this.peekCodePoint(0) === EQUALS_SIGN) {
            this.consumeCodePoint();
            return SUFFIX_MATCH_TOKEN;
          }
          break;
        case APOSTROPHE:
          return this.consumeStringToken(APOSTROPHE);
        case LEFT_PARENTHESIS:
          return LEFT_PARENTHESIS_TOKEN;
        case RIGHT_PARENTHESIS:
          return RIGHT_PARENTHESIS_TOKEN;
        case ASTERISK:
          if (this.peekCodePoint(0) === EQUALS_SIGN) {
            this.consumeCodePoint();
            return SUBSTRING_MATCH_TOKEN;
          }
          break;
        case PLUS_SIGN:
          if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
            this.reconsumeCodePoint(codePoint);
            return this.consumeNumericToken();
          }
          break;
        case COMMA:
          return COMMA_TOKEN;
        case HYPHEN_MINUS:
          var e1 = codePoint;
          var e2 = this.peekCodePoint(0);
          var e3 = this.peekCodePoint(1);
          if (isNumberStart(e1, e2, e3)) {
            this.reconsumeCodePoint(codePoint);
            return this.consumeNumericToken();
          }
          if (isIdentifierStart(e1, e2, e3)) {
            this.reconsumeCodePoint(codePoint);
            return this.consumeIdentLikeToken();
          }
          if (e2 === HYPHEN_MINUS && e3 === GREATER_THAN_SIGN) {
            this.consumeCodePoint();
            this.consumeCodePoint();
            return CDC_TOKEN;
          }
          break;
        case FULL_STOP:
          if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
            this.reconsumeCodePoint(codePoint);
            return this.consumeNumericToken();
          }
          break;
        case SOLIDUS:
          if (this.peekCodePoint(0) === ASTERISK) {
            this.consumeCodePoint();
            while (true) {
              var c4 = this.consumeCodePoint();
              if (c4 === ASTERISK) {
                c4 = this.consumeCodePoint();
                if (c4 === SOLIDUS) {
                  return this.consumeToken();
                }
              }
              if (c4 === EOF) {
                return this.consumeToken();
              }
            }
          }
          break;
        case COLON:
          return COLON_TOKEN;
        case SEMICOLON:
          return SEMICOLON_TOKEN;
        case LESS_THAN_SIGN:
          if (this.peekCodePoint(0) === EXCLAMATION_MARK && this.peekCodePoint(1) === HYPHEN_MINUS && this.peekCodePoint(2) === HYPHEN_MINUS) {
            this.consumeCodePoint();
            this.consumeCodePoint();
            return CDO_TOKEN;
          }
          break;
        case COMMERCIAL_AT:
          var a1 = this.peekCodePoint(0);
          var a2 = this.peekCodePoint(1);
          var a3 = this.peekCodePoint(2);
          if (isIdentifierStart(a1, a2, a3)) {
            var value2 = this.consumeName();
            return { type: 7, value: value2 };
          }
          break;
        case LEFT_SQUARE_BRACKET:
          return LEFT_SQUARE_BRACKET_TOKEN;
        case REVERSE_SOLIDUS:
          if (isValidEscape(codePoint, this.peekCodePoint(0))) {
            this.reconsumeCodePoint(codePoint);
            return this.consumeIdentLikeToken();
          }
          break;
        case RIGHT_SQUARE_BRACKET:
          return RIGHT_SQUARE_BRACKET_TOKEN;
        case CIRCUMFLEX_ACCENT:
          if (this.peekCodePoint(0) === EQUALS_SIGN) {
            this.consumeCodePoint();
            return PREFIX_MATCH_TOKEN;
          }
          break;
        case LEFT_CURLY_BRACKET:
          return LEFT_CURLY_BRACKET_TOKEN;
        case RIGHT_CURLY_BRACKET:
          return RIGHT_CURLY_BRACKET_TOKEN;
        case u:
        case U:
          var u1 = this.peekCodePoint(0);
          var u2 = this.peekCodePoint(1);
          if (u1 === PLUS_SIGN && (isHex(u2) || u2 === QUESTION_MARK)) {
            this.consumeCodePoint();
            this.consumeUnicodeRangeToken();
          }
          this.reconsumeCodePoint(codePoint);
          return this.consumeIdentLikeToken();
        case VERTICAL_LINE:
          if (this.peekCodePoint(0) === EQUALS_SIGN) {
            this.consumeCodePoint();
            return DASH_MATCH_TOKEN;
          }
          if (this.peekCodePoint(0) === VERTICAL_LINE) {
            this.consumeCodePoint();
            return COLUMN_TOKEN;
          }
          break;
        case TILDE:
          if (this.peekCodePoint(0) === EQUALS_SIGN) {
            this.consumeCodePoint();
            return INCLUDE_MATCH_TOKEN;
          }
          break;
        case EOF:
          return EOF_TOKEN;
      }
      if (isWhiteSpace(codePoint)) {
        this.consumeWhiteSpace();
        return WHITESPACE_TOKEN;
      }
      if (isDigit(codePoint)) {
        this.reconsumeCodePoint(codePoint);
        return this.consumeNumericToken();
      }
      if (isNameStartCodePoint(codePoint)) {
        this.reconsumeCodePoint(codePoint);
        return this.consumeIdentLikeToken();
      }
      return { type: 6, value: fromCodePoint$1(codePoint) };
    };
    Tokenizer2.prototype.consumeCodePoint = function() {
      var value2 = this._value.shift();
      return typeof value2 === "undefined" ? -1 : value2;
    };
    Tokenizer2.prototype.reconsumeCodePoint = function(codePoint) {
      this._value.unshift(codePoint);
    };
    Tokenizer2.prototype.peekCodePoint = function(delta) {
      if (delta >= this._value.length) {
        return -1;
      }
      return this._value[delta];
    };
    Tokenizer2.prototype.consumeUnicodeRangeToken = function() {
      var digits = [];
      var codePoint = this.consumeCodePoint();
      while (isHex(codePoint) && digits.length < 6) {
        digits.push(codePoint);
        codePoint = this.consumeCodePoint();
      }
      var questionMarks = false;
      while (codePoint === QUESTION_MARK && digits.length < 6) {
        digits.push(codePoint);
        codePoint = this.consumeCodePoint();
        questionMarks = true;
      }
      if (questionMarks) {
        var start_1 = parseInt(fromCodePoint$1.apply(void 0, digits.map(function(digit) {
          return digit === QUESTION_MARK ? ZERO : digit;
        })), 16);
        var end = parseInt(fromCodePoint$1.apply(void 0, digits.map(function(digit) {
          return digit === QUESTION_MARK ? F : digit;
        })), 16);
        return { type: 30, start: start_1, end };
      }
      var start = parseInt(fromCodePoint$1.apply(void 0, digits), 16);
      if (this.peekCodePoint(0) === HYPHEN_MINUS && isHex(this.peekCodePoint(1))) {
        this.consumeCodePoint();
        codePoint = this.consumeCodePoint();
        var endDigits = [];
        while (isHex(codePoint) && endDigits.length < 6) {
          endDigits.push(codePoint);
          codePoint = this.consumeCodePoint();
        }
        var end = parseInt(fromCodePoint$1.apply(void 0, endDigits), 16);
        return { type: 30, start, end };
      } else {
        return { type: 30, start, end: start };
      }
    };
    Tokenizer2.prototype.consumeIdentLikeToken = function() {
      var value2 = this.consumeName();
      if (value2.toLowerCase() === "url" && this.peekCodePoint(0) === LEFT_PARENTHESIS) {
        this.consumeCodePoint();
        return this.consumeUrlToken();
      } else if (this.peekCodePoint(0) === LEFT_PARENTHESIS) {
        this.consumeCodePoint();
        return { type: 19, value: value2 };
      }
      return { type: 20, value: value2 };
    };
    Tokenizer2.prototype.consumeUrlToken = function() {
      var value2 = [];
      this.consumeWhiteSpace();
      if (this.peekCodePoint(0) === EOF) {
        return { type: 22, value: "" };
      }
      var next = this.peekCodePoint(0);
      if (next === APOSTROPHE || next === QUOTATION_MARK) {
        var stringToken = this.consumeStringToken(this.consumeCodePoint());
        if (stringToken.type === 0) {
          this.consumeWhiteSpace();
          if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
            this.consumeCodePoint();
            return { type: 22, value: stringToken.value };
          }
        }
        this.consumeBadUrlRemnants();
        return BAD_URL_TOKEN;
      }
      while (true) {
        var codePoint = this.consumeCodePoint();
        if (codePoint === EOF || codePoint === RIGHT_PARENTHESIS) {
          return { type: 22, value: fromCodePoint$1.apply(void 0, value2) };
        } else if (isWhiteSpace(codePoint)) {
          this.consumeWhiteSpace();
          if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
            this.consumeCodePoint();
            return { type: 22, value: fromCodePoint$1.apply(void 0, value2) };
          }
          this.consumeBadUrlRemnants();
          return BAD_URL_TOKEN;
        } else if (codePoint === QUOTATION_MARK || codePoint === APOSTROPHE || codePoint === LEFT_PARENTHESIS || isNonPrintableCodePoint(codePoint)) {
          this.consumeBadUrlRemnants();
          return BAD_URL_TOKEN;
        } else if (codePoint === REVERSE_SOLIDUS) {
          if (isValidEscape(codePoint, this.peekCodePoint(0))) {
            value2.push(this.consumeEscapedCodePoint());
          } else {
            this.consumeBadUrlRemnants();
            return BAD_URL_TOKEN;
          }
        } else {
          value2.push(codePoint);
        }
      }
    };
    Tokenizer2.prototype.consumeWhiteSpace = function() {
      while (isWhiteSpace(this.peekCodePoint(0))) {
        this.consumeCodePoint();
      }
    };
    Tokenizer2.prototype.consumeBadUrlRemnants = function() {
      while (true) {
        var codePoint = this.consumeCodePoint();
        if (codePoint === RIGHT_PARENTHESIS || codePoint === EOF) {
          return;
        }
        if (isValidEscape(codePoint, this.peekCodePoint(0))) {
          this.consumeEscapedCodePoint();
        }
      }
    };
    Tokenizer2.prototype.consumeStringSlice = function(count) {
      var SLICE_STACK_SIZE = 5e4;
      var value2 = "";
      while (count > 0) {
        var amount = Math.min(SLICE_STACK_SIZE, count);
        value2 += fromCodePoint$1.apply(void 0, this._value.splice(0, amount));
        count -= amount;
      }
      this._value.shift();
      return value2;
    };
    Tokenizer2.prototype.consumeStringToken = function(endingCodePoint) {
      var value2 = "";
      var i = 0;
      do {
        var codePoint = this._value[i];
        if (codePoint === EOF || codePoint === void 0 || codePoint === endingCodePoint) {
          value2 += this.consumeStringSlice(i);
          return { type: 0, value: value2 };
        }
        if (codePoint === LINE_FEED) {
          this._value.splice(0, i);
          return BAD_STRING_TOKEN;
        }
        if (codePoint === REVERSE_SOLIDUS) {
          var next = this._value[i + 1];
          if (next !== EOF && next !== void 0) {
            if (next === LINE_FEED) {
              value2 += this.consumeStringSlice(i);
              i = -1;
              this._value.shift();
            } else if (isValidEscape(codePoint, next)) {
              value2 += this.consumeStringSlice(i);
              value2 += fromCodePoint$1(this.consumeEscapedCodePoint());
              i = -1;
            }
          }
        }
        i++;
      } while (true);
    };
    Tokenizer2.prototype.consumeNumber = function() {
      var repr = [];
      var type = FLAG_INTEGER;
      var c1 = this.peekCodePoint(0);
      if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
        repr.push(this.consumeCodePoint());
      }
      while (isDigit(this.peekCodePoint(0))) {
        repr.push(this.consumeCodePoint());
      }
      c1 = this.peekCodePoint(0);
      var c2 = this.peekCodePoint(1);
      if (c1 === FULL_STOP && isDigit(c2)) {
        repr.push(this.consumeCodePoint(), this.consumeCodePoint());
        type = FLAG_NUMBER;
        while (isDigit(this.peekCodePoint(0))) {
          repr.push(this.consumeCodePoint());
        }
      }
      c1 = this.peekCodePoint(0);
      c2 = this.peekCodePoint(1);
      var c3 = this.peekCodePoint(2);
      if ((c1 === E || c1 === e) && ((c2 === PLUS_SIGN || c2 === HYPHEN_MINUS) && isDigit(c3) || isDigit(c2))) {
        repr.push(this.consumeCodePoint(), this.consumeCodePoint());
        type = FLAG_NUMBER;
        while (isDigit(this.peekCodePoint(0))) {
          repr.push(this.consumeCodePoint());
        }
      }
      return [stringToNumber(repr), type];
    };
    Tokenizer2.prototype.consumeNumericToken = function() {
      var _a2 = this.consumeNumber(), number = _a2[0], flags = _a2[1];
      var c1 = this.peekCodePoint(0);
      var c2 = this.peekCodePoint(1);
      var c3 = this.peekCodePoint(2);
      if (isIdentifierStart(c1, c2, c3)) {
        var unit = this.consumeName();
        return { type: 15, number, flags, unit };
      }
      if (c1 === PERCENTAGE_SIGN) {
        this.consumeCodePoint();
        return { type: 16, number, flags };
      }
      return { type: 17, number, flags };
    };
    Tokenizer2.prototype.consumeEscapedCodePoint = function() {
      var codePoint = this.consumeCodePoint();
      if (isHex(codePoint)) {
        var hex2 = fromCodePoint$1(codePoint);
        while (isHex(this.peekCodePoint(0)) && hex2.length < 6) {
          hex2 += fromCodePoint$1(this.consumeCodePoint());
        }
        if (isWhiteSpace(this.peekCodePoint(0))) {
          this.consumeCodePoint();
        }
        var hexCodePoint = parseInt(hex2, 16);
        if (hexCodePoint === 0 || isSurrogateCodePoint(hexCodePoint) || hexCodePoint > 1114111) {
          return REPLACEMENT_CHARACTER;
        }
        return hexCodePoint;
      }
      if (codePoint === EOF) {
        return REPLACEMENT_CHARACTER;
      }
      return codePoint;
    };
    Tokenizer2.prototype.consumeName = function() {
      var result = "";
      while (true) {
        var codePoint = this.consumeCodePoint();
        if (isNameCodePoint(codePoint)) {
          result += fromCodePoint$1(codePoint);
        } else if (isValidEscape(codePoint, this.peekCodePoint(0))) {
          result += fromCodePoint$1(this.consumeEscapedCodePoint());
        } else {
          this.reconsumeCodePoint(codePoint);
          return result;
        }
      }
    };
    return Tokenizer2;
  }()
);
var Parser = (
  /** @class */
  function() {
    function Parser2(tokens) {
      this._tokens = tokens;
    }
    Parser2.create = function(value2) {
      var tokenizer = new Tokenizer();
      tokenizer.write(value2);
      return new Parser2(tokenizer.read());
    };
    Parser2.parseValue = function(value2) {
      return Parser2.create(value2).parseComponentValue();
    };
    Parser2.parseValues = function(value2) {
      return Parser2.create(value2).parseComponentValues();
    };
    Parser2.prototype.parseComponentValue = function() {
      var token2 = this.consumeToken();
      while (token2.type === 31) {
        token2 = this.consumeToken();
      }
      if (token2.type === 32) {
        throw new SyntaxError("Error parsing CSS component value, unexpected EOF");
      }
      this.reconsumeToken(token2);
      var value2 = this.consumeComponentValue();
      do {
        token2 = this.consumeToken();
      } while (token2.type === 31);
      if (token2.type === 32) {
        return value2;
      }
      throw new SyntaxError("Error parsing CSS component value, multiple values found when expecting only one");
    };
    Parser2.prototype.parseComponentValues = function() {
      var values = [];
      while (true) {
        var value2 = this.consumeComponentValue();
        if (value2.type === 32) {
          return values;
        }
        values.push(value2);
        values.push();
      }
    };
    Parser2.prototype.consumeComponentValue = function() {
      var token2 = this.consumeToken();
      switch (token2.type) {
        case 11:
        case 28:
        case 2:
          return this.consumeSimpleBlock(token2.type);
        case 19:
          return this.consumeFunction(token2);
      }
      return token2;
    };
    Parser2.prototype.consumeSimpleBlock = function(type) {
      var block = { type, values: [] };
      var token2 = this.consumeToken();
      while (true) {
        if (token2.type === 32 || isEndingTokenFor(token2, type)) {
          return block;
        }
        this.reconsumeToken(token2);
        block.values.push(this.consumeComponentValue());
        token2 = this.consumeToken();
      }
    };
    Parser2.prototype.consumeFunction = function(functionToken) {
      var cssFunction = {
        name: functionToken.value,
        values: [],
        type: 18
        /* FUNCTION */
      };
      while (true) {
        var token2 = this.consumeToken();
        if (token2.type === 32 || token2.type === 3) {
          return cssFunction;
        }
        this.reconsumeToken(token2);
        cssFunction.values.push(this.consumeComponentValue());
      }
    };
    Parser2.prototype.consumeToken = function() {
      var token2 = this._tokens.shift();
      return typeof token2 === "undefined" ? EOF_TOKEN : token2;
    };
    Parser2.prototype.reconsumeToken = function(token2) {
      this._tokens.unshift(token2);
    };
    return Parser2;
  }()
);
var isDimensionToken = function(token2) {
  return token2.type === 15;
};
var isNumberToken = function(token2) {
  return token2.type === 17;
};
var isIdentToken = function(token2) {
  return token2.type === 20;
};
var isStringToken = function(token2) {
  return token2.type === 0;
};
var isIdentWithValue = function(token2, value2) {
  return isIdentToken(token2) && token2.value === value2;
};
var nonWhiteSpace = function(token2) {
  return token2.type !== 31;
};
var nonFunctionArgSeparator = function(token2) {
  return token2.type !== 31 && token2.type !== 4;
};
var parseFunctionArgs = function(tokens) {
  var args = [];
  var arg = [];
  tokens.forEach(function(token2) {
    if (token2.type === 4) {
      if (arg.length === 0) {
        throw new Error("Error parsing function args, zero tokens for arg");
      }
      args.push(arg);
      arg = [];
      return;
    }
    if (token2.type !== 31) {
      arg.push(token2);
    }
  });
  if (arg.length) {
    args.push(arg);
  }
  return args;
};
var isEndingTokenFor = function(token2, type) {
  if (type === 11 && token2.type === 12) {
    return true;
  }
  if (type === 28 && token2.type === 29) {
    return true;
  }
  return type === 2 && token2.type === 3;
};
var isLength = function(token2) {
  return token2.type === 17 || token2.type === 15;
};
var isLengthPercentage = function(token2) {
  return token2.type === 16 || isLength(token2);
};
var parseLengthPercentageTuple = function(tokens) {
  return tokens.length > 1 ? [tokens[0], tokens[1]] : [tokens[0]];
};
var ZERO_LENGTH = {
  type: 17,
  number: 0,
  flags: FLAG_INTEGER
};
var FIFTY_PERCENT = {
  type: 16,
  number: 50,
  flags: FLAG_INTEGER
};
var HUNDRED_PERCENT = {
  type: 16,
  number: 100,
  flags: FLAG_INTEGER
};
var getAbsoluteValueForTuple = function(tuple, width2, height) {
  var x2 = tuple[0], y2 = tuple[1];
  return [getAbsoluteValue(x2, width2), getAbsoluteValue(typeof y2 !== "undefined" ? y2 : x2, height)];
};
var getAbsoluteValue = function(token2, parent) {
  if (token2.type === 16) {
    return token2.number / 100 * parent;
  }
  if (isDimensionToken(token2)) {
    switch (token2.unit) {
      case "rem":
      case "em":
        return 16 * token2.number;
      case "px":
      default:
        return token2.number;
    }
  }
  return token2.number;
};
var DEG = "deg";
var GRAD = "grad";
var RAD = "rad";
var TURN = "turn";
var angle = {
  name: "angle",
  parse: function(_context, value2) {
    if (value2.type === 15) {
      switch (value2.unit) {
        case DEG:
          return Math.PI * value2.number / 180;
        case GRAD:
          return Math.PI / 200 * value2.number;
        case RAD:
          return value2.number;
        case TURN:
          return Math.PI * 2 * value2.number;
      }
    }
    throw new Error("Unsupported angle type");
  }
};
var isAngle = function(value2) {
  if (value2.type === 15) {
    if (value2.unit === DEG || value2.unit === GRAD || value2.unit === RAD || value2.unit === TURN) {
      return true;
    }
  }
  return false;
};
var parseNamedSide = function(tokens) {
  var sideOrCorner = tokens.filter(isIdentToken).map(function(ident) {
    return ident.value;
  }).join(" ");
  switch (sideOrCorner) {
    case "to bottom right":
    case "to right bottom":
    case "left top":
    case "top left":
      return [ZERO_LENGTH, ZERO_LENGTH];
    case "to top":
    case "bottom":
      return deg(0);
    case "to bottom left":
    case "to left bottom":
    case "right top":
    case "top right":
      return [ZERO_LENGTH, HUNDRED_PERCENT];
    case "to right":
    case "left":
      return deg(90);
    case "to top left":
    case "to left top":
    case "right bottom":
    case "bottom right":
      return [HUNDRED_PERCENT, HUNDRED_PERCENT];
    case "to bottom":
    case "top":
      return deg(180);
    case "to top right":
    case "to right top":
    case "left bottom":
    case "bottom left":
      return [HUNDRED_PERCENT, ZERO_LENGTH];
    case "to left":
    case "right":
      return deg(270);
  }
  return 0;
};
var deg = function(deg2) {
  return Math.PI * deg2 / 180;
};
var color$1 = {
  name: "color",
  parse: function(context, value2) {
    if (value2.type === 18) {
      var colorFunction = SUPPORTED_COLOR_FUNCTIONS[value2.name];
      if (typeof colorFunction === "undefined") {
        throw new Error('Attempting to parse an unsupported color function "' + value2.name + '"');
      }
      return colorFunction(context, value2.values);
    }
    if (value2.type === 5) {
      if (value2.value.length === 3) {
        var r = value2.value.substring(0, 1);
        var g2 = value2.value.substring(1, 2);
        var b2 = value2.value.substring(2, 3);
        return pack(parseInt(r + r, 16), parseInt(g2 + g2, 16), parseInt(b2 + b2, 16), 1);
      }
      if (value2.value.length === 4) {
        var r = value2.value.substring(0, 1);
        var g2 = value2.value.substring(1, 2);
        var b2 = value2.value.substring(2, 3);
        var a2 = value2.value.substring(3, 4);
        return pack(parseInt(r + r, 16), parseInt(g2 + g2, 16), parseInt(b2 + b2, 16), parseInt(a2 + a2, 16) / 255);
      }
      if (value2.value.length === 6) {
        var r = value2.value.substring(0, 2);
        var g2 = value2.value.substring(2, 4);
        var b2 = value2.value.substring(4, 6);
        return pack(parseInt(r, 16), parseInt(g2, 16), parseInt(b2, 16), 1);
      }
      if (value2.value.length === 8) {
        var r = value2.value.substring(0, 2);
        var g2 = value2.value.substring(2, 4);
        var b2 = value2.value.substring(4, 6);
        var a2 = value2.value.substring(6, 8);
        return pack(parseInt(r, 16), parseInt(g2, 16), parseInt(b2, 16), parseInt(a2, 16) / 255);
      }
    }
    if (value2.type === 20) {
      var namedColor = COLORS[value2.value.toUpperCase()];
      if (typeof namedColor !== "undefined") {
        return namedColor;
      }
    }
    return COLORS.TRANSPARENT;
  }
};
var isTransparent = function(color2) {
  return (255 & color2) === 0;
};
var asString = function(color2) {
  var alpha = 255 & color2;
  var blue = 255 & color2 >> 8;
  var green = 255 & color2 >> 16;
  var red = 255 & color2 >> 24;
  return alpha < 255 ? "rgba(" + red + "," + green + "," + blue + "," + alpha / 255 + ")" : "rgb(" + red + "," + green + "," + blue + ")";
};
var pack = function(r, g2, b2, a2) {
  return (r << 24 | g2 << 16 | b2 << 8 | Math.round(a2 * 255) << 0) >>> 0;
};
var getTokenColorValue = function(token2, i) {
  if (token2.type === 17) {
    return token2.number;
  }
  if (token2.type === 16) {
    var max2 = i === 3 ? 1 : 255;
    return i === 3 ? token2.number / 100 * max2 : Math.round(token2.number / 100 * max2);
  }
  return 0;
};
var rgb = function(_context, args) {
  var tokens = args.filter(nonFunctionArgSeparator);
  if (tokens.length === 3) {
    var _a2 = tokens.map(getTokenColorValue), r = _a2[0], g2 = _a2[1], b2 = _a2[2];
    return pack(r, g2, b2, 1);
  }
  if (tokens.length === 4) {
    var _b2 = tokens.map(getTokenColorValue), r = _b2[0], g2 = _b2[1], b2 = _b2[2], a2 = _b2[3];
    return pack(r, g2, b2, a2);
  }
  return 0;
};
function hue2rgb(t1, t2, hue) {
  if (hue < 0) {
    hue += 1;
  }
  if (hue >= 1) {
    hue -= 1;
  }
  if (hue < 1 / 6) {
    return (t2 - t1) * hue * 6 + t1;
  } else if (hue < 1 / 2) {
    return t2;
  } else if (hue < 2 / 3) {
    return (t2 - t1) * 6 * (2 / 3 - hue) + t1;
  } else {
    return t1;
  }
}
var hsl = function(context, args) {
  var tokens = args.filter(nonFunctionArgSeparator);
  var hue = tokens[0], saturation = tokens[1], lightness = tokens[2], alpha = tokens[3];
  var h2 = (hue.type === 17 ? deg(hue.number) : angle.parse(context, hue)) / (Math.PI * 2);
  var s2 = isLengthPercentage(saturation) ? saturation.number / 100 : 0;
  var l2 = isLengthPercentage(lightness) ? lightness.number / 100 : 0;
  var a2 = typeof alpha !== "undefined" && isLengthPercentage(alpha) ? getAbsoluteValue(alpha, 1) : 1;
  if (s2 === 0) {
    return pack(l2 * 255, l2 * 255, l2 * 255, 1);
  }
  var t2 = l2 <= 0.5 ? l2 * (s2 + 1) : l2 + s2 - l2 * s2;
  var t1 = l2 * 2 - t2;
  var r = hue2rgb(t1, t2, h2 + 1 / 3);
  var g2 = hue2rgb(t1, t2, h2);
  var b2 = hue2rgb(t1, t2, h2 - 1 / 3);
  return pack(r * 255, g2 * 255, b2 * 255, a2);
};
var SUPPORTED_COLOR_FUNCTIONS = {
  hsl,
  hsla: hsl,
  rgb,
  rgba: rgb
};
var parseColor = function(context, value2) {
  return color$1.parse(context, Parser.create(value2).parseComponentValue());
};
var COLORS = {
  ALICEBLUE: 4042850303,
  ANTIQUEWHITE: 4209760255,
  AQUA: 16777215,
  AQUAMARINE: 2147472639,
  AZURE: 4043309055,
  BEIGE: 4126530815,
  BISQUE: 4293182719,
  BLACK: 255,
  BLANCHEDALMOND: 4293643775,
  BLUE: 65535,
  BLUEVIOLET: 2318131967,
  BROWN: 2771004159,
  BURLYWOOD: 3736635391,
  CADETBLUE: 1604231423,
  CHARTREUSE: 2147418367,
  CHOCOLATE: 3530104575,
  CORAL: 4286533887,
  CORNFLOWERBLUE: 1687547391,
  CORNSILK: 4294499583,
  CRIMSON: 3692313855,
  CYAN: 16777215,
  DARKBLUE: 35839,
  DARKCYAN: 9145343,
  DARKGOLDENROD: 3095837695,
  DARKGRAY: 2846468607,
  DARKGREEN: 6553855,
  DARKGREY: 2846468607,
  DARKKHAKI: 3182914559,
  DARKMAGENTA: 2332068863,
  DARKOLIVEGREEN: 1433087999,
  DARKORANGE: 4287365375,
  DARKORCHID: 2570243327,
  DARKRED: 2332033279,
  DARKSALMON: 3918953215,
  DARKSEAGREEN: 2411499519,
  DARKSLATEBLUE: 1211993087,
  DARKSLATEGRAY: 793726975,
  DARKSLATEGREY: 793726975,
  DARKTURQUOISE: 13554175,
  DARKVIOLET: 2483082239,
  DEEPPINK: 4279538687,
  DEEPSKYBLUE: 12582911,
  DIMGRAY: 1768516095,
  DIMGREY: 1768516095,
  DODGERBLUE: 512819199,
  FIREBRICK: 2988581631,
  FLORALWHITE: 4294635775,
  FORESTGREEN: 579543807,
  FUCHSIA: 4278255615,
  GAINSBORO: 3705462015,
  GHOSTWHITE: 4177068031,
  GOLD: 4292280575,
  GOLDENROD: 3668254975,
  GRAY: 2155905279,
  GREEN: 8388863,
  GREENYELLOW: 2919182335,
  GREY: 2155905279,
  HONEYDEW: 4043305215,
  HOTPINK: 4285117695,
  INDIANRED: 3445382399,
  INDIGO: 1258324735,
  IVORY: 4294963455,
  KHAKI: 4041641215,
  LAVENDER: 3873897215,
  LAVENDERBLUSH: 4293981695,
  LAWNGREEN: 2096890111,
  LEMONCHIFFON: 4294626815,
  LIGHTBLUE: 2916673279,
  LIGHTCORAL: 4034953471,
  LIGHTCYAN: 3774873599,
  LIGHTGOLDENRODYELLOW: 4210742015,
  LIGHTGRAY: 3553874943,
  LIGHTGREEN: 2431553791,
  LIGHTGREY: 3553874943,
  LIGHTPINK: 4290167295,
  LIGHTSALMON: 4288707327,
  LIGHTSEAGREEN: 548580095,
  LIGHTSKYBLUE: 2278488831,
  LIGHTSLATEGRAY: 2005441023,
  LIGHTSLATEGREY: 2005441023,
  LIGHTSTEELBLUE: 2965692159,
  LIGHTYELLOW: 4294959359,
  LIME: 16711935,
  LIMEGREEN: 852308735,
  LINEN: 4210091775,
  MAGENTA: 4278255615,
  MAROON: 2147483903,
  MEDIUMAQUAMARINE: 1724754687,
  MEDIUMBLUE: 52735,
  MEDIUMORCHID: 3126187007,
  MEDIUMPURPLE: 2473647103,
  MEDIUMSEAGREEN: 1018393087,
  MEDIUMSLATEBLUE: 2070474495,
  MEDIUMSPRINGGREEN: 16423679,
  MEDIUMTURQUOISE: 1221709055,
  MEDIUMVIOLETRED: 3340076543,
  MIDNIGHTBLUE: 421097727,
  MINTCREAM: 4127193855,
  MISTYROSE: 4293190143,
  MOCCASIN: 4293178879,
  NAVAJOWHITE: 4292783615,
  NAVY: 33023,
  OLDLACE: 4260751103,
  OLIVE: 2155872511,
  OLIVEDRAB: 1804477439,
  ORANGE: 4289003775,
  ORANGERED: 4282712319,
  ORCHID: 3664828159,
  PALEGOLDENROD: 4008225535,
  PALEGREEN: 2566625535,
  PALETURQUOISE: 2951671551,
  PALEVIOLETRED: 3681588223,
  PAPAYAWHIP: 4293907967,
  PEACHPUFF: 4292524543,
  PERU: 3448061951,
  PINK: 4290825215,
  PLUM: 3718307327,
  POWDERBLUE: 2967529215,
  PURPLE: 2147516671,
  REBECCAPURPLE: 1714657791,
  RED: 4278190335,
  ROSYBROWN: 3163525119,
  ROYALBLUE: 1097458175,
  SADDLEBROWN: 2336560127,
  SALMON: 4202722047,
  SANDYBROWN: 4104413439,
  SEAGREEN: 780883967,
  SEASHELL: 4294307583,
  SIENNA: 2689740287,
  SILVER: 3233857791,
  SKYBLUE: 2278484991,
  SLATEBLUE: 1784335871,
  SLATEGRAY: 1887473919,
  SLATEGREY: 1887473919,
  SNOW: 4294638335,
  SPRINGGREEN: 16744447,
  STEELBLUE: 1182971135,
  TAN: 3535047935,
  TEAL: 8421631,
  THISTLE: 3636451583,
  TOMATO: 4284696575,
  TRANSPARENT: 0,
  TURQUOISE: 1088475391,
  VIOLET: 4001558271,
  WHEAT: 4125012991,
  WHITE: 4294967295,
  WHITESMOKE: 4126537215,
  YELLOW: 4294902015,
  YELLOWGREEN: 2597139199
};
var backgroundClip = {
  name: "background-clip",
  initialValue: "border-box",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return tokens.map(function(token2) {
      if (isIdentToken(token2)) {
        switch (token2.value) {
          case "padding-box":
            return 1;
          case "content-box":
            return 2;
        }
      }
      return 0;
    });
  }
};
var backgroundColor = {
  name: "background-color",
  initialValue: "transparent",
  prefix: false,
  type: 3,
  format: "color"
};
var parseColorStop = function(context, args) {
  var color2 = color$1.parse(context, args[0]);
  var stop2 = args[1];
  return stop2 && isLengthPercentage(stop2) ? { color: color2, stop: stop2 } : { color: color2, stop: null };
};
var processColorStops = function(stops, lineLength) {
  var first = stops[0];
  var last = stops[stops.length - 1];
  if (first.stop === null) {
    first.stop = ZERO_LENGTH;
  }
  if (last.stop === null) {
    last.stop = HUNDRED_PERCENT;
  }
  var processStops = [];
  var previous = 0;
  for (var i = 0; i < stops.length; i++) {
    var stop_1 = stops[i].stop;
    if (stop_1 !== null) {
      var absoluteValue = getAbsoluteValue(stop_1, lineLength);
      if (absoluteValue > previous) {
        processStops.push(absoluteValue);
      } else {
        processStops.push(previous);
      }
      previous = absoluteValue;
    } else {
      processStops.push(null);
    }
  }
  var gapBegin = null;
  for (var i = 0; i < processStops.length; i++) {
    var stop_2 = processStops[i];
    if (stop_2 === null) {
      if (gapBegin === null) {
        gapBegin = i;
      }
    } else if (gapBegin !== null) {
      var gapLength = i - gapBegin;
      var beforeGap = processStops[gapBegin - 1];
      var gapValue = (stop_2 - beforeGap) / (gapLength + 1);
      for (var g2 = 1; g2 <= gapLength; g2++) {
        processStops[gapBegin + g2 - 1] = gapValue * g2;
      }
      gapBegin = null;
    }
  }
  return stops.map(function(_a2, i2) {
    var color2 = _a2.color;
    return { color: color2, stop: Math.max(Math.min(1, processStops[i2] / lineLength), 0) };
  });
};
var getAngleFromCorner = function(corner, width2, height) {
  var centerX = width2 / 2;
  var centerY = height / 2;
  var x2 = getAbsoluteValue(corner[0], width2) - centerX;
  var y2 = centerY - getAbsoluteValue(corner[1], height);
  return (Math.atan2(y2, x2) + Math.PI * 2) % (Math.PI * 2);
};
var calculateGradientDirection = function(angle2, width2, height) {
  var radian = typeof angle2 === "number" ? angle2 : getAngleFromCorner(angle2, width2, height);
  var lineLength = Math.abs(width2 * Math.sin(radian)) + Math.abs(height * Math.cos(radian));
  var halfWidth = width2 / 2;
  var halfHeight = height / 2;
  var halfLineLength = lineLength / 2;
  var yDiff = Math.sin(radian - Math.PI / 2) * halfLineLength;
  var xDiff = Math.cos(radian - Math.PI / 2) * halfLineLength;
  return [lineLength, halfWidth - xDiff, halfWidth + xDiff, halfHeight - yDiff, halfHeight + yDiff];
};
var distance = function(a2, b2) {
  return Math.sqrt(a2 * a2 + b2 * b2);
};
var findCorner = function(width2, height, x2, y2, closest) {
  var corners = [
    [0, 0],
    [0, height],
    [width2, 0],
    [width2, height]
  ];
  return corners.reduce(function(stat, corner) {
    var cx = corner[0], cy = corner[1];
    var d2 = distance(x2 - cx, y2 - cy);
    if (closest ? d2 < stat.optimumDistance : d2 > stat.optimumDistance) {
      return {
        optimumCorner: corner,
        optimumDistance: d2
      };
    }
    return stat;
  }, {
    optimumDistance: closest ? Infinity : -Infinity,
    optimumCorner: null
  }).optimumCorner;
};
var calculateRadius = function(gradient, x2, y2, width2, height) {
  var rx = 0;
  var ry = 0;
  switch (gradient.size) {
    case 0:
      if (gradient.shape === 0) {
        rx = ry = Math.min(Math.abs(x2), Math.abs(x2 - width2), Math.abs(y2), Math.abs(y2 - height));
      } else if (gradient.shape === 1) {
        rx = Math.min(Math.abs(x2), Math.abs(x2 - width2));
        ry = Math.min(Math.abs(y2), Math.abs(y2 - height));
      }
      break;
    case 2:
      if (gradient.shape === 0) {
        rx = ry = Math.min(distance(x2, y2), distance(x2, y2 - height), distance(x2 - width2, y2), distance(x2 - width2, y2 - height));
      } else if (gradient.shape === 1) {
        var c2 = Math.min(Math.abs(y2), Math.abs(y2 - height)) / Math.min(Math.abs(x2), Math.abs(x2 - width2));
        var _a2 = findCorner(width2, height, x2, y2, true), cx = _a2[0], cy = _a2[1];
        rx = distance(cx - x2, (cy - y2) / c2);
        ry = c2 * rx;
      }
      break;
    case 1:
      if (gradient.shape === 0) {
        rx = ry = Math.max(Math.abs(x2), Math.abs(x2 - width2), Math.abs(y2), Math.abs(y2 - height));
      } else if (gradient.shape === 1) {
        rx = Math.max(Math.abs(x2), Math.abs(x2 - width2));
        ry = Math.max(Math.abs(y2), Math.abs(y2 - height));
      }
      break;
    case 3:
      if (gradient.shape === 0) {
        rx = ry = Math.max(distance(x2, y2), distance(x2, y2 - height), distance(x2 - width2, y2), distance(x2 - width2, y2 - height));
      } else if (gradient.shape === 1) {
        var c2 = Math.max(Math.abs(y2), Math.abs(y2 - height)) / Math.max(Math.abs(x2), Math.abs(x2 - width2));
        var _b2 = findCorner(width2, height, x2, y2, false), cx = _b2[0], cy = _b2[1];
        rx = distance(cx - x2, (cy - y2) / c2);
        ry = c2 * rx;
      }
      break;
  }
  if (Array.isArray(gradient.size)) {
    rx = getAbsoluteValue(gradient.size[0], width2);
    ry = gradient.size.length === 2 ? getAbsoluteValue(gradient.size[1], height) : rx;
  }
  return [rx, ry];
};
var linearGradient = function(context, tokens) {
  var angle$1 = deg(180);
  var stops = [];
  parseFunctionArgs(tokens).forEach(function(arg, i) {
    if (i === 0) {
      var firstToken = arg[0];
      if (firstToken.type === 20 && firstToken.value === "to") {
        angle$1 = parseNamedSide(arg);
        return;
      } else if (isAngle(firstToken)) {
        angle$1 = angle.parse(context, firstToken);
        return;
      }
    }
    var colorStop = parseColorStop(context, arg);
    stops.push(colorStop);
  });
  return {
    angle: angle$1,
    stops,
    type: 1
    /* LINEAR_GRADIENT */
  };
};
var prefixLinearGradient = function(context, tokens) {
  var angle$1 = deg(180);
  var stops = [];
  parseFunctionArgs(tokens).forEach(function(arg, i) {
    if (i === 0) {
      var firstToken = arg[0];
      if (firstToken.type === 20 && ["top", "left", "right", "bottom"].indexOf(firstToken.value) !== -1) {
        angle$1 = parseNamedSide(arg);
        return;
      } else if (isAngle(firstToken)) {
        angle$1 = (angle.parse(context, firstToken) + deg(270)) % deg(360);
        return;
      }
    }
    var colorStop = parseColorStop(context, arg);
    stops.push(colorStop);
  });
  return {
    angle: angle$1,
    stops,
    type: 1
    /* LINEAR_GRADIENT */
  };
};
var webkitGradient = function(context, tokens) {
  var angle2 = deg(180);
  var stops = [];
  var type = 1;
  var shape = 0;
  var size2 = 3;
  var position2 = [];
  parseFunctionArgs(tokens).forEach(function(arg, i) {
    var firstToken = arg[0];
    if (i === 0) {
      if (isIdentToken(firstToken) && firstToken.value === "linear") {
        type = 1;
        return;
      } else if (isIdentToken(firstToken) && firstToken.value === "radial") {
        type = 2;
        return;
      }
    }
    if (firstToken.type === 18) {
      if (firstToken.name === "from") {
        var color2 = color$1.parse(context, firstToken.values[0]);
        stops.push({ stop: ZERO_LENGTH, color: color2 });
      } else if (firstToken.name === "to") {
        var color2 = color$1.parse(context, firstToken.values[0]);
        stops.push({ stop: HUNDRED_PERCENT, color: color2 });
      } else if (firstToken.name === "color-stop") {
        var values = firstToken.values.filter(nonFunctionArgSeparator);
        if (values.length === 2) {
          var color2 = color$1.parse(context, values[1]);
          var stop_1 = values[0];
          if (isNumberToken(stop_1)) {
            stops.push({
              stop: { type: 16, number: stop_1.number * 100, flags: stop_1.flags },
              color: color2
            });
          }
        }
      }
    }
  });
  return type === 1 ? {
    angle: (angle2 + deg(180)) % deg(360),
    stops,
    type
  } : { size: size2, shape, stops, position: position2, type };
};
var CLOSEST_SIDE = "closest-side";
var FARTHEST_SIDE = "farthest-side";
var CLOSEST_CORNER = "closest-corner";
var FARTHEST_CORNER = "farthest-corner";
var CIRCLE = "circle";
var ELLIPSE = "ellipse";
var COVER = "cover";
var CONTAIN = "contain";
var radialGradient = function(context, tokens) {
  var shape = 0;
  var size2 = 3;
  var stops = [];
  var position2 = [];
  parseFunctionArgs(tokens).forEach(function(arg, i) {
    var isColorStop = true;
    if (i === 0) {
      var isAtPosition_1 = false;
      isColorStop = arg.reduce(function(acc, token2) {
        if (isAtPosition_1) {
          if (isIdentToken(token2)) {
            switch (token2.value) {
              case "center":
                position2.push(FIFTY_PERCENT);
                return acc;
              case "top":
              case "left":
                position2.push(ZERO_LENGTH);
                return acc;
              case "right":
              case "bottom":
                position2.push(HUNDRED_PERCENT);
                return acc;
            }
          } else if (isLengthPercentage(token2) || isLength(token2)) {
            position2.push(token2);
          }
        } else if (isIdentToken(token2)) {
          switch (token2.value) {
            case CIRCLE:
              shape = 0;
              return false;
            case ELLIPSE:
              shape = 1;
              return false;
            case "at":
              isAtPosition_1 = true;
              return false;
            case CLOSEST_SIDE:
              size2 = 0;
              return false;
            case COVER:
            case FARTHEST_SIDE:
              size2 = 1;
              return false;
            case CONTAIN:
            case CLOSEST_CORNER:
              size2 = 2;
              return false;
            case FARTHEST_CORNER:
              size2 = 3;
              return false;
          }
        } else if (isLength(token2) || isLengthPercentage(token2)) {
          if (!Array.isArray(size2)) {
            size2 = [];
          }
          size2.push(token2);
          return false;
        }
        return acc;
      }, isColorStop);
    }
    if (isColorStop) {
      var colorStop = parseColorStop(context, arg);
      stops.push(colorStop);
    }
  });
  return {
    size: size2,
    shape,
    stops,
    position: position2,
    type: 2
    /* RADIAL_GRADIENT */
  };
};
var prefixRadialGradient = function(context, tokens) {
  var shape = 0;
  var size2 = 3;
  var stops = [];
  var position2 = [];
  parseFunctionArgs(tokens).forEach(function(arg, i) {
    var isColorStop = true;
    if (i === 0) {
      isColorStop = arg.reduce(function(acc, token2) {
        if (isIdentToken(token2)) {
          switch (token2.value) {
            case "center":
              position2.push(FIFTY_PERCENT);
              return false;
            case "top":
            case "left":
              position2.push(ZERO_LENGTH);
              return false;
            case "right":
            case "bottom":
              position2.push(HUNDRED_PERCENT);
              return false;
          }
        } else if (isLengthPercentage(token2) || isLength(token2)) {
          position2.push(token2);
          return false;
        }
        return acc;
      }, isColorStop);
    } else if (i === 1) {
      isColorStop = arg.reduce(function(acc, token2) {
        if (isIdentToken(token2)) {
          switch (token2.value) {
            case CIRCLE:
              shape = 0;
              return false;
            case ELLIPSE:
              shape = 1;
              return false;
            case CONTAIN:
            case CLOSEST_SIDE:
              size2 = 0;
              return false;
            case FARTHEST_SIDE:
              size2 = 1;
              return false;
            case CLOSEST_CORNER:
              size2 = 2;
              return false;
            case COVER:
            case FARTHEST_CORNER:
              size2 = 3;
              return false;
          }
        } else if (isLength(token2) || isLengthPercentage(token2)) {
          if (!Array.isArray(size2)) {
            size2 = [];
          }
          size2.push(token2);
          return false;
        }
        return acc;
      }, isColorStop);
    }
    if (isColorStop) {
      var colorStop = parseColorStop(context, arg);
      stops.push(colorStop);
    }
  });
  return {
    size: size2,
    shape,
    stops,
    position: position2,
    type: 2
    /* RADIAL_GRADIENT */
  };
};
var isLinearGradient = function(background) {
  return background.type === 1;
};
var isRadialGradient = function(background) {
  return background.type === 2;
};
var image = {
  name: "image",
  parse: function(context, value2) {
    if (value2.type === 22) {
      var image_1 = {
        url: value2.value,
        type: 0
        /* URL */
      };
      context.cache.addImage(value2.value);
      return image_1;
    }
    if (value2.type === 18) {
      var imageFunction = SUPPORTED_IMAGE_FUNCTIONS[value2.name];
      if (typeof imageFunction === "undefined") {
        throw new Error('Attempting to parse an unsupported image function "' + value2.name + '"');
      }
      return imageFunction(context, value2.values);
    }
    throw new Error("Unsupported image type " + value2.type);
  }
};
function isSupportedImage(value2) {
  return !(value2.type === 20 && value2.value === "none") && (value2.type !== 18 || !!SUPPORTED_IMAGE_FUNCTIONS[value2.name]);
}
var SUPPORTED_IMAGE_FUNCTIONS = {
  "linear-gradient": linearGradient,
  "-moz-linear-gradient": prefixLinearGradient,
  "-ms-linear-gradient": prefixLinearGradient,
  "-o-linear-gradient": prefixLinearGradient,
  "-webkit-linear-gradient": prefixLinearGradient,
  "radial-gradient": radialGradient,
  "-moz-radial-gradient": prefixRadialGradient,
  "-ms-radial-gradient": prefixRadialGradient,
  "-o-radial-gradient": prefixRadialGradient,
  "-webkit-radial-gradient": prefixRadialGradient,
  "-webkit-gradient": webkitGradient
};
var backgroundImage = {
  name: "background-image",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(context, tokens) {
    if (tokens.length === 0) {
      return [];
    }
    var first = tokens[0];
    if (first.type === 20 && first.value === "none") {
      return [];
    }
    return tokens.filter(function(value2) {
      return nonFunctionArgSeparator(value2) && isSupportedImage(value2);
    }).map(function(value2) {
      return image.parse(context, value2);
    });
  }
};
var backgroundOrigin = {
  name: "background-origin",
  initialValue: "border-box",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return tokens.map(function(token2) {
      if (isIdentToken(token2)) {
        switch (token2.value) {
          case "padding-box":
            return 1;
          case "content-box":
            return 2;
        }
      }
      return 0;
    });
  }
};
var backgroundPosition = {
  name: "background-position",
  initialValue: "0% 0%",
  type: 1,
  prefix: false,
  parse: function(_context, tokens) {
    return parseFunctionArgs(tokens).map(function(values) {
      return values.filter(isLengthPercentage);
    }).map(parseLengthPercentageTuple);
  }
};
var backgroundRepeat = {
  name: "background-repeat",
  initialValue: "repeat",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return parseFunctionArgs(tokens).map(function(values) {
      return values.filter(isIdentToken).map(function(token2) {
        return token2.value;
      }).join(" ");
    }).map(parseBackgroundRepeat);
  }
};
var parseBackgroundRepeat = function(value2) {
  switch (value2) {
    case "no-repeat":
      return 1;
    case "repeat-x":
    case "repeat no-repeat":
      return 2;
    case "repeat-y":
    case "no-repeat repeat":
      return 3;
    case "repeat":
    default:
      return 0;
  }
};
var BACKGROUND_SIZE;
(function(BACKGROUND_SIZE2) {
  BACKGROUND_SIZE2["AUTO"] = "auto";
  BACKGROUND_SIZE2["CONTAIN"] = "contain";
  BACKGROUND_SIZE2["COVER"] = "cover";
})(BACKGROUND_SIZE || (BACKGROUND_SIZE = {}));
var backgroundSize = {
  name: "background-size",
  initialValue: "0",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return parseFunctionArgs(tokens).map(function(values) {
      return values.filter(isBackgroundSizeInfoToken);
    });
  }
};
var isBackgroundSizeInfoToken = function(value2) {
  return isIdentToken(value2) || isLengthPercentage(value2);
};
var borderColorForSide = function(side) {
  return {
    name: "border-" + side + "-color",
    initialValue: "transparent",
    prefix: false,
    type: 3,
    format: "color"
  };
};
var borderTopColor = borderColorForSide("top");
var borderRightColor = borderColorForSide("right");
var borderBottomColor = borderColorForSide("bottom");
var borderLeftColor = borderColorForSide("left");
var borderRadiusForSide = function(side) {
  return {
    name: "border-radius-" + side,
    initialValue: "0 0",
    prefix: false,
    type: 1,
    parse: function(_context, tokens) {
      return parseLengthPercentageTuple(tokens.filter(isLengthPercentage));
    }
  };
};
var borderTopLeftRadius = borderRadiusForSide("top-left");
var borderTopRightRadius = borderRadiusForSide("top-right");
var borderBottomRightRadius = borderRadiusForSide("bottom-right");
var borderBottomLeftRadius = borderRadiusForSide("bottom-left");
var borderStyleForSide = function(side) {
  return {
    name: "border-" + side + "-style",
    initialValue: "solid",
    prefix: false,
    type: 2,
    parse: function(_context, style) {
      switch (style) {
        case "none":
          return 0;
        case "dashed":
          return 2;
        case "dotted":
          return 3;
        case "double":
          return 4;
      }
      return 1;
    }
  };
};
var borderTopStyle = borderStyleForSide("top");
var borderRightStyle = borderStyleForSide("right");
var borderBottomStyle = borderStyleForSide("bottom");
var borderLeftStyle = borderStyleForSide("left");
var borderWidthForSide = function(side) {
  return {
    name: "border-" + side + "-width",
    initialValue: "0",
    type: 0,
    prefix: false,
    parse: function(_context, token2) {
      if (isDimensionToken(token2)) {
        return token2.number;
      }
      return 0;
    }
  };
};
var borderTopWidth = borderWidthForSide("top");
var borderRightWidth = borderWidthForSide("right");
var borderBottomWidth = borderWidthForSide("bottom");
var borderLeftWidth = borderWidthForSide("left");
var color = {
  name: "color",
  initialValue: "transparent",
  prefix: false,
  type: 3,
  format: "color"
};
var direction = {
  name: "direction",
  initialValue: "ltr",
  prefix: false,
  type: 2,
  parse: function(_context, direction2) {
    switch (direction2) {
      case "rtl":
        return 1;
      case "ltr":
      default:
        return 0;
    }
  }
};
var display = {
  name: "display",
  initialValue: "inline-block",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return tokens.filter(isIdentToken).reduce(
      function(bit, token2) {
        return bit | parseDisplayValue(token2.value);
      },
      0
      /* NONE */
    );
  }
};
var parseDisplayValue = function(display2) {
  switch (display2) {
    case "block":
    case "-webkit-box":
      return 2;
    case "inline":
      return 4;
    case "run-in":
      return 8;
    case "flow":
      return 16;
    case "flow-root":
      return 32;
    case "table":
      return 64;
    case "flex":
    case "-webkit-flex":
      return 128;
    case "grid":
    case "-ms-grid":
      return 256;
    case "ruby":
      return 512;
    case "subgrid":
      return 1024;
    case "list-item":
      return 2048;
    case "table-row-group":
      return 4096;
    case "table-header-group":
      return 8192;
    case "table-footer-group":
      return 16384;
    case "table-row":
      return 32768;
    case "table-cell":
      return 65536;
    case "table-column-group":
      return 131072;
    case "table-column":
      return 262144;
    case "table-caption":
      return 524288;
    case "ruby-base":
      return 1048576;
    case "ruby-text":
      return 2097152;
    case "ruby-base-container":
      return 4194304;
    case "ruby-text-container":
      return 8388608;
    case "contents":
      return 16777216;
    case "inline-block":
      return 33554432;
    case "inline-list-item":
      return 67108864;
    case "inline-table":
      return 134217728;
    case "inline-flex":
      return 268435456;
    case "inline-grid":
      return 536870912;
  }
  return 0;
};
var float = {
  name: "float",
  initialValue: "none",
  prefix: false,
  type: 2,
  parse: function(_context, float2) {
    switch (float2) {
      case "left":
        return 1;
      case "right":
        return 2;
      case "inline-start":
        return 3;
      case "inline-end":
        return 4;
    }
    return 0;
  }
};
var letterSpacing = {
  name: "letter-spacing",
  initialValue: "0",
  prefix: false,
  type: 0,
  parse: function(_context, token2) {
    if (token2.type === 20 && token2.value === "normal") {
      return 0;
    }
    if (token2.type === 17) {
      return token2.number;
    }
    if (token2.type === 15) {
      return token2.number;
    }
    return 0;
  }
};
var LINE_BREAK;
(function(LINE_BREAK2) {
  LINE_BREAK2["NORMAL"] = "normal";
  LINE_BREAK2["STRICT"] = "strict";
})(LINE_BREAK || (LINE_BREAK = {}));
var lineBreak = {
  name: "line-break",
  initialValue: "normal",
  prefix: false,
  type: 2,
  parse: function(_context, lineBreak2) {
    switch (lineBreak2) {
      case "strict":
        return LINE_BREAK.STRICT;
      case "normal":
      default:
        return LINE_BREAK.NORMAL;
    }
  }
};
var lineHeight = {
  name: "line-height",
  initialValue: "normal",
  prefix: false,
  type: 4
  /* TOKEN_VALUE */
};
var computeLineHeight = function(token2, fontSize2) {
  if (isIdentToken(token2) && token2.value === "normal") {
    return 1.2 * fontSize2;
  } else if (token2.type === 17) {
    return fontSize2 * token2.number;
  } else if (isLengthPercentage(token2)) {
    return getAbsoluteValue(token2, fontSize2);
  }
  return fontSize2;
};
var listStyleImage = {
  name: "list-style-image",
  initialValue: "none",
  type: 0,
  prefix: false,
  parse: function(context, token2) {
    if (token2.type === 20 && token2.value === "none") {
      return null;
    }
    return image.parse(context, token2);
  }
};
var listStylePosition = {
  name: "list-style-position",
  initialValue: "outside",
  prefix: false,
  type: 2,
  parse: function(_context, position2) {
    switch (position2) {
      case "inside":
        return 0;
      case "outside":
      default:
        return 1;
    }
  }
};
var listStyleType = {
  name: "list-style-type",
  initialValue: "none",
  prefix: false,
  type: 2,
  parse: function(_context, type) {
    switch (type) {
      case "disc":
        return 0;
      case "circle":
        return 1;
      case "square":
        return 2;
      case "decimal":
        return 3;
      case "cjk-decimal":
        return 4;
      case "decimal-leading-zero":
        return 5;
      case "lower-roman":
        return 6;
      case "upper-roman":
        return 7;
      case "lower-greek":
        return 8;
      case "lower-alpha":
        return 9;
      case "upper-alpha":
        return 10;
      case "arabic-indic":
        return 11;
      case "armenian":
        return 12;
      case "bengali":
        return 13;
      case "cambodian":
        return 14;
      case "cjk-earthly-branch":
        return 15;
      case "cjk-heavenly-stem":
        return 16;
      case "cjk-ideographic":
        return 17;
      case "devanagari":
        return 18;
      case "ethiopic-numeric":
        return 19;
      case "georgian":
        return 20;
      case "gujarati":
        return 21;
      case "gurmukhi":
        return 22;
      case "hebrew":
        return 22;
      case "hiragana":
        return 23;
      case "hiragana-iroha":
        return 24;
      case "japanese-formal":
        return 25;
      case "japanese-informal":
        return 26;
      case "kannada":
        return 27;
      case "katakana":
        return 28;
      case "katakana-iroha":
        return 29;
      case "khmer":
        return 30;
      case "korean-hangul-formal":
        return 31;
      case "korean-hanja-formal":
        return 32;
      case "korean-hanja-informal":
        return 33;
      case "lao":
        return 34;
      case "lower-armenian":
        return 35;
      case "malayalam":
        return 36;
      case "mongolian":
        return 37;
      case "myanmar":
        return 38;
      case "oriya":
        return 39;
      case "persian":
        return 40;
      case "simp-chinese-formal":
        return 41;
      case "simp-chinese-informal":
        return 42;
      case "tamil":
        return 43;
      case "telugu":
        return 44;
      case "thai":
        return 45;
      case "tibetan":
        return 46;
      case "trad-chinese-formal":
        return 47;
      case "trad-chinese-informal":
        return 48;
      case "upper-armenian":
        return 49;
      case "disclosure-open":
        return 50;
      case "disclosure-closed":
        return 51;
      case "none":
      default:
        return -1;
    }
  }
};
var marginForSide = function(side) {
  return {
    name: "margin-" + side,
    initialValue: "0",
    prefix: false,
    type: 4
    /* TOKEN_VALUE */
  };
};
var marginTop = marginForSide("top");
var marginRight = marginForSide("right");
var marginBottom = marginForSide("bottom");
var marginLeft = marginForSide("left");
var overflow = {
  name: "overflow",
  initialValue: "visible",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return tokens.filter(isIdentToken).map(function(overflow2) {
      switch (overflow2.value) {
        case "hidden":
          return 1;
        case "scroll":
          return 2;
        case "clip":
          return 3;
        case "auto":
          return 4;
        case "visible":
        default:
          return 0;
      }
    });
  }
};
var overflowWrap = {
  name: "overflow-wrap",
  initialValue: "normal",
  prefix: false,
  type: 2,
  parse: function(_context, overflow2) {
    switch (overflow2) {
      case "break-word":
        return "break-word";
      case "normal":
      default:
        return "normal";
    }
  }
};
var paddingForSide = function(side) {
  return {
    name: "padding-" + side,
    initialValue: "0",
    prefix: false,
    type: 3,
    format: "length-percentage"
  };
};
var paddingTop = paddingForSide("top");
var paddingRight = paddingForSide("right");
var paddingBottom = paddingForSide("bottom");
var paddingLeft = paddingForSide("left");
var textAlign = {
  name: "text-align",
  initialValue: "left",
  prefix: false,
  type: 2,
  parse: function(_context, textAlign2) {
    switch (textAlign2) {
      case "right":
        return 2;
      case "center":
      case "justify":
        return 1;
      case "left":
      default:
        return 0;
    }
  }
};
var position = {
  name: "position",
  initialValue: "static",
  prefix: false,
  type: 2,
  parse: function(_context, position2) {
    switch (position2) {
      case "relative":
        return 1;
      case "absolute":
        return 2;
      case "fixed":
        return 3;
      case "sticky":
        return 4;
    }
    return 0;
  }
};
var textShadow = {
  name: "text-shadow",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(context, tokens) {
    if (tokens.length === 1 && isIdentWithValue(tokens[0], "none")) {
      return [];
    }
    return parseFunctionArgs(tokens).map(function(values) {
      var shadow = {
        color: COLORS.TRANSPARENT,
        offsetX: ZERO_LENGTH,
        offsetY: ZERO_LENGTH,
        blur: ZERO_LENGTH
      };
      var c2 = 0;
      for (var i = 0; i < values.length; i++) {
        var token2 = values[i];
        if (isLength(token2)) {
          if (c2 === 0) {
            shadow.offsetX = token2;
          } else if (c2 === 1) {
            shadow.offsetY = token2;
          } else {
            shadow.blur = token2;
          }
          c2++;
        } else {
          shadow.color = color$1.parse(context, token2);
        }
      }
      return shadow;
    });
  }
};
var textTransform = {
  name: "text-transform",
  initialValue: "none",
  prefix: false,
  type: 2,
  parse: function(_context, textTransform2) {
    switch (textTransform2) {
      case "uppercase":
        return 2;
      case "lowercase":
        return 1;
      case "capitalize":
        return 3;
    }
    return 0;
  }
};
var transform$1 = {
  name: "transform",
  initialValue: "none",
  prefix: true,
  type: 0,
  parse: function(_context, token2) {
    if (token2.type === 20 && token2.value === "none") {
      return null;
    }
    if (token2.type === 18) {
      var transformFunction = SUPPORTED_TRANSFORM_FUNCTIONS[token2.name];
      if (typeof transformFunction === "undefined") {
        throw new Error('Attempting to parse an unsupported transform function "' + token2.name + '"');
      }
      return transformFunction(token2.values);
    }
    return null;
  }
};
var matrix = function(args) {
  var values = args.filter(function(arg) {
    return arg.type === 17;
  }).map(function(arg) {
    return arg.number;
  });
  return values.length === 6 ? values : null;
};
var matrix3d = function(args) {
  var values = args.filter(function(arg) {
    return arg.type === 17;
  }).map(function(arg) {
    return arg.number;
  });
  var a1 = values[0], b1 = values[1];
  values[2];
  values[3];
  var a2 = values[4], b2 = values[5];
  values[6];
  values[7];
  values[8];
  values[9];
  values[10];
  values[11];
  var a4 = values[12], b4 = values[13];
  values[14];
  values[15];
  return values.length === 16 ? [a1, b1, a2, b2, a4, b4] : null;
};
var SUPPORTED_TRANSFORM_FUNCTIONS = {
  matrix,
  matrix3d
};
var DEFAULT_VALUE = {
  type: 16,
  number: 50,
  flags: FLAG_INTEGER
};
var DEFAULT = [DEFAULT_VALUE, DEFAULT_VALUE];
var transformOrigin = {
  name: "transform-origin",
  initialValue: "50% 50%",
  prefix: true,
  type: 1,
  parse: function(_context, tokens) {
    var origins = tokens.filter(isLengthPercentage);
    if (origins.length !== 2) {
      return DEFAULT;
    }
    return [origins[0], origins[1]];
  }
};
var visibility = {
  name: "visible",
  initialValue: "none",
  prefix: false,
  type: 2,
  parse: function(_context, visibility2) {
    switch (visibility2) {
      case "hidden":
        return 1;
      case "collapse":
        return 2;
      case "visible":
      default:
        return 0;
    }
  }
};
var WORD_BREAK;
(function(WORD_BREAK2) {
  WORD_BREAK2["NORMAL"] = "normal";
  WORD_BREAK2["BREAK_ALL"] = "break-all";
  WORD_BREAK2["KEEP_ALL"] = "keep-all";
})(WORD_BREAK || (WORD_BREAK = {}));
var wordBreak = {
  name: "word-break",
  initialValue: "normal",
  prefix: false,
  type: 2,
  parse: function(_context, wordBreak2) {
    switch (wordBreak2) {
      case "break-all":
        return WORD_BREAK.BREAK_ALL;
      case "keep-all":
        return WORD_BREAK.KEEP_ALL;
      case "normal":
      default:
        return WORD_BREAK.NORMAL;
    }
  }
};
var zIndex = {
  name: "z-index",
  initialValue: "auto",
  prefix: false,
  type: 0,
  parse: function(_context, token2) {
    if (token2.type === 20) {
      return { auto: true, order: 0 };
    }
    if (isNumberToken(token2)) {
      return { auto: false, order: token2.number };
    }
    throw new Error("Invalid z-index number parsed");
  }
};
var time = {
  name: "time",
  parse: function(_context, value2) {
    if (value2.type === 15) {
      switch (value2.unit.toLowerCase()) {
        case "s":
          return 1e3 * value2.number;
        case "ms":
          return value2.number;
      }
    }
    throw new Error("Unsupported time type");
  }
};
var opacity = {
  name: "opacity",
  initialValue: "1",
  type: 0,
  prefix: false,
  parse: function(_context, token2) {
    if (isNumberToken(token2)) {
      return token2.number;
    }
    return 1;
  }
};
var textDecorationColor = {
  name: "text-decoration-color",
  initialValue: "transparent",
  prefix: false,
  type: 3,
  format: "color"
};
var textDecorationLine = {
  name: "text-decoration-line",
  initialValue: "none",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return tokens.filter(isIdentToken).map(function(token2) {
      switch (token2.value) {
        case "underline":
          return 1;
        case "overline":
          return 2;
        case "line-through":
          return 3;
        case "none":
          return 4;
      }
      return 0;
    }).filter(function(line) {
      return line !== 0;
    });
  }
};
var fontFamily = {
  name: "font-family",
  initialValue: "",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    var accumulator = [];
    var results = [];
    tokens.forEach(function(token2) {
      switch (token2.type) {
        case 20:
        case 0:
          accumulator.push(token2.value);
          break;
        case 17:
          accumulator.push(token2.number.toString());
          break;
        case 4:
          results.push(accumulator.join(" "));
          accumulator.length = 0;
          break;
      }
    });
    if (accumulator.length) {
      results.push(accumulator.join(" "));
    }
    return results.map(function(result) {
      return result.indexOf(" ") === -1 ? result : "'" + result + "'";
    });
  }
};
var fontSize = {
  name: "font-size",
  initialValue: "0",
  prefix: false,
  type: 3,
  format: "length"
};
var fontWeight = {
  name: "font-weight",
  initialValue: "normal",
  type: 0,
  prefix: false,
  parse: function(_context, token2) {
    if (isNumberToken(token2)) {
      return token2.number;
    }
    if (isIdentToken(token2)) {
      switch (token2.value) {
        case "bold":
          return 700;
        case "normal":
        default:
          return 400;
      }
    }
    return 400;
  }
};
var fontVariant = {
  name: "font-variant",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(_context, tokens) {
    return tokens.filter(isIdentToken).map(function(token2) {
      return token2.value;
    });
  }
};
var fontStyle = {
  name: "font-style",
  initialValue: "normal",
  prefix: false,
  type: 2,
  parse: function(_context, overflow2) {
    switch (overflow2) {
      case "oblique":
        return "oblique";
      case "italic":
        return "italic";
      case "normal":
      default:
        return "normal";
    }
  }
};
var contains = function(bit, value2) {
  return (bit & value2) !== 0;
};
var content = {
  name: "content",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(_context, tokens) {
    if (tokens.length === 0) {
      return [];
    }
    var first = tokens[0];
    if (first.type === 20 && first.value === "none") {
      return [];
    }
    return tokens;
  }
};
var counterIncrement = {
  name: "counter-increment",
  initialValue: "none",
  prefix: true,
  type: 1,
  parse: function(_context, tokens) {
    if (tokens.length === 0) {
      return null;
    }
    var first = tokens[0];
    if (first.type === 20 && first.value === "none") {
      return null;
    }
    var increments = [];
    var filtered = tokens.filter(nonWhiteSpace);
    for (var i = 0; i < filtered.length; i++) {
      var counter2 = filtered[i];
      var next = filtered[i + 1];
      if (counter2.type === 20) {
        var increment = next && isNumberToken(next) ? next.number : 1;
        increments.push({ counter: counter2.value, increment });
      }
    }
    return increments;
  }
};
var counterReset = {
  name: "counter-reset",
  initialValue: "none",
  prefix: true,
  type: 1,
  parse: function(_context, tokens) {
    if (tokens.length === 0) {
      return [];
    }
    var resets = [];
    var filtered = tokens.filter(nonWhiteSpace);
    for (var i = 0; i < filtered.length; i++) {
      var counter2 = filtered[i];
      var next = filtered[i + 1];
      if (isIdentToken(counter2) && counter2.value !== "none") {
        var reset = next && isNumberToken(next) ? next.number : 0;
        resets.push({ counter: counter2.value, reset });
      }
    }
    return resets;
  }
};
var duration = {
  name: "duration",
  initialValue: "0s",
  prefix: false,
  type: 1,
  parse: function(context, tokens) {
    return tokens.filter(isDimensionToken).map(function(token2) {
      return time.parse(context, token2);
    });
  }
};
var quotes = {
  name: "quotes",
  initialValue: "none",
  prefix: true,
  type: 1,
  parse: function(_context, tokens) {
    if (tokens.length === 0) {
      return null;
    }
    var first = tokens[0];
    if (first.type === 20 && first.value === "none") {
      return null;
    }
    var quotes2 = [];
    var filtered = tokens.filter(isStringToken);
    if (filtered.length % 2 !== 0) {
      return null;
    }
    for (var i = 0; i < filtered.length; i += 2) {
      var open_1 = filtered[i].value;
      var close_1 = filtered[i + 1].value;
      quotes2.push({ open: open_1, close: close_1 });
    }
    return quotes2;
  }
};
var getQuote = function(quotes2, depth, open2) {
  if (!quotes2) {
    return "";
  }
  var quote = quotes2[Math.min(depth, quotes2.length - 1)];
  if (!quote) {
    return "";
  }
  return open2 ? quote.open : quote.close;
};
var boxShadow = {
  name: "box-shadow",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(context, tokens) {
    if (tokens.length === 1 && isIdentWithValue(tokens[0], "none")) {
      return [];
    }
    return parseFunctionArgs(tokens).map(function(values) {
      var shadow = {
        color: 255,
        offsetX: ZERO_LENGTH,
        offsetY: ZERO_LENGTH,
        blur: ZERO_LENGTH,
        spread: ZERO_LENGTH,
        inset: false
      };
      var c2 = 0;
      for (var i = 0; i < values.length; i++) {
        var token2 = values[i];
        if (isIdentWithValue(token2, "inset")) {
          shadow.inset = true;
        } else if (isLength(token2)) {
          if (c2 === 0) {
            shadow.offsetX = token2;
          } else if (c2 === 1) {
            shadow.offsetY = token2;
          } else if (c2 === 2) {
            shadow.blur = token2;
          } else {
            shadow.spread = token2;
          }
          c2++;
        } else {
          shadow.color = color$1.parse(context, token2);
        }
      }
      return shadow;
    });
  }
};
var paintOrder = {
  name: "paint-order",
  initialValue: "normal",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    var DEFAULT_VALUE2 = [
      0,
      1,
      2
      /* MARKERS */
    ];
    var layers = [];
    tokens.filter(isIdentToken).forEach(function(token2) {
      switch (token2.value) {
        case "stroke":
          layers.push(
            1
            /* STROKE */
          );
          break;
        case "fill":
          layers.push(
            0
            /* FILL */
          );
          break;
        case "markers":
          layers.push(
            2
            /* MARKERS */
          );
          break;
      }
    });
    DEFAULT_VALUE2.forEach(function(value2) {
      if (layers.indexOf(value2) === -1) {
        layers.push(value2);
      }
    });
    return layers;
  }
};
var webkitTextStrokeColor = {
  name: "-webkit-text-stroke-color",
  initialValue: "currentcolor",
  prefix: false,
  type: 3,
  format: "color"
};
var webkitTextStrokeWidth = {
  name: "-webkit-text-stroke-width",
  initialValue: "0",
  type: 0,
  prefix: false,
  parse: function(_context, token2) {
    if (isDimensionToken(token2)) {
      return token2.number;
    }
    return 0;
  }
};
var CSSParsedDeclaration = (
  /** @class */
  function() {
    function CSSParsedDeclaration2(context, declaration) {
      var _a2, _b2;
      this.animationDuration = parse(context, duration, declaration.animationDuration);
      this.backgroundClip = parse(context, backgroundClip, declaration.backgroundClip);
      this.backgroundColor = parse(context, backgroundColor, declaration.backgroundColor);
      this.backgroundImage = parse(context, backgroundImage, declaration.backgroundImage);
      this.backgroundOrigin = parse(context, backgroundOrigin, declaration.backgroundOrigin);
      this.backgroundPosition = parse(context, backgroundPosition, declaration.backgroundPosition);
      this.backgroundRepeat = parse(context, backgroundRepeat, declaration.backgroundRepeat);
      this.backgroundSize = parse(context, backgroundSize, declaration.backgroundSize);
      this.borderTopColor = parse(context, borderTopColor, declaration.borderTopColor);
      this.borderRightColor = parse(context, borderRightColor, declaration.borderRightColor);
      this.borderBottomColor = parse(context, borderBottomColor, declaration.borderBottomColor);
      this.borderLeftColor = parse(context, borderLeftColor, declaration.borderLeftColor);
      this.borderTopLeftRadius = parse(context, borderTopLeftRadius, declaration.borderTopLeftRadius);
      this.borderTopRightRadius = parse(context, borderTopRightRadius, declaration.borderTopRightRadius);
      this.borderBottomRightRadius = parse(context, borderBottomRightRadius, declaration.borderBottomRightRadius);
      this.borderBottomLeftRadius = parse(context, borderBottomLeftRadius, declaration.borderBottomLeftRadius);
      this.borderTopStyle = parse(context, borderTopStyle, declaration.borderTopStyle);
      this.borderRightStyle = parse(context, borderRightStyle, declaration.borderRightStyle);
      this.borderBottomStyle = parse(context, borderBottomStyle, declaration.borderBottomStyle);
      this.borderLeftStyle = parse(context, borderLeftStyle, declaration.borderLeftStyle);
      this.borderTopWidth = parse(context, borderTopWidth, declaration.borderTopWidth);
      this.borderRightWidth = parse(context, borderRightWidth, declaration.borderRightWidth);
      this.borderBottomWidth = parse(context, borderBottomWidth, declaration.borderBottomWidth);
      this.borderLeftWidth = parse(context, borderLeftWidth, declaration.borderLeftWidth);
      this.boxShadow = parse(context, boxShadow, declaration.boxShadow);
      this.color = parse(context, color, declaration.color);
      this.direction = parse(context, direction, declaration.direction);
      this.display = parse(context, display, declaration.display);
      this.float = parse(context, float, declaration.cssFloat);
      this.fontFamily = parse(context, fontFamily, declaration.fontFamily);
      this.fontSize = parse(context, fontSize, declaration.fontSize);
      this.fontStyle = parse(context, fontStyle, declaration.fontStyle);
      this.fontVariant = parse(context, fontVariant, declaration.fontVariant);
      this.fontWeight = parse(context, fontWeight, declaration.fontWeight);
      this.letterSpacing = parse(context, letterSpacing, declaration.letterSpacing);
      this.lineBreak = parse(context, lineBreak, declaration.lineBreak);
      this.lineHeight = parse(context, lineHeight, declaration.lineHeight);
      this.listStyleImage = parse(context, listStyleImage, declaration.listStyleImage);
      this.listStylePosition = parse(context, listStylePosition, declaration.listStylePosition);
      this.listStyleType = parse(context, listStyleType, declaration.listStyleType);
      this.marginTop = parse(context, marginTop, declaration.marginTop);
      this.marginRight = parse(context, marginRight, declaration.marginRight);
      this.marginBottom = parse(context, marginBottom, declaration.marginBottom);
      this.marginLeft = parse(context, marginLeft, declaration.marginLeft);
      this.opacity = parse(context, opacity, declaration.opacity);
      var overflowTuple = parse(context, overflow, declaration.overflow);
      this.overflowX = overflowTuple[0];
      this.overflowY = overflowTuple[overflowTuple.length > 1 ? 1 : 0];
      this.overflowWrap = parse(context, overflowWrap, declaration.overflowWrap);
      this.paddingTop = parse(context, paddingTop, declaration.paddingTop);
      this.paddingRight = parse(context, paddingRight, declaration.paddingRight);
      this.paddingBottom = parse(context, paddingBottom, declaration.paddingBottom);
      this.paddingLeft = parse(context, paddingLeft, declaration.paddingLeft);
      this.paintOrder = parse(context, paintOrder, declaration.paintOrder);
      this.position = parse(context, position, declaration.position);
      this.textAlign = parse(context, textAlign, declaration.textAlign);
      this.textDecorationColor = parse(context, textDecorationColor, (_a2 = declaration.textDecorationColor) !== null && _a2 !== void 0 ? _a2 : declaration.color);
      this.textDecorationLine = parse(context, textDecorationLine, (_b2 = declaration.textDecorationLine) !== null && _b2 !== void 0 ? _b2 : declaration.textDecoration);
      this.textShadow = parse(context, textShadow, declaration.textShadow);
      this.textTransform = parse(context, textTransform, declaration.textTransform);
      this.transform = parse(context, transform$1, declaration.transform);
      this.transformOrigin = parse(context, transformOrigin, declaration.transformOrigin);
      this.visibility = parse(context, visibility, declaration.visibility);
      this.webkitTextStrokeColor = parse(context, webkitTextStrokeColor, declaration.webkitTextStrokeColor);
      this.webkitTextStrokeWidth = parse(context, webkitTextStrokeWidth, declaration.webkitTextStrokeWidth);
      this.wordBreak = parse(context, wordBreak, declaration.wordBreak);
      this.zIndex = parse(context, zIndex, declaration.zIndex);
    }
    CSSParsedDeclaration2.prototype.isVisible = function() {
      return this.display > 0 && this.opacity > 0 && this.visibility === 0;
    };
    CSSParsedDeclaration2.prototype.isTransparent = function() {
      return isTransparent(this.backgroundColor);
    };
    CSSParsedDeclaration2.prototype.isTransformed = function() {
      return this.transform !== null;
    };
    CSSParsedDeclaration2.prototype.isPositioned = function() {
      return this.position !== 0;
    };
    CSSParsedDeclaration2.prototype.isPositionedWithZIndex = function() {
      return this.isPositioned() && !this.zIndex.auto;
    };
    CSSParsedDeclaration2.prototype.isFloating = function() {
      return this.float !== 0;
    };
    CSSParsedDeclaration2.prototype.isInlineLevel = function() {
      return contains(
        this.display,
        4
        /* INLINE */
      ) || contains(
        this.display,
        33554432
        /* INLINE_BLOCK */
      ) || contains(
        this.display,
        268435456
        /* INLINE_FLEX */
      ) || contains(
        this.display,
        536870912
        /* INLINE_GRID */
      ) || contains(
        this.display,
        67108864
        /* INLINE_LIST_ITEM */
      ) || contains(
        this.display,
        134217728
        /* INLINE_TABLE */
      );
    };
    return CSSParsedDeclaration2;
  }()
);
var CSSParsedPseudoDeclaration = (
  /** @class */
  /* @__PURE__ */ function() {
    function CSSParsedPseudoDeclaration2(context, declaration) {
      this.content = parse(context, content, declaration.content);
      this.quotes = parse(context, quotes, declaration.quotes);
    }
    return CSSParsedPseudoDeclaration2;
  }()
);
var CSSParsedCounterDeclaration = (
  /** @class */
  /* @__PURE__ */ function() {
    function CSSParsedCounterDeclaration2(context, declaration) {
      this.counterIncrement = parse(context, counterIncrement, declaration.counterIncrement);
      this.counterReset = parse(context, counterReset, declaration.counterReset);
    }
    return CSSParsedCounterDeclaration2;
  }()
);
var parse = function(context, descriptor, style) {
  var tokenizer = new Tokenizer();
  var value2 = style !== null && typeof style !== "undefined" ? style.toString() : descriptor.initialValue;
  tokenizer.write(value2);
  var parser2 = new Parser(tokenizer.read());
  switch (descriptor.type) {
    case 2:
      var token2 = parser2.parseComponentValue();
      return descriptor.parse(context, isIdentToken(token2) ? token2.value : descriptor.initialValue);
    case 0:
      return descriptor.parse(context, parser2.parseComponentValue());
    case 1:
      return descriptor.parse(context, parser2.parseComponentValues());
    case 4:
      return parser2.parseComponentValue();
    case 3:
      switch (descriptor.format) {
        case "angle":
          return angle.parse(context, parser2.parseComponentValue());
        case "color":
          return color$1.parse(context, parser2.parseComponentValue());
        case "image":
          return image.parse(context, parser2.parseComponentValue());
        case "length":
          var length_1 = parser2.parseComponentValue();
          return isLength(length_1) ? length_1 : ZERO_LENGTH;
        case "length-percentage":
          var value_1 = parser2.parseComponentValue();
          return isLengthPercentage(value_1) ? value_1 : ZERO_LENGTH;
        case "time":
          return time.parse(context, parser2.parseComponentValue());
      }
      break;
  }
};
var elementDebuggerAttribute = "data-html2canvas-debug";
var getElementDebugType = function(element) {
  var attribute = element.getAttribute(elementDebuggerAttribute);
  switch (attribute) {
    case "all":
      return 1;
    case "clone":
      return 2;
    case "parse":
      return 3;
    case "render":
      return 4;
    default:
      return 0;
  }
};
var isDebugging = function(element, type) {
  var elementType = getElementDebugType(element);
  return elementType === 1 || type === elementType;
};
var ElementContainer = (
  /** @class */
  /* @__PURE__ */ function() {
    function ElementContainer2(context, element) {
      this.context = context;
      this.textNodes = [];
      this.elements = [];
      this.flags = 0;
      if (isDebugging(
        element,
        3
        /* PARSE */
      )) {
        debugger;
      }
      this.styles = new CSSParsedDeclaration(context, window.getComputedStyle(element, null));
      if (isHTMLElementNode(element)) {
        if (this.styles.animationDuration.some(function(duration2) {
          return duration2 > 0;
        })) {
          element.style.animationDuration = "0s";
        }
        if (this.styles.transform !== null) {
          element.style.transform = "none";
        }
      }
      this.bounds = parseBounds(this.context, element);
      if (isDebugging(
        element,
        4
        /* RENDER */
      )) {
        this.flags |= 16;
      }
    }
    return ElementContainer2;
  }()
);
var base64 = "AAAAAAAAAAAAEA4AGBkAAFAaAAACAAAAAAAIABAAGAAwADgACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAAQABIAEQATAAIABAACAAQAAgAEAAIABAAVABcAAgAEAAIABAACAAQAGAAaABwAHgAgACIAI4AlgAIABAAmwCjAKgAsAC2AL4AvQDFAMoA0gBPAVYBWgEIAAgACACMANoAYgFkAWwBdAF8AX0BhQGNAZUBlgGeAaMBlQGWAasBswF8AbsBwwF0AcsBYwHTAQgA2wG/AOMBdAF8AekB8QF0AfkB+wHiAHQBfAEIAAMC5gQIAAsCEgIIAAgAFgIeAggAIgIpAggAMQI5AkACygEIAAgASAJQAlgCYAIIAAgACAAKBQoFCgUTBRMFGQUrBSsFCAAIAAgACAAIAAgACAAIAAgACABdAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABoAmgCrwGvAQgAbgJ2AggAHgEIAAgACADnAXsCCAAIAAgAgwIIAAgACAAIAAgACACKAggAkQKZAggAPADJAAgAoQKkAqwCsgK6AsICCADJAggA0AIIAAgACAAIANYC3gIIAAgACAAIAAgACABAAOYCCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAkASoB+QIEAAgACAA8AEMCCABCBQgACABJBVAFCAAIAAgACAAIAAgACAAIAAgACABTBVoFCAAIAFoFCABfBWUFCAAIAAgACAAIAAgAbQUIAAgACAAIAAgACABzBXsFfQWFBYoFigWKBZEFigWKBYoFmAWfBaYFrgWxBbkFCAAIAAgACAAIAAgACAAIAAgACAAIAMEFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAMgFCADQBQgACAAIAAgACAAIAAgACAAIAAgACAAIAO4CCAAIAAgAiQAIAAgACABAAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAD0AggACAD8AggACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIANYFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAMDvwAIAAgAJAIIAAgACAAIAAgACAAIAAgACwMTAwgACAB9BOsEGwMjAwgAKwMyAwsFYgE3A/MEPwMIAEUDTQNRAwgAWQOsAGEDCAAIAAgACAAIAAgACABpAzQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFIQUoBSwFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABtAwgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABMAEwACAAIAAgACAAIABgACAAIAAgACAC/AAgACAAyAQgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACAAIAAwAAgACAAIAAgACAAIAAgACAAIAAAARABIAAgACAAIABQASAAIAAgAIABwAEAAjgCIABsAqAC2AL0AigDQAtwC+IJIQqVAZUBWQqVAZUBlQGVAZUBlQGrC5UBlQGVAZUBlQGVAZUBlQGVAXsKlQGVAbAK6wsrDGUMpQzlDJUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAfAKAAuZA64AtwCJALoC6ADwAAgAuACgA/oEpgO6AqsD+AAIAAgAswMIAAgACAAIAIkAuwP5AfsBwwPLAwgACAAIAAgACADRA9kDCAAIAOED6QMIAAgACAAIAAgACADuA/YDCAAIAP4DyQAIAAgABgQIAAgAXQAOBAgACAAIAAgACAAIABMECAAIAAgACAAIAAgACAD8AAQBCAAIAAgAGgQiBCoECAExBAgAEAEIAAgACAAIAAgACAAIAAgACAAIAAgACAA4BAgACABABEYECAAIAAgATAQYAQgAVAQIAAgACAAIAAgACAAIAAgACAAIAFoECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAOQEIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAB+BAcACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEABhgSMBAgACAAIAAgAlAQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAwAEAAQABAADAAMAAwADAAQABAAEAAQABAAEAAQABHATAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAdQMIAAgACAAIAAgACAAIAMkACAAIAAgAfQMIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACFA4kDCAAIAAgACAAIAOcBCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAIcDCAAIAAgACAAIAAgACAAIAAgACAAIAJEDCAAIAAgACADFAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABgBAgAZgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAbAQCBXIECAAIAHkECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABAAJwEQACjBKoEsgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAC6BMIECAAIAAgACAAIAAgACABmBAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAxwQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAGYECAAIAAgAzgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBd0FXwUIAOIF6gXxBYoF3gT5BQAGCAaKBYoFigWKBYoFigWKBYoFigWKBYoFigXWBIoFigWKBYoFigWKBYoFigWKBYsFEAaKBYoFigWKBYoFigWKBRQGCACKBYoFigWKBQgACAAIANEECAAIABgGigUgBggAJgYIAC4GMwaKBYoF0wQ3Bj4GigWKBYoFigWKBYoFigWKBYoFigWKBYoFigUIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWLBf///////wQABAAEAAQABAAEAAQABAAEAAQAAwAEAAQAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAQADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUAAAAFAAUAAAAFAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAQAAAAUABQAFAAUABQAFAAAAAAAFAAUAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAFAAUAAQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAAABwAHAAcAAAAHAAcABwAFAAEAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAcABwAFAAUAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQABAAAAAAAAAAAAAAAFAAUABQAFAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAHAAcAAAAHAAcAAAAAAAUABQAHAAUAAQAHAAEABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwABAAUABQAFAAUAAAAAAAAAAAAAAAEAAQABAAEAAQABAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABQANAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAABQAHAAUABQAFAAAAAAAAAAcABQAFAAUABQAFAAQABAAEAAQABAAEAAQABAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUAAAAFAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAUAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAcABwAFAAcABwAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUABwAHAAUABQAFAAUAAAAAAAcABwAAAAAABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAAAAAAAAAAABQAFAAAAAAAFAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAFAAUABQAFAAUAAAAFAAUABwAAAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABwAFAAUABQAFAAAAAAAHAAcAAAAAAAcABwAFAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAAAAAAAAAHAAcABwAAAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAUABQAFAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAHAAcABQAHAAcAAAAFAAcABwAAAAcABwAFAAUAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAFAAcABwAFAAUABQAAAAUAAAAHAAcABwAHAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAHAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUAAAAFAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAUAAAAFAAUAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABwAFAAUABQAFAAUABQAAAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABQAFAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAFAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAHAAUABQAFAAUABQAFAAUABwAHAAcABwAHAAcABwAHAAUABwAHAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABwAHAAcABwAFAAUABwAHAAcAAAAAAAAAAAAHAAcABQAHAAcABwAHAAcABwAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAUABQAFAAUABQAFAAUAAAAFAAAABQAAAAAABQAFAAUABQAFAAUABQAFAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAUABQAFAAUABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABwAFAAcABwAHAAcABwAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAUABQAFAAUABwAHAAUABQAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABQAFAAcABwAHAAUABwAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAcABQAFAAUABQAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAAAAAABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAUABQAHAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAFAAUABQAFAAcABwAFAAUABwAHAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAcABwAFAAUABwAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABQAAAAAABQAFAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAcABwAAAAAAAAAAAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAcABwAFAAcABwAAAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAFAAUABQAAAAUABQAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABwAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAHAAcABQAHAAUABQAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAAABwAHAAAAAAAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAFAAUABwAFAAcABwAFAAcABQAFAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAAAAAABwAHAAcABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAFAAcABwAFAAUABQAFAAUABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAUABQAFAAcABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABQAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAAAAAAFAAUABwAHAAcABwAFAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAHAAUABQAFAAUABQAFAAUABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAABQAAAAUABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAHAAcAAAAFAAUAAAAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABQAFAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAABQAFAAUABQAFAAUABQAAAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAFAAUABQAFAAUADgAOAA4ADgAOAA4ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAMAAwADAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAAAAAAAAAAAAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAAAAAAAAAAAAsADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwACwAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAADgAOAA4AAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAAAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4AAAAOAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAAAAAAAAAAAA4AAAAOAAAAAAAAAAAADgAOAA4AAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAA=";
var chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$1 = 0; i$1 < chars$1.length; i$1++) {
  lookup$1[chars$1.charCodeAt(i$1)] = i$1;
}
var decode = function(base642) {
  var bufferLength = base642.length * 0.75, len = base642.length, i, p2 = 0, encoded1, encoded2, encoded3, encoded4;
  if (base642[base642.length - 1] === "=") {
    bufferLength--;
    if (base642[base642.length - 2] === "=") {
      bufferLength--;
    }
  }
  var buffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
  var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
  for (i = 0; i < len; i += 4) {
    encoded1 = lookup$1[base642.charCodeAt(i)];
    encoded2 = lookup$1[base642.charCodeAt(i + 1)];
    encoded3 = lookup$1[base642.charCodeAt(i + 2)];
    encoded4 = lookup$1[base642.charCodeAt(i + 3)];
    bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return buffer;
};
var polyUint16Array = function(buffer) {
  var length = buffer.length;
  var bytes = [];
  for (var i = 0; i < length; i += 2) {
    bytes.push(buffer[i + 1] << 8 | buffer[i]);
  }
  return bytes;
};
var polyUint32Array = function(buffer) {
  var length = buffer.length;
  var bytes = [];
  for (var i = 0; i < length; i += 4) {
    bytes.push(buffer[i + 3] << 24 | buffer[i + 2] << 16 | buffer[i + 1] << 8 | buffer[i]);
  }
  return bytes;
};
var UTRIE2_SHIFT_2 = 5;
var UTRIE2_SHIFT_1 = 6 + 5;
var UTRIE2_INDEX_SHIFT = 2;
var UTRIE2_SHIFT_1_2 = UTRIE2_SHIFT_1 - UTRIE2_SHIFT_2;
var UTRIE2_LSCP_INDEX_2_OFFSET = 65536 >> UTRIE2_SHIFT_2;
var UTRIE2_DATA_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_2;
var UTRIE2_DATA_MASK = UTRIE2_DATA_BLOCK_LENGTH - 1;
var UTRIE2_LSCP_INDEX_2_LENGTH = 1024 >> UTRIE2_SHIFT_2;
var UTRIE2_INDEX_2_BMP_LENGTH = UTRIE2_LSCP_INDEX_2_OFFSET + UTRIE2_LSCP_INDEX_2_LENGTH;
var UTRIE2_UTF8_2B_INDEX_2_OFFSET = UTRIE2_INDEX_2_BMP_LENGTH;
var UTRIE2_UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;
var UTRIE2_INDEX_1_OFFSET = UTRIE2_UTF8_2B_INDEX_2_OFFSET + UTRIE2_UTF8_2B_INDEX_2_LENGTH;
var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = 65536 >> UTRIE2_SHIFT_1;
var UTRIE2_INDEX_2_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_1_2;
var UTRIE2_INDEX_2_MASK = UTRIE2_INDEX_2_BLOCK_LENGTH - 1;
var slice16 = function(view, start, end) {
  if (view.slice) {
    return view.slice(start, end);
  }
  return new Uint16Array(Array.prototype.slice.call(view, start, end));
};
var slice32 = function(view, start, end) {
  if (view.slice) {
    return view.slice(start, end);
  }
  return new Uint32Array(Array.prototype.slice.call(view, start, end));
};
var createTrieFromBase64 = function(base642, _byteLength) {
  var buffer = decode(base642);
  var view32 = Array.isArray(buffer) ? polyUint32Array(buffer) : new Uint32Array(buffer);
  var view16 = Array.isArray(buffer) ? polyUint16Array(buffer) : new Uint16Array(buffer);
  var headerLength = 24;
  var index = slice16(view16, headerLength / 2, view32[4] / 2);
  var data = view32[5] === 2 ? slice16(view16, (headerLength + view32[4]) / 2) : slice32(view32, Math.ceil((headerLength + view32[4]) / 4));
  return new Trie(view32[0], view32[1], view32[2], view32[3], index, data);
};
var Trie = (
  /** @class */
  function() {
    function Trie2(initialValue, errorValue, highStart, highValueIndex, index, data) {
      this.initialValue = initialValue;
      this.errorValue = errorValue;
      this.highStart = highStart;
      this.highValueIndex = highValueIndex;
      this.index = index;
      this.data = data;
    }
    Trie2.prototype.get = function(codePoint) {
      var ix;
      if (codePoint >= 0) {
        if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
          ix = this.index[codePoint >> UTRIE2_SHIFT_2];
          ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
          return this.data[ix];
        }
        if (codePoint <= 65535) {
          ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> UTRIE2_SHIFT_2)];
          ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
          return this.data[ix];
        }
        if (codePoint < this.highStart) {
          ix = UTRIE2_INDEX_1_OFFSET - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> UTRIE2_SHIFT_1);
          ix = this.index[ix];
          ix += codePoint >> UTRIE2_SHIFT_2 & UTRIE2_INDEX_2_MASK;
          ix = this.index[ix];
          ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
          return this.data[ix];
        }
        if (codePoint <= 1114111) {
          return this.data[this.highValueIndex];
        }
      }
      return this.errorValue;
    };
    return Trie2;
  }()
);
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i = 0; i < chars.length; i++) {
  lookup[chars.charCodeAt(i)] = i;
}
var Prepend = 1;
var CR = 2;
var LF = 3;
var Control = 4;
var Extend = 5;
var SpacingMark = 7;
var L = 8;
var V = 9;
var T = 10;
var LV = 11;
var LVT = 12;
var ZWJ = 13;
var Extended_Pictographic = 14;
var RI = 15;
var toCodePoints = function(str) {
  var codePoints = [];
  var i = 0;
  var length = str.length;
  while (i < length) {
    var value2 = str.charCodeAt(i++);
    if (value2 >= 55296 && value2 <= 56319 && i < length) {
      var extra = str.charCodeAt(i++);
      if ((extra & 64512) === 56320) {
        codePoints.push(((value2 & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        codePoints.push(value2);
        i--;
      }
    } else {
      codePoints.push(value2);
    }
  }
  return codePoints;
};
var fromCodePoint = function() {
  var codePoints = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    codePoints[_i] = arguments[_i];
  }
  if (String.fromCodePoint) {
    return String.fromCodePoint.apply(String, codePoints);
  }
  var length = codePoints.length;
  if (!length) {
    return "";
  }
  var codeUnits = [];
  var index = -1;
  var result = "";
  while (++index < length) {
    var codePoint = codePoints[index];
    if (codePoint <= 65535) {
      codeUnits.push(codePoint);
    } else {
      codePoint -= 65536;
      codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
    }
    if (index + 1 === length || codeUnits.length > 16384) {
      result += String.fromCharCode.apply(String, codeUnits);
      codeUnits.length = 0;
    }
  }
  return result;
};
var UnicodeTrie = createTrieFromBase64(base64);
var BREAK_NOT_ALLOWED = "×";
var BREAK_ALLOWED = "÷";
var codePointToClass = function(codePoint) {
  return UnicodeTrie.get(codePoint);
};
var _graphemeBreakAtIndex = function(_codePoints, classTypes, index) {
  var prevIndex = index - 2;
  var prev = classTypes[prevIndex];
  var current = classTypes[index - 1];
  var next = classTypes[index];
  if (current === CR && next === LF) {
    return BREAK_NOT_ALLOWED;
  }
  if (current === CR || current === LF || current === Control) {
    return BREAK_ALLOWED;
  }
  if (next === CR || next === LF || next === Control) {
    return BREAK_ALLOWED;
  }
  if (current === L && [L, V, LV, LVT].indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED;
  }
  if ((current === LV || current === V) && (next === V || next === T)) {
    return BREAK_NOT_ALLOWED;
  }
  if ((current === LVT || current === T) && next === T) {
    return BREAK_NOT_ALLOWED;
  }
  if (next === ZWJ || next === Extend) {
    return BREAK_NOT_ALLOWED;
  }
  if (next === SpacingMark) {
    return BREAK_NOT_ALLOWED;
  }
  if (current === Prepend) {
    return BREAK_NOT_ALLOWED;
  }
  if (current === ZWJ && next === Extended_Pictographic) {
    while (prev === Extend) {
      prev = classTypes[--prevIndex];
    }
    if (prev === Extended_Pictographic) {
      return BREAK_NOT_ALLOWED;
    }
  }
  if (current === RI && next === RI) {
    var countRI = 0;
    while (prev === RI) {
      countRI++;
      prev = classTypes[--prevIndex];
    }
    if (countRI % 2 === 0) {
      return BREAK_NOT_ALLOWED;
    }
  }
  return BREAK_ALLOWED;
};
var GraphemeBreaker = function(str) {
  var codePoints = toCodePoints(str);
  var length = codePoints.length;
  var index = 0;
  var lastEnd = 0;
  var classTypes = codePoints.map(codePointToClass);
  return {
    next: function() {
      if (index >= length) {
        return { done: true, value: null };
      }
      var graphemeBreak = BREAK_NOT_ALLOWED;
      while (index < length && (graphemeBreak = _graphemeBreakAtIndex(codePoints, classTypes, ++index)) === BREAK_NOT_ALLOWED) {
      }
      if (graphemeBreak !== BREAK_NOT_ALLOWED || index === length) {
        var value2 = fromCodePoint.apply(null, codePoints.slice(lastEnd, index));
        lastEnd = index;
        return { value: value2, done: false };
      }
      return { done: true, value: null };
    }
  };
};
var splitGraphemes = function(str) {
  var breaker = GraphemeBreaker(str);
  var graphemes = [];
  var bk;
  while (!(bk = breaker.next()).done) {
    if (bk.value) {
      graphemes.push(bk.value.slice());
    }
  }
  return graphemes;
};
var testRangeBounds = function(document2) {
  var TEST_HEIGHT = 123;
  if (document2.createRange) {
    var range = document2.createRange();
    if (range.getBoundingClientRect) {
      var testElement = document2.createElement("boundtest");
      testElement.style.height = TEST_HEIGHT + "px";
      testElement.style.display = "block";
      document2.body.appendChild(testElement);
      range.selectNode(testElement);
      var rangeBounds = range.getBoundingClientRect();
      var rangeHeight = Math.round(rangeBounds.height);
      document2.body.removeChild(testElement);
      if (rangeHeight === TEST_HEIGHT) {
        return true;
      }
    }
  }
  return false;
};
var testIOSLineBreak = function(document2) {
  var testElement = document2.createElement("boundtest");
  testElement.style.width = "50px";
  testElement.style.display = "block";
  testElement.style.fontSize = "12px";
  testElement.style.letterSpacing = "0px";
  testElement.style.wordSpacing = "0px";
  document2.body.appendChild(testElement);
  var range = document2.createRange();
  testElement.innerHTML = typeof "".repeat === "function" ? "&#128104;".repeat(10) : "";
  var node = testElement.firstChild;
  var textList = toCodePoints$1(node.data).map(function(i) {
    return fromCodePoint$1(i);
  });
  var offset = 0;
  var prev = {};
  var supports = textList.every(function(text, i) {
    range.setStart(node, offset);
    range.setEnd(node, offset + text.length);
    var rect = range.getBoundingClientRect();
    offset += text.length;
    var boundAhead = rect.x > prev.x || rect.y > prev.y;
    prev = rect;
    if (i === 0) {
      return true;
    }
    return boundAhead;
  });
  document2.body.removeChild(testElement);
  return supports;
};
var testCORS = function() {
  return typeof new Image().crossOrigin !== "undefined";
};
var testResponseType = function() {
  return typeof new XMLHttpRequest().responseType === "string";
};
var testSVG = function(document2) {
  var img = new Image();
  var canvas = document2.createElement("canvas");
  var ctx = canvas.getContext("2d");
  if (!ctx) {
    return false;
  }
  img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
  try {
    ctx.drawImage(img, 0, 0);
    canvas.toDataURL();
  } catch (e2) {
    return false;
  }
  return true;
};
var isGreenPixel = function(data) {
  return data[0] === 0 && data[1] === 255 && data[2] === 0 && data[3] === 255;
};
var testForeignObject = function(document2) {
  var canvas = document2.createElement("canvas");
  var size2 = 100;
  canvas.width = size2;
  canvas.height = size2;
  var ctx = canvas.getContext("2d");
  if (!ctx) {
    return Promise.reject(false);
  }
  ctx.fillStyle = "rgb(0, 255, 0)";
  ctx.fillRect(0, 0, size2, size2);
  var img = new Image();
  var greenImageSrc = canvas.toDataURL();
  img.src = greenImageSrc;
  var svg2 = createForeignObjectSVG(size2, size2, 0, 0, img);
  ctx.fillStyle = "red";
  ctx.fillRect(0, 0, size2, size2);
  return loadSerializedSVG$1(svg2).then(function(img2) {
    ctx.drawImage(img2, 0, 0);
    var data = ctx.getImageData(0, 0, size2, size2).data;
    ctx.fillStyle = "red";
    ctx.fillRect(0, 0, size2, size2);
    var node = document2.createElement("div");
    node.style.backgroundImage = "url(" + greenImageSrc + ")";
    node.style.height = size2 + "px";
    return isGreenPixel(data) ? loadSerializedSVG$1(createForeignObjectSVG(size2, size2, 0, 0, node)) : Promise.reject(false);
  }).then(function(img2) {
    ctx.drawImage(img2, 0, 0);
    return isGreenPixel(ctx.getImageData(0, 0, size2, size2).data);
  }).catch(function() {
    return false;
  });
};
var createForeignObjectSVG = function(width2, height, x2, y2, node) {
  var xmlns = "http://www.w3.org/2000/svg";
  var svg2 = document.createElementNS(xmlns, "svg");
  var foreignObject = document.createElementNS(xmlns, "foreignObject");
  svg2.setAttributeNS(null, "width", width2.toString());
  svg2.setAttributeNS(null, "height", height.toString());
  foreignObject.setAttributeNS(null, "width", "100%");
  foreignObject.setAttributeNS(null, "height", "100%");
  foreignObject.setAttributeNS(null, "x", x2.toString());
  foreignObject.setAttributeNS(null, "y", y2.toString());
  foreignObject.setAttributeNS(null, "externalResourcesRequired", "true");
  svg2.appendChild(foreignObject);
  foreignObject.appendChild(node);
  return svg2;
};
var loadSerializedSVG$1 = function(svg2) {
  return new Promise(function(resolve2, reject) {
    var img = new Image();
    img.onload = function() {
      return resolve2(img);
    };
    img.onerror = reject;
    img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg2));
  });
};
var FEATURES = {
  get SUPPORT_RANGE_BOUNDS() {
    var value2 = testRangeBounds(document);
    Object.defineProperty(FEATURES, "SUPPORT_RANGE_BOUNDS", { value: value2 });
    return value2;
  },
  get SUPPORT_WORD_BREAKING() {
    var value2 = FEATURES.SUPPORT_RANGE_BOUNDS && testIOSLineBreak(document);
    Object.defineProperty(FEATURES, "SUPPORT_WORD_BREAKING", { value: value2 });
    return value2;
  },
  get SUPPORT_SVG_DRAWING() {
    var value2 = testSVG(document);
    Object.defineProperty(FEATURES, "SUPPORT_SVG_DRAWING", { value: value2 });
    return value2;
  },
  get SUPPORT_FOREIGNOBJECT_DRAWING() {
    var value2 = typeof Array.from === "function" && typeof window.fetch === "function" ? testForeignObject(document) : Promise.resolve(false);
    Object.defineProperty(FEATURES, "SUPPORT_FOREIGNOBJECT_DRAWING", { value: value2 });
    return value2;
  },
  get SUPPORT_CORS_IMAGES() {
    var value2 = testCORS();
    Object.defineProperty(FEATURES, "SUPPORT_CORS_IMAGES", { value: value2 });
    return value2;
  },
  get SUPPORT_RESPONSE_TYPE() {
    var value2 = testResponseType();
    Object.defineProperty(FEATURES, "SUPPORT_RESPONSE_TYPE", { value: value2 });
    return value2;
  },
  get SUPPORT_CORS_XHR() {
    var value2 = "withCredentials" in new XMLHttpRequest();
    Object.defineProperty(FEATURES, "SUPPORT_CORS_XHR", { value: value2 });
    return value2;
  },
  get SUPPORT_NATIVE_TEXT_SEGMENTATION() {
    var value2 = !!(typeof Intl !== "undefined" && Intl.Segmenter);
    Object.defineProperty(FEATURES, "SUPPORT_NATIVE_TEXT_SEGMENTATION", { value: value2 });
    return value2;
  }
};
var TextBounds = (
  /** @class */
  /* @__PURE__ */ function() {
    function TextBounds2(text, bounds) {
      this.text = text;
      this.bounds = bounds;
    }
    return TextBounds2;
  }()
);
var parseTextBounds = function(context, value2, styles, node) {
  var textList = breakText(value2, styles);
  var textBounds = [];
  var offset = 0;
  textList.forEach(function(text) {
    if (styles.textDecorationLine.length || text.trim().length > 0) {
      if (FEATURES.SUPPORT_RANGE_BOUNDS) {
        var clientRects = createRange(node, offset, text.length).getClientRects();
        if (clientRects.length > 1) {
          var subSegments = segmentGraphemes(text);
          var subOffset_1 = 0;
          subSegments.forEach(function(subSegment) {
            textBounds.push(new TextBounds(subSegment, Bounds.fromDOMRectList(context, createRange(node, subOffset_1 + offset, subSegment.length).getClientRects())));
            subOffset_1 += subSegment.length;
          });
        } else {
          textBounds.push(new TextBounds(text, Bounds.fromDOMRectList(context, clientRects)));
        }
      } else {
        var replacementNode = node.splitText(text.length);
        textBounds.push(new TextBounds(text, getWrapperBounds(context, node)));
        node = replacementNode;
      }
    } else if (!FEATURES.SUPPORT_RANGE_BOUNDS) {
      node = node.splitText(text.length);
    }
    offset += text.length;
  });
  return textBounds;
};
var getWrapperBounds = function(context, node) {
  var ownerDocument = node.ownerDocument;
  if (ownerDocument) {
    var wrapper = ownerDocument.createElement("html2canvaswrapper");
    wrapper.appendChild(node.cloneNode(true));
    var parentNode = node.parentNode;
    if (parentNode) {
      parentNode.replaceChild(wrapper, node);
      var bounds = parseBounds(context, wrapper);
      if (wrapper.firstChild) {
        parentNode.replaceChild(wrapper.firstChild, wrapper);
      }
      return bounds;
    }
  }
  return Bounds.EMPTY;
};
var createRange = function(node, offset, length) {
  var ownerDocument = node.ownerDocument;
  if (!ownerDocument) {
    throw new Error("Node has no owner document");
  }
  var range = ownerDocument.createRange();
  range.setStart(node, offset);
  range.setEnd(node, offset + length);
  return range;
};
var segmentGraphemes = function(value2) {
  if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
    var segmenter = new Intl.Segmenter(void 0, { granularity: "grapheme" });
    return Array.from(segmenter.segment(value2)).map(function(segment) {
      return segment.segment;
    });
  }
  return splitGraphemes(value2);
};
var segmentWords = function(value2, styles) {
  if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
    var segmenter = new Intl.Segmenter(void 0, {
      granularity: "word"
    });
    return Array.from(segmenter.segment(value2)).map(function(segment) {
      return segment.segment;
    });
  }
  return breakWords(value2, styles);
};
var breakText = function(value2, styles) {
  return styles.letterSpacing !== 0 ? segmentGraphemes(value2) : segmentWords(value2, styles);
};
var wordSeparators = [32, 160, 4961, 65792, 65793, 4153, 4241];
var breakWords = function(str, styles) {
  var breaker = LineBreaker(str, {
    lineBreak: styles.lineBreak,
    wordBreak: styles.overflowWrap === "break-word" ? "break-word" : styles.wordBreak
  });
  var words = [];
  var bk;
  var _loop_1 = function() {
    if (bk.value) {
      var value2 = bk.value.slice();
      var codePoints = toCodePoints$1(value2);
      var word_1 = "";
      codePoints.forEach(function(codePoint) {
        if (wordSeparators.indexOf(codePoint) === -1) {
          word_1 += fromCodePoint$1(codePoint);
        } else {
          if (word_1.length) {
            words.push(word_1);
          }
          words.push(fromCodePoint$1(codePoint));
          word_1 = "";
        }
      });
      if (word_1.length) {
        words.push(word_1);
      }
    }
  };
  while (!(bk = breaker.next()).done) {
    _loop_1();
  }
  return words;
};
var TextContainer = (
  /** @class */
  /* @__PURE__ */ function() {
    function TextContainer2(context, node, styles) {
      this.text = transform(node.data, styles.textTransform);
      this.textBounds = parseTextBounds(context, this.text, styles, node);
    }
    return TextContainer2;
  }()
);
var transform = function(text, transform2) {
  switch (transform2) {
    case 1:
      return text.toLowerCase();
    case 3:
      return text.replace(CAPITALIZE, capitalize);
    case 2:
      return text.toUpperCase();
    default:
      return text;
  }
};
var CAPITALIZE = /(^|\s|:|-|\(|\))([a-z])/g;
var capitalize = function(m2, p1, p2) {
  if (m2.length > 0) {
    return p1 + p2.toUpperCase();
  }
  return m2;
};
var ImageElementContainer = (
  /** @class */
  function(_super) {
    __extends(ImageElementContainer2, _super);
    function ImageElementContainer2(context, img) {
      var _this = _super.call(this, context, img) || this;
      _this.src = img.currentSrc || img.src;
      _this.intrinsicWidth = img.naturalWidth;
      _this.intrinsicHeight = img.naturalHeight;
      _this.context.cache.addImage(_this.src);
      return _this;
    }
    return ImageElementContainer2;
  }(ElementContainer)
);
var CanvasElementContainer = (
  /** @class */
  function(_super) {
    __extends(CanvasElementContainer2, _super);
    function CanvasElementContainer2(context, canvas) {
      var _this = _super.call(this, context, canvas) || this;
      _this.canvas = canvas;
      _this.intrinsicWidth = canvas.width;
      _this.intrinsicHeight = canvas.height;
      return _this;
    }
    return CanvasElementContainer2;
  }(ElementContainer)
);
var SVGElementContainer = (
  /** @class */
  function(_super) {
    __extends(SVGElementContainer2, _super);
    function SVGElementContainer2(context, img) {
      var _this = _super.call(this, context, img) || this;
      var s2 = new XMLSerializer();
      var bounds = parseBounds(context, img);
      img.setAttribute("width", bounds.width + "px");
      img.setAttribute("height", bounds.height + "px");
      _this.svg = "data:image/svg+xml," + encodeURIComponent(s2.serializeToString(img));
      _this.intrinsicWidth = img.width.baseVal.value;
      _this.intrinsicHeight = img.height.baseVal.value;
      _this.context.cache.addImage(_this.svg);
      return _this;
    }
    return SVGElementContainer2;
  }(ElementContainer)
);
var LIElementContainer = (
  /** @class */
  function(_super) {
    __extends(LIElementContainer2, _super);
    function LIElementContainer2(context, element) {
      var _this = _super.call(this, context, element) || this;
      _this.value = element.value;
      return _this;
    }
    return LIElementContainer2;
  }(ElementContainer)
);
var OLElementContainer = (
  /** @class */
  function(_super) {
    __extends(OLElementContainer2, _super);
    function OLElementContainer2(context, element) {
      var _this = _super.call(this, context, element) || this;
      _this.start = element.start;
      _this.reversed = typeof element.reversed === "boolean" && element.reversed === true;
      return _this;
    }
    return OLElementContainer2;
  }(ElementContainer)
);
var CHECKBOX_BORDER_RADIUS = [
  {
    type: 15,
    flags: 0,
    unit: "px",
    number: 3
  }
];
var RADIO_BORDER_RADIUS = [
  {
    type: 16,
    flags: 0,
    number: 50
  }
];
var reformatInputBounds = function(bounds) {
  if (bounds.width > bounds.height) {
    return new Bounds(bounds.left + (bounds.width - bounds.height) / 2, bounds.top, bounds.height, bounds.height);
  } else if (bounds.width < bounds.height) {
    return new Bounds(bounds.left, bounds.top + (bounds.height - bounds.width) / 2, bounds.width, bounds.width);
  }
  return bounds;
};
var getInputValue = function(node) {
  var value2 = node.type === PASSWORD ? new Array(node.value.length + 1).join("•") : node.value;
  return value2.length === 0 ? node.placeholder || "" : value2;
};
var CHECKBOX = "checkbox";
var RADIO = "radio";
var PASSWORD = "password";
var INPUT_COLOR = 707406591;
var InputElementContainer = (
  /** @class */
  function(_super) {
    __extends(InputElementContainer2, _super);
    function InputElementContainer2(context, input) {
      var _this = _super.call(this, context, input) || this;
      _this.type = input.type.toLowerCase();
      _this.checked = input.checked;
      _this.value = getInputValue(input);
      if (_this.type === CHECKBOX || _this.type === RADIO) {
        _this.styles.backgroundColor = 3739148031;
        _this.styles.borderTopColor = _this.styles.borderRightColor = _this.styles.borderBottomColor = _this.styles.borderLeftColor = 2779096575;
        _this.styles.borderTopWidth = _this.styles.borderRightWidth = _this.styles.borderBottomWidth = _this.styles.borderLeftWidth = 1;
        _this.styles.borderTopStyle = _this.styles.borderRightStyle = _this.styles.borderBottomStyle = _this.styles.borderLeftStyle = 1;
        _this.styles.backgroundClip = [
          0
          /* BORDER_BOX */
        ];
        _this.styles.backgroundOrigin = [
          0
          /* BORDER_BOX */
        ];
        _this.bounds = reformatInputBounds(_this.bounds);
      }
      switch (_this.type) {
        case CHECKBOX:
          _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = CHECKBOX_BORDER_RADIUS;
          break;
        case RADIO:
          _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = RADIO_BORDER_RADIUS;
          break;
      }
      return _this;
    }
    return InputElementContainer2;
  }(ElementContainer)
);
var SelectElementContainer = (
  /** @class */
  function(_super) {
    __extends(SelectElementContainer2, _super);
    function SelectElementContainer2(context, element) {
      var _this = _super.call(this, context, element) || this;
      var option = element.options[element.selectedIndex || 0];
      _this.value = option ? option.text || "" : "";
      return _this;
    }
    return SelectElementContainer2;
  }(ElementContainer)
);
var TextareaElementContainer = (
  /** @class */
  function(_super) {
    __extends(TextareaElementContainer2, _super);
    function TextareaElementContainer2(context, element) {
      var _this = _super.call(this, context, element) || this;
      _this.value = element.value;
      return _this;
    }
    return TextareaElementContainer2;
  }(ElementContainer)
);
var IFrameElementContainer = (
  /** @class */
  function(_super) {
    __extends(IFrameElementContainer2, _super);
    function IFrameElementContainer2(context, iframe) {
      var _this = _super.call(this, context, iframe) || this;
      _this.src = iframe.src;
      _this.width = parseInt(iframe.width, 10) || 0;
      _this.height = parseInt(iframe.height, 10) || 0;
      _this.backgroundColor = _this.styles.backgroundColor;
      try {
        if (iframe.contentWindow && iframe.contentWindow.document && iframe.contentWindow.document.documentElement) {
          _this.tree = parseTree(context, iframe.contentWindow.document.documentElement);
          var documentBackgroundColor = iframe.contentWindow.document.documentElement ? parseColor(context, getComputedStyle(iframe.contentWindow.document.documentElement).backgroundColor) : COLORS.TRANSPARENT;
          var bodyBackgroundColor = iframe.contentWindow.document.body ? parseColor(context, getComputedStyle(iframe.contentWindow.document.body).backgroundColor) : COLORS.TRANSPARENT;
          _this.backgroundColor = isTransparent(documentBackgroundColor) ? isTransparent(bodyBackgroundColor) ? _this.styles.backgroundColor : bodyBackgroundColor : documentBackgroundColor;
        }
      } catch (e2) {
      }
      return _this;
    }
    return IFrameElementContainer2;
  }(ElementContainer)
);
var LIST_OWNERS = ["OL", "UL", "MENU"];
var parseNodeTree = function(context, node, parent, root) {
  for (var childNode = node.firstChild, nextNode = void 0; childNode; childNode = nextNode) {
    nextNode = childNode.nextSibling;
    if (isTextNode(childNode) && childNode.data.trim().length > 0) {
      parent.textNodes.push(new TextContainer(context, childNode, parent.styles));
    } else if (isElementNode(childNode)) {
      if (isSlotElement(childNode) && childNode.assignedNodes) {
        childNode.assignedNodes().forEach(function(childNode2) {
          return parseNodeTree(context, childNode2, parent, root);
        });
      } else {
        var container = createContainer(context, childNode);
        if (container.styles.isVisible()) {
          if (createsRealStackingContext(childNode, container, root)) {
            container.flags |= 4;
          } else if (createsStackingContext(container.styles)) {
            container.flags |= 2;
          }
          if (LIST_OWNERS.indexOf(childNode.tagName) !== -1) {
            container.flags |= 8;
          }
          parent.elements.push(container);
          childNode.slot;
          if (childNode.shadowRoot) {
            parseNodeTree(context, childNode.shadowRoot, container, root);
          } else if (!isTextareaElement(childNode) && !isSVGElement(childNode) && !isSelectElement(childNode)) {
            parseNodeTree(context, childNode, container, root);
          }
        }
      }
    }
  }
};
var createContainer = function(context, element) {
  if (isImageElement(element)) {
    return new ImageElementContainer(context, element);
  }
  if (isCanvasElement(element)) {
    return new CanvasElementContainer(context, element);
  }
  if (isSVGElement(element)) {
    return new SVGElementContainer(context, element);
  }
  if (isLIElement(element)) {
    return new LIElementContainer(context, element);
  }
  if (isOLElement(element)) {
    return new OLElementContainer(context, element);
  }
  if (isInputElement(element)) {
    return new InputElementContainer(context, element);
  }
  if (isSelectElement(element)) {
    return new SelectElementContainer(context, element);
  }
  if (isTextareaElement(element)) {
    return new TextareaElementContainer(context, element);
  }
  if (isIFrameElement(element)) {
    return new IFrameElementContainer(context, element);
  }
  return new ElementContainer(context, element);
};
var parseTree = function(context, element) {
  var container = createContainer(context, element);
  container.flags |= 4;
  parseNodeTree(context, element, container, container);
  return container;
};
var createsRealStackingContext = function(node, container, root) {
  return container.styles.isPositionedWithZIndex() || container.styles.opacity < 1 || container.styles.isTransformed() || isBodyElement(node) && root.styles.isTransparent();
};
var createsStackingContext = function(styles) {
  return styles.isPositioned() || styles.isFloating();
};
var isTextNode = function(node) {
  return node.nodeType === Node.TEXT_NODE;
};
var isElementNode = function(node) {
  return node.nodeType === Node.ELEMENT_NODE;
};
var isHTMLElementNode = function(node) {
  return isElementNode(node) && typeof node.style !== "undefined" && !isSVGElementNode(node);
};
var isSVGElementNode = function(element) {
  return typeof element.className === "object";
};
var isLIElement = function(node) {
  return node.tagName === "LI";
};
var isOLElement = function(node) {
  return node.tagName === "OL";
};
var isInputElement = function(node) {
  return node.tagName === "INPUT";
};
var isHTMLElement = function(node) {
  return node.tagName === "HTML";
};
var isSVGElement = function(node) {
  return node.tagName === "svg";
};
var isBodyElement = function(node) {
  return node.tagName === "BODY";
};
var isCanvasElement = function(node) {
  return node.tagName === "CANVAS";
};
var isVideoElement = function(node) {
  return node.tagName === "VIDEO";
};
var isImageElement = function(node) {
  return node.tagName === "IMG";
};
var isIFrameElement = function(node) {
  return node.tagName === "IFRAME";
};
var isStyleElement = function(node) {
  return node.tagName === "STYLE";
};
var isScriptElement = function(node) {
  return node.tagName === "SCRIPT";
};
var isTextareaElement = function(node) {
  return node.tagName === "TEXTAREA";
};
var isSelectElement = function(node) {
  return node.tagName === "SELECT";
};
var isSlotElement = function(node) {
  return node.tagName === "SLOT";
};
var isCustomElement = function(node) {
  return node.tagName.indexOf("-") > 0;
};
var CounterState = (
  /** @class */
  function() {
    function CounterState2() {
      this.counters = {};
    }
    CounterState2.prototype.getCounterValue = function(name) {
      var counter2 = this.counters[name];
      if (counter2 && counter2.length) {
        return counter2[counter2.length - 1];
      }
      return 1;
    };
    CounterState2.prototype.getCounterValues = function(name) {
      var counter2 = this.counters[name];
      return counter2 ? counter2 : [];
    };
    CounterState2.prototype.pop = function(counters) {
      var _this = this;
      counters.forEach(function(counter2) {
        return _this.counters[counter2].pop();
      });
    };
    CounterState2.prototype.parse = function(style) {
      var _this = this;
      var counterIncrement2 = style.counterIncrement;
      var counterReset2 = style.counterReset;
      var canReset = true;
      if (counterIncrement2 !== null) {
        counterIncrement2.forEach(function(entry) {
          var counter2 = _this.counters[entry.counter];
          if (counter2 && entry.increment !== 0) {
            canReset = false;
            if (!counter2.length) {
              counter2.push(1);
            }
            counter2[Math.max(0, counter2.length - 1)] += entry.increment;
          }
        });
      }
      var counterNames = [];
      if (canReset) {
        counterReset2.forEach(function(entry) {
          var counter2 = _this.counters[entry.counter];
          counterNames.push(entry.counter);
          if (!counter2) {
            counter2 = _this.counters[entry.counter] = [];
          }
          counter2.push(entry.reset);
        });
      }
      return counterNames;
    };
    return CounterState2;
  }()
);
var ROMAN_UPPER = {
  integers: [1e3, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
  values: ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]
};
var ARMENIAN = {
  integers: [
    9e3,
    8e3,
    7e3,
    6e3,
    5e3,
    4e3,
    3e3,
    2e3,
    1e3,
    900,
    800,
    700,
    600,
    500,
    400,
    300,
    200,
    100,
    90,
    80,
    70,
    60,
    50,
    40,
    30,
    20,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1
  ],
  values: [
    "Ք",
    "Փ",
    "Ւ",
    "Ց",
    "Ր",
    "Տ",
    "Վ",
    "Ս",
    "Ռ",
    "Ջ",
    "Պ",
    "Չ",
    "Ո",
    "Շ",
    "Ն",
    "Յ",
    "Մ",
    "Ճ",
    "Ղ",
    "Ձ",
    "Հ",
    "Կ",
    "Ծ",
    "Խ",
    "Լ",
    "Ի",
    "Ժ",
    "Թ",
    "Ը",
    "Է",
    "Զ",
    "Ե",
    "Դ",
    "Գ",
    "Բ",
    "Ա"
  ]
};
var HEBREW = {
  integers: [
    1e4,
    9e3,
    8e3,
    7e3,
    6e3,
    5e3,
    4e3,
    3e3,
    2e3,
    1e3,
    400,
    300,
    200,
    100,
    90,
    80,
    70,
    60,
    50,
    40,
    30,
    20,
    19,
    18,
    17,
    16,
    15,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1
  ],
  values: [
    "י׳",
    "ט׳",
    "ח׳",
    "ז׳",
    "ו׳",
    "ה׳",
    "ד׳",
    "ג׳",
    "ב׳",
    "א׳",
    "ת",
    "ש",
    "ר",
    "ק",
    "צ",
    "פ",
    "ע",
    "ס",
    "נ",
    "מ",
    "ל",
    "כ",
    "יט",
    "יח",
    "יז",
    "טז",
    "טו",
    "י",
    "ט",
    "ח",
    "ז",
    "ו",
    "ה",
    "ד",
    "ג",
    "ב",
    "א"
  ]
};
var GEORGIAN = {
  integers: [
    1e4,
    9e3,
    8e3,
    7e3,
    6e3,
    5e3,
    4e3,
    3e3,
    2e3,
    1e3,
    900,
    800,
    700,
    600,
    500,
    400,
    300,
    200,
    100,
    90,
    80,
    70,
    60,
    50,
    40,
    30,
    20,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1
  ],
  values: [
    "ჵ",
    "ჰ",
    "ჯ",
    "ჴ",
    "ხ",
    "ჭ",
    "წ",
    "ძ",
    "ც",
    "ჩ",
    "შ",
    "ყ",
    "ღ",
    "ქ",
    "ფ",
    "ჳ",
    "ტ",
    "ს",
    "რ",
    "ჟ",
    "პ",
    "ო",
    "ჲ",
    "ნ",
    "მ",
    "ლ",
    "კ",
    "ი",
    "თ",
    "ჱ",
    "ზ",
    "ვ",
    "ე",
    "დ",
    "გ",
    "ბ",
    "ა"
  ]
};
var createAdditiveCounter = function(value2, min, max2, symbols, fallback, suffix) {
  if (value2 < min || value2 > max2) {
    return createCounterText(value2, fallback, suffix.length > 0);
  }
  return symbols.integers.reduce(function(string, integer, index) {
    while (value2 >= integer) {
      value2 -= integer;
      string += symbols.values[index];
    }
    return string;
  }, "") + suffix;
};
var createCounterStyleWithSymbolResolver = function(value2, codePointRangeLength, isNumeric, resolver) {
  var string = "";
  do {
    if (!isNumeric) {
      value2--;
    }
    string = resolver(value2) + string;
    value2 /= codePointRangeLength;
  } while (value2 * codePointRangeLength >= codePointRangeLength);
  return string;
};
var createCounterStyleFromRange = function(value2, codePointRangeStart, codePointRangeEnd, isNumeric, suffix) {
  var codePointRangeLength = codePointRangeEnd - codePointRangeStart + 1;
  return (value2 < 0 ? "-" : "") + (createCounterStyleWithSymbolResolver(Math.abs(value2), codePointRangeLength, isNumeric, function(codePoint) {
    return fromCodePoint$1(Math.floor(codePoint % codePointRangeLength) + codePointRangeStart);
  }) + suffix);
};
var createCounterStyleFromSymbols = function(value2, symbols, suffix) {
  if (suffix === void 0) {
    suffix = ". ";
  }
  var codePointRangeLength = symbols.length;
  return createCounterStyleWithSymbolResolver(Math.abs(value2), codePointRangeLength, false, function(codePoint) {
    return symbols[Math.floor(codePoint % codePointRangeLength)];
  }) + suffix;
};
var CJK_ZEROS = 1 << 0;
var CJK_TEN_COEFFICIENTS = 1 << 1;
var CJK_TEN_HIGH_COEFFICIENTS = 1 << 2;
var CJK_HUNDRED_COEFFICIENTS = 1 << 3;
var createCJKCounter = function(value2, numbers, multipliers, negativeSign, suffix, flags) {
  if (value2 < -9999 || value2 > 9999) {
    return createCounterText(value2, 4, suffix.length > 0);
  }
  var tmp = Math.abs(value2);
  var string = suffix;
  if (tmp === 0) {
    return numbers[0] + string;
  }
  for (var digit = 0; tmp > 0 && digit <= 4; digit++) {
    var coefficient = tmp % 10;
    if (coefficient === 0 && contains(flags, CJK_ZEROS) && string !== "") {
      string = numbers[coefficient] + string;
    } else if (coefficient > 1 || coefficient === 1 && digit === 0 || coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_COEFFICIENTS) || coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_HIGH_COEFFICIENTS) && value2 > 100 || coefficient === 1 && digit > 1 && contains(flags, CJK_HUNDRED_COEFFICIENTS)) {
      string = numbers[coefficient] + (digit > 0 ? multipliers[digit - 1] : "") + string;
    } else if (coefficient === 1 && digit > 0) {
      string = multipliers[digit - 1] + string;
    }
    tmp = Math.floor(tmp / 10);
  }
  return (value2 < 0 ? negativeSign : "") + string;
};
var CHINESE_INFORMAL_MULTIPLIERS = "十百千萬";
var CHINESE_FORMAL_MULTIPLIERS = "拾佰仟萬";
var JAPANESE_NEGATIVE = "マイナス";
var KOREAN_NEGATIVE = "마이너스";
var createCounterText = function(value2, type, appendSuffix) {
  var defaultSuffix = appendSuffix ? ". " : "";
  var cjkSuffix = appendSuffix ? "、" : "";
  var koreanSuffix = appendSuffix ? ", " : "";
  var spaceSuffix = appendSuffix ? " " : "";
  switch (type) {
    case 0:
      return "•" + spaceSuffix;
    case 1:
      return "◦" + spaceSuffix;
    case 2:
      return "◾" + spaceSuffix;
    case 5:
      var string = createCounterStyleFromRange(value2, 48, 57, true, defaultSuffix);
      return string.length < 4 ? "0" + string : string;
    case 4:
      return createCounterStyleFromSymbols(value2, "〇一二三四五六七八九", cjkSuffix);
    case 6:
      return createAdditiveCounter(value2, 1, 3999, ROMAN_UPPER, 3, defaultSuffix).toLowerCase();
    case 7:
      return createAdditiveCounter(value2, 1, 3999, ROMAN_UPPER, 3, defaultSuffix);
    case 8:
      return createCounterStyleFromRange(value2, 945, 969, false, defaultSuffix);
    case 9:
      return createCounterStyleFromRange(value2, 97, 122, false, defaultSuffix);
    case 10:
      return createCounterStyleFromRange(value2, 65, 90, false, defaultSuffix);
    case 11:
      return createCounterStyleFromRange(value2, 1632, 1641, true, defaultSuffix);
    case 12:
    case 49:
      return createAdditiveCounter(value2, 1, 9999, ARMENIAN, 3, defaultSuffix);
    case 35:
      return createAdditiveCounter(value2, 1, 9999, ARMENIAN, 3, defaultSuffix).toLowerCase();
    case 13:
      return createCounterStyleFromRange(value2, 2534, 2543, true, defaultSuffix);
    case 14:
    case 30:
      return createCounterStyleFromRange(value2, 6112, 6121, true, defaultSuffix);
    case 15:
      return createCounterStyleFromSymbols(value2, "子丑寅卯辰巳午未申酉戌亥", cjkSuffix);
    case 16:
      return createCounterStyleFromSymbols(value2, "甲乙丙丁戊己庚辛壬癸", cjkSuffix);
    case 17:
    case 48:
      return createCJKCounter(value2, "零一二三四五六七八九", CHINESE_INFORMAL_MULTIPLIERS, "負", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
    case 47:
      return createCJKCounter(value2, "零壹貳參肆伍陸柒捌玖", CHINESE_FORMAL_MULTIPLIERS, "負", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
    case 42:
      return createCJKCounter(value2, "零一二三四五六七八九", CHINESE_INFORMAL_MULTIPLIERS, "负", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
    case 41:
      return createCJKCounter(value2, "零壹贰叁肆伍陆柒捌玖", CHINESE_FORMAL_MULTIPLIERS, "负", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
    case 26:
      return createCJKCounter(value2, "〇一二三四五六七八九", "十百千万", JAPANESE_NEGATIVE, cjkSuffix, 0);
    case 25:
      return createCJKCounter(value2, "零壱弐参四伍六七八九", "拾百千万", JAPANESE_NEGATIVE, cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
    case 31:
      return createCJKCounter(value2, "영일이삼사오육칠팔구", "십백천만", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
    case 33:
      return createCJKCounter(value2, "零一二三四五六七八九", "十百千萬", KOREAN_NEGATIVE, koreanSuffix, 0);
    case 32:
      return createCJKCounter(value2, "零壹貳參四五六七八九", "拾百千", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
    case 18:
      return createCounterStyleFromRange(value2, 2406, 2415, true, defaultSuffix);
    case 20:
      return createAdditiveCounter(value2, 1, 19999, GEORGIAN, 3, defaultSuffix);
    case 21:
      return createCounterStyleFromRange(value2, 2790, 2799, true, defaultSuffix);
    case 22:
      return createCounterStyleFromRange(value2, 2662, 2671, true, defaultSuffix);
    case 22:
      return createAdditiveCounter(value2, 1, 10999, HEBREW, 3, defaultSuffix);
    case 23:
      return createCounterStyleFromSymbols(value2, "あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわゐゑをん");
    case 24:
      return createCounterStyleFromSymbols(value2, "いろはにほへとちりぬるをわかよたれそつねならむうゐのおくやまけふこえてあさきゆめみしゑひもせす");
    case 27:
      return createCounterStyleFromRange(value2, 3302, 3311, true, defaultSuffix);
    case 28:
      return createCounterStyleFromSymbols(value2, "アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヰヱヲン", cjkSuffix);
    case 29:
      return createCounterStyleFromSymbols(value2, "イロハニホヘトチリヌルヲワカヨタレソツネナラムウヰノオクヤマケフコエテアサキユメミシヱヒモセス", cjkSuffix);
    case 34:
      return createCounterStyleFromRange(value2, 3792, 3801, true, defaultSuffix);
    case 37:
      return createCounterStyleFromRange(value2, 6160, 6169, true, defaultSuffix);
    case 38:
      return createCounterStyleFromRange(value2, 4160, 4169, true, defaultSuffix);
    case 39:
      return createCounterStyleFromRange(value2, 2918, 2927, true, defaultSuffix);
    case 40:
      return createCounterStyleFromRange(value2, 1776, 1785, true, defaultSuffix);
    case 43:
      return createCounterStyleFromRange(value2, 3046, 3055, true, defaultSuffix);
    case 44:
      return createCounterStyleFromRange(value2, 3174, 3183, true, defaultSuffix);
    case 45:
      return createCounterStyleFromRange(value2, 3664, 3673, true, defaultSuffix);
    case 46:
      return createCounterStyleFromRange(value2, 3872, 3881, true, defaultSuffix);
    case 3:
    default:
      return createCounterStyleFromRange(value2, 48, 57, true, defaultSuffix);
  }
};
var IGNORE_ATTRIBUTE = "data-html2canvas-ignore";
var DocumentCloner = (
  /** @class */
  function() {
    function DocumentCloner2(context, element, options) {
      this.context = context;
      this.options = options;
      this.scrolledElements = [];
      this.referenceElement = element;
      this.counters = new CounterState();
      this.quoteDepth = 0;
      if (!element.ownerDocument) {
        throw new Error("Cloned element does not have an owner document");
      }
      this.documentElement = this.cloneNode(element.ownerDocument.documentElement, false);
    }
    DocumentCloner2.prototype.toIFrame = function(ownerDocument, windowSize) {
      var _this = this;
      var iframe = createIFrameContainer(ownerDocument, windowSize);
      if (!iframe.contentWindow) {
        return Promise.reject("Unable to find iframe window");
      }
      var scrollX = ownerDocument.defaultView.pageXOffset;
      var scrollY = ownerDocument.defaultView.pageYOffset;
      var cloneWindow = iframe.contentWindow;
      var documentClone = cloneWindow.document;
      var iframeLoad = iframeLoader(iframe).then(function() {
        return __awaiter(_this, void 0, void 0, function() {
          var onclone, referenceElement;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                this.scrolledElements.forEach(restoreNodeScroll);
                if (cloneWindow) {
                  cloneWindow.scrollTo(windowSize.left, windowSize.top);
                  if (/(iPad|iPhone|iPod)/g.test(navigator.userAgent) && (cloneWindow.scrollY !== windowSize.top || cloneWindow.scrollX !== windowSize.left)) {
                    this.context.logger.warn("Unable to restore scroll position for cloned document");
                    this.context.windowBounds = this.context.windowBounds.add(cloneWindow.scrollX - windowSize.left, cloneWindow.scrollY - windowSize.top, 0, 0);
                  }
                }
                onclone = this.options.onclone;
                referenceElement = this.clonedReferenceElement;
                if (typeof referenceElement === "undefined") {
                  return [2, Promise.reject("Error finding the " + this.referenceElement.nodeName + " in the cloned document")];
                }
                if (!(documentClone.fonts && documentClone.fonts.ready)) return [3, 2];
                return [4, documentClone.fonts.ready];
              case 1:
                _a2.sent();
                _a2.label = 2;
              case 2:
                if (!/(AppleWebKit)/g.test(navigator.userAgent)) return [3, 4];
                return [4, imagesReady(documentClone)];
              case 3:
                _a2.sent();
                _a2.label = 4;
              case 4:
                if (typeof onclone === "function") {
                  return [2, Promise.resolve().then(function() {
                    return onclone(documentClone, referenceElement);
                  }).then(function() {
                    return iframe;
                  })];
                }
                return [2, iframe];
            }
          });
        });
      });
      documentClone.open();
      documentClone.write(serializeDoctype(document.doctype) + "<html></html>");
      restoreOwnerScroll(this.referenceElement.ownerDocument, scrollX, scrollY);
      documentClone.replaceChild(documentClone.adoptNode(this.documentElement), documentClone.documentElement);
      documentClone.close();
      return iframeLoad;
    };
    DocumentCloner2.prototype.createElementClone = function(node) {
      if (isDebugging(
        node,
        2
        /* CLONE */
      )) {
        debugger;
      }
      if (isCanvasElement(node)) {
        return this.createCanvasClone(node);
      }
      if (isVideoElement(node)) {
        return this.createVideoClone(node);
      }
      if (isStyleElement(node)) {
        return this.createStyleClone(node);
      }
      var clone = node.cloneNode(false);
      if (isImageElement(clone)) {
        if (isImageElement(node) && node.currentSrc && node.currentSrc !== node.src) {
          clone.src = node.currentSrc;
          clone.srcset = "";
        }
        if (clone.loading === "lazy") {
          clone.loading = "eager";
        }
      }
      if (isCustomElement(clone)) {
        return this.createCustomElementClone(clone);
      }
      return clone;
    };
    DocumentCloner2.prototype.createCustomElementClone = function(node) {
      var clone = document.createElement("html2canvascustomelement");
      copyCSSStyles(node.style, clone);
      return clone;
    };
    DocumentCloner2.prototype.createStyleClone = function(node) {
      try {
        var sheet = node.sheet;
        if (sheet && sheet.cssRules) {
          var css2 = [].slice.call(sheet.cssRules, 0).reduce(function(css3, rule) {
            if (rule && typeof rule.cssText === "string") {
              return css3 + rule.cssText;
            }
            return css3;
          }, "");
          var style = node.cloneNode(false);
          style.textContent = css2;
          return style;
        }
      } catch (e2) {
        this.context.logger.error("Unable to access cssRules property", e2);
        if (e2.name !== "SecurityError") {
          throw e2;
        }
      }
      return node.cloneNode(false);
    };
    DocumentCloner2.prototype.createCanvasClone = function(canvas) {
      var _a2;
      if (this.options.inlineImages && canvas.ownerDocument) {
        var img = canvas.ownerDocument.createElement("img");
        try {
          img.src = canvas.toDataURL();
          return img;
        } catch (e2) {
          this.context.logger.info("Unable to inline canvas contents, canvas is tainted", canvas);
        }
      }
      var clonedCanvas = canvas.cloneNode(false);
      try {
        clonedCanvas.width = canvas.width;
        clonedCanvas.height = canvas.height;
        var ctx = canvas.getContext("2d");
        var clonedCtx = clonedCanvas.getContext("2d");
        if (clonedCtx) {
          if (!this.options.allowTaint && ctx) {
            clonedCtx.putImageData(ctx.getImageData(0, 0, canvas.width, canvas.height), 0, 0);
          } else {
            var gl = (_a2 = canvas.getContext("webgl2")) !== null && _a2 !== void 0 ? _a2 : canvas.getContext("webgl");
            if (gl) {
              var attribs = gl.getContextAttributes();
              if ((attribs === null || attribs === void 0 ? void 0 : attribs.preserveDrawingBuffer) === false) {
                this.context.logger.warn("Unable to clone WebGL context as it has preserveDrawingBuffer=false", canvas);
              }
            }
            clonedCtx.drawImage(canvas, 0, 0);
          }
        }
        return clonedCanvas;
      } catch (e2) {
        this.context.logger.info("Unable to clone canvas as it is tainted", canvas);
      }
      return clonedCanvas;
    };
    DocumentCloner2.prototype.createVideoClone = function(video) {
      var canvas = video.ownerDocument.createElement("canvas");
      canvas.width = video.offsetWidth;
      canvas.height = video.offsetHeight;
      var ctx = canvas.getContext("2d");
      try {
        if (ctx) {
          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
          if (!this.options.allowTaint) {
            ctx.getImageData(0, 0, canvas.width, canvas.height);
          }
        }
        return canvas;
      } catch (e2) {
        this.context.logger.info("Unable to clone video as it is tainted", video);
      }
      var blankCanvas = video.ownerDocument.createElement("canvas");
      blankCanvas.width = video.offsetWidth;
      blankCanvas.height = video.offsetHeight;
      return blankCanvas;
    };
    DocumentCloner2.prototype.appendChildNode = function(clone, child, copyStyles) {
      if (!isElementNode(child) || !isScriptElement(child) && !child.hasAttribute(IGNORE_ATTRIBUTE) && (typeof this.options.ignoreElements !== "function" || !this.options.ignoreElements(child))) {
        if (!this.options.copyStyles || !isElementNode(child) || !isStyleElement(child)) {
          clone.appendChild(this.cloneNode(child, copyStyles));
        }
      }
    };
    DocumentCloner2.prototype.cloneChildNodes = function(node, clone, copyStyles) {
      var _this = this;
      for (var child = node.shadowRoot ? node.shadowRoot.firstChild : node.firstChild; child; child = child.nextSibling) {
        if (isElementNode(child) && isSlotElement(child) && typeof child.assignedNodes === "function") {
          var assignedNodes = child.assignedNodes();
          if (assignedNodes.length) {
            assignedNodes.forEach(function(assignedNode) {
              return _this.appendChildNode(clone, assignedNode, copyStyles);
            });
          }
        } else {
          this.appendChildNode(clone, child, copyStyles);
        }
      }
    };
    DocumentCloner2.prototype.cloneNode = function(node, copyStyles) {
      if (isTextNode(node)) {
        return document.createTextNode(node.data);
      }
      if (!node.ownerDocument) {
        return node.cloneNode(false);
      }
      var window2 = node.ownerDocument.defaultView;
      if (window2 && isElementNode(node) && (isHTMLElementNode(node) || isSVGElementNode(node))) {
        var clone = this.createElementClone(node);
        clone.style.transitionProperty = "none";
        var style = window2.getComputedStyle(node);
        var styleBefore = window2.getComputedStyle(node, ":before");
        var styleAfter = window2.getComputedStyle(node, ":after");
        if (this.referenceElement === node && isHTMLElementNode(clone)) {
          this.clonedReferenceElement = clone;
        }
        if (isBodyElement(clone)) {
          createPseudoHideStyles(clone);
        }
        var counters = this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
        var before = this.resolvePseudoContent(node, clone, styleBefore, PseudoElementType.BEFORE);
        if (isCustomElement(node)) {
          copyStyles = true;
        }
        if (!isVideoElement(node)) {
          this.cloneChildNodes(node, clone, copyStyles);
        }
        if (before) {
          clone.insertBefore(before, clone.firstChild);
        }
        var after = this.resolvePseudoContent(node, clone, styleAfter, PseudoElementType.AFTER);
        if (after) {
          clone.appendChild(after);
        }
        this.counters.pop(counters);
        if (style && (this.options.copyStyles || isSVGElementNode(node)) && !isIFrameElement(node) || copyStyles) {
          copyCSSStyles(style, clone);
        }
        if (node.scrollTop !== 0 || node.scrollLeft !== 0) {
          this.scrolledElements.push([clone, node.scrollLeft, node.scrollTop]);
        }
        if ((isTextareaElement(node) || isSelectElement(node)) && (isTextareaElement(clone) || isSelectElement(clone))) {
          clone.value = node.value;
        }
        return clone;
      }
      return node.cloneNode(false);
    };
    DocumentCloner2.prototype.resolvePseudoContent = function(node, clone, style, pseudoElt) {
      var _this = this;
      if (!style) {
        return;
      }
      var value2 = style.content;
      var document2 = clone.ownerDocument;
      if (!document2 || !value2 || value2 === "none" || value2 === "-moz-alt-content" || style.display === "none") {
        return;
      }
      this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
      var declaration = new CSSParsedPseudoDeclaration(this.context, style);
      var anonymousReplacedElement = document2.createElement("html2canvaspseudoelement");
      copyCSSStyles(style, anonymousReplacedElement);
      declaration.content.forEach(function(token2) {
        if (token2.type === 0) {
          anonymousReplacedElement.appendChild(document2.createTextNode(token2.value));
        } else if (token2.type === 22) {
          var img = document2.createElement("img");
          img.src = token2.value;
          img.style.opacity = "1";
          anonymousReplacedElement.appendChild(img);
        } else if (token2.type === 18) {
          if (token2.name === "attr") {
            var attr = token2.values.filter(isIdentToken);
            if (attr.length) {
              anonymousReplacedElement.appendChild(document2.createTextNode(node.getAttribute(attr[0].value) || ""));
            }
          } else if (token2.name === "counter") {
            var _a2 = token2.values.filter(nonFunctionArgSeparator), counter2 = _a2[0], counterStyle = _a2[1];
            if (counter2 && isIdentToken(counter2)) {
              var counterState = _this.counters.getCounterValue(counter2.value);
              var counterType = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : 3;
              anonymousReplacedElement.appendChild(document2.createTextNode(createCounterText(counterState, counterType, false)));
            }
          } else if (token2.name === "counters") {
            var _b2 = token2.values.filter(nonFunctionArgSeparator), counter2 = _b2[0], delim = _b2[1], counterStyle = _b2[2];
            if (counter2 && isIdentToken(counter2)) {
              var counterStates = _this.counters.getCounterValues(counter2.value);
              var counterType_1 = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : 3;
              var separator = delim && delim.type === 0 ? delim.value : "";
              var text = counterStates.map(function(value3) {
                return createCounterText(value3, counterType_1, false);
              }).join(separator);
              anonymousReplacedElement.appendChild(document2.createTextNode(text));
            }
          } else ;
        } else if (token2.type === 20) {
          switch (token2.value) {
            case "open-quote":
              anonymousReplacedElement.appendChild(document2.createTextNode(getQuote(declaration.quotes, _this.quoteDepth++, true)));
              break;
            case "close-quote":
              anonymousReplacedElement.appendChild(document2.createTextNode(getQuote(declaration.quotes, --_this.quoteDepth, false)));
              break;
            default:
              anonymousReplacedElement.appendChild(document2.createTextNode(token2.value));
          }
        }
      });
      anonymousReplacedElement.className = PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
      var newClassName = pseudoElt === PseudoElementType.BEFORE ? " " + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE : " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
      if (isSVGElementNode(clone)) {
        clone.className.baseValue += newClassName;
      } else {
        clone.className += newClassName;
      }
      return anonymousReplacedElement;
    };
    DocumentCloner2.destroy = function(container) {
      if (container.parentNode) {
        container.parentNode.removeChild(container);
        return true;
      }
      return false;
    };
    return DocumentCloner2;
  }()
);
var PseudoElementType;
(function(PseudoElementType2) {
  PseudoElementType2[PseudoElementType2["BEFORE"] = 0] = "BEFORE";
  PseudoElementType2[PseudoElementType2["AFTER"] = 1] = "AFTER";
})(PseudoElementType || (PseudoElementType = {}));
var createIFrameContainer = function(ownerDocument, bounds) {
  var cloneIframeContainer = ownerDocument.createElement("iframe");
  cloneIframeContainer.className = "html2canvas-container";
  cloneIframeContainer.style.visibility = "hidden";
  cloneIframeContainer.style.position = "fixed";
  cloneIframeContainer.style.left = "-10000px";
  cloneIframeContainer.style.top = "0px";
  cloneIframeContainer.style.border = "0";
  cloneIframeContainer.width = bounds.width.toString();
  cloneIframeContainer.height = bounds.height.toString();
  cloneIframeContainer.scrolling = "no";
  cloneIframeContainer.setAttribute(IGNORE_ATTRIBUTE, "true");
  ownerDocument.body.appendChild(cloneIframeContainer);
  return cloneIframeContainer;
};
var imageReady = function(img) {
  return new Promise(function(resolve2) {
    if (img.complete) {
      resolve2();
      return;
    }
    if (!img.src) {
      resolve2();
      return;
    }
    img.onload = resolve2;
    img.onerror = resolve2;
  });
};
var imagesReady = function(document2) {
  return Promise.all([].slice.call(document2.images, 0).map(imageReady));
};
var iframeLoader = function(iframe) {
  return new Promise(function(resolve2, reject) {
    var cloneWindow = iframe.contentWindow;
    if (!cloneWindow) {
      return reject("No window assigned for iframe");
    }
    var documentClone = cloneWindow.document;
    cloneWindow.onload = iframe.onload = function() {
      cloneWindow.onload = iframe.onload = null;
      var interval = setInterval(function() {
        if (documentClone.body.childNodes.length > 0 && documentClone.readyState === "complete") {
          clearInterval(interval);
          resolve2(iframe);
        }
      }, 50);
    };
  });
};
var ignoredStyleProperties = [
  "all",
  "d",
  "content"
  // Safari shows pseudoelements if content is set
];
var copyCSSStyles = function(style, target2) {
  for (var i = style.length - 1; i >= 0; i--) {
    var property = style.item(i);
    if (ignoredStyleProperties.indexOf(property) === -1) {
      target2.style.setProperty(property, style.getPropertyValue(property));
    }
  }
  return target2;
};
var serializeDoctype = function(doctype) {
  var str = "";
  if (doctype) {
    str += "<!DOCTYPE ";
    if (doctype.name) {
      str += doctype.name;
    }
    if (doctype.internalSubset) {
      str += doctype.internalSubset;
    }
    if (doctype.publicId) {
      str += '"' + doctype.publicId + '"';
    }
    if (doctype.systemId) {
      str += '"' + doctype.systemId + '"';
    }
    str += ">";
  }
  return str;
};
var restoreOwnerScroll = function(ownerDocument, x2, y2) {
  if (ownerDocument && ownerDocument.defaultView && (x2 !== ownerDocument.defaultView.pageXOffset || y2 !== ownerDocument.defaultView.pageYOffset)) {
    ownerDocument.defaultView.scrollTo(x2, y2);
  }
};
var restoreNodeScroll = function(_a2) {
  var element = _a2[0], x2 = _a2[1], y2 = _a2[2];
  element.scrollLeft = x2;
  element.scrollTop = y2;
};
var PSEUDO_BEFORE = ":before";
var PSEUDO_AFTER = ":after";
var PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = "___html2canvas___pseudoelement_before";
var PSEUDO_HIDE_ELEMENT_CLASS_AFTER = "___html2canvas___pseudoelement_after";
var PSEUDO_HIDE_ELEMENT_STYLE = '{\n    content: "" !important;\n    display: none !important;\n}';
var createPseudoHideStyles = function(body) {
  createStyles(body, "." + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + PSEUDO_BEFORE + PSEUDO_HIDE_ELEMENT_STYLE + "\n         ." + PSEUDO_HIDE_ELEMENT_CLASS_AFTER + PSEUDO_AFTER + PSEUDO_HIDE_ELEMENT_STYLE);
};
var createStyles = function(body, styles) {
  var document2 = body.ownerDocument;
  if (document2) {
    var style = document2.createElement("style");
    style.textContent = styles;
    body.appendChild(style);
  }
};
var CacheStorage = (
  /** @class */
  function() {
    function CacheStorage2() {
    }
    CacheStorage2.getOrigin = function(url2) {
      var link = CacheStorage2._link;
      if (!link) {
        return "about:blank";
      }
      link.href = url2;
      link.href = link.href;
      return link.protocol + link.hostname + link.port;
    };
    CacheStorage2.isSameOrigin = function(src) {
      return CacheStorage2.getOrigin(src) === CacheStorage2._origin;
    };
    CacheStorage2.setContext = function(window2) {
      CacheStorage2._link = window2.document.createElement("a");
      CacheStorage2._origin = CacheStorage2.getOrigin(window2.location.href);
    };
    CacheStorage2._origin = "about:blank";
    return CacheStorage2;
  }()
);
var Cache = (
  /** @class */
  function() {
    function Cache2(context, _options) {
      this.context = context;
      this._options = _options;
      this._cache = {};
    }
    Cache2.prototype.addImage = function(src) {
      var result = Promise.resolve();
      if (this.has(src)) {
        return result;
      }
      if (isBlobImage(src) || isRenderable(src)) {
        (this._cache[src] = this.loadImage(src)).catch(function() {
        });
        return result;
      }
      return result;
    };
    Cache2.prototype.match = function(src) {
      return this._cache[src];
    };
    Cache2.prototype.loadImage = function(key) {
      return __awaiter(this, void 0, void 0, function() {
        var isSameOrigin, useCORS, useProxy, src;
        var _this = this;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              isSameOrigin = CacheStorage.isSameOrigin(key);
              useCORS = !isInlineImage(key) && this._options.useCORS === true && FEATURES.SUPPORT_CORS_IMAGES && !isSameOrigin;
              useProxy = !isInlineImage(key) && !isSameOrigin && !isBlobImage(key) && typeof this._options.proxy === "string" && FEATURES.SUPPORT_CORS_XHR && !useCORS;
              if (!isSameOrigin && this._options.allowTaint === false && !isInlineImage(key) && !isBlobImage(key) && !useProxy && !useCORS) {
                return [
                  2
                  /*return*/
                ];
              }
              src = key;
              if (!useProxy) return [3, 2];
              return [4, this.proxy(src)];
            case 1:
              src = _a2.sent();
              _a2.label = 2;
            case 2:
              this.context.logger.debug("Added image " + key.substring(0, 256));
              return [4, new Promise(function(resolve2, reject) {
                var img = new Image();
                img.onload = function() {
                  return resolve2(img);
                };
                img.onerror = reject;
                if (isInlineBase64Image(src) || useCORS) {
                  img.crossOrigin = "anonymous";
                }
                img.src = src;
                if (img.complete === true) {
                  setTimeout(function() {
                    return resolve2(img);
                  }, 500);
                }
                if (_this._options.imageTimeout > 0) {
                  setTimeout(function() {
                    return reject("Timed out (" + _this._options.imageTimeout + "ms) loading image");
                  }, _this._options.imageTimeout);
                }
              })];
            case 3:
              return [2, _a2.sent()];
          }
        });
      });
    };
    Cache2.prototype.has = function(key) {
      return typeof this._cache[key] !== "undefined";
    };
    Cache2.prototype.keys = function() {
      return Promise.resolve(Object.keys(this._cache));
    };
    Cache2.prototype.proxy = function(src) {
      var _this = this;
      var proxy = this._options.proxy;
      if (!proxy) {
        throw new Error("No proxy defined");
      }
      var key = src.substring(0, 256);
      return new Promise(function(resolve2, reject) {
        var responseType = FEATURES.SUPPORT_RESPONSE_TYPE ? "blob" : "text";
        var xhr = new XMLHttpRequest();
        xhr.onload = function() {
          if (xhr.status === 200) {
            if (responseType === "text") {
              resolve2(xhr.response);
            } else {
              var reader_1 = new FileReader();
              reader_1.addEventListener("load", function() {
                return resolve2(reader_1.result);
              }, false);
              reader_1.addEventListener("error", function(e2) {
                return reject(e2);
              }, false);
              reader_1.readAsDataURL(xhr.response);
            }
          } else {
            reject("Failed to proxy resource " + key + " with status code " + xhr.status);
          }
        };
        xhr.onerror = reject;
        var queryString = proxy.indexOf("?") > -1 ? "&" : "?";
        xhr.open("GET", "" + proxy + queryString + "url=" + encodeURIComponent(src) + "&responseType=" + responseType);
        if (responseType !== "text" && xhr instanceof XMLHttpRequest) {
          xhr.responseType = responseType;
        }
        if (_this._options.imageTimeout) {
          var timeout_1 = _this._options.imageTimeout;
          xhr.timeout = timeout_1;
          xhr.ontimeout = function() {
            return reject("Timed out (" + timeout_1 + "ms) proxying " + key);
          };
        }
        xhr.send();
      });
    };
    return Cache2;
  }()
);
var INLINE_SVG = /^data:image\/svg\+xml/i;
var INLINE_BASE64 = /^data:image\/.*;base64,/i;
var INLINE_IMG = /^data:image\/.*/i;
var isRenderable = function(src) {
  return FEATURES.SUPPORT_SVG_DRAWING || !isSVG(src);
};
var isInlineImage = function(src) {
  return INLINE_IMG.test(src);
};
var isInlineBase64Image = function(src) {
  return INLINE_BASE64.test(src);
};
var isBlobImage = function(src) {
  return src.substr(0, 4) === "blob";
};
var isSVG = function(src) {
  return src.substr(-3).toLowerCase() === "svg" || INLINE_SVG.test(src);
};
var Vector = (
  /** @class */
  function() {
    function Vector2(x2, y2) {
      this.type = 0;
      this.x = x2;
      this.y = y2;
    }
    Vector2.prototype.add = function(deltaX, deltaY) {
      return new Vector2(this.x + deltaX, this.y + deltaY);
    };
    return Vector2;
  }()
);
var lerp = function(a2, b2, t2) {
  return new Vector(a2.x + (b2.x - a2.x) * t2, a2.y + (b2.y - a2.y) * t2);
};
var BezierCurve = (
  /** @class */
  function() {
    function BezierCurve2(start, startControl, endControl, end) {
      this.type = 1;
      this.start = start;
      this.startControl = startControl;
      this.endControl = endControl;
      this.end = end;
    }
    BezierCurve2.prototype.subdivide = function(t2, firstHalf) {
      var ab = lerp(this.start, this.startControl, t2);
      var bc = lerp(this.startControl, this.endControl, t2);
      var cd = lerp(this.endControl, this.end, t2);
      var abbc = lerp(ab, bc, t2);
      var bccd = lerp(bc, cd, t2);
      var dest = lerp(abbc, bccd, t2);
      return firstHalf ? new BezierCurve2(this.start, ab, abbc, dest) : new BezierCurve2(dest, bccd, cd, this.end);
    };
    BezierCurve2.prototype.add = function(deltaX, deltaY) {
      return new BezierCurve2(this.start.add(deltaX, deltaY), this.startControl.add(deltaX, deltaY), this.endControl.add(deltaX, deltaY), this.end.add(deltaX, deltaY));
    };
    BezierCurve2.prototype.reverse = function() {
      return new BezierCurve2(this.end, this.endControl, this.startControl, this.start);
    };
    return BezierCurve2;
  }()
);
var isBezierCurve = function(path) {
  return path.type === 1;
};
var BoundCurves = (
  /** @class */
  /* @__PURE__ */ function() {
    function BoundCurves2(element) {
      var styles = element.styles;
      var bounds = element.bounds;
      var _a2 = getAbsoluteValueForTuple(styles.borderTopLeftRadius, bounds.width, bounds.height), tlh = _a2[0], tlv = _a2[1];
      var _b2 = getAbsoluteValueForTuple(styles.borderTopRightRadius, bounds.width, bounds.height), trh = _b2[0], trv = _b2[1];
      var _c = getAbsoluteValueForTuple(styles.borderBottomRightRadius, bounds.width, bounds.height), brh = _c[0], brv = _c[1];
      var _d = getAbsoluteValueForTuple(styles.borderBottomLeftRadius, bounds.width, bounds.height), blh = _d[0], blv = _d[1];
      var factors = [];
      factors.push((tlh + trh) / bounds.width);
      factors.push((blh + brh) / bounds.width);
      factors.push((tlv + blv) / bounds.height);
      factors.push((trv + brv) / bounds.height);
      var maxFactor = Math.max.apply(Math, factors);
      if (maxFactor > 1) {
        tlh /= maxFactor;
        tlv /= maxFactor;
        trh /= maxFactor;
        trv /= maxFactor;
        brh /= maxFactor;
        brv /= maxFactor;
        blh /= maxFactor;
        blv /= maxFactor;
      }
      var topWidth = bounds.width - trh;
      var rightHeight = bounds.height - brv;
      var bottomWidth = bounds.width - brh;
      var leftHeight = bounds.height - blv;
      var borderTopWidth2 = styles.borderTopWidth;
      var borderRightWidth2 = styles.borderRightWidth;
      var borderBottomWidth2 = styles.borderBottomWidth;
      var borderLeftWidth2 = styles.borderLeftWidth;
      var paddingTop2 = getAbsoluteValue(styles.paddingTop, element.bounds.width);
      var paddingRight2 = getAbsoluteValue(styles.paddingRight, element.bounds.width);
      var paddingBottom2 = getAbsoluteValue(styles.paddingBottom, element.bounds.width);
      var paddingLeft2 = getAbsoluteValue(styles.paddingLeft, element.bounds.width);
      this.topLeftBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3, tlh - borderLeftWidth2 / 3, tlv - borderTopWidth2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3);
      this.topRightBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 3, trh - borderRightWidth2 / 3, trv - borderTopWidth2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + borderTopWidth2 / 3);
      this.bottomRightBorderDoubleOuterBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 3, brv - borderBottomWidth2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
      this.bottomLeftBorderDoubleOuterBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 / 3, blv - borderBottomWidth2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
      this.topLeftBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3, tlh - borderLeftWidth2 * 2 / 3, tlv - borderTopWidth2 * 2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
      this.topRightBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 * 2 / 3, trh - borderRightWidth2 * 2 / 3, trv - borderTopWidth2 * 2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
      this.bottomRightBorderDoubleInnerBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 * 2 / 3, brv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
      this.bottomLeftBorderDoubleInnerBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 * 2 / 3, blv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
      this.topLeftBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2, tlh - borderLeftWidth2 / 2, tlv - borderTopWidth2 / 2, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2);
      this.topRightBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 2, trh - borderRightWidth2 / 2, trv - borderTopWidth2 / 2, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + borderTopWidth2 / 2);
      this.bottomRightBorderStroke = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 2, brv - borderBottomWidth2 / 2, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
      this.bottomLeftBorderStroke = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + leftHeight, blh - borderLeftWidth2 / 2, blv - borderBottomWidth2 / 2, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
      this.topLeftBorderBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left, bounds.top, tlh, tlv, CORNER.TOP_LEFT) : new Vector(bounds.left, bounds.top);
      this.topRightBorderBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top, trh, trv, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top);
      this.bottomRightBorderBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh, brv, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top + bounds.height);
      this.bottomLeftBorderBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left, bounds.top + leftHeight, blh, blv, CORNER.BOTTOM_LEFT) : new Vector(bounds.left, bounds.top + bounds.height);
      this.topLeftPaddingBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2, Math.max(0, tlh - borderLeftWidth2), Math.max(0, tlv - borderTopWidth2), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2);
      this.topRightPaddingBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width - borderRightWidth2), bounds.top + borderTopWidth2, topWidth > bounds.width + borderRightWidth2 ? 0 : Math.max(0, trh - borderRightWidth2), Math.max(0, trv - borderTopWidth2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + borderTopWidth2);
      this.bottomRightPaddingBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - borderLeftWidth2), bounds.top + Math.min(rightHeight, bounds.height - borderBottomWidth2), Math.max(0, brh - borderRightWidth2), Math.max(0, brv - borderBottomWidth2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + bounds.height - borderBottomWidth2);
      this.bottomLeftPaddingBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + Math.min(leftHeight, bounds.height - borderBottomWidth2), Math.max(0, blh - borderLeftWidth2), Math.max(0, blv - borderBottomWidth2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + bounds.height - borderBottomWidth2);
      this.topLeftContentBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2, Math.max(0, tlh - (borderLeftWidth2 + paddingLeft2)), Math.max(0, tlv - (borderTopWidth2 + paddingTop2)), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2);
      this.topRightContentBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width + borderLeftWidth2 + paddingLeft2), bounds.top + borderTopWidth2 + paddingTop2, topWidth > bounds.width + borderLeftWidth2 + paddingLeft2 ? 0 : trh - borderLeftWidth2 + paddingLeft2, trv - (borderTopWidth2 + paddingTop2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + borderTopWidth2 + paddingTop2);
      this.bottomRightContentBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - (borderLeftWidth2 + paddingLeft2)), bounds.top + Math.min(rightHeight, bounds.height + borderTopWidth2 + paddingTop2), Math.max(0, brh - (borderRightWidth2 + paddingRight2)), brv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
      this.bottomLeftContentBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + leftHeight, Math.max(0, blh - (borderLeftWidth2 + paddingLeft2)), blv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
    }
    return BoundCurves2;
  }()
);
var CORNER;
(function(CORNER2) {
  CORNER2[CORNER2["TOP_LEFT"] = 0] = "TOP_LEFT";
  CORNER2[CORNER2["TOP_RIGHT"] = 1] = "TOP_RIGHT";
  CORNER2[CORNER2["BOTTOM_RIGHT"] = 2] = "BOTTOM_RIGHT";
  CORNER2[CORNER2["BOTTOM_LEFT"] = 3] = "BOTTOM_LEFT";
})(CORNER || (CORNER = {}));
var getCurvePoints = function(x2, y2, r1, r2, position2) {
  var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
  var ox = r1 * kappa;
  var oy = r2 * kappa;
  var xm = x2 + r1;
  var ym = y2 + r2;
  switch (position2) {
    case CORNER.TOP_LEFT:
      return new BezierCurve(new Vector(x2, ym), new Vector(x2, ym - oy), new Vector(xm - ox, y2), new Vector(xm, y2));
    case CORNER.TOP_RIGHT:
      return new BezierCurve(new Vector(x2, y2), new Vector(x2 + ox, y2), new Vector(xm, ym - oy), new Vector(xm, ym));
    case CORNER.BOTTOM_RIGHT:
      return new BezierCurve(new Vector(xm, y2), new Vector(xm, y2 + oy), new Vector(x2 + ox, ym), new Vector(x2, ym));
    case CORNER.BOTTOM_LEFT:
    default:
      return new BezierCurve(new Vector(xm, ym), new Vector(xm - ox, ym), new Vector(x2, y2 + oy), new Vector(x2, y2));
  }
};
var calculateBorderBoxPath = function(curves) {
  return [curves.topLeftBorderBox, curves.topRightBorderBox, curves.bottomRightBorderBox, curves.bottomLeftBorderBox];
};
var calculateContentBoxPath = function(curves) {
  return [
    curves.topLeftContentBox,
    curves.topRightContentBox,
    curves.bottomRightContentBox,
    curves.bottomLeftContentBox
  ];
};
var calculatePaddingBoxPath = function(curves) {
  return [
    curves.topLeftPaddingBox,
    curves.topRightPaddingBox,
    curves.bottomRightPaddingBox,
    curves.bottomLeftPaddingBox
  ];
};
var TransformEffect = (
  /** @class */
  /* @__PURE__ */ function() {
    function TransformEffect2(offsetX, offsetY, matrix2) {
      this.offsetX = offsetX;
      this.offsetY = offsetY;
      this.matrix = matrix2;
      this.type = 0;
      this.target = 2 | 4;
    }
    return TransformEffect2;
  }()
);
var ClipEffect = (
  /** @class */
  /* @__PURE__ */ function() {
    function ClipEffect2(path, target2) {
      this.path = path;
      this.target = target2;
      this.type = 1;
    }
    return ClipEffect2;
  }()
);
var OpacityEffect = (
  /** @class */
  /* @__PURE__ */ function() {
    function OpacityEffect2(opacity2) {
      this.opacity = opacity2;
      this.type = 2;
      this.target = 2 | 4;
    }
    return OpacityEffect2;
  }()
);
var isTransformEffect = function(effect) {
  return effect.type === 0;
};
var isClipEffect = function(effect) {
  return effect.type === 1;
};
var isOpacityEffect = function(effect) {
  return effect.type === 2;
};
var equalPath = function(a2, b2) {
  if (a2.length === b2.length) {
    return a2.some(function(v2, i) {
      return v2 === b2[i];
    });
  }
  return false;
};
var transformPath = function(path, deltaX, deltaY, deltaW, deltaH) {
  return path.map(function(point, index) {
    switch (index) {
      case 0:
        return point.add(deltaX, deltaY);
      case 1:
        return point.add(deltaX + deltaW, deltaY);
      case 2:
        return point.add(deltaX + deltaW, deltaY + deltaH);
      case 3:
        return point.add(deltaX, deltaY + deltaH);
    }
    return point;
  });
};
var StackingContext = (
  /** @class */
  /* @__PURE__ */ function() {
    function StackingContext2(container) {
      this.element = container;
      this.inlineLevel = [];
      this.nonInlineLevel = [];
      this.negativeZIndex = [];
      this.zeroOrAutoZIndexOrTransformedOrOpacity = [];
      this.positiveZIndex = [];
      this.nonPositionedFloats = [];
      this.nonPositionedInlineLevel = [];
    }
    return StackingContext2;
  }()
);
var ElementPaint = (
  /** @class */
  function() {
    function ElementPaint2(container, parent) {
      this.container = container;
      this.parent = parent;
      this.effects = [];
      this.curves = new BoundCurves(this.container);
      if (this.container.styles.opacity < 1) {
        this.effects.push(new OpacityEffect(this.container.styles.opacity));
      }
      if (this.container.styles.transform !== null) {
        var offsetX = this.container.bounds.left + this.container.styles.transformOrigin[0].number;
        var offsetY = this.container.bounds.top + this.container.styles.transformOrigin[1].number;
        var matrix2 = this.container.styles.transform;
        this.effects.push(new TransformEffect(offsetX, offsetY, matrix2));
      }
      if (this.container.styles.overflowX !== 0) {
        var borderBox = calculateBorderBoxPath(this.curves);
        var paddingBox2 = calculatePaddingBoxPath(this.curves);
        if (equalPath(borderBox, paddingBox2)) {
          this.effects.push(new ClipEffect(
            borderBox,
            2 | 4
            /* CONTENT */
          ));
        } else {
          this.effects.push(new ClipEffect(
            borderBox,
            2
            /* BACKGROUND_BORDERS */
          ));
          this.effects.push(new ClipEffect(
            paddingBox2,
            4
            /* CONTENT */
          ));
        }
      }
    }
    ElementPaint2.prototype.getEffects = function(target2) {
      var inFlow = [
        2,
        3
        /* FIXED */
      ].indexOf(this.container.styles.position) === -1;
      var parent = this.parent;
      var effects = this.effects.slice(0);
      while (parent) {
        var croplessEffects = parent.effects.filter(function(effect) {
          return !isClipEffect(effect);
        });
        if (inFlow || parent.container.styles.position !== 0 || !parent.parent) {
          effects.unshift.apply(effects, croplessEffects);
          inFlow = [
            2,
            3
            /* FIXED */
          ].indexOf(parent.container.styles.position) === -1;
          if (parent.container.styles.overflowX !== 0) {
            var borderBox = calculateBorderBoxPath(parent.curves);
            var paddingBox2 = calculatePaddingBoxPath(parent.curves);
            if (!equalPath(borderBox, paddingBox2)) {
              effects.unshift(new ClipEffect(
                paddingBox2,
                2 | 4
                /* CONTENT */
              ));
            }
          }
        } else {
          effects.unshift.apply(effects, croplessEffects);
        }
        parent = parent.parent;
      }
      return effects.filter(function(effect) {
        return contains(effect.target, target2);
      });
    };
    return ElementPaint2;
  }()
);
var parseStackTree = function(parent, stackingContext, realStackingContext, listItems) {
  parent.container.elements.forEach(function(child) {
    var treatAsRealStackingContext = contains(
      child.flags,
      4
      /* CREATES_REAL_STACKING_CONTEXT */
    );
    var createsStackingContext2 = contains(
      child.flags,
      2
      /* CREATES_STACKING_CONTEXT */
    );
    var paintContainer = new ElementPaint(child, parent);
    if (contains(
      child.styles.display,
      2048
      /* LIST_ITEM */
    )) {
      listItems.push(paintContainer);
    }
    var listOwnerItems = contains(
      child.flags,
      8
      /* IS_LIST_OWNER */
    ) ? [] : listItems;
    if (treatAsRealStackingContext || createsStackingContext2) {
      var parentStack = treatAsRealStackingContext || child.styles.isPositioned() ? realStackingContext : stackingContext;
      var stack2 = new StackingContext(paintContainer);
      if (child.styles.isPositioned() || child.styles.opacity < 1 || child.styles.isTransformed()) {
        var order_1 = child.styles.zIndex.order;
        if (order_1 < 0) {
          var index_1 = 0;
          parentStack.negativeZIndex.some(function(current, i) {
            if (order_1 > current.element.container.styles.zIndex.order) {
              index_1 = i;
              return false;
            } else if (index_1 > 0) {
              return true;
            }
            return false;
          });
          parentStack.negativeZIndex.splice(index_1, 0, stack2);
        } else if (order_1 > 0) {
          var index_2 = 0;
          parentStack.positiveZIndex.some(function(current, i) {
            if (order_1 >= current.element.container.styles.zIndex.order) {
              index_2 = i + 1;
              return false;
            } else if (index_2 > 0) {
              return true;
            }
            return false;
          });
          parentStack.positiveZIndex.splice(index_2, 0, stack2);
        } else {
          parentStack.zeroOrAutoZIndexOrTransformedOrOpacity.push(stack2);
        }
      } else {
        if (child.styles.isFloating()) {
          parentStack.nonPositionedFloats.push(stack2);
        } else {
          parentStack.nonPositionedInlineLevel.push(stack2);
        }
      }
      parseStackTree(paintContainer, stack2, treatAsRealStackingContext ? stack2 : realStackingContext, listOwnerItems);
    } else {
      if (child.styles.isInlineLevel()) {
        stackingContext.inlineLevel.push(paintContainer);
      } else {
        stackingContext.nonInlineLevel.push(paintContainer);
      }
      parseStackTree(paintContainer, stackingContext, realStackingContext, listOwnerItems);
    }
    if (contains(
      child.flags,
      8
      /* IS_LIST_OWNER */
    )) {
      processListItems(child, listOwnerItems);
    }
  });
};
var processListItems = function(owner, elements) {
  var numbering = owner instanceof OLElementContainer ? owner.start : 1;
  var reversed = owner instanceof OLElementContainer ? owner.reversed : false;
  for (var i = 0; i < elements.length; i++) {
    var item = elements[i];
    if (item.container instanceof LIElementContainer && typeof item.container.value === "number" && item.container.value !== 0) {
      numbering = item.container.value;
    }
    item.listValue = createCounterText(numbering, item.container.styles.listStyleType, true);
    numbering += reversed ? -1 : 1;
  }
};
var parseStackingContexts = function(container) {
  var paintContainer = new ElementPaint(container, null);
  var root = new StackingContext(paintContainer);
  var listItems = [];
  parseStackTree(paintContainer, root, root, listItems);
  processListItems(paintContainer.container, listItems);
  return root;
};
var parsePathForBorder = function(curves, borderSide) {
  switch (borderSide) {
    case 0:
      return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftPaddingBox, curves.topRightBorderBox, curves.topRightPaddingBox);
    case 1:
      return createPathFromCurves(curves.topRightBorderBox, curves.topRightPaddingBox, curves.bottomRightBorderBox, curves.bottomRightPaddingBox);
    case 2:
      return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox);
    case 3:
    default:
      return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox, curves.topLeftBorderBox, curves.topLeftPaddingBox);
  }
};
var parsePathForBorderDoubleOuter = function(curves, borderSide) {
  switch (borderSide) {
    case 0:
      return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox, curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox);
    case 1:
      return createPathFromCurves(curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox, curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox);
    case 2:
      return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox, curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox);
    case 3:
    default:
      return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox, curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox);
  }
};
var parsePathForBorderDoubleInner = function(curves, borderSide) {
  switch (borderSide) {
    case 0:
      return createPathFromCurves(curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox, curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox);
    case 1:
      return createPathFromCurves(curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox, curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox);
    case 2:
      return createPathFromCurves(curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox);
    case 3:
    default:
      return createPathFromCurves(curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox, curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox);
  }
};
var parsePathForBorderStroke = function(curves, borderSide) {
  switch (borderSide) {
    case 0:
      return createStrokePathFromCurves(curves.topLeftBorderStroke, curves.topRightBorderStroke);
    case 1:
      return createStrokePathFromCurves(curves.topRightBorderStroke, curves.bottomRightBorderStroke);
    case 2:
      return createStrokePathFromCurves(curves.bottomRightBorderStroke, curves.bottomLeftBorderStroke);
    case 3:
    default:
      return createStrokePathFromCurves(curves.bottomLeftBorderStroke, curves.topLeftBorderStroke);
  }
};
var createStrokePathFromCurves = function(outer1, outer2) {
  var path = [];
  if (isBezierCurve(outer1)) {
    path.push(outer1.subdivide(0.5, false));
  } else {
    path.push(outer1);
  }
  if (isBezierCurve(outer2)) {
    path.push(outer2.subdivide(0.5, true));
  } else {
    path.push(outer2);
  }
  return path;
};
var createPathFromCurves = function(outer1, inner1, outer2, inner2) {
  var path = [];
  if (isBezierCurve(outer1)) {
    path.push(outer1.subdivide(0.5, false));
  } else {
    path.push(outer1);
  }
  if (isBezierCurve(outer2)) {
    path.push(outer2.subdivide(0.5, true));
  } else {
    path.push(outer2);
  }
  if (isBezierCurve(inner2)) {
    path.push(inner2.subdivide(0.5, true).reverse());
  } else {
    path.push(inner2);
  }
  if (isBezierCurve(inner1)) {
    path.push(inner1.subdivide(0.5, false).reverse());
  } else {
    path.push(inner1);
  }
  return path;
};
var paddingBox = function(element) {
  var bounds = element.bounds;
  var styles = element.styles;
  return bounds.add(styles.borderLeftWidth, styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth), -(styles.borderTopWidth + styles.borderBottomWidth));
};
var contentBox = function(element) {
  var styles = element.styles;
  var bounds = element.bounds;
  var paddingLeft2 = getAbsoluteValue(styles.paddingLeft, bounds.width);
  var paddingRight2 = getAbsoluteValue(styles.paddingRight, bounds.width);
  var paddingTop2 = getAbsoluteValue(styles.paddingTop, bounds.width);
  var paddingBottom2 = getAbsoluteValue(styles.paddingBottom, bounds.width);
  return bounds.add(paddingLeft2 + styles.borderLeftWidth, paddingTop2 + styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth + paddingLeft2 + paddingRight2), -(styles.borderTopWidth + styles.borderBottomWidth + paddingTop2 + paddingBottom2));
};
var calculateBackgroundPositioningArea = function(backgroundOrigin2, element) {
  if (backgroundOrigin2 === 0) {
    return element.bounds;
  }
  if (backgroundOrigin2 === 2) {
    return contentBox(element);
  }
  return paddingBox(element);
};
var calculateBackgroundPaintingArea = function(backgroundClip2, element) {
  if (backgroundClip2 === 0) {
    return element.bounds;
  }
  if (backgroundClip2 === 2) {
    return contentBox(element);
  }
  return paddingBox(element);
};
var calculateBackgroundRendering = function(container, index, intrinsicSize) {
  var backgroundPositioningArea = calculateBackgroundPositioningArea(getBackgroundValueForIndex(container.styles.backgroundOrigin, index), container);
  var backgroundPaintingArea = calculateBackgroundPaintingArea(getBackgroundValueForIndex(container.styles.backgroundClip, index), container);
  var backgroundImageSize = calculateBackgroundSize(getBackgroundValueForIndex(container.styles.backgroundSize, index), intrinsicSize, backgroundPositioningArea);
  var sizeWidth = backgroundImageSize[0], sizeHeight = backgroundImageSize[1];
  var position2 = getAbsoluteValueForTuple(getBackgroundValueForIndex(container.styles.backgroundPosition, index), backgroundPositioningArea.width - sizeWidth, backgroundPositioningArea.height - sizeHeight);
  var path = calculateBackgroundRepeatPath(getBackgroundValueForIndex(container.styles.backgroundRepeat, index), position2, backgroundImageSize, backgroundPositioningArea, backgroundPaintingArea);
  var offsetX = Math.round(backgroundPositioningArea.left + position2[0]);
  var offsetY = Math.round(backgroundPositioningArea.top + position2[1]);
  return [path, offsetX, offsetY, sizeWidth, sizeHeight];
};
var isAuto = function(token2) {
  return isIdentToken(token2) && token2.value === BACKGROUND_SIZE.AUTO;
};
var hasIntrinsicValue = function(value2) {
  return typeof value2 === "number";
};
var calculateBackgroundSize = function(size2, _a2, bounds) {
  var intrinsicWidth = _a2[0], intrinsicHeight = _a2[1], intrinsicProportion = _a2[2];
  var first = size2[0], second = size2[1];
  if (!first) {
    return [0, 0];
  }
  if (isLengthPercentage(first) && second && isLengthPercentage(second)) {
    return [getAbsoluteValue(first, bounds.width), getAbsoluteValue(second, bounds.height)];
  }
  var hasIntrinsicProportion = hasIntrinsicValue(intrinsicProportion);
  if (isIdentToken(first) && (first.value === BACKGROUND_SIZE.CONTAIN || first.value === BACKGROUND_SIZE.COVER)) {
    if (hasIntrinsicValue(intrinsicProportion)) {
      var targetRatio = bounds.width / bounds.height;
      return targetRatio < intrinsicProportion !== (first.value === BACKGROUND_SIZE.COVER) ? [bounds.width, bounds.width / intrinsicProportion] : [bounds.height * intrinsicProportion, bounds.height];
    }
    return [bounds.width, bounds.height];
  }
  var hasIntrinsicWidth = hasIntrinsicValue(intrinsicWidth);
  var hasIntrinsicHeight = hasIntrinsicValue(intrinsicHeight);
  var hasIntrinsicDimensions = hasIntrinsicWidth || hasIntrinsicHeight;
  if (isAuto(first) && (!second || isAuto(second))) {
    if (hasIntrinsicWidth && hasIntrinsicHeight) {
      return [intrinsicWidth, intrinsicHeight];
    }
    if (!hasIntrinsicProportion && !hasIntrinsicDimensions) {
      return [bounds.width, bounds.height];
    }
    if (hasIntrinsicDimensions && hasIntrinsicProportion) {
      var width_1 = hasIntrinsicWidth ? intrinsicWidth : intrinsicHeight * intrinsicProportion;
      var height_1 = hasIntrinsicHeight ? intrinsicHeight : intrinsicWidth / intrinsicProportion;
      return [width_1, height_1];
    }
    var width_2 = hasIntrinsicWidth ? intrinsicWidth : bounds.width;
    var height_2 = hasIntrinsicHeight ? intrinsicHeight : bounds.height;
    return [width_2, height_2];
  }
  if (hasIntrinsicProportion) {
    var width_3 = 0;
    var height_3 = 0;
    if (isLengthPercentage(first)) {
      width_3 = getAbsoluteValue(first, bounds.width);
    } else if (isLengthPercentage(second)) {
      height_3 = getAbsoluteValue(second, bounds.height);
    }
    if (isAuto(first)) {
      width_3 = height_3 * intrinsicProportion;
    } else if (!second || isAuto(second)) {
      height_3 = width_3 / intrinsicProportion;
    }
    return [width_3, height_3];
  }
  var width2 = null;
  var height = null;
  if (isLengthPercentage(first)) {
    width2 = getAbsoluteValue(first, bounds.width);
  } else if (second && isLengthPercentage(second)) {
    height = getAbsoluteValue(second, bounds.height);
  }
  if (width2 !== null && (!second || isAuto(second))) {
    height = hasIntrinsicWidth && hasIntrinsicHeight ? width2 / intrinsicWidth * intrinsicHeight : bounds.height;
  }
  if (height !== null && isAuto(first)) {
    width2 = hasIntrinsicWidth && hasIntrinsicHeight ? height / intrinsicHeight * intrinsicWidth : bounds.width;
  }
  if (width2 !== null && height !== null) {
    return [width2, height];
  }
  throw new Error("Unable to calculate background-size for element");
};
var getBackgroundValueForIndex = function(values, index) {
  var value2 = values[index];
  if (typeof value2 === "undefined") {
    return values[0];
  }
  return value2;
};
var calculateBackgroundRepeatPath = function(repeat, _a2, _b2, backgroundPositioningArea, backgroundPaintingArea) {
  var x2 = _a2[0], y2 = _a2[1];
  var width2 = _b2[0], height = _b2[1];
  switch (repeat) {
    case 2:
      return [
        new Vector(Math.round(backgroundPositioningArea.left), Math.round(backgroundPositioningArea.top + y2)),
        new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(backgroundPositioningArea.top + y2)),
        new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(height + backgroundPositioningArea.top + y2)),
        new Vector(Math.round(backgroundPositioningArea.left), Math.round(height + backgroundPositioningArea.top + y2))
      ];
    case 3:
      return [
        new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top)),
        new Vector(Math.round(backgroundPositioningArea.left + x2 + width2), Math.round(backgroundPositioningArea.top)),
        new Vector(Math.round(backgroundPositioningArea.left + x2 + width2), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top)),
        new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top))
      ];
    case 1:
      return [
        new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top + y2)),
        new Vector(Math.round(backgroundPositioningArea.left + x2 + width2), Math.round(backgroundPositioningArea.top + y2)),
        new Vector(Math.round(backgroundPositioningArea.left + x2 + width2), Math.round(backgroundPositioningArea.top + y2 + height)),
        new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top + y2 + height))
      ];
    default:
      return [
        new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.top)),
        new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.top)),
        new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top)),
        new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top))
      ];
  }
};
var SMALL_IMAGE = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
var SAMPLE_TEXT = "Hidden Text";
var FontMetrics = (
  /** @class */
  function() {
    function FontMetrics2(document2) {
      this._data = {};
      this._document = document2;
    }
    FontMetrics2.prototype.parseMetrics = function(fontFamily2, fontSize2) {
      var container = this._document.createElement("div");
      var img = this._document.createElement("img");
      var span = this._document.createElement("span");
      var body = this._document.body;
      container.style.visibility = "hidden";
      container.style.fontFamily = fontFamily2;
      container.style.fontSize = fontSize2;
      container.style.margin = "0";
      container.style.padding = "0";
      container.style.whiteSpace = "nowrap";
      body.appendChild(container);
      img.src = SMALL_IMAGE;
      img.width = 1;
      img.height = 1;
      img.style.margin = "0";
      img.style.padding = "0";
      img.style.verticalAlign = "baseline";
      span.style.fontFamily = fontFamily2;
      span.style.fontSize = fontSize2;
      span.style.margin = "0";
      span.style.padding = "0";
      span.appendChild(this._document.createTextNode(SAMPLE_TEXT));
      container.appendChild(span);
      container.appendChild(img);
      var baseline = img.offsetTop - span.offsetTop + 2;
      container.removeChild(span);
      container.appendChild(this._document.createTextNode(SAMPLE_TEXT));
      container.style.lineHeight = "normal";
      img.style.verticalAlign = "super";
      var middle = img.offsetTop - container.offsetTop + 2;
      body.removeChild(container);
      return { baseline, middle };
    };
    FontMetrics2.prototype.getMetrics = function(fontFamily2, fontSize2) {
      var key = fontFamily2 + " " + fontSize2;
      if (typeof this._data[key] === "undefined") {
        this._data[key] = this.parseMetrics(fontFamily2, fontSize2);
      }
      return this._data[key];
    };
    return FontMetrics2;
  }()
);
var Renderer = (
  /** @class */
  /* @__PURE__ */ function() {
    function Renderer2(context, options) {
      this.context = context;
      this.options = options;
    }
    return Renderer2;
  }()
);
var MASK_OFFSET = 1e4;
var CanvasRenderer = (
  /** @class */
  function(_super) {
    __extends(CanvasRenderer2, _super);
    function CanvasRenderer2(context, options) {
      var _this = _super.call(this, context, options) || this;
      _this._activeEffects = [];
      _this.canvas = options.canvas ? options.canvas : document.createElement("canvas");
      _this.ctx = _this.canvas.getContext("2d");
      if (!options.canvas) {
        _this.canvas.width = Math.floor(options.width * options.scale);
        _this.canvas.height = Math.floor(options.height * options.scale);
        _this.canvas.style.width = options.width + "px";
        _this.canvas.style.height = options.height + "px";
      }
      _this.fontMetrics = new FontMetrics(document);
      _this.ctx.scale(_this.options.scale, _this.options.scale);
      _this.ctx.translate(-options.x, -options.y);
      _this.ctx.textBaseline = "bottom";
      _this._activeEffects = [];
      _this.context.logger.debug("Canvas renderer initialized (" + options.width + "x" + options.height + ") with scale " + options.scale);
      return _this;
    }
    CanvasRenderer2.prototype.applyEffects = function(effects) {
      var _this = this;
      while (this._activeEffects.length) {
        this.popEffect();
      }
      effects.forEach(function(effect) {
        return _this.applyEffect(effect);
      });
    };
    CanvasRenderer2.prototype.applyEffect = function(effect) {
      this.ctx.save();
      if (isOpacityEffect(effect)) {
        this.ctx.globalAlpha = effect.opacity;
      }
      if (isTransformEffect(effect)) {
        this.ctx.translate(effect.offsetX, effect.offsetY);
        this.ctx.transform(effect.matrix[0], effect.matrix[1], effect.matrix[2], effect.matrix[3], effect.matrix[4], effect.matrix[5]);
        this.ctx.translate(-effect.offsetX, -effect.offsetY);
      }
      if (isClipEffect(effect)) {
        this.path(effect.path);
        this.ctx.clip();
      }
      this._activeEffects.push(effect);
    };
    CanvasRenderer2.prototype.popEffect = function() {
      this._activeEffects.pop();
      this.ctx.restore();
    };
    CanvasRenderer2.prototype.renderStack = function(stack2) {
      return __awaiter(this, void 0, void 0, function() {
        var styles;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              styles = stack2.element.container.styles;
              if (!styles.isVisible()) return [3, 2];
              return [4, this.renderStackContent(stack2)];
            case 1:
              _a2.sent();
              _a2.label = 2;
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    CanvasRenderer2.prototype.renderNode = function(paint) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (contains(
                paint.container.flags,
                16
                /* DEBUG_RENDER */
              )) {
                debugger;
              }
              if (!paint.container.styles.isVisible()) return [3, 3];
              return [4, this.renderNodeBackgroundAndBorders(paint)];
            case 1:
              _a2.sent();
              return [4, this.renderNodeContent(paint)];
            case 2:
              _a2.sent();
              _a2.label = 3;
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    CanvasRenderer2.prototype.renderTextWithLetterSpacing = function(text, letterSpacing2, baseline) {
      var _this = this;
      if (letterSpacing2 === 0) {
        this.ctx.fillText(text.text, text.bounds.left, text.bounds.top + baseline);
      } else {
        var letters = segmentGraphemes(text.text);
        letters.reduce(function(left, letter) {
          _this.ctx.fillText(letter, left, text.bounds.top + baseline);
          return left + _this.ctx.measureText(letter).width;
        }, text.bounds.left);
      }
    };
    CanvasRenderer2.prototype.createFontStyle = function(styles) {
      var fontVariant2 = styles.fontVariant.filter(function(variant) {
        return variant === "normal" || variant === "small-caps";
      }).join("");
      var fontFamily2 = fixIOSSystemFonts(styles.fontFamily).join(", ");
      var fontSize2 = isDimensionToken(styles.fontSize) ? "" + styles.fontSize.number + styles.fontSize.unit : styles.fontSize.number + "px";
      return [
        [styles.fontStyle, fontVariant2, styles.fontWeight, fontSize2, fontFamily2].join(" "),
        fontFamily2,
        fontSize2
      ];
    };
    CanvasRenderer2.prototype.renderTextNode = function(text, styles) {
      return __awaiter(this, void 0, void 0, function() {
        var _a2, font, fontFamily2, fontSize2, _b2, baseline, middle, paintOrder2;
        var _this = this;
        return __generator(this, function(_c) {
          _a2 = this.createFontStyle(styles), font = _a2[0], fontFamily2 = _a2[1], fontSize2 = _a2[2];
          this.ctx.font = font;
          this.ctx.direction = styles.direction === 1 ? "rtl" : "ltr";
          this.ctx.textAlign = "left";
          this.ctx.textBaseline = "alphabetic";
          _b2 = this.fontMetrics.getMetrics(fontFamily2, fontSize2), baseline = _b2.baseline, middle = _b2.middle;
          paintOrder2 = styles.paintOrder;
          text.textBounds.forEach(function(text2) {
            paintOrder2.forEach(function(paintOrderLayer) {
              switch (paintOrderLayer) {
                case 0:
                  _this.ctx.fillStyle = asString(styles.color);
                  _this.renderTextWithLetterSpacing(text2, styles.letterSpacing, baseline);
                  var textShadows = styles.textShadow;
                  if (textShadows.length && text2.text.trim().length) {
                    textShadows.slice(0).reverse().forEach(function(textShadow2) {
                      _this.ctx.shadowColor = asString(textShadow2.color);
                      _this.ctx.shadowOffsetX = textShadow2.offsetX.number * _this.options.scale;
                      _this.ctx.shadowOffsetY = textShadow2.offsetY.number * _this.options.scale;
                      _this.ctx.shadowBlur = textShadow2.blur.number;
                      _this.renderTextWithLetterSpacing(text2, styles.letterSpacing, baseline);
                    });
                    _this.ctx.shadowColor = "";
                    _this.ctx.shadowOffsetX = 0;
                    _this.ctx.shadowOffsetY = 0;
                    _this.ctx.shadowBlur = 0;
                  }
                  if (styles.textDecorationLine.length) {
                    _this.ctx.fillStyle = asString(styles.textDecorationColor || styles.color);
                    styles.textDecorationLine.forEach(function(textDecorationLine2) {
                      switch (textDecorationLine2) {
                        case 1:
                          _this.ctx.fillRect(text2.bounds.left, Math.round(text2.bounds.top + baseline), text2.bounds.width, 1);
                          break;
                        case 2:
                          _this.ctx.fillRect(text2.bounds.left, Math.round(text2.bounds.top), text2.bounds.width, 1);
                          break;
                        case 3:
                          _this.ctx.fillRect(text2.bounds.left, Math.ceil(text2.bounds.top + middle), text2.bounds.width, 1);
                          break;
                      }
                    });
                  }
                  break;
                case 1:
                  if (styles.webkitTextStrokeWidth && text2.text.trim().length) {
                    _this.ctx.strokeStyle = asString(styles.webkitTextStrokeColor);
                    _this.ctx.lineWidth = styles.webkitTextStrokeWidth;
                    _this.ctx.lineJoin = !!window.chrome ? "miter" : "round";
                    _this.ctx.strokeText(text2.text, text2.bounds.left, text2.bounds.top + baseline);
                  }
                  _this.ctx.strokeStyle = "";
                  _this.ctx.lineWidth = 0;
                  _this.ctx.lineJoin = "miter";
                  break;
              }
            });
          });
          return [
            2
            /*return*/
          ];
        });
      });
    };
    CanvasRenderer2.prototype.renderReplacedElement = function(container, curves, image2) {
      if (image2 && container.intrinsicWidth > 0 && container.intrinsicHeight > 0) {
        var box = contentBox(container);
        var path = calculatePaddingBoxPath(curves);
        this.path(path);
        this.ctx.save();
        this.ctx.clip();
        this.ctx.drawImage(image2, 0, 0, container.intrinsicWidth, container.intrinsicHeight, box.left, box.top, box.width, box.height);
        this.ctx.restore();
      }
    };
    CanvasRenderer2.prototype.renderNodeContent = function(paint) {
      return __awaiter(this, void 0, void 0, function() {
        var container, curves, styles, _i, _a2, child, image2, image2, iframeRenderer, canvas, size2, _b2, fontFamily2, fontSize2, baseline, bounds, x2, textBounds, img, image2, url2, fontFamily2, bounds;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              this.applyEffects(paint.getEffects(
                4
                /* CONTENT */
              ));
              container = paint.container;
              curves = paint.curves;
              styles = container.styles;
              _i = 0, _a2 = container.textNodes;
              _c.label = 1;
            case 1:
              if (!(_i < _a2.length)) return [3, 4];
              child = _a2[_i];
              return [4, this.renderTextNode(child, styles)];
            case 2:
              _c.sent();
              _c.label = 3;
            case 3:
              _i++;
              return [3, 1];
            case 4:
              if (!(container instanceof ImageElementContainer)) return [3, 8];
              _c.label = 5;
            case 5:
              _c.trys.push([5, 7, , 8]);
              return [4, this.context.cache.match(container.src)];
            case 6:
              image2 = _c.sent();
              this.renderReplacedElement(container, curves, image2);
              return [3, 8];
            case 7:
              _c.sent();
              this.context.logger.error("Error loading image " + container.src);
              return [3, 8];
            case 8:
              if (container instanceof CanvasElementContainer) {
                this.renderReplacedElement(container, curves, container.canvas);
              }
              if (!(container instanceof SVGElementContainer)) return [3, 12];
              _c.label = 9;
            case 9:
              _c.trys.push([9, 11, , 12]);
              return [4, this.context.cache.match(container.svg)];
            case 10:
              image2 = _c.sent();
              this.renderReplacedElement(container, curves, image2);
              return [3, 12];
            case 11:
              _c.sent();
              this.context.logger.error("Error loading svg " + container.svg.substring(0, 255));
              return [3, 12];
            case 12:
              if (!(container instanceof IFrameElementContainer && container.tree)) return [3, 14];
              iframeRenderer = new CanvasRenderer2(this.context, {
                scale: this.options.scale,
                backgroundColor: container.backgroundColor,
                x: 0,
                y: 0,
                width: container.width,
                height: container.height
              });
              return [4, iframeRenderer.render(container.tree)];
            case 13:
              canvas = _c.sent();
              if (container.width && container.height) {
                this.ctx.drawImage(canvas, 0, 0, container.width, container.height, container.bounds.left, container.bounds.top, container.bounds.width, container.bounds.height);
              }
              _c.label = 14;
            case 14:
              if (container instanceof InputElementContainer) {
                size2 = Math.min(container.bounds.width, container.bounds.height);
                if (container.type === CHECKBOX) {
                  if (container.checked) {
                    this.ctx.save();
                    this.path([
                      new Vector(container.bounds.left + size2 * 0.39363, container.bounds.top + size2 * 0.79),
                      new Vector(container.bounds.left + size2 * 0.16, container.bounds.top + size2 * 0.5549),
                      new Vector(container.bounds.left + size2 * 0.27347, container.bounds.top + size2 * 0.44071),
                      new Vector(container.bounds.left + size2 * 0.39694, container.bounds.top + size2 * 0.5649),
                      new Vector(container.bounds.left + size2 * 0.72983, container.bounds.top + size2 * 0.23),
                      new Vector(container.bounds.left + size2 * 0.84, container.bounds.top + size2 * 0.34085),
                      new Vector(container.bounds.left + size2 * 0.39363, container.bounds.top + size2 * 0.79)
                    ]);
                    this.ctx.fillStyle = asString(INPUT_COLOR);
                    this.ctx.fill();
                    this.ctx.restore();
                  }
                } else if (container.type === RADIO) {
                  if (container.checked) {
                    this.ctx.save();
                    this.ctx.beginPath();
                    this.ctx.arc(container.bounds.left + size2 / 2, container.bounds.top + size2 / 2, size2 / 4, 0, Math.PI * 2, true);
                    this.ctx.fillStyle = asString(INPUT_COLOR);
                    this.ctx.fill();
                    this.ctx.restore();
                  }
                }
              }
              if (isTextInputElement(container) && container.value.length) {
                _b2 = this.createFontStyle(styles), fontFamily2 = _b2[0], fontSize2 = _b2[1];
                baseline = this.fontMetrics.getMetrics(fontFamily2, fontSize2).baseline;
                this.ctx.font = fontFamily2;
                this.ctx.fillStyle = asString(styles.color);
                this.ctx.textBaseline = "alphabetic";
                this.ctx.textAlign = canvasTextAlign(container.styles.textAlign);
                bounds = contentBox(container);
                x2 = 0;
                switch (container.styles.textAlign) {
                  case 1:
                    x2 += bounds.width / 2;
                    break;
                  case 2:
                    x2 += bounds.width;
                    break;
                }
                textBounds = bounds.add(x2, 0, 0, -bounds.height / 2 + 1);
                this.ctx.save();
                this.path([
                  new Vector(bounds.left, bounds.top),
                  new Vector(bounds.left + bounds.width, bounds.top),
                  new Vector(bounds.left + bounds.width, bounds.top + bounds.height),
                  new Vector(bounds.left, bounds.top + bounds.height)
                ]);
                this.ctx.clip();
                this.renderTextWithLetterSpacing(new TextBounds(container.value, textBounds), styles.letterSpacing, baseline);
                this.ctx.restore();
                this.ctx.textBaseline = "alphabetic";
                this.ctx.textAlign = "left";
              }
              if (!contains(
                container.styles.display,
                2048
                /* LIST_ITEM */
              )) return [3, 20];
              if (!(container.styles.listStyleImage !== null)) return [3, 19];
              img = container.styles.listStyleImage;
              if (!(img.type === 0)) return [3, 18];
              image2 = void 0;
              url2 = img.url;
              _c.label = 15;
            case 15:
              _c.trys.push([15, 17, , 18]);
              return [4, this.context.cache.match(url2)];
            case 16:
              image2 = _c.sent();
              this.ctx.drawImage(image2, container.bounds.left - (image2.width + 10), container.bounds.top);
              return [3, 18];
            case 17:
              _c.sent();
              this.context.logger.error("Error loading list-style-image " + url2);
              return [3, 18];
            case 18:
              return [3, 20];
            case 19:
              if (paint.listValue && container.styles.listStyleType !== -1) {
                fontFamily2 = this.createFontStyle(styles)[0];
                this.ctx.font = fontFamily2;
                this.ctx.fillStyle = asString(styles.color);
                this.ctx.textBaseline = "middle";
                this.ctx.textAlign = "right";
                bounds = new Bounds(container.bounds.left, container.bounds.top + getAbsoluteValue(container.styles.paddingTop, container.bounds.width), container.bounds.width, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 1);
                this.renderTextWithLetterSpacing(new TextBounds(paint.listValue, bounds), styles.letterSpacing, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 2);
                this.ctx.textBaseline = "bottom";
                this.ctx.textAlign = "left";
              }
              _c.label = 20;
            case 20:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    CanvasRenderer2.prototype.renderStackContent = function(stack2) {
      return __awaiter(this, void 0, void 0, function() {
        var _i, _a2, child, _b2, _c, child, _d, _e, child, _f, _g, child, _h, _j, child, _k, _l, child, _m, _o, child;
        return __generator(this, function(_p) {
          switch (_p.label) {
            case 0:
              if (contains(
                stack2.element.container.flags,
                16
                /* DEBUG_RENDER */
              )) {
                debugger;
              }
              return [4, this.renderNodeBackgroundAndBorders(stack2.element)];
            case 1:
              _p.sent();
              _i = 0, _a2 = stack2.negativeZIndex;
              _p.label = 2;
            case 2:
              if (!(_i < _a2.length)) return [3, 5];
              child = _a2[_i];
              return [4, this.renderStack(child)];
            case 3:
              _p.sent();
              _p.label = 4;
            case 4:
              _i++;
              return [3, 2];
            case 5:
              return [4, this.renderNodeContent(stack2.element)];
            case 6:
              _p.sent();
              _b2 = 0, _c = stack2.nonInlineLevel;
              _p.label = 7;
            case 7:
              if (!(_b2 < _c.length)) return [3, 10];
              child = _c[_b2];
              return [4, this.renderNode(child)];
            case 8:
              _p.sent();
              _p.label = 9;
            case 9:
              _b2++;
              return [3, 7];
            case 10:
              _d = 0, _e = stack2.nonPositionedFloats;
              _p.label = 11;
            case 11:
              if (!(_d < _e.length)) return [3, 14];
              child = _e[_d];
              return [4, this.renderStack(child)];
            case 12:
              _p.sent();
              _p.label = 13;
            case 13:
              _d++;
              return [3, 11];
            case 14:
              _f = 0, _g = stack2.nonPositionedInlineLevel;
              _p.label = 15;
            case 15:
              if (!(_f < _g.length)) return [3, 18];
              child = _g[_f];
              return [4, this.renderStack(child)];
            case 16:
              _p.sent();
              _p.label = 17;
            case 17:
              _f++;
              return [3, 15];
            case 18:
              _h = 0, _j = stack2.inlineLevel;
              _p.label = 19;
            case 19:
              if (!(_h < _j.length)) return [3, 22];
              child = _j[_h];
              return [4, this.renderNode(child)];
            case 20:
              _p.sent();
              _p.label = 21;
            case 21:
              _h++;
              return [3, 19];
            case 22:
              _k = 0, _l = stack2.zeroOrAutoZIndexOrTransformedOrOpacity;
              _p.label = 23;
            case 23:
              if (!(_k < _l.length)) return [3, 26];
              child = _l[_k];
              return [4, this.renderStack(child)];
            case 24:
              _p.sent();
              _p.label = 25;
            case 25:
              _k++;
              return [3, 23];
            case 26:
              _m = 0, _o = stack2.positiveZIndex;
              _p.label = 27;
            case 27:
              if (!(_m < _o.length)) return [3, 30];
              child = _o[_m];
              return [4, this.renderStack(child)];
            case 28:
              _p.sent();
              _p.label = 29;
            case 29:
              _m++;
              return [3, 27];
            case 30:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    CanvasRenderer2.prototype.mask = function(paths) {
      this.ctx.beginPath();
      this.ctx.moveTo(0, 0);
      this.ctx.lineTo(this.canvas.width, 0);
      this.ctx.lineTo(this.canvas.width, this.canvas.height);
      this.ctx.lineTo(0, this.canvas.height);
      this.ctx.lineTo(0, 0);
      this.formatPath(paths.slice(0).reverse());
      this.ctx.closePath();
    };
    CanvasRenderer2.prototype.path = function(paths) {
      this.ctx.beginPath();
      this.formatPath(paths);
      this.ctx.closePath();
    };
    CanvasRenderer2.prototype.formatPath = function(paths) {
      var _this = this;
      paths.forEach(function(point, index) {
        var start = isBezierCurve(point) ? point.start : point;
        if (index === 0) {
          _this.ctx.moveTo(start.x, start.y);
        } else {
          _this.ctx.lineTo(start.x, start.y);
        }
        if (isBezierCurve(point)) {
          _this.ctx.bezierCurveTo(point.startControl.x, point.startControl.y, point.endControl.x, point.endControl.y, point.end.x, point.end.y);
        }
      });
    };
    CanvasRenderer2.prototype.renderRepeat = function(path, pattern, offsetX, offsetY) {
      this.path(path);
      this.ctx.fillStyle = pattern;
      this.ctx.translate(offsetX, offsetY);
      this.ctx.fill();
      this.ctx.translate(-offsetX, -offsetY);
    };
    CanvasRenderer2.prototype.resizeImage = function(image2, width2, height) {
      var _a2;
      if (image2.width === width2 && image2.height === height) {
        return image2;
      }
      var ownerDocument = (_a2 = this.canvas.ownerDocument) !== null && _a2 !== void 0 ? _a2 : document;
      var canvas = ownerDocument.createElement("canvas");
      canvas.width = Math.max(1, width2);
      canvas.height = Math.max(1, height);
      var ctx = canvas.getContext("2d");
      ctx.drawImage(image2, 0, 0, image2.width, image2.height, 0, 0, width2, height);
      return canvas;
    };
    CanvasRenderer2.prototype.renderBackgroundImage = function(container) {
      return __awaiter(this, void 0, void 0, function() {
        var index, _loop_1, this_1, _i, _a2, backgroundImage2;
        return __generator(this, function(_b2) {
          switch (_b2.label) {
            case 0:
              index = container.styles.backgroundImage.length - 1;
              _loop_1 = function(backgroundImage3) {
                var image2, url2, _c, path, x2, y2, width2, height, pattern, _d, path, x2, y2, width2, height, _e, lineLength, x0, x1, y0, y1, canvas, ctx, gradient_1, pattern, _f, path, left, top_1, width2, height, position2, x2, y2, _g, rx, ry, radialGradient_1, midX, midY, f2, invF;
                return __generator(this, function(_h) {
                  switch (_h.label) {
                    case 0:
                      if (!(backgroundImage3.type === 0)) return [3, 5];
                      image2 = void 0;
                      url2 = backgroundImage3.url;
                      _h.label = 1;
                    case 1:
                      _h.trys.push([1, 3, , 4]);
                      return [4, this_1.context.cache.match(url2)];
                    case 2:
                      image2 = _h.sent();
                      return [3, 4];
                    case 3:
                      _h.sent();
                      this_1.context.logger.error("Error loading background-image " + url2);
                      return [3, 4];
                    case 4:
                      if (image2) {
                        _c = calculateBackgroundRendering(container, index, [
                          image2.width,
                          image2.height,
                          image2.width / image2.height
                        ]), path = _c[0], x2 = _c[1], y2 = _c[2], width2 = _c[3], height = _c[4];
                        pattern = this_1.ctx.createPattern(this_1.resizeImage(image2, width2, height), "repeat");
                        this_1.renderRepeat(path, pattern, x2, y2);
                      }
                      return [3, 6];
                    case 5:
                      if (isLinearGradient(backgroundImage3)) {
                        _d = calculateBackgroundRendering(container, index, [null, null, null]), path = _d[0], x2 = _d[1], y2 = _d[2], width2 = _d[3], height = _d[4];
                        _e = calculateGradientDirection(backgroundImage3.angle, width2, height), lineLength = _e[0], x0 = _e[1], x1 = _e[2], y0 = _e[3], y1 = _e[4];
                        canvas = document.createElement("canvas");
                        canvas.width = width2;
                        canvas.height = height;
                        ctx = canvas.getContext("2d");
                        gradient_1 = ctx.createLinearGradient(x0, y0, x1, y1);
                        processColorStops(backgroundImage3.stops, lineLength).forEach(function(colorStop) {
                          return gradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                        });
                        ctx.fillStyle = gradient_1;
                        ctx.fillRect(0, 0, width2, height);
                        if (width2 > 0 && height > 0) {
                          pattern = this_1.ctx.createPattern(canvas, "repeat");
                          this_1.renderRepeat(path, pattern, x2, y2);
                        }
                      } else if (isRadialGradient(backgroundImage3)) {
                        _f = calculateBackgroundRendering(container, index, [
                          null,
                          null,
                          null
                        ]), path = _f[0], left = _f[1], top_1 = _f[2], width2 = _f[3], height = _f[4];
                        position2 = backgroundImage3.position.length === 0 ? [FIFTY_PERCENT] : backgroundImage3.position;
                        x2 = getAbsoluteValue(position2[0], width2);
                        y2 = getAbsoluteValue(position2[position2.length - 1], height);
                        _g = calculateRadius(backgroundImage3, x2, y2, width2, height), rx = _g[0], ry = _g[1];
                        if (rx > 0 && ry > 0) {
                          radialGradient_1 = this_1.ctx.createRadialGradient(left + x2, top_1 + y2, 0, left + x2, top_1 + y2, rx);
                          processColorStops(backgroundImage3.stops, rx * 2).forEach(function(colorStop) {
                            return radialGradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                          });
                          this_1.path(path);
                          this_1.ctx.fillStyle = radialGradient_1;
                          if (rx !== ry) {
                            midX = container.bounds.left + 0.5 * container.bounds.width;
                            midY = container.bounds.top + 0.5 * container.bounds.height;
                            f2 = ry / rx;
                            invF = 1 / f2;
                            this_1.ctx.save();
                            this_1.ctx.translate(midX, midY);
                            this_1.ctx.transform(1, 0, 0, f2, 0, 0);
                            this_1.ctx.translate(-midX, -midY);
                            this_1.ctx.fillRect(left, invF * (top_1 - midY) + midY, width2, height * invF);
                            this_1.ctx.restore();
                          } else {
                            this_1.ctx.fill();
                          }
                        }
                      }
                      _h.label = 6;
                    case 6:
                      index--;
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              };
              this_1 = this;
              _i = 0, _a2 = container.styles.backgroundImage.slice(0).reverse();
              _b2.label = 1;
            case 1:
              if (!(_i < _a2.length)) return [3, 4];
              backgroundImage2 = _a2[_i];
              return [5, _loop_1(backgroundImage2)];
            case 2:
              _b2.sent();
              _b2.label = 3;
            case 3:
              _i++;
              return [3, 1];
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    CanvasRenderer2.prototype.renderSolidBorder = function(color2, side, curvePoints) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          this.path(parsePathForBorder(curvePoints, side));
          this.ctx.fillStyle = asString(color2);
          this.ctx.fill();
          return [
            2
            /*return*/
          ];
        });
      });
    };
    CanvasRenderer2.prototype.renderDoubleBorder = function(color2, width2, side, curvePoints) {
      return __awaiter(this, void 0, void 0, function() {
        var outerPaths, innerPaths;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (!(width2 < 3)) return [3, 2];
              return [4, this.renderSolidBorder(color2, side, curvePoints)];
            case 1:
              _a2.sent();
              return [
                2
                /*return*/
              ];
            case 2:
              outerPaths = parsePathForBorderDoubleOuter(curvePoints, side);
              this.path(outerPaths);
              this.ctx.fillStyle = asString(color2);
              this.ctx.fill();
              innerPaths = parsePathForBorderDoubleInner(curvePoints, side);
              this.path(innerPaths);
              this.ctx.fill();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    CanvasRenderer2.prototype.renderNodeBackgroundAndBorders = function(paint) {
      return __awaiter(this, void 0, void 0, function() {
        var styles, hasBackground, borders, backgroundPaintingArea, side, _i, borders_1, border;
        var _this = this;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              this.applyEffects(paint.getEffects(
                2
                /* BACKGROUND_BORDERS */
              ));
              styles = paint.container.styles;
              hasBackground = !isTransparent(styles.backgroundColor) || styles.backgroundImage.length;
              borders = [
                { style: styles.borderTopStyle, color: styles.borderTopColor, width: styles.borderTopWidth },
                { style: styles.borderRightStyle, color: styles.borderRightColor, width: styles.borderRightWidth },
                { style: styles.borderBottomStyle, color: styles.borderBottomColor, width: styles.borderBottomWidth },
                { style: styles.borderLeftStyle, color: styles.borderLeftColor, width: styles.borderLeftWidth }
              ];
              backgroundPaintingArea = calculateBackgroundCurvedPaintingArea(getBackgroundValueForIndex(styles.backgroundClip, 0), paint.curves);
              if (!(hasBackground || styles.boxShadow.length)) return [3, 2];
              this.ctx.save();
              this.path(backgroundPaintingArea);
              this.ctx.clip();
              if (!isTransparent(styles.backgroundColor)) {
                this.ctx.fillStyle = asString(styles.backgroundColor);
                this.ctx.fill();
              }
              return [4, this.renderBackgroundImage(paint.container)];
            case 1:
              _a2.sent();
              this.ctx.restore();
              styles.boxShadow.slice(0).reverse().forEach(function(shadow) {
                _this.ctx.save();
                var borderBoxArea = calculateBorderBoxPath(paint.curves);
                var maskOffset = shadow.inset ? 0 : MASK_OFFSET;
                var shadowPaintingArea = transformPath(borderBoxArea, -maskOffset + (shadow.inset ? 1 : -1) * shadow.spread.number, (shadow.inset ? 1 : -1) * shadow.spread.number, shadow.spread.number * (shadow.inset ? -2 : 2), shadow.spread.number * (shadow.inset ? -2 : 2));
                if (shadow.inset) {
                  _this.path(borderBoxArea);
                  _this.ctx.clip();
                  _this.mask(shadowPaintingArea);
                } else {
                  _this.mask(borderBoxArea);
                  _this.ctx.clip();
                  _this.path(shadowPaintingArea);
                }
                _this.ctx.shadowOffsetX = shadow.offsetX.number + maskOffset;
                _this.ctx.shadowOffsetY = shadow.offsetY.number;
                _this.ctx.shadowColor = asString(shadow.color);
                _this.ctx.shadowBlur = shadow.blur.number;
                _this.ctx.fillStyle = shadow.inset ? asString(shadow.color) : "rgba(0,0,0,1)";
                _this.ctx.fill();
                _this.ctx.restore();
              });
              _a2.label = 2;
            case 2:
              side = 0;
              _i = 0, borders_1 = borders;
              _a2.label = 3;
            case 3:
              if (!(_i < borders_1.length)) return [3, 13];
              border = borders_1[_i];
              if (!(border.style !== 0 && !isTransparent(border.color) && border.width > 0)) return [3, 11];
              if (!(border.style === 2)) return [3, 5];
              return [4, this.renderDashedDottedBorder(
                border.color,
                border.width,
                side,
                paint.curves,
                2
                /* DASHED */
              )];
            case 4:
              _a2.sent();
              return [3, 11];
            case 5:
              if (!(border.style === 3)) return [3, 7];
              return [4, this.renderDashedDottedBorder(
                border.color,
                border.width,
                side,
                paint.curves,
                3
                /* DOTTED */
              )];
            case 6:
              _a2.sent();
              return [3, 11];
            case 7:
              if (!(border.style === 4)) return [3, 9];
              return [4, this.renderDoubleBorder(border.color, border.width, side, paint.curves)];
            case 8:
              _a2.sent();
              return [3, 11];
            case 9:
              return [4, this.renderSolidBorder(border.color, side, paint.curves)];
            case 10:
              _a2.sent();
              _a2.label = 11;
            case 11:
              side++;
              _a2.label = 12;
            case 12:
              _i++;
              return [3, 3];
            case 13:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    CanvasRenderer2.prototype.renderDashedDottedBorder = function(color2, width2, side, curvePoints, style) {
      return __awaiter(this, void 0, void 0, function() {
        var strokePaths, boxPaths, startX, startY, endX, endY, length, dashLength, spaceLength, useLineDash, multiplier, numberOfDashes, minSpace, maxSpace, path1, path2, path1, path2;
        return __generator(this, function(_a2) {
          this.ctx.save();
          strokePaths = parsePathForBorderStroke(curvePoints, side);
          boxPaths = parsePathForBorder(curvePoints, side);
          if (style === 2) {
            this.path(boxPaths);
            this.ctx.clip();
          }
          if (isBezierCurve(boxPaths[0])) {
            startX = boxPaths[0].start.x;
            startY = boxPaths[0].start.y;
          } else {
            startX = boxPaths[0].x;
            startY = boxPaths[0].y;
          }
          if (isBezierCurve(boxPaths[1])) {
            endX = boxPaths[1].end.x;
            endY = boxPaths[1].end.y;
          } else {
            endX = boxPaths[1].x;
            endY = boxPaths[1].y;
          }
          if (side === 0 || side === 2) {
            length = Math.abs(startX - endX);
          } else {
            length = Math.abs(startY - endY);
          }
          this.ctx.beginPath();
          if (style === 3) {
            this.formatPath(strokePaths);
          } else {
            this.formatPath(boxPaths.slice(0, 2));
          }
          dashLength = width2 < 3 ? width2 * 3 : width2 * 2;
          spaceLength = width2 < 3 ? width2 * 2 : width2;
          if (style === 3) {
            dashLength = width2;
            spaceLength = width2;
          }
          useLineDash = true;
          if (length <= dashLength * 2) {
            useLineDash = false;
          } else if (length <= dashLength * 2 + spaceLength) {
            multiplier = length / (2 * dashLength + spaceLength);
            dashLength *= multiplier;
            spaceLength *= multiplier;
          } else {
            numberOfDashes = Math.floor((length + spaceLength) / (dashLength + spaceLength));
            minSpace = (length - numberOfDashes * dashLength) / (numberOfDashes - 1);
            maxSpace = (length - (numberOfDashes + 1) * dashLength) / numberOfDashes;
            spaceLength = maxSpace <= 0 || Math.abs(spaceLength - minSpace) < Math.abs(spaceLength - maxSpace) ? minSpace : maxSpace;
          }
          if (useLineDash) {
            if (style === 3) {
              this.ctx.setLineDash([0, dashLength + spaceLength]);
            } else {
              this.ctx.setLineDash([dashLength, spaceLength]);
            }
          }
          if (style === 3) {
            this.ctx.lineCap = "round";
            this.ctx.lineWidth = width2;
          } else {
            this.ctx.lineWidth = width2 * 2 + 1.1;
          }
          this.ctx.strokeStyle = asString(color2);
          this.ctx.stroke();
          this.ctx.setLineDash([]);
          if (style === 2) {
            if (isBezierCurve(boxPaths[0])) {
              path1 = boxPaths[3];
              path2 = boxPaths[0];
              this.ctx.beginPath();
              this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
              this.ctx.stroke();
            }
            if (isBezierCurve(boxPaths[1])) {
              path1 = boxPaths[1];
              path2 = boxPaths[2];
              this.ctx.beginPath();
              this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
              this.ctx.stroke();
            }
          }
          this.ctx.restore();
          return [
            2
            /*return*/
          ];
        });
      });
    };
    CanvasRenderer2.prototype.render = function(element) {
      return __awaiter(this, void 0, void 0, function() {
        var stack2;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (this.options.backgroundColor) {
                this.ctx.fillStyle = asString(this.options.backgroundColor);
                this.ctx.fillRect(this.options.x, this.options.y, this.options.width, this.options.height);
              }
              stack2 = parseStackingContexts(element);
              return [4, this.renderStack(stack2)];
            case 1:
              _a2.sent();
              this.applyEffects([]);
              return [2, this.canvas];
          }
        });
      });
    };
    return CanvasRenderer2;
  }(Renderer)
);
var isTextInputElement = function(container) {
  if (container instanceof TextareaElementContainer) {
    return true;
  } else if (container instanceof SelectElementContainer) {
    return true;
  } else if (container instanceof InputElementContainer && container.type !== RADIO && container.type !== CHECKBOX) {
    return true;
  }
  return false;
};
var calculateBackgroundCurvedPaintingArea = function(clip, curves) {
  switch (clip) {
    case 0:
      return calculateBorderBoxPath(curves);
    case 2:
      return calculateContentBoxPath(curves);
    case 1:
    default:
      return calculatePaddingBoxPath(curves);
  }
};
var canvasTextAlign = function(textAlign2) {
  switch (textAlign2) {
    case 1:
      return "center";
    case 2:
      return "right";
    case 0:
    default:
      return "left";
  }
};
var iOSBrokenFonts = ["-apple-system", "system-ui"];
var fixIOSSystemFonts = function(fontFamilies) {
  return /iPhone OS 15_(0|1)/.test(window.navigator.userAgent) ? fontFamilies.filter(function(fontFamily2) {
    return iOSBrokenFonts.indexOf(fontFamily2) === -1;
  }) : fontFamilies;
};
var ForeignObjectRenderer = (
  /** @class */
  function(_super) {
    __extends(ForeignObjectRenderer2, _super);
    function ForeignObjectRenderer2(context, options) {
      var _this = _super.call(this, context, options) || this;
      _this.canvas = options.canvas ? options.canvas : document.createElement("canvas");
      _this.ctx = _this.canvas.getContext("2d");
      _this.options = options;
      _this.canvas.width = Math.floor(options.width * options.scale);
      _this.canvas.height = Math.floor(options.height * options.scale);
      _this.canvas.style.width = options.width + "px";
      _this.canvas.style.height = options.height + "px";
      _this.ctx.scale(_this.options.scale, _this.options.scale);
      _this.ctx.translate(-options.x, -options.y);
      _this.context.logger.debug("EXPERIMENTAL ForeignObject renderer initialized (" + options.width + "x" + options.height + " at " + options.x + "," + options.y + ") with scale " + options.scale);
      return _this;
    }
    ForeignObjectRenderer2.prototype.render = function(element) {
      return __awaiter(this, void 0, void 0, function() {
        var svg2, img;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              svg2 = createForeignObjectSVG(this.options.width * this.options.scale, this.options.height * this.options.scale, this.options.scale, this.options.scale, element);
              return [4, loadSerializedSVG(svg2)];
            case 1:
              img = _a2.sent();
              if (this.options.backgroundColor) {
                this.ctx.fillStyle = asString(this.options.backgroundColor);
                this.ctx.fillRect(0, 0, this.options.width * this.options.scale, this.options.height * this.options.scale);
              }
              this.ctx.drawImage(img, -this.options.x * this.options.scale, -this.options.y * this.options.scale);
              return [2, this.canvas];
          }
        });
      });
    };
    return ForeignObjectRenderer2;
  }(Renderer)
);
var loadSerializedSVG = function(svg2) {
  return new Promise(function(resolve2, reject) {
    var img = new Image();
    img.onload = function() {
      resolve2(img);
    };
    img.onerror = reject;
    img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg2));
  });
};
var Logger = (
  /** @class */
  function() {
    function Logger2(_a2) {
      var id2 = _a2.id, enabled = _a2.enabled;
      this.id = id2;
      this.enabled = enabled;
      this.start = Date.now();
    }
    Logger2.prototype.debug = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (this.enabled) {
        if (typeof window !== "undefined" && window.console && typeof console.debug === "function") {
          console.debug.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
        } else {
          this.info.apply(this, args);
        }
      }
    };
    Logger2.prototype.getTime = function() {
      return Date.now() - this.start;
    };
    Logger2.prototype.info = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (this.enabled) {
        if (typeof window !== "undefined" && window.console && typeof console.info === "function") {
          console.info.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
        }
      }
    };
    Logger2.prototype.warn = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (this.enabled) {
        if (typeof window !== "undefined" && window.console && typeof console.warn === "function") {
          console.warn.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
        } else {
          this.info.apply(this, args);
        }
      }
    };
    Logger2.prototype.error = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (this.enabled) {
        if (typeof window !== "undefined" && window.console && typeof console.error === "function") {
          console.error.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
        } else {
          this.info.apply(this, args);
        }
      }
    };
    Logger2.instances = {};
    return Logger2;
  }()
);
var Context = (
  /** @class */
  function() {
    function Context2(options, windowBounds) {
      var _a2;
      this.windowBounds = windowBounds;
      this.instanceName = "#" + Context2.instanceCount++;
      this.logger = new Logger({ id: this.instanceName, enabled: options.logging });
      this.cache = (_a2 = options.cache) !== null && _a2 !== void 0 ? _a2 : new Cache(this, options);
    }
    Context2.instanceCount = 1;
    return Context2;
  }()
);
var html2canvas = function(element, options) {
  if (options === void 0) {
    options = {};
  }
  return renderElement(element, options);
};
if (typeof window !== "undefined") {
  CacheStorage.setContext(window);
}
var renderElement = function(element, opts) {
  return __awaiter(void 0, void 0, void 0, function() {
    var ownerDocument, defaultView, resourceOptions, contextOptions, windowOptions, windowBounds, context, foreignObjectRendering, cloneOptions, documentCloner, clonedElement, container, _a2, width2, height, left, top, backgroundColor2, renderOptions, canvas, renderer2, root, renderer2;
    var _b2, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t2;
    return __generator(this, function(_u) {
      switch (_u.label) {
        case 0:
          if (!element || typeof element !== "object") {
            return [2, Promise.reject("Invalid element provided as first argument")];
          }
          ownerDocument = element.ownerDocument;
          if (!ownerDocument) {
            throw new Error("Element is not attached to a Document");
          }
          defaultView = ownerDocument.defaultView;
          if (!defaultView) {
            throw new Error("Document is not attached to a Window");
          }
          resourceOptions = {
            allowTaint: (_b2 = opts.allowTaint) !== null && _b2 !== void 0 ? _b2 : false,
            imageTimeout: (_c = opts.imageTimeout) !== null && _c !== void 0 ? _c : 15e3,
            proxy: opts.proxy,
            useCORS: (_d = opts.useCORS) !== null && _d !== void 0 ? _d : false
          };
          contextOptions = __assign({ logging: (_e = opts.logging) !== null && _e !== void 0 ? _e : true, cache: opts.cache }, resourceOptions);
          windowOptions = {
            windowWidth: (_f = opts.windowWidth) !== null && _f !== void 0 ? _f : defaultView.innerWidth,
            windowHeight: (_g = opts.windowHeight) !== null && _g !== void 0 ? _g : defaultView.innerHeight,
            scrollX: (_h = opts.scrollX) !== null && _h !== void 0 ? _h : defaultView.pageXOffset,
            scrollY: (_j = opts.scrollY) !== null && _j !== void 0 ? _j : defaultView.pageYOffset
          };
          windowBounds = new Bounds(windowOptions.scrollX, windowOptions.scrollY, windowOptions.windowWidth, windowOptions.windowHeight);
          context = new Context(contextOptions, windowBounds);
          foreignObjectRendering = (_k = opts.foreignObjectRendering) !== null && _k !== void 0 ? _k : false;
          cloneOptions = {
            allowTaint: (_l = opts.allowTaint) !== null && _l !== void 0 ? _l : false,
            onclone: opts.onclone,
            ignoreElements: opts.ignoreElements,
            inlineImages: foreignObjectRendering,
            copyStyles: foreignObjectRendering
          };
          context.logger.debug("Starting document clone with size " + windowBounds.width + "x" + windowBounds.height + " scrolled to " + -windowBounds.left + "," + -windowBounds.top);
          documentCloner = new DocumentCloner(context, element, cloneOptions);
          clonedElement = documentCloner.clonedReferenceElement;
          if (!clonedElement) {
            return [2, Promise.reject("Unable to find element in cloned iframe")];
          }
          return [4, documentCloner.toIFrame(ownerDocument, windowBounds)];
        case 1:
          container = _u.sent();
          _a2 = isBodyElement(clonedElement) || isHTMLElement(clonedElement) ? parseDocumentSize(clonedElement.ownerDocument) : parseBounds(context, clonedElement), width2 = _a2.width, height = _a2.height, left = _a2.left, top = _a2.top;
          backgroundColor2 = parseBackgroundColor(context, clonedElement, opts.backgroundColor);
          renderOptions = {
            canvas: opts.canvas,
            backgroundColor: backgroundColor2,
            scale: (_o = (_m = opts.scale) !== null && _m !== void 0 ? _m : defaultView.devicePixelRatio) !== null && _o !== void 0 ? _o : 1,
            x: ((_p = opts.x) !== null && _p !== void 0 ? _p : 0) + left,
            y: ((_q = opts.y) !== null && _q !== void 0 ? _q : 0) + top,
            width: (_r = opts.width) !== null && _r !== void 0 ? _r : Math.ceil(width2),
            height: (_s = opts.height) !== null && _s !== void 0 ? _s : Math.ceil(height)
          };
          if (!foreignObjectRendering) return [3, 3];
          context.logger.debug("Document cloned, using foreign object rendering");
          renderer2 = new ForeignObjectRenderer(context, renderOptions);
          return [4, renderer2.render(clonedElement)];
        case 2:
          canvas = _u.sent();
          return [3, 5];
        case 3:
          context.logger.debug("Document cloned, element located at " + left + "," + top + " with size " + width2 + "x" + height + " using computed rendering");
          context.logger.debug("Starting DOM parsing");
          root = parseTree(context, clonedElement);
          if (backgroundColor2 === root.styles.backgroundColor) {
            root.styles.backgroundColor = COLORS.TRANSPARENT;
          }
          context.logger.debug("Starting renderer for element at " + renderOptions.x + "," + renderOptions.y + " with size " + renderOptions.width + "x" + renderOptions.height);
          renderer2 = new CanvasRenderer(context, renderOptions);
          return [4, renderer2.render(root)];
        case 4:
          canvas = _u.sent();
          _u.label = 5;
        case 5:
          if ((_t2 = opts.removeContainer) !== null && _t2 !== void 0 ? _t2 : true) {
            if (!DocumentCloner.destroy(container)) {
              context.logger.error("Cannot detach cloned iframe as it is not in the DOM anymore");
            }
          }
          context.logger.debug("Finished rendering");
          return [2, canvas];
      }
    });
  });
};
var parseBackgroundColor = function(context, element, backgroundColorOverride) {
  var ownerDocument = element.ownerDocument;
  var documentBackgroundColor = ownerDocument.documentElement ? parseColor(context, getComputedStyle(ownerDocument.documentElement).backgroundColor) : COLORS.TRANSPARENT;
  var bodyBackgroundColor = ownerDocument.body ? parseColor(context, getComputedStyle(ownerDocument.body).backgroundColor) : COLORS.TRANSPARENT;
  var defaultBackgroundColor = typeof backgroundColorOverride === "string" ? parseColor(context, backgroundColorOverride) : backgroundColorOverride === null ? COLORS.TRANSPARENT : 4294967295;
  return element === ownerDocument.documentElement ? isTransparent(documentBackgroundColor) ? isTransparent(bodyBackgroundColor) ? defaultBackgroundColor : bodyBackgroundColor : documentBackgroundColor : defaultBackgroundColor;
};
const html2canvas_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: html2canvas
}, Symbol.toStringTag, { value: "Module" }));
const _withScopeId$1 = (n2) => (pushScopeId("data-v-8e0d46f4"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$1 = { class: "row" };
const _hoisted_2$1 = { class: "col-12" };
const _hoisted_3$1 = {
  id: "contFilter",
  class: "justify-evenly flex full-width"
};
const _hoisted_4$1 = {
  class: "divInputFilter",
  style: { "max-width": "300px" }
};
const _hoisted_5$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("span", null, "Fecha inicial: ", -1));
const _hoisted_6$1 = { class: "row items-center justify-end" };
const _hoisted_7$1 = {
  class: "divInputFilter",
  style: { "max-width": "300px" }
};
const _hoisted_8$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("span", null, "Fecha final: ", -1));
const _hoisted_9$1 = { class: "row items-center justify-end" };
const _hoisted_10$1 = {
  class: "divInputFilter",
  style: { "max-width": "300px" }
};
const _hoisted_11$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("span", null, "Finca: ", -1));
const _hoisted_12$1 = { class: "justify-around flex full-width q-my-sm" };
const _hoisted_13$1 = {
  key: 0,
  class: "col-12 flex",
  style: { "overflow": "auto" }
};
const _hoisted_14$1 = { class: "q-pa-md" };
const _hoisted_15$1 = { class: "q-gutter-y-md" };
const _hoisted_16$1 = { class: "col-10 justify-end flex" };
const _hoisted_17$1 = { id: "pdf" };
const _hoisted_18 = { id: "graphics" };
const _hoisted_19 = { key: 0 };
const _hoisted_20 = {
  class: "col-12 col-md-6",
  style: { "width": "400px" }
};
const _hoisted_21 = {
  class: "col-12 col-md-6",
  style: { "width": "400px" }
};
const _hoisted_22 = {
  class: "col-12 col-md-6",
  style: { "width": "400px" }
};
const _hoisted_23 = {
  class: "col-12 col-md-6",
  style: { "width": "400px" }
};
const _hoisted_24 = { class: "col-12 col-md-6" };
const _hoisted_25 = { class: "col-12 col-md-6" };
const _hoisted_26 = { class: "col-12 col-md-6" };
const _hoisted_27 = { class: "col-12 col-md-6" };
const _hoisted_28 = {
  key: 1,
  class: "col-12 justify-center flex"
};
const _hoisted_29 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("h1", null, "No hay datos para mostrar", -1));
const _hoisted_30 = [
  _hoisted_29
];
const _sfc_main$1 = {
  __name: "GenerateReport",
  setup(__props) {
    const $q = useQuasar();
    const useUsers = storeUsers();
    const load = ref({ farm: true, report: false });
    const data = ref({ farm: "", fechaA: "", fechaB: "" });
    const dataReport = ref([]);
    const farms = ref([]);
    onMounted(() => {
      load.value.farm = true;
      try {
        farms.value = useUsers.farms.map((farm) => {
          return {
            label: `${farm.codeFarm} - ${farm.name}`,
            value: farm._id
          };
        });
      } catch (error) {
        console.log(error);
      } finally {
        load.value.farm = false;
      }
    });
    const farmsFilter = ref(farms.value);
    function filterFnFarm(val, update2) {
      val = val.trim();
      if (val === "") {
        update2(() => {
          farmsFilter.value = farms.value;
        });
        return;
      }
      update2(() => {
        const needle = val.toLowerCase();
        farmsFilter.value = farms.value.filter((v2) => v2.label.toLowerCase().indexOf(needle) > -1) || [];
      });
    }
    function convertDate(date) {
      return date.replaceAll("/", "-");
    }
    const msgNoData = ref(false);
    async function getReports() {
      dataReport.value = [];
      msgNoData.value = false;
      load.value.report = true;
      try {
        const info = {
          farm: data.value.farm.value,
          fechaA: convertDate(data.value.fechaA),
          fechaB: convertDate(data.value.fechaB)
        };
        const response = await getReportPDF(info);
        dataReport.value = response;
        if (dataReport.value.length === 0) msgNoData.value = true;
        generateDataGraphif();
      } catch (error) {
        console.log(error);
      }
      load.value.report = false;
    }
    function fechaActual() {
      const fecha = /* @__PURE__ */ new Date();
      const formatoFecha = `${fecha.getFullYear()}/${(fecha.getMonth() + 1).toString().padStart(2, "0")}/${fecha.getDate().toString().padStart(2, "0")}`;
      return formatoFecha;
    }
    function optionsDate(date) {
      return date <= (/* @__PURE__ */ new Date()).toISOString().slice(0, 10).replace(/-/g, "/") && date >= data.value.fechaA;
    }
    watch(
      () => data.value.farm,
      () => {
        dataReport.value = [];
      }
    );
    watch(
      () => data.value.fechaA,
      () => {
        dataReport.value = [];
      }
    );
    watch(
      () => data.value.fechaB,
      () => {
        dataReport.value = [];
      }
    );
    function clearData() {
      data.value = { farm: "", fechaA: "", fechaB: "" };
      dataReport.value = [];
    }
    function optionsFn(date) {
      return date <= (/* @__PURE__ */ new Date()).toISOString().slice(0, 10).replace(/-/g, "/");
    }
    let dataGraphic = {};
    let categoriesGraphic = [];
    function generateDataGraphif() {
      dataGraphic = { temperature: [], humidity: [], radiation: [], masa: [], humfinal: [] };
      categoriesGraphic = [];
      dataReport.value.forEach((month) => {
        month.data.forEach((day) => {
          console.log(day);
          dataGraphic.temperature.push(parseFloat(day.temperature).toFixed(2));
          dataGraphic.humidity.push(parseFloat(day.humidity).toFixed(2));
          dataGraphic.radiation.push(parseFloat(day.u).toFixed(2));
          dataGraphic.masa.push(parseFloat(day.masa).toFixed(2));
          dataGraphic.humfinal.push(parseFloat(day.humfinal).toFixed(2));
          categoriesGraphic.push(day.date);
        });
      });
    }
    const tab = ref("tabla");
    let nameFile = ref("Reporte");
    let generatingPdf = ref(false);
    async function generatePdf() {
      generatingPdf.value = true;
      $q.loading.show({
        message: "Generando PDF..."
      });
      const current = document.getElementById("pdf").style.width;
      document.getElementById("pdf").style.width = "800px";
      await new Promise((resolve2) => {
        const element = document.getElementById("graphics");
        if (element.children.length > 0) {
          resolve2();
        } else {
          const observer = new MutationObserver(() => {
            if (element.children.length > 0) {
              observer.disconnect();
              resolve2();
            }
          });
          observer.observe(element, { childList: true });
        }
      });
      const graphics = [
        "temperature",
        "humidity",
        "masa",
        "humfinal"
      ];
      const toolbars = document.getElementsByClassName("apexcharts-toolbar");
      const arrayToolbars = Array.from(toolbars);
      for (const toolbar of arrayToolbars) {
        toolbar.remove();
      }
      const table = document.getElementsByClassName("q-table")[0];
      console.log(table.style.border);
      const border = table.style.border;
      table.style.border = "2px solid black";
      const doc2 = new E$1({
        orientation: "landscape",
        unit: "mm",
        format: [600, 830],
        compress: true,
        //para que no pese tanto el pdf
        precision: 2,
        //para que no se vea borroso el texto
        userUnit: 1
      });
      let yOffset = 120;
      const report = document.getElementById("pdf");
      await doc2.html(report, {
        x: 0,
        // Posición x en el PDF
        y: 0,
        // Posición y en el PDF
        margin: [15, 15, 15, 15],
        autoPaging: true
        // Agregar nuevas páginas si el contenido HTML es largo
      });
      for (let i = 0; i < graphics.length; i++) {
        const graphic = graphics[i];
        await html2canvas(document.getElementById(graphic)).then(
          (canvas) => {
            const imgData = canvas.toDataURL("image/png");
            const imgWidth = 350;
            const pageHeight = doc2.internal.pageSize.height;
            const imgHeight = canvas.height * imgWidth / canvas.width;
            const remainingHeight = yOffset + imgHeight;
            if (i == 0) doc2.addPage();
            if (remainingHeight > pageHeight) {
              doc2.addPage();
              yOffset = 120;
            }
            const isPar = (i + 1) % 2 == 0;
            const xOffset = isPar ? 436 : 43;
            doc2.addImage(imgData, "PNG", xOffset, yOffset, imgWidth, imgHeight);
            if (isPar) yOffset += imgHeight + 120;
          }
        );
      }
      doc2.save(`${nameFile.value}-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.pdf`);
      $q.loading.hide();
      generatingPdf.value = false;
      document.getElementById("pdf").style.width = current;
      table.style.border = border;
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1, [
        createBaseVNode("div", _hoisted_2$1, [
          createVNode(_sfc_main$c, { title: "Reportes" }),
          createVNode(QForm, {
            onSubmit: withModifiers(getReports, ["prevent", "stop"])
          }, {
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_3$1, [
                createBaseVNode("div", _hoisted_4$1, [
                  _hoisted_5$1,
                  createVNode(QInput, {
                    class: "subtitles",
                    filled: "",
                    modelValue: data.value.fechaA,
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => data.value.fechaA = $event),
                    mask: "date",
                    rules: [
                      "date",
                      (val) => val <= fechaActual() || "La fecha no puede ser mayor a la fecha actual"
                    ]
                  }, {
                    append: withCtx(() => [
                      createVNode(QIcon, {
                        name: "event",
                        class: "cursor-pointer"
                      }, {
                        default: withCtx(() => [
                          createVNode(QPopupProxy, {
                            cover: "",
                            "transition-show": "scale",
                            "transition-hide": "scale"
                          }, {
                            default: withCtx(() => [
                              createVNode(QDate, {
                                modelValue: data.value.fechaA,
                                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => data.value.fechaA = $event),
                                options: optionsFn
                              }, {
                                default: withCtx(() => [
                                  createBaseVNode("div", _hoisted_6$1, [
                                    withDirectives(createVNode(QBtn, {
                                      label: "Cerrar",
                                      color: "primary",
                                      flat: ""
                                    }, null, 512), [
                                      [ClosePopup]
                                    ])
                                  ])
                                ]),
                                _: 1
                              }, 8, ["modelValue"])
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }, 8, ["modelValue", "rules"])
                ]),
                createBaseVNode("div", _hoisted_7$1, [
                  _hoisted_8$1,
                  createVNode(QInput, {
                    class: "subtitles",
                    filled: "",
                    modelValue: data.value.fechaB,
                    "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => data.value.fechaB = $event),
                    mask: "date",
                    rules: [
                      "date",
                      (val) => val >= data.value.fechaA || "La fecha no puede ser anterior a la fecha inicial"
                    ]
                  }, {
                    append: withCtx(() => [
                      createVNode(QIcon, {
                        name: "event",
                        class: "cursor-pointer"
                      }, {
                        default: withCtx(() => [
                          createVNode(QPopupProxy, {
                            cover: "",
                            "transition-show": "scale",
                            "transition-hide": "scale"
                          }, {
                            default: withCtx(() => [
                              createVNode(QDate, {
                                modelValue: data.value.fechaB,
                                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => data.value.fechaB = $event),
                                options: optionsDate
                              }, {
                                default: withCtx(() => [
                                  createBaseVNode("div", _hoisted_9$1, [
                                    withDirectives(createVNode(QBtn, {
                                      label: "Cerrar",
                                      color: "primary",
                                      flat: ""
                                    }, null, 512), [
                                      [ClosePopup]
                                    ])
                                  ])
                                ]),
                                _: 1
                              }, 8, ["modelValue"])
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }, 8, ["modelValue", "rules"])
                ]),
                createBaseVNode("div", _hoisted_10$1, [
                  _hoisted_11$1,
                  createVNode(QSelect, {
                    class: "subtitles",
                    outlined: "",
                    modelValue: data.value.farm,
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => data.value.farm = $event),
                    "use-input": "",
                    "input-debounce": "0",
                    label: "Seleccione una finca",
                    behavior: "menu",
                    onFilter: filterFnFarm,
                    options: farmsFilter.value,
                    rules: [(val) => !!val || "Seleccione una opción"],
                    loading: load.value.farm,
                    disable: load.value.farm,
                    "fill-input": "",
                    "hide-selected": ""
                  }, {
                    "no-option": withCtx(() => [
                      createVNode(QItem, null, {
                        default: withCtx(() => [
                          createVNode(QItemSection, { class: "text-grey" }, {
                            default: withCtx(() => [
                              createTextVNode(" Sin resultados ")
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }, 8, ["modelValue", "options", "rules", "loading", "disable"])
                ])
              ]),
              createBaseVNode("div", _hoisted_12$1, [
                dataReport.value.length <= 0 ? (openBlock(), createBlock(QBtn, {
                  key: 0,
                  class: "bg-green-7 text-white",
                  label: "Generar",
                  type: "submit",
                  loading: load.value.report
                }, null, 8, ["loading"])) : createCommentVNode("", true),
                dataReport.value.length > 0 ? (openBlock(), createBlock(QBtn, {
                  key: 1,
                  class: "bg-green-7 text-white",
                  label: "Limpiar",
                  onClick: _cache[5] || (_cache[5] = ($event) => clearData())
                })) : createCommentVNode("", true)
              ])
            ]),
            _: 1
          })
        ]),
        dataReport.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_13$1, [
          createBaseVNode("div", _hoisted_14$1, [
            createBaseVNode("div", _hoisted_15$1, [
              createVNode(QCard, { style: { "min-width": "95vw" } }, {
                default: withCtx(() => [
                  createVNode(QTabs, {
                    modelValue: tab.value,
                    "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => tab.value = $event),
                    dense: "",
                    "active-color": "primary",
                    "indicator-color": "primary",
                    align: "justify",
                    "narrow-indicator": ""
                  }, {
                    default: withCtx(() => [
                      createVNode(QTab, {
                        name: "tabla",
                        label: "Tabla de datos"
                      }),
                      createVNode(QTab, {
                        name: "temperature",
                        label: "Temperatura"
                      }),
                      createVNode(QTab, {
                        name: "humidity",
                        label: "Humedad"
                      }),
                      createVNode(QTab, {
                        name: "masa",
                        label: "Masa"
                      }),
                      createVNode(QTab, {
                        name: "humfinal",
                        label: "Humedad final"
                      })
                    ]),
                    _: 1
                  }, 8, ["modelValue"]),
                  createVNode(QSeparator),
                  createVNode(QTabPanels, {
                    modelValue: tab.value,
                    "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => tab.value = $event),
                    animated: ""
                  }, {
                    default: withCtx(() => [
                      createVNode(QTabPanel, { name: "tabla" }, {
                        default: withCtx(() => [
                          createBaseVNode("div", _hoisted_16$1, [
                            createVNode(QBtn, {
                              icon: "picture_as_pdf",
                              color: "red-10",
                              size: "14px",
                              onClick: generatePdf
                            }, {
                              default: withCtx(() => [
                                createVNode(QTooltip, { class: "bg-white text-green-9" }, {
                                  default: withCtx(() => [
                                    createTextVNode("Descargar PDF")
                                  ]),
                                  _: 1
                                })
                              ]),
                              _: 1
                            })
                          ]),
                          createBaseVNode("div", _hoisted_17$1, [
                            createVNode(_sfc_main$2, {
                              dates: {
                                start: data.value.fechaA,
                                end: data.value.fechaB,
                                farm: data.value.farm.label
                              },
                              data: dataReport.value
                            }, null, 8, ["dates", "data"])
                          ]),
                          createBaseVNode("div", _hoisted_18, [
                            unref(generatingPdf) ? (openBlock(), createElementBlock("div", _hoisted_19, [
                              createBaseVNode("div", _hoisted_20, [
                                dataReport.value.length > 0 ? (openBlock(), createBlock(LineChartBasic, {
                                  key: 0,
                                  data: unref(dataGraphic).temperature,
                                  categories: unref(categoriesGraphic),
                                  name: "temperature",
                                  title: "Temperatura",
                                  symbolLabel: "°C"
                                }, null, 8, ["data", "categories"])) : createCommentVNode("", true)
                              ]),
                              createBaseVNode("div", _hoisted_21, [
                                dataReport.value.length > 0 ? (openBlock(), createBlock(LineChartBasic, {
                                  key: 0,
                                  data: unref(dataGraphic).humidity,
                                  categories: unref(categoriesGraphic),
                                  name: "humidity",
                                  title: "Humedad",
                                  symbolLabel: "%"
                                }, null, 8, ["data", "categories"])) : createCommentVNode("", true)
                              ]),
                              createBaseVNode("div", _hoisted_22, [
                                dataReport.value.length > 0 ? (openBlock(), createBlock(LineChartBasic, {
                                  key: 0,
                                  data: unref(dataGraphic).masa,
                                  categories: unref(categoriesGraphic),
                                  name: "masa",
                                  title: "Masa",
                                  symbolLabel: "g"
                                }, null, 8, ["data", "categories"])) : createCommentVNode("", true)
                              ]),
                              createBaseVNode("div", _hoisted_23, [
                                dataReport.value.length > 0 ? (openBlock(), createBlock(LineChartBasic, {
                                  key: 0,
                                  data: unref(dataGraphic).humfinal,
                                  categories: unref(categoriesGraphic),
                                  name: "humfinal",
                                  title: "Humedad final",
                                  symbolLabel: "%"
                                }, null, 8, ["data", "categories"])) : createCommentVNode("", true)
                              ])
                            ])) : createCommentVNode("", true)
                          ])
                        ]),
                        _: 1
                      }),
                      createVNode(QTabPanel, { name: "temperature" }, {
                        default: withCtx(() => [
                          createBaseVNode("div", _hoisted_24, [
                            dataReport.value.length > 0 ? (openBlock(), createBlock(LineChartBasic, {
                              key: 0,
                              data: unref(dataGraphic).temperature,
                              categories: unref(categoriesGraphic),
                              name: "Nivel",
                              title: "Temperatura",
                              symbolLabel: "°C"
                            }, null, 8, ["data", "categories"])) : createCommentVNode("", true)
                          ])
                        ]),
                        _: 1
                      }),
                      createVNode(QTabPanel, { name: "humidity" }, {
                        default: withCtx(() => [
                          createBaseVNode("div", _hoisted_25, [
                            dataReport.value.length > 0 ? (openBlock(), createBlock(LineChartBasic, {
                              key: 0,
                              data: unref(dataGraphic).humidity,
                              categories: unref(categoriesGraphic),
                              name: "Nivel",
                              title: "Humedad",
                              symbolLabel: "%"
                            }, null, 8, ["data", "categories"])) : createCommentVNode("", true)
                          ])
                        ]),
                        _: 1
                      }),
                      createVNode(QTabPanel, { name: "masa" }, {
                        default: withCtx(() => [
                          createBaseVNode("div", _hoisted_26, [
                            dataReport.value.length > 0 ? (openBlock(), createBlock(LineChartBasic, {
                              key: 0,
                              data: unref(dataGraphic).masa,
                              categories: unref(categoriesGraphic),
                              name: "Peso",
                              title: "Masa",
                              symbolLabel: "g"
                            }, null, 8, ["data", "categories"])) : createCommentVNode("", true)
                          ])
                        ]),
                        _: 1
                      }),
                      createVNode(QTabPanel, { name: "humfinal" }, {
                        default: withCtx(() => [
                          createBaseVNode("div", _hoisted_27, [
                            dataReport.value.length > 0 ? (openBlock(), createBlock(LineChartBasic, {
                              key: 0,
                              data: unref(dataGraphic).humfinal,
                              categories: unref(categoriesGraphic),
                              name: "Nivel",
                              title: "Humedad final",
                              symbolLabel: "%"
                            }, null, 8, ["data", "categories"])) : createCommentVNode("", true)
                          ])
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }, 8, ["modelValue"])
                ]),
                _: 1
              })
            ])
          ])
        ])) : createCommentVNode("", true),
        msgNoData.value ? (openBlock(), createElementBlock("div", _hoisted_28, _hoisted_30)) : createCommentVNode("", true)
      ]);
    };
  }
};
const GenerateReport = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-8e0d46f4"]]);
const _withScopeId = (n2) => (pushScopeId("data-v-4863dd43"), n2 = n2(), popScopeId(), n2);
const _hoisted_1 = { class: "q-my-xl" };
const _hoisted_2 = { class: "row q-mt-lg" };
const _hoisted_3 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("div", { class: "col-1" }, null, -1));
const _hoisted_4 = { class: "col-10" };
const _hoisted_5 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", {
  class: "material-symbols-outlined q-mr-sm",
  style: { "font-size": "20px" }
}, " add_circle ", -1));
const _hoisted_6 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("div", { class: "col-1" }, null, -1));
const _hoisted_7 = { class: "row q-mt-md justify-center" };
const _hoisted_8 = { class: "col-11 q-mb-lg" };
const _hoisted_9 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", {
  class: "material-symbols-outlined",
  style: { "font-size": "18px" }
}, " check ", -1));
const _hoisted_10 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", {
  class: "material-symbols-outlined",
  style: { "font-size": "18px" }
}, " close ", -1));
const _hoisted_11 = { class: "q-mt-sm q-mb-sm text-white text-center text-weight-bold" };
const _hoisted_12 = { class: "q-pa-md" };
const _hoisted_13 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", { class: "material-symbols-outlined" }, " person ", -1));
const _hoisted_14 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", { class: "material-symbols-outlined" }, " category ", -1));
const _hoisted_15 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", { class: "material-symbols-outlined" }, " house ", -1));
const _hoisted_16 = { class: "justify-center flex" };
const _hoisted_17 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", {
  class: "material-symbols-outlined q-mr-sm",
  style: { "font-size": "23px" }
}, " cancel ", -1));
const _sfc_main = {
  __name: "Sensors",
  setup(__props) {
    let index = ref();
    let prompt = ref(false);
    let edit = ref(false);
    let form = ref({
      name: "",
      type: "",
      farm: "",
      status: 0
    });
    let loading = ref(false);
    let columns = ref([
      {
        name: "name",
        label: "NOMBRE",
        field: "name",
        align: "center",
        sortable: true
      },
      {
        name: "type",
        label: "TIPO",
        field: "type",
        align: "center",
        sortable: true
      },
      {
        name: "farm",
        label: "FINCA",
        field: (val) => val.farm.name + " / " + val.farm.codeFarm,
        align: "center",
        sortable: true
      },
      {
        name: "status",
        label: "ESTADO",
        field: (row) => row.status == false ? "Inactivo" : "Activo",
        align: "center",
        sortable: true
      },
      { name: "options", label: "OPCIONES", align: "center" }
    ]);
    let rows = ref([]);
    const optionsSelect = ref({
      farms: [],
      typeSensor: [{ label: "TERMÓMETRO", value: "TERMOMETRO" }, { label: "TERMOHIGRÓMETRO", value: "TERMOHIGROMETRO" }, { label: "BÁSCULA", value: "BASCULA" }]
    });
    const loadFarm = ref(true);
    onBeforeMount(async () => {
      await getSensors();
      await getFarms();
    });
    function showInfo(data) {
      index.value = data._id;
      form.value = { ...data, farm: { label: data.farm.name + " / " + data.farm.codeFarm, value: data.farm._id } };
      edit.value = true;
      prompt.value = true;
      loading.value = false;
    }
    async function activeInactive(idSensor) {
      index.value = idSensor;
      const data = rows.value.find((item) => item._id == idSensor);
      console.log(data);
      data.status = !data.status;
      console.log(data);
      form.value = { ...data, farm: { label: data.farm.name, value: data.farm._id } };
      await putSensor();
    }
    const getSensors = async () => {
      var _a2;
      const data = await getSensorsApi();
      if ((data == null ? void 0 : data.data.length) > 0) {
        console.log(data.data);
        rows.value = (_a2 = data.data) == null ? void 0 : _a2.map((sensor) => {
          return {
            ...sensor,
            type: optionsSelect.value.typeSensor.find((item) => item.value == sensor.type)
          };
        });
      }
    };
    const clearForm = () => {
      form.value = {
        name: "",
        type: "",
        farm: "",
        status: true
      };
    };
    async function postSensor() {
      loading.value = true;
      await createSensorApi({
        ...form.value,
        farm: form.value.farm.value,
        type: form.value.type.value
      }).then(async (res) => {
        console.log(res);
        if (res && res.status < 299) {
          prompt.value = false;
          edit.value = false;
          clearForm();
          await getSensors();
        }
      });
      loading.value = false;
    }
    async function putSensor() {
      loading.value = true;
      console.log(form.value);
      await updateSensorApi({
        ...form.value,
        id: index.value,
        farm: form.value.farm.value,
        type: form.value.type.value
      }).then(
        async (res) => {
          if (res && res.status < 299) {
            clearForm();
            prompt.value = false;
            edit.value = false;
            await getSensors();
          }
        }
      );
      loading.value = false;
    }
    const getFarms = async () => {
      loadFarm.value = true;
      const data = await getFarmsApi();
      if ((data == null ? void 0 : data.data.length) > 0) {
        console.log(data.data);
        const farms = data.data.filter((farm) => farm.status === true);
        optionsSelect.value.farms = farms.map((farm) => {
          return {
            label: farm.name + " / " + farm.codeFarm,
            value: farm._id,
            disable: farm.status === 0
          };
        });
      }
      loadFarm.value = false;
    };
    const optionsFilter = ref({
      farms: optionsSelect.farms
    });
    function filterFn(val, update2) {
      val = val.trim();
      if (val === "") {
        update2(() => {
          optionsFilter.value.farms = optionsSelect.value.farms;
        });
        return;
      }
      update2(() => {
        const needle = val.toLowerCase();
        optionsFilter.value.farms = optionsSelect.value.farms.filter(
          (v2) => v2.label.toLowerCase().indexOf(needle) > -1
        ) || [];
      });
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1, [
        createVNode(_sfc_main$c, { title: "Sensores" }),
        createBaseVNode("div", _hoisted_2, [
          _hoisted_3,
          createBaseVNode("div", _hoisted_4, [
            createVNode(QBtn, {
              class: "bg-green-9 text-white",
              onClick: _cache[0] || (_cache[0] = ($event) => (clearForm(), isRef(prompt) ? prompt.value = true : prompt = true, isRef(edit) ? edit.value = false : edit = false))
            }, {
              default: withCtx(() => [
                _hoisted_5,
                createTextVNode(" Crear ")
              ]),
              _: 1
            })
          ]),
          _hoisted_6
        ]),
        createBaseVNode("div", _hoisted_7, [
          createBaseVNode("div", _hoisted_8, [
            createVNode(QTable, {
              flat: "",
              bordered: "",
              "no-data-label": "Sin registros aún",
              rows: unref(rows),
              columns: unref(columns),
              "row-key": "index",
              class: "q-mx-md my-sticky-header-table",
              "rows-per-page-label": "Numero de documentos",
              "rows-per-page-options": [10, 20, 30, 40, 50, 0],
              pagination: {
                rowsPerPage: 50
              }
            }, {
              "body-cell-type": withCtx((props2) => [
                createVNode(QTd, { props: props2 }, {
                  default: withCtx(() => [
                    createBaseVNode("div", null, toDisplayString(props2.value.label), 1)
                  ]),
                  _: 2
                }, 1032, ["props"])
              ]),
              "body-cell-status": withCtx((props2) => [
                createVNode(QTd, { props: props2 }, {
                  default: withCtx(() => [
                    createBaseVNode("div", null, [
                      props2.value === "Activo" ? (openBlock(), createBlock(QBadge, {
                        key: 0,
                        class: "bg-green-10"
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(props2.value), 1)
                        ]),
                        _: 2
                      }, 1024)) : (openBlock(), createBlock(QBadge, {
                        key: 1,
                        class: "bg-red"
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(props2.value), 1)
                        ]),
                        _: 2
                      }, 1024))
                    ])
                  ]),
                  _: 2
                }, 1032, ["props"])
              ]),
              "body-cell-options": withCtx((props2) => [
                createVNode(QTd, { props: props2 }, {
                  default: withCtx(() => [
                    createBaseVNode("div", null, [
                      createVNode(QBtn, {
                        round: "",
                        icon: "edit",
                        class: "q-mx-md",
                        size: "xs",
                        color: "green-10",
                        onClick: ($event) => showInfo(props2.row)
                      }, null, 8, ["onClick"]),
                      props2.row.status ? (openBlock(), createBlock(QBtn, {
                        key: 0,
                        round: "",
                        size: "xs",
                        color: "green-10",
                        onClick: ($event) => activeInactive(props2.row._id)
                      }, {
                        default: withCtx(() => [
                          _hoisted_9
                        ]),
                        _: 2
                      }, 1032, ["onClick"])) : (openBlock(), createBlock(QBtn, {
                        key: 1,
                        round: "",
                        size: "xs",
                        color: "red",
                        onClick: ($event) => activeInactive(props2.row._id)
                      }, {
                        default: withCtx(() => [
                          _hoisted_10
                        ]),
                        _: 2
                      }, 1032, ["onClick"]))
                    ])
                  ]),
                  _: 2
                }, 1032, ["props"])
              ]),
              _: 1
            }, 8, ["rows", "columns"])
          ])
        ]),
        createVNode(QDialog, {
          modelValue: unref(prompt),
          "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => isRef(prompt) ? prompt.value = $event : prompt = $event)
        }, {
          default: withCtx(() => [
            createVNode(QCard, null, {
              default: withCtx(() => [
                createVNode(QCardSection, { class: "bg-green-9 q-px-lg" }, {
                  default: withCtx(() => [
                    createBaseVNode("h5", _hoisted_11, toDisplayString(unref(edit) ? "MODIFICA LA INFORMACIÓN" : "DILIGENCIA LA INFORMACIÓN"), 1)
                  ]),
                  _: 1
                }),
                createBaseVNode("div", _hoisted_12, [
                  createVNode(QForm, {
                    onSubmit: _cache[4] || (_cache[4] = withModifiers(($event) => unref(edit) ? putSensor() : postSensor(), ["prevent", "stop"])),
                    novalidate: ""
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("div", null, [
                        createVNode(QInput, {
                          filled: "",
                          type: "text",
                          modelValue: unref(form).name,
                          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(form).name = $event),
                          label: "Nombre del sensor",
                          "lazy-rules": "",
                          rules: [
                            (val) => val && val.trim().length > 0 || "El campo es requerido"
                          ]
                        }, {
                          prepend: withCtx(() => [
                            _hoisted_13
                          ]),
                          _: 1
                        }, 8, ["modelValue", "rules"]),
                        createVNode(QSelect, {
                          filled: "",
                          "model-value": unref(form).type,
                          "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => unref(form).type = $event),
                          "input-debounce": "0",
                          label: "Tipo",
                          options: optionsSelect.value.typeSensor,
                          behavior: "menu",
                          rules: [(val) => !!val || "Seleccione una opción"]
                        }, {
                          prepend: withCtx(() => [
                            _hoisted_14
                          ]),
                          _: 1
                        }, 8, ["model-value", "options", "rules"]),
                        createVNode(QSelect, {
                          class: "input3",
                          filled: "",
                          modelValue: unref(form).farm,
                          "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => unref(form).farm = $event),
                          "use-input": "",
                          "input-debounce": "0",
                          "fill-input": "",
                          "hide-selected": "",
                          label: "Finca",
                          behavior: "menu",
                          onFilter: filterFn,
                          options: optionsFilter.value.farms,
                          rules: [(val) => val != null || "Seleccione una finca"],
                          loading: loadFarm.value,
                          disable: loadFarm.value
                        }, {
                          "no-option": withCtx(() => [
                            createVNode(QItem, null, {
                              default: withCtx(() => [
                                createVNode(QItemSection, { class: "text-grey" }, {
                                  default: withCtx(() => [
                                    createTextVNode(" Sin resultados ")
                                  ]),
                                  _: 1
                                })
                              ]),
                              _: 1
                            })
                          ]),
                          prepend: withCtx(() => [
                            _hoisted_15
                          ]),
                          _: 1
                        }, 8, ["modelValue", "options", "rules", "loading", "disable"]),
                        createBaseVNode("div", _hoisted_16, [
                          createVNode(QBtn, {
                            icon: "save_as",
                            label: "GUARDAR",
                            type: "submit",
                            class: "q-mt-md q-mb-sm q-mx-sm save_as",
                            loading: unref(loading)
                          }, {
                            loading: withCtx(() => [
                              createVNode(QSpinnerOval, {
                                color: "white",
                                size: "1em"
                              })
                            ]),
                            _: 1
                          }, 8, ["loading"]),
                          withDirectives((openBlock(), createBlock(QBtn, {
                            type: "button",
                            class: "q-mt-md q-mb-sm q-mx-sm",
                            to: ""
                          }, {
                            default: withCtx(() => [
                              _hoisted_17,
                              createTextVNode("CERRAR")
                            ]),
                            _: 1
                          })), [
                            [ClosePopup]
                          ])
                        ])
                      ])
                    ]),
                    _: 1
                  })
                ])
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["modelValue"])
      ]);
    };
  }
};
const Sensors = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-4863dd43"]]);
const checkAuth = () => {
  const cookie = api.get("access_token");
  if (!cookie) return false;
  return true;
};
const auth = (to, from, next) => {
  var _a2;
  if (checkAuth()) {
    const userStore = storeUsers();
    const role = (_a2 = userStore.user) == null ? void 0 : _a2.role;
    if (to.meta.rol && !to.meta.rol.includes(role)) {
      return next({ name: "home" });
    }
    next();
  } else {
    next({ name: "login" });
  }
};
const returnHome = (to, from, next) => {
  if (checkAuth()) {
    next({ name: "home" });
  } else {
    next();
  }
};
useRouter();
const routes = [
  {
    path: "/",
    name: "login",
    component: Login,
    beforeEnter: returnHome
  },
  {
    path: "/forgot-password",
    name: "forgot-password",
    component: ForgotPassword,
    beforeEnter: returnHome
  },
  {
    path: "/new-password/:token",
    name: "new-password",
    component: NewPassword,
    beforeEnter: returnHome
  },
  {
    path: "/:catchAll(.*)",
    redirect: "/"
  },
  {
    path: "/nav",
    name: "nav",
    component: Nav,
    children: [
      { path: "/nav", redirect: "/home" },
      {
        path: "/users",
        name: "users",
        component: Users,
        meta: {
          rol: ["ADMINISTRADOR"]
        },
        beforeEnter: auth
      },
      {
        path: "/farms",
        name: "farms",
        component: Farms,
        meta: {
          rol: ["ADMINISTRADOR"]
        },
        beforeEnter: auth
      },
      {
        path: "/sensors",
        name: "sensors",
        component: Sensors,
        meta: {
          rol: ["ADMINISTRADOR"]
        },
        beforeEnter: auth
      },
      {
        path: "/home",
        name: "home",
        component: Home,
        beforeEnter: auth,
        meta: {
          rol: ["ADMINISTRADOR", "USUARIO"]
        },
        redirect: "/weighing"
      },
      {
        path: "/termometro",
        name: "termometro",
        component: Termometro,
        meta: {
          rol: ["ADMINISTRADOR", "USUARIO"]
        },
        beforeEnter: auth
      },
      {
        path: "/termohigrometro",
        name: "termohigrometro",
        component: Termomanometro,
        meta: {
          rol: ["ADMINISTRADOR", "USUARIO"]
        },
        beforeEnter: auth
      },
      {
        path: "/weighing",
        name: "weighing",
        component: Weighing,
        meta: {
          rol: ["ADMINISTRADOR", "USUARIO"]
        },
        beforeEnter: auth
      },
      {
        path: "/report",
        name: "report",
        component: GenerateReport,
        meta: {
          rol: ["ADMINISTRADOR", "USUARIO"]
        },
        beforeEnter: auth
      }
    ]
  }
];
const app = createApp(App);
const pinia = createPinia();
pinia.use(
  createPersistedState({
    storage: localStorage
  })
);
app.use(Quasar, {
  lang: langEs,
  plugins: {
    Notify,
    Dialog,
    Loading: Plugin
  }
});
const router = createRouter({
  history: createWebHashHistory(),
  routes
});
app.use(pinia);
app.use(qe);
app.use(router);
app.mount("#app");
export {
  _typeof as _
};
